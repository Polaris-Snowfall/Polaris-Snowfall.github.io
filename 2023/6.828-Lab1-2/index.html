<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
        
      <meta name="description" content="Boom? PWN ! ! !" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>MIT6.828 Lab1-Lab2 |  北极落小雪</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
  </html>
</html>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-6.828-Lab1-2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  MIT6.828 Lab1-Lab2
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/6.828-Lab1-2/" class="article-date">
  <time datetime="2023-09-26T16:00:00.000Z" itemprop="datePublished">2023-09-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6-828/">6.828</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">3.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">15 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="LEC-1"><a href="#LEC-1" class="headerlink" title="LEC 1"></a>LEC 1</h1><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><p>管道本质上是一个内核的缓冲区,大多数情况下半开工,描述符可跨fork继承.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309202328496.png"></p>
<h2 id="Lab-1-Booting-a-PC"><a href="#Lab-1-Booting-a-PC" class="headerlink" title="Lab 1: Booting a PC"></a>Lab 1: Booting a PC</h2><h3 id="PC-Bootstrap"><a href="#PC-Bootstrap" class="headerlink" title="PC Bootstrap"></a>PC Bootstrap</h3><p>BIOS: 设置中断描述符表,初始化设备.加载bootloader</p>
<blockquote>
<p>When the BIOS runs, it sets up an interrupt descriptor table and initializes various devices such as the VGA display. This is where the “Starting SeaBIOS” message you see in the QEMU window comes from. </p>
</blockquote>
<span id="more"></span>
<p>计算机通电后地址设为0xf000:0xfff0,通过一个jmp指令跳转到BIOS的稍前部分</p>
<blockquote>
<p>Therefore we shouldn’t be surprised that the first thing that the BIOS does is jmp backwards to an earlier location in the BIOS</p>
</blockquote>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309211035578.png"></p>
<h3 id="The-Boot-Loader"><a href="#The-Boot-Loader" class="headerlink" title="The Boot Loader"></a>The Boot Loader</h3><p>BIOS将第一个扇区(引导扇区)加载到物理地址0x7c00~0x7dff的内存中,jmp到0x0000:0x7c00,控制权转移到bootloader.</p>
<blockquote>
<p>如果此扇区末尾两个字节分别是魔数0x55和0xaa，则BIOS认为此扇区中存在可执行的程序</p>
</blockquote>
<blockquote>
<p>Floppy and hard disks for PCs are divided into 512 byte regions called sectors. A sector is the disk’s minimum transfer granularity: each read or write operation must be one or more sectors in size and aligned on a sector boundary. If the disk is bootable, the first sector is called the boot sector, since this is where the boot loader code resides. When the BIOS finds a bootable floppy or hard disk, it loads the 512-byte boot sector into memory at physical addresses 0x7c00 through 0x7dff, and then uses a jmp instruction to set the CS:IP to 0000:7c00, passing control to the boot loader. Like the BIOS load address, these addresses are fairly arbitrary - but they are fixed and standardized for PCs.</p>
</blockquote>
<p>MBR与bootloader的关系.</p>
<blockquote>
<p>MBR是主引导记录（Master Boot Record），也被称为主引导扇区，是计算机开机以后访问硬盘时所必须要读取的第一个扇区。其内部前446字节存储了bootloader代码，其后是4个16字节的“磁盘分区表”。</p>
</blockquote>
<h4 id="boot-S流程分析"><a href="#boot-S流程分析" class="headerlink" title="boot.S流程分析"></a>boot.S流程分析</h4><p>.set 相当于define的宏定义</p>
<p>.code16以16-bit模式产生代码<br>cli(clear interrupt flag),禁止中断发生.</p>
<blockquote>
<p> 下面是两条规则：<br>       1）在改变SS：SP之前，必须用cli指令屏蔽中断，然后等操作执行完立即用sti指令恢复<br>       2）SS：SP需要设置在空闲的内存地址，不要建立在其他的程序（尤其是系统的）代码区   </p>
</blockquote>
<p>cld(clear direction flag),清除方向标志位,当方向位清除时,字符串操作按递增地址的方式进行.<br>对应的有sti,std(set)</p>
<p>开启A20 gate:向0x64端口写入0xd1的命令,再向0x60端口写入0xdf(0x11011111)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">  outb    %al,$0x60</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309211153437.png"></p>
<p>加载gdt,lgdt 48位内存数据,加载到48位寄存器GDTR,16位的(gdt)段界限,32位的(gdt)段基址<br>gdt初始化内容:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL				# null seg</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)	    </span><br></pre></td></tr></tbody></table></figure>


<p>将%cr0寄存器PE标志置1,长跳转ljmp $PROT_MODE_CSEG, $protcseg以更新cs基地址,正式进入保护模式.</p>
<p>更新其他段寄存器<br>这里有个点需要注意一下,段选择子的0-1位用来存储RPL,第2位是TI(table indicator)位,用来指示选择子是在GDT(0)还是LDT(1)中,3~15位是13位的段描述符索引值,所以boot.S中定义的0x8和0x10代表的序号其实是1和2.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.set PROT_MODE_CSEG, 0x8         # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG, 0x10        # kernel data segment selector</span><br></pre></td></tr></tbody></table></figure>

<p>设置esp后便可以调用c代码bootmain.</p>
<blockquote>
<p>control starts in boot.S – which sets up protected mode,and a stack so C code then run, then calls bootmain()</p>
</blockquote>
<h4 id="boot-main-c流程分析"><a href="#boot-main-c流程分析" class="headerlink" title="(boot)main.c流程分析"></a>(boot)main.c流程分析</h4><p>从扇区1(第二个扇区)的位置开始,从硬盘读取8个扇区(一个页大小)的数据到物理内存0x10000处.这一个页的内容只是ELF文件(Kernel)的部分内容,但至少包含了完整的文件头.接下来便根据程序头表读入程序中的各个段到内存中,(这里的段不是内存中的段,而是硬盘上ELF文件中的各个代码段数据段等),形成内核映像,即真正运行的内核.</p>
<blockquote>
<p>内核被加载到内存后,loader还要通过分析其elf结构将其展开到新的位置,所以说,内核在内存中有两份拷贝,一份是elf格式的源文件kernel.bin,另一份是loader解析elf格式的kernel.bin后在内存中生成的内核映像,这个映像才是真正运行的内核.</p>
</blockquote>
<p>完成内核的加载后,跳转到ELF头中记录的内核的入口点.0x10000c</p>
<p>补充一下JOS的磁盘镜像相关内容.JOS的引导盘由两部分组成,boot和kernel,boot位于第一个扇区(引导扇区).所以需要从扇区1开始读取Kernel的ELF文件.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># How to build the kernel disk image</span><br><span class="line">$(OBJDIR)/kern/kernel.img: $(OBJDIR)/kern/kernel $(OBJDIR)/boot/boot</span><br><span class="line">	@echo + mk $@</span><br><span class="line">	$(V)dd if=/dev/zero of=$(OBJDIR)/kern/kernel.img~ count=10000 2&gt;/dev/null</span><br><span class="line">	$(V)dd if=$(OBJDIR)/boot/boot of=$(OBJDIR)/kern/kernel.img~ conv=notrunc 2&gt;/dev/null</span><br><span class="line">	$(V)dd if=$(OBJDIR)/kern/kernel of=$(OBJDIR)/kern/kernel.img~ seek=1 conv=notrunc 2&gt;/dev/null</span><br><span class="line">	$(V)mv $(OBJDIR)/kern/kernel.img~ $(OBJDIR)/kern/kernel.img</span><br></pre></td></tr></tbody></table></figure>
<h3 id="The-Kernel"><a href="#The-Kernel" class="headerlink" title="The Kernel"></a>The Kernel</h3><h4 id="entry-S流程分析"><a href="#entry-S流程分析" class="headerlink" title="entry.S流程分析"></a>entry.S流程分析</h4><p>上来第一个指令就看不懂</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movw	$0x1234,0x472			# warm boot</span><br></pre></td></tr></tbody></table></figure>

<p>加载页目录表到$cr3(页目录寄存器)<br>$cr0的PG位置1,开启分页模式.<br>初始化堆栈</p>
<p>开启分页模式后,线性地址的高十位作为页目录表entry_pgdir的索引,中间10位作为页表entry_pgtable的索引.<br>如0xf0100000,页部件先以960为索引在页目录表中找到对应的页表条目,再以256为索引找到页表条目中的物理地址0x100000.<br>理解了这个过程之后再看entrypgdir.c就明白如下映射的原理了:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[KERNBASE, KERNBASE+4MB) --&gt; [0, 4MB) .</span><br><span class="line">[0, 4MB) --&gt; [0, 4MB)</span><br></pre></td></tr></tbody></table></figure>



<h4 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h4><p>c可变参数的实现机制:<br> va_list args;               // 准备接受参数的列表对象<br> va_start(args, fmt);        // 从…中取出参数到args中，并指定…之前的参数<br> T va_arg（va_list， T）;<br> va_end(args);               // 释放参数列表</p>
<p>其实就是通过va_start得到固定参数fmt的地址再加上sizeof(fmt)得到第一个参数的地址,之后每次调用va_arg函数获得T类型的参数值,并加sizeof(T)指向下一个参数.</p>
<p>八进制改改就好了</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">	<span class="comment">// Replace this with your code.</span></span><br><span class="line">	num = getint(&amp;ap,lflag);</span><br><span class="line">	<span class="keyword">if</span>((<span class="type">long</span> <span class="type">long</span>)num &lt; <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		putch(<span class="string">'-'</span>,putdat);</span><br><span class="line">		num = -(<span class="type">long</span> <span class="type">long</span>)num;</span><br><span class="line">	}</span><br><span class="line">	base = <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">goto</span> number;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// Your code here.</span></span><br><span class="line">	cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line">	<span class="type">uint32_t</span> ebp = read_ebp();</span><br><span class="line">	<span class="type">uint32_t</span> eip = *(<span class="type">uint32_t</span>*)(ebp+<span class="number">4</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">dinfo</span>;</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		debuginfo_eip(eip,&amp;dinfo);</span><br><span class="line">		cprintf(<span class="string">"  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n"</span>,ebp,eip,*(<span class="type">uint32_t</span>*)(ebp+<span class="number">8</span>),*(<span class="type">uint32_t</span>*)(ebp+<span class="number">12</span>),*(<span class="type">uint32_t</span>*)(ebp+<span class="number">16</span>),*(<span class="type">uint32_t</span>*)(ebp+<span class="number">20</span>),*(<span class="type">uint32_t</span>*)(ebp+<span class="number">24</span>));</span><br><span class="line">		cprintf(<span class="string">"         %s:%d: %.*s+%d\n"</span>,dinfo.eip_file,dinfo.eip_line,dinfo.eip_fn_namelen,dinfo.eip_fn_name,eip-dinfo.eip_fn_addr);</span><br><span class="line">		ebp = *(<span class="type">uint32_t</span>*)(ebp);</span><br><span class="line">		<span class="keyword">if</span>(ebp!=<span class="number">0</span>)</span><br><span class="line">			eip = *(<span class="type">uint32_t</span>*)(ebp+<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>其实没怎么弄明白.<br><a target="_blank" rel="noopener" href="https://sourceware.org/gdb/onlinedocs/stabs.html#Symbol-Tables">https://sourceware.org/gdb/onlinedocs/stabs.html#Symbol-Tables</a><br><a target="_blank" rel="noopener" href="https://sourceware.org/gdb/onlinedocs/stabs.html#Line-Numbers">https://sourceware.org/gdb/onlinedocs/stabs.html#Line-Numbers</a></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line"><span class="keyword">if</span> (lline &lt;= rline) {</span><br><span class="line">	info-&gt;eip_line = stabs[lline].n_desc;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">	info-&gt;eip_fn_addr = addr;</span><br><span class="line">	lline = lfile;</span><br><span class="line">	rline = rfile;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="LEC-3"><a href="#LEC-3" class="headerlink" title="LEC 3"></a>LEC 3</h1><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>先学学pipe的用法.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span>    pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span>   buf;</span><br><span class="line">    <span class="type">pid_t</span>  cpid;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) {</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: %s &lt;string&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefd) == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"pipe"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    cpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">-1</span>) {</span><br><span class="line">        perror(<span class="string">"fork"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cpid == <span class="number">0</span>) {    <span class="comment">/* Child reads from pipe */</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);          <span class="comment">/* Close unused write end */</span></span><br><span class="line">        <span class="keyword">while</span> (read(pipefd[<span class="number">0</span>], &amp;buf, <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            write(STDOUT_FILENO, &amp;buf, <span class="number">1</span>);</span><br><span class="line">        write(STDOUT_FILENO, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    } <span class="keyword">else</span> {            <span class="comment">/* Parent writes argv[1] to pipe */</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);          <span class="comment">/* Close unused read end */</span></span><br><span class="line">        write(pipefd[<span class="number">1</span>], argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>]));</span><br><span class="line">        close(pipefd[<span class="number">1</span>]);          <span class="comment">/* Reader will see EOF */</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);                <span class="comment">/* Wait for child */</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute cmd.  Never returns.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">runcmd</span><span class="params">(<span class="keyword">struct</span> cmd *cmd)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>], r;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">execcmd</span> *<span class="title">ecmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipecmd</span> *<span class="title">pcmd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">redircmd</span> *<span class="title">rcmd</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(cmd == <span class="number">0</span>)</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">switch</span>(cmd-&gt;type){</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"unknown runcmd\n"</span>);</span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">    ecmd = (<span class="keyword">struct</span> execcmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(ecmd-&gt;argv[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">      _exit(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    execve(ecmd-&gt;argv[<span class="number">0</span>],ecmd-&gt;argv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">    rcmd = (<span class="keyword">struct</span> redircmd*)cmd;</span><br><span class="line">    <span class="comment">// Your code here ...</span></span><br><span class="line">    r = open(rcmd-&gt;file,rcmd-&gt;flags,S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);</span><br><span class="line">    <span class="keyword">if</span>(r==<span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">      perror(<span class="string">"no such file"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(dup2(r,rcmd-&gt;fd)==<span class="number">-1</span>)</span><br><span class="line">      perror(<span class="string">"dup2 fail"</span>);</span><br><span class="line">    runcmd(rcmd-&gt;cmd);</span><br><span class="line">    close(rcmd-&gt;fd);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'|'</span>:</span><br><span class="line">    <span class="keyword">if</span>(pipe(p)==<span class="number">-1</span>)</span><br><span class="line">      perror(<span class="string">"pipe create error"</span>);</span><br><span class="line">    pcmd = (<span class="keyword">struct</span> pipecmd*)cmd;</span><br><span class="line">    <span class="keyword">if</span>(fork1()==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">      close(p[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">if</span>(dup2(p[<span class="number">1</span>],STDOUT_FILENO)==<span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"dup2 fail"</span>);</span><br><span class="line">      runcmd(pcmd-&gt;left);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">          wait(&amp;r);</span><br><span class="line">          close(p[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">if</span>(dup2(p[<span class="number">0</span>],STDIN_FILENO)==<span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"dup2 fail"</span>);</span><br><span class="line">      runcmd(pcmd-&gt;right);   </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  }    </span><br><span class="line">  _exit(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Lab-2-Memory-Management"><a href="#Lab-2-Memory-Management" class="headerlink" title="Lab 2: Memory Management"></a>Lab 2: Memory Management</h2><h3 id="mem-init流程分析"><a href="#mem-init流程分析" class="headerlink" title="mem_init流程分析"></a>mem_init流程分析</h3><p>可以先看完下面的部分再来看流程分析.<br>删去了注释和check.<br>先<code>i386_detect_memory</code>检测机器的物理空间大小,然后使用boot_alloc分配一个kern_pgdir的页目录表.<br>再次boot_alloc为每一个物理页分配一个PageInfo管理结构.<br>之后<code>page_init</code>完成对整个物理页的初始化.标记不可分配或正在使用的物理页为inuse,完成空闲页链表page_free_list的创建.<br>在之后调用三次boot_map_region在kern_pgdir中完成对用户页表UPAGES,内核栈,内核地址空间的映射.<br>安装kern_pgdir替换之前临时的entry_pgdir.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">uint32_t</span> cr0;</span><br><span class="line">	<span class="type">size_t</span> n;</span><br><span class="line"></span><br><span class="line">	i386_detect_memory();</span><br><span class="line"></span><br><span class="line">	kern_pgdir = (<span class="type">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">	<span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	pages = (<span class="keyword">struct</span> PageInfo* )boot_alloc(npages*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo));</span><br><span class="line">	<span class="built_in">memset</span>(pages,<span class="number">0</span>,npages*(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	page_init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	boot_map_region(kern_pgdir, UPAGES, npages*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo), PADDR(pages), PTE_U|PTE_P);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	boot_map_region(kern_pgdir,KSTACKTOP-KSTKSIZE,KSTKSIZE,PADDR(bootstack),PTE_W|PTE_P);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	boot_map_region(kern_pgdir, KERNBASE, (<span class="number">1ULL</span> &lt;&lt; <span class="number">32</span>) - KERNBASE, <span class="number">0</span>, PTE_W);</span><br><span class="line"></span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cr0 = rcr0();</span><br><span class="line">	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;</span><br><span class="line">	cr0 &amp;= ~(CR0_TS|CR0_EM);</span><br><span class="line">	lcr0(cr0);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h3><p>写page_init之前回顾理解一下物理地址和虚拟地址的布局,在图中指出memlayout.h中各个宏定义表示的位置.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309232009006.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309232009885.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309232010431.png"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//设置第一页为inuse,保留实模式下的IDT和BIOS结构</span></span><br><span class="line">	<span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">	pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">	pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	++i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将Base_memory全部设置为free.(basemem应该指低1MB的内存)</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; ++i) {</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将IO hole设置为inuse,避免被分配.</span></span><br><span class="line">	<span class="keyword">for</span>(i = pa2page(IOPHYSMEM),i&lt;pa2page(EXTPHYSMEM),++i)</span><br><span class="line">	{</span><br><span class="line">		pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">		pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将1MB以上的Kernel映像,kern_pgdir以及pages的页设置为inuse.</span></span><br><span class="line">	<span class="keyword">for</span>(i = pa2page(EXTPHYSMEM);i&lt;pa2page(PADDR(boot_alloc(<span class="number">0</span>)));++i)</span><br><span class="line">	{</span><br><span class="line">		pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">		pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	}	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将上方所有物理地址设置为free</span></span><br><span class="line">	<span class="keyword">for</span>(;i&lt;npages;++i)</span><br><span class="line">	{</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>之后就是page_alloc(),page_free().<br>如下是初看时的一些疑惑,我知道很蠢hh<br><del>我暂时并不理解这两个功能存在的必要,特别是把释放的物理页对应的pageinfo链入page_free_list链表中的操作.</del><br><del>我们在meminit中已经调用bootalloc为所有的物理页分配了一个对应的pageinfo结构,这些结构即使被page_free释放之后也不会被其他用途的内存分配重用,不存在像常见的内存分配机制的设立是为了提高内存利用率的原因.</del><br>解答:释放pageinfo结构,其实是表示对pageinfo对应物理页的释放与分配,用于操作系统的追踪管理,与提高内存利用率无关.</p>
<blockquote>
<p>The operating system must keep track of which parts of physical RAM are free and which are currently in use. JOS manages the PC’s physical memory with page granularity so that it can use the MMU to map and protect each piece of allocated memory.</p>
</blockquote>
<p><del>更不理解的,pageinfo结构中并没有记录对应物理页的地址,page2pa函数是通过pageinfo结构相对于pages的偏移来计算出对应的物理页的.但当page_insert调用page_alloc是从free_list中取出最后free的pageinfo结构,不与物理地址对应.</del><br>解答:page_alloc的作用是分配客户(相对于该函数来说)申请的一页的物理地址空间,客户并不在乎该物理地址空间位于哪里,page_alloc只是随便取出一个pageinfo结构,并将该pageinfo结构对应的物理页分配给客户.是先有pageinfo结构再有对应的物理页,而不是为某个特定的物理页分配pageinfo结构,自然不存在无法对应的问题.</p>
<p>关于pgdir_walk() boot_map_region() page_lookup() page_remove() page_insert()等函数的实现,主要理清内核虚拟地址(KADDR),物理地址,物理页,PageInfo等结构的关系,实现完后跟着check的报错一点点调整.太多了就不放出来了.详见github.</p>
<h3 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h3><p>详见github.</p>
<h3 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h3><p>详见github.</p>
<h4 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h4><h5 id="物理页面映射打印"><a href="#物理页面映射打印" class="headerlink" title="物理页面映射打印"></a>物理页面映射打印</h5><p>模仿实验中qemu的info pg命令实现showmappings.<br>合并打印原则是权限位相同且物理页相邻的页表合并打印,页目录表始终不合并.其实改进也简单但是时间挺紧的…<br>qemu中的info pg:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309271912082.png"><br>showmappings:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309271913080.png"></p>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309271926936.png"></p>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309271914406.png"></p>
<h4 id="一些小插曲"><a href="#一些小插曲" class="headerlink" title="一些小插曲"></a>一些小插曲</h4><p>memset崩了,刚开始猜测是引用到了当前页目录映射之外的物理地址,到崩溃现场之后发现又没问题,找了半天发现原来页目录表中虚拟地址低4MB没有写的权限。。。<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202309232256150.png"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="type">pde_t</span> entry_pgdir[NPDENTRIES] = {</span><br><span class="line">	<span class="comment">// Map VA's [0, 4MB) to PA's [0, 4MB)</span></span><br><span class="line">	[<span class="number">0</span>]</span><br><span class="line">		= ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P,</span><br><span class="line">	<span class="comment">// Map VA's [KERNBASE, KERNBASE+4MB) to PA's [0, 4MB)</span></span><br><span class="line">	[KERNBASE&gt;&gt;PDXSHIFT]</span><br><span class="line">		= ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P + PTE_W</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>又突然想到page_init后,page_free_list指向的头部页应该位于物理内存的最高处,确实是在当前页目录映射之外的,确实应该崩.检查之后发现在check_page_free_list函数中有这样一个处理free_list的操作.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (only_low_memory) {</span><br><span class="line">	<span class="comment">// Move pages with lower addresses first in the free</span></span><br><span class="line">	<span class="comment">// list, since entry_pgdir does not map all pages.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> **<span class="title">tp</span>[2] =</span> { &amp;pp1, &amp;pp2 };</span><br><span class="line">	<span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link) {</span><br><span class="line">		<span class="type">int</span> pagetype = PDX(page2pa(pp)) &gt;= pdx_limit;</span><br><span class="line">		*tp[pagetype] = pp;</span><br><span class="line">		tp[pagetype] = &amp;pp-&gt;pp_link;</span><br><span class="line">	}</span><br><span class="line">	*tp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	*tp[<span class="number">0</span>] = pp2;</span><br><span class="line">	page_free_list = pp1;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://jamorant12138.github.io/2023/6.828-Lab1-2/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/6%C2%B7828/" rel="tag">6·828</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/ycb2023/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            羊城杯2023 复现
          
        </div>
      </a>
    
    
      <a href="/2023/SGI-STL--Notes/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">SGI STL学习笔记</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> 翰青HanQi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="北极落小雪"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/About">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>