<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
        
      <meta name="description" content="Boom? PWN ! ! !" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>MIT6.828 Lab4 |  北极落小雪</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
  </html>
</html>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-6.828-Lab4"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  MIT6.828 Lab4
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/6.828-Lab4/" class="article-date">
  <time datetime="2023-10-13T16:00:00.000Z" itemprop="datePublished">2023-10-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6-828/">6.828</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">22 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Lec-9"><a href="#Lec-9" class="headerlink" title="Lec 9"></a>Lec 9</h1><h2 id="“Locking”"><a href="#“Locking”" class="headerlink" title="“Locking”"></a>“Locking”</h2><blockquote>
<p>When we say that a lock protects data, we really mean that the lock protects some<br>collection of invariants that apply to the data. Invariants are properties of data struc-<br>tures that are maintained across operations. Typically, an operation’s correct behavior<br>depends on the invariants being true when the operation begins. The operation may<br>temporarily violate the invariants but must reestablish them before finishing. For ex-<br>ample, in the linked list case, the invariant is that list points at the first node in the<br>list and that each node’s next field points at the next node. The implementation of<br>insert violates this invariant temporarily: in line 15, l points to the next list element,<br>but list does not point at l yet (reestablished at line 16). The race condition we ex-<br>amined above happened because a second CPU executed code that depended on the<br>list invariants while they were (temporarily) violated. Proper use of a lock ensures that<br>only one CPU at a time can operate on the data structure in the critical section, so<br>that no CPU will execute a data structure operation when the data structure’s invari-<br>ants do not hold.</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>You can think of locks as serializing concurrent critical sections so that they run<br>one at a time, and thus preserve invariants (assuming they are correct in isolation).<br>You can also think of critical sections as being atomic with respect to each other, so<br>that a critical section that obtains the lock later sees only the complete set of changes<br>from earlier critical sections, and never sees partially-completed updates.</p>
</blockquote>
<h2 id="Lab-4-Preemptive-Multitasking"><a href="#Lab-4-Preemptive-Multitasking" class="headerlink" title="Lab 4: Preemptive Multitasking"></a>Lab 4: Preemptive Multitasking</h2><h3 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h3><h4 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h4><p>对称多处理器模型(SMP):<br>引导处理器 （BSP） 负责初始化系统和引导操作系统;应用处理器 （AP） 仅在操作系统启动并运行后由 BSP 激活。哪个处理器是 BSP 由硬件和 BIOS 决定。</p>
<blockquote>
<p>We are going to make JOS support “symmetric multiprocessing” (SMP), a multiprocessor model in which all CPUs have equivalent access to system resources such as memory and I/O buses. While all CPUs are functionally identical in SMP, during the boot process they can be classified into two types: the bootstrap processor (BSP) is responsible for initializing the system and for booting the operating system; and the application processors (APs) are activated by the BSP only after the operating system is up and running. Which processor is the BSP is determined by the hardware and the BIOS.</p>
</blockquote>
<p>每个CPU有个LAPIC单元,LAPIC单元负责在整个系统中传输中断</p>
<blockquote>
<p>In an SMP system, each CPU has an accompanying local APIC (LAPIC) unit. The LAPIC units are responsible for delivering interrupts throughout the system. The LAPIC also provides its connected CPU with a unique identifier. </p>
</blockquote>
<h5 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h5><p>映射MMIO.</p>
<blockquote>
<p>A processor accesses its LAPIC using memory-mapped I/O (MMIO). In MMIO, a portion of physical memory is hardwired to the registers of some I/O devices, so the same load/store instructions typically used to access memory can be used to access device registers. You’ve already seen one IO hole at physical address 0xA0000 (we use this to write to the VGA display buffer).</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span></span><br><span class="line"><span class="comment">// location.  Return the base of the reserved region.  size does *not*</span></span><br><span class="line"><span class="comment">// have to be multiple of PGSIZE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">mmio_map_region</span><span class="params">(<span class="type">physaddr_t</span> pa, <span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">static</span> <span class="type">uintptr_t</span> base = MMIOBASE;</span><br><span class="line">	</span><br><span class="line">	size = ROUNDUP(size,PGSIZE);</span><br><span class="line">	pa = ROUNDDOWN(pa,PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (base + size &gt; MMIOLIM)</span><br><span class="line">        panic(<span class="string">"mmio_map_region: cannot go higher than MMIOLIM!\n"</span>);</span><br><span class="line"></span><br><span class="line">	boot_map_region(kern_pgdir,base,size,pa,PTE_PCD|PTE_PWT|PTE_W);</span><br><span class="line">	base += size;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span>*)(base-size);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为每一个cpu映射栈空间.<br>注意下方是NCPU而不是ncpu,因为ncpu此时还未初始化.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modify mappings in kern_pgdir to support SMP</span></span><br><span class="line"><span class="comment">//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init_mp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;NCPU;++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">uint32_t</span> kstacktop_i = KSTACKTOP-i*(KSTKSIZE+KSTKGAP);</span><br><span class="line">		boot_map_region(kern_pgdir,kstacktop_i-KSTKSIZE,KSTKSIZE,PADDR(percpu_kstacks[i]),PTE_W|PTE_P);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>为每个CPU设置tss,idr.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap_init_percpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> id = cpunum();</span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP-id*(KSTKGAP+KSTKSIZE);</span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate);</span><br><span class="line"></span><br><span class="line">	gdt[(GD_TSS0&gt;&gt;<span class="number">3</span>)+id] = SEG16(STS_T32A, (<span class="type">uint32_t</span>) (&amp;(thiscpu-&gt;cpu_ts)),</span><br><span class="line">					<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	gdt[(GD_TSS0&gt;&gt;<span class="number">3</span>)+id].sd_s = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">	<span class="comment">// ltr(((GD_TSS0&gt;&gt;3)+id)&lt;&lt;3);</span></span><br><span class="line">	ltr(GD_TSS0 + id*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Gatedesc));</span><br><span class="line">	lidt(&amp;idt_pd);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下图有助于理解为什么gdt中使用cpt_ts的逻辑地址而不是物理地址，以及ltr操作的tss选择子.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310082204791.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310082204847.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310082226355.png"></p>
<h4 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h4><h4 id="System-Calls-for-Environment-Creation"><a href="#System-Calls-for-Environment-Creation" class="headerlink" title="System Calls for Environment Creation"></a>System Calls for Environment Creation</h4><p>几个系统调用,需要检查的东西都列出来了,挨着做就行了.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a new environment.</span></span><br><span class="line"><span class="comment">// Returns envid of new environment, or &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_NO_FREE_ENV if no free environment is available.</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM on memory exhaustion.</span></span><br><span class="line"><span class="type">static</span> <span class="type">envid_t</span></span><br><span class="line"><span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="keyword">if</span>((result = env_alloc(&amp;e,curenv-&gt;env_id)))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;e-&gt;env_tf,&amp;curenv-&gt;env_tf,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe));</span><br><span class="line">	e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set envid's env_status to status, which must be ENV_RUNNABLE</span></span><br><span class="line"><span class="comment">// or ENV_NOT_RUNNABLE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if status is not a valid status for an environment.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_status</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">int</span> status)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">if</span>((result=envid2env(envid,&amp;e,<span class="number">1</span>)))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(status!=ENV_RUNNABLE&amp;&amp;status!=ENV_NOT_RUNNABLE)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line">	e-&gt;env_status = status;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page of memory and map it at 'va' with permission</span></span><br><span class="line"><span class="comment">// 'perm' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// The page's contents are set to 0.</span></span><br><span class="line"><span class="comment">// If a page is already mapped at 'va', that page is unmapped as a</span></span><br><span class="line"><span class="comment">// side effect.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span></span><br><span class="line"><span class="comment">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if perm is inappropriate (see above).</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if there's no memory to allocate the new page,</span></span><br><span class="line"><span class="comment">//		or to allocate any necessary page tables.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_alloc</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">if</span>((perm|PTE_SYSCALL)!=PTE_SYSCALL)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(va&gt;=(<span class="type">void</span>*)UTOP||va!=ROUNDDOWN(va,PGSIZE))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> E_INVAL;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>((result = envid2env(envid,&amp;e,<span class="number">1</span>)))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!(page = page_alloc(ALLOC_ZERO)))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	}</span><br><span class="line">	page_insert(e-&gt;env_pgdir,page,va,perm);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map the page of memory at 'srcva' in srcenvid's address space</span></span><br><span class="line"><span class="comment">// at 'dstva' in dstenvid's address space with permission 'perm'.</span></span><br><span class="line"><span class="comment">// Perm has the same restrictions as in sys_page_alloc, except</span></span><br><span class="line"><span class="comment">// that it also must not grant write access to a read-only</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if srcenvid and/or dstenvid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change one of them.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></span><br><span class="line"><span class="comment">//		or dstva &gt;= UTOP or dstva is not page-aligned.</span></span><br><span class="line"><span class="comment">//	-E_INVAL is srcva is not mapped in srcenvid's address space.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if perm is inappropriate (see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//	-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid's</span></span><br><span class="line"><span class="comment">//		address space.</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if there's no memory to allocate any necessary page tables.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_map</span><span class="params">(<span class="type">envid_t</span> srcenvid, <span class="type">void</span> *srcva,</span></span><br><span class="line"><span class="params">	     <span class="type">envid_t</span> dstenvid, <span class="type">void</span> *dstva, <span class="type">int</span> perm)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">srcenv</span>,*<span class="title">dstenv</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">pte_t</span>* srcpte,*dstpte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">srcpage</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="keyword">if</span>(srcva&gt;=(<span class="type">void</span>*)UTOP||srcva!=ROUNDDOWN(srcva,PGSIZE)||dstva&gt;=(<span class="type">void</span>*)UTOP||dstva!=ROUNDDOWN(dstva,PGSIZE))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> E_INVAL;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>((perm|PTE_SYSCALL)!=PTE_SYSCALL)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>((result = envid2env(srcenvid,&amp;srcenv,<span class="number">1</span>)))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>((result = envid2env(dstenvid,&amp;dstenv,<span class="number">1</span>)))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!(srcpage = page_lookup(srcenv-&gt;env_pgdir,srcva,&amp;srcpte)))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(((*srcpte)&amp;PTE_W)==<span class="number">0</span>&amp;&amp;((perm&amp;PTE_W)!=<span class="number">0</span>))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((result = page_insert(dstenv-&gt;env_pgdir,srcpage,dstva,perm)))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unmap the page of memory at 'va' in the address space of 'envid'.</span></span><br><span class="line"><span class="comment">// If no page is mapped, the function silently succeeds.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_unmap</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(va&gt;=(<span class="type">void</span>*)UTOP||va!=ROUNDDOWN(va,PGSIZE))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>((result = envid2env(envid,&amp;e,<span class="number">1</span>)))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	}</span><br><span class="line">	page_remove(e-&gt;env_pgdir,va);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B: Copy-on-Write Fork"></a>Part B: Copy-on-Write Fork</h3><h4 id="User-level-page-fault-handling"><a href="#User-level-page-fault-handling" class="headerlink" title="User-level page fault handling"></a>User-level page fault handling</h4><h5 id="Setting-the-Page-Fault-Handler"><a href="#Setting-the-Page-Fault-Handler" class="headerlink" title="Setting the Page Fault Handler"></a>Setting the Page Fault Handler</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the page fault upcall for 'envid' by modifying the corresponding struct</span></span><br><span class="line"><span class="comment">// Env's 'env_pgfault_upcall' field.  When 'envid' causes a page fault, the</span></span><br><span class="line"><span class="comment">// kernel will push a fault record onto the exception stack, then branch to</span></span><br><span class="line"><span class="comment">// 'func'.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn't currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn't have permission to change envid.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_pgfault_upcall</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *func)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="keyword">if</span>((result = envid2env(envid,&amp;e,<span class="number">1</span>)))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	}</span><br><span class="line">	e-&gt;env_pgfault_upcall = func;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="Invoking-the-User-Page-Fault-Handler"><a href="#Invoking-the-User-Page-Fault-Handler" class="headerlink" title="Invoking the User Page Fault Handler"></a>Invoking the User Page Fault Handler</h5><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_fault_handler</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">uint32_t</span> fault_va;</span><br><span class="line">	fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((tf-&gt;tf_cs&amp;<span class="number">3</span>)==<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"kernel pagefalut\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(curenv-&gt;env_pgfault_upcall==<span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> recursive = (tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE) &amp;&amp; (tf-&gt;tf_esp &lt; UXSTACKTOP);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span>* <span class="title">utf</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(recursive)</span><br><span class="line">	{</span><br><span class="line">		utf = (<span class="keyword">struct</span> UTrapframe*)(tf-&gt;tf_esp-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe)-<span class="keyword">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">		<span class="comment">// cprintf("recursive\n");</span></span><br><span class="line">		user_mem_assert(curenv,utf,tf-&gt;tf_esp-(<span class="type">uint32_t</span>)utf,PTE_W);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		utf = (<span class="keyword">struct</span> UTrapframe*)(UXSTACKTOP-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe));</span><br><span class="line">		<span class="comment">// cprintf("non-recursive\n");</span></span><br><span class="line">		user_mem_assert(curenv,utf,UXSTACKTOP-(<span class="type">uint32_t</span>)utf,PTE_W);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	utf-&gt;utf_esp = tf-&gt;tf_esp; </span><br><span class="line">	utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">	utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">	utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">	utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">	utf-&gt;utf_fault_va = fault_va;</span><br><span class="line"></span><br><span class="line">	tf-&gt;tf_esp = (<span class="type">uintptr_t</span>)utf;</span><br><span class="line">	tf-&gt;tf_eip = (<span class="type">uint32_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">	env_run(curenv);</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">	<span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">	cprintf(<span class="string">"[%08x] user fault va %08x ip %08x\n"</span>,</span><br><span class="line">		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	env_destroy(curenv);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="User-mode-Page-Fault-Entrypoint"><a href="#User-mode-Page-Fault-Entrypoint" class="headerlink" title="User-mode Page Fault Entrypoint"></a>User-mode Page Fault Entrypoint</h5><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">	// Call the C page fault handler.</span><br><span class="line">	pushl %esp			// function argument: pointer to UTF</span><br><span class="line">	movl _pgfault_handler, %eax</span><br><span class="line">	call *%eax</span><br><span class="line">	addl $4, %esp			// pop function argument</span><br><span class="line">	</span><br><span class="line">	movl 40(%esp),%ebx //取出trap_eip</span><br><span class="line">	subl $4,48(%esp) //抬高栈4字节,此空间为trap_eip的返回地址</span><br><span class="line">	movl 48(%esp),%eax //取出trap_esp</span><br><span class="line">	movl %ebx,(%eax) </span><br><span class="line"></span><br><span class="line">	addl $8,%esp //跳过err和fault_va</span><br><span class="line"></span><br><span class="line">	popal //restore the trap-time registers</span><br><span class="line"></span><br><span class="line">	addl $4,%esp //跳过trap_eip</span><br><span class="line">	popf</span><br><span class="line"></span><br><span class="line">     popl %esp</span><br><span class="line">	ret</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">set_pgfault_handler</span><span class="params">(<span class="type">void</span> (*handler)(<span class="keyword">struct</span> UTrapframe *utf))</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) {</span><br><span class="line">		<span class="comment">// First time through!</span></span><br><span class="line">		<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">		<span class="type">envid_t</span> eid = sys_getenvid();</span><br><span class="line">		<span class="keyword">if</span>(sys_page_alloc(eid,(<span class="type">void</span>*)(UXSTACKTOP-PGSIZE),PTE_W|PTE_U|PTE_P))</span><br><span class="line">		{</span><br><span class="line">			<span class="comment">//panic("fail\n"); User系统调用失败,凭啥让内核panic?</span></span><br><span class="line">		}</span><br><span class="line">		sys_env_set_pgfault_upcall(eid,_pgfault_upcall);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">	_pgfault_handler = handler;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h4><h5 id="页表-页目录表的映射分析"><a href="#页表-页目录表的映射分析" class="headerlink" title="页表,页目录表的映射分析"></a>页表,页目录表的映射分析</h5><p>实现完用户级页面错误处理例程的安装工作后,下面进入Fork函数的实现.<br>在此之前,先来理解一个<code>clever mapping trick</code>.</p>
<p>在为环境建立映射的时候,有这样一个操作.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UVPT maps the env's own page table read-only.</span></span><br><span class="line"><span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br></pre></td></tr></tbody></table></figure>
<p>UVPT的定义如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User read-only virtual page table (see 'uvpt' below)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVPT		(ULIM - PTSIZE)</span></span><br></pre></td></tr></tbody></table></figure>

<p>根据注释,我们可以理解这一操作是将页目录表自身映射到虚拟地址UVPT,使用户进程可以只读访问.But how does it work?</p>
<p>先来看这样一个情形.用户态lib的某个函数要检查一个物理页在其页表中的pte条目来判断操作是否合法.自然而然的想法是:通过之前映射的页目录表找到对应的页目录表目中的页表地址,再访问该页表的对应pte条目.</p>
<p>但问题是,页目录表条目pde中存的是页表的物理地址而不是虚拟地址,没办法访问到对应页表.你可能会想,不对啊,之前在内核态的时候有过访问pte的操作啊.其实是因为之前访问时是先将从页目录表中取出的页表物理地址转换成KVA虚拟地址后再访问的,能完成这样的操作是因为我们曾经将从0开始的物理地址空间映射到了KERNBASE之上.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, KERNBASE, (<span class="number">1ULL</span> &lt;&lt; <span class="number">32</span>) - KERNBASE, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></tbody></table></figure>

<p>而用户进程并不具有访问KERNBASE之上虚拟地址空间的能力.</p>
<p>那用户进程应该怎么访问页表条目呢?页表本身也是一个物理页,而访问一个物理页就需要找到该物理页对应的页表,页表的页表,也就是页目录表.把页目录表当作一个页表,不久能找到页表本身的物理地址了?</p>
<p>回想一下分页机制的工作.先在页目录表中通过PDX找到页表,再在页表中通过PTX找到物理页.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310111628497.png"><br>那如果我们让页目录表根据PDX找到页目录表自身,页部件就会把页目录表当成页表,再根据PTX找到页表本身的物理地址并进行访问.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202310111631565.png"></p>
<p>理解完这一过程,再来看看如何找到想访问的页表或页表项的地址.<br>对于32位地址addr –&gt; PDX|PTX|OFFSET.</p>
<p>PDX是页目录表的索引,要让它索引到自身,便固定了得是(UPVT&gt;&gt;22)<br>由于我们将页目录表当作是页表,则PTX同样也用来在页目录表上索引,查找到的物理地址意义为第PTX个页表的物理地址.<br>OFFSET便用于在页表上偏移,页表的内容是页表条目,每个大小4字节,所以OFFSET便是该页表的第OFFSET/4项.</p>
<p>综合起来,upvt[n]就相当于访问了物理空间第n页的页表条目.<br>upvt[addr&gt;&gt;12]访问的就是addr所在物理页的页表条目.<br>upvd[addr&gt;&gt;22]访问的就是addr对应的页表在页目录表中的条目.<br>这也解释了entry.S中的宏定义.<br>其实挺反直觉的,页目录表映射到UVPT,但访问UVPT却访问到的是第0页的页表.而页目录表要用uvpd去访问(UVPT+(UVPT&gt;&gt;12)*4).</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.globl uvpt</span><br><span class="line">.<span class="built_in">set</span> uvpt, UVPT</span><br><span class="line">.globl uvpd</span><br><span class="line">.<span class="built_in">set</span> uvpd, (UVPT+(UVPT&gt;&gt;<span class="number">12</span>)*<span class="number">4</span>)</span><br></pre></td></tr></tbody></table></figure>
<h5 id="Fork代码实现"><a href="#Fork代码实现" class="headerlink" title="Fork代码实现"></a>Fork代码实现</h5><p>pgfault是Custom page fault handler,如果发生页面错误的是对COW页面的写入操作,分配一个物理页拷贝原数据并设定可写</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Custom page fault handler - if faulting page is copy-on-write,</span></span><br><span class="line"><span class="comment">// map in our own private writable copy.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pgfault</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">void</span> *addr = (<span class="type">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">	<span class="type">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((err&amp;FEC_WR)==<span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		panic(<span class="string">"pgfault: the faulting access was not a write\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="type">pte_t</span> pte = ((<span class="type">pte_t</span>*)UVPT)[PGNUM(addr)];</span><br><span class="line">	<span class="keyword">if</span>((pte&amp;PTE_COW)==<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">"pgfault: the faulting access was not to a copy-on-write page\n"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((r = sys_page_alloc(<span class="number">0</span>,PFTEMP,PTE_W|PTE_U)))</span><br><span class="line">	{</span><br><span class="line">		panic(<span class="string">"pgfault: page_alloc error when COW\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="type">void</span>*)PFTEMP,ROUNDDOWN(addr,PGSIZE),PGSIZE);</span><br><span class="line">	<span class="keyword">if</span>(sys_page_map(<span class="number">0</span>,PFTEMP,<span class="number">0</span>,ROUNDDOWN(addr,PGSIZE),PTE_W|(pte&amp;PTE_SYSCALL&amp;~PTE_COW)))</span><br><span class="line">	{</span><br><span class="line">		panic(<span class="string">"pgfault: page_map error when COW\n"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, (<span class="type">void</span> *)PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">"pgfault: sys_page_unmap() failed: %e\n"</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>duppage映射页面pn到envid(子)进程,若为可写页面或COW则将自身(父进程)和envid进程中该页均映射为COW(因为父进程可能也是fork出来的且并没有得到独立的页面,仅是COW).</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">duppage</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">unsigned</span> pn)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="type">uintptr_t</span> addr = pn*PGSIZE;</span><br><span class="line">	</span><br><span class="line">	<span class="type">pte_t</span> pte = ((<span class="type">pte_t</span>*)UVPT)[pn];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pte&amp;(PTE_W|PTE_COW))</span><br><span class="line">	{</span><br><span class="line"></span><br><span class="line">		<span class="comment">//为子进程映射页面并设置PTE_COW</span></span><br><span class="line">		<span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>,(<span class="type">void</span>*)addr,envid,(<span class="type">void</span>*)addr,PTE_COW|PTE_U|(pte&amp;PTE_SYSCALL&amp;~PTE_W)))&lt;<span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		}</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//清除父进程的PTE_W并设置PTE_COW</span></span><br><span class="line">		<span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>,(<span class="type">void</span>*)addr,<span class="number">0</span>,(<span class="type">void</span>*)addr,PTE_COW|PTE_U|(pte&amp;PTE_SYSCALL&amp;~PTE_W)))&lt;<span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>,(<span class="type">void</span>*)addr,envid,(<span class="type">void</span>*)addr,PTE_U|(pte&amp;PTE_SYSCALL)))&lt;<span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>fork创建子进程,为子进程映射(duppage)地址空间.为自身和子进程安装错误处理函数.<br>注意子进程的错误处理函数一定要由父进程安装,因为子进程在调用函数或系统调用时的压栈操作会触发页面错误(目前子进程的栈还是COW的),而错误处理函数还未安装,无法处理.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// User-level fork with copy-on-write.</span></span><br><span class="line"><span class="comment">// Set up our page fault handler appropriately.</span></span><br><span class="line"><span class="comment">// Create a child.</span></span><br><span class="line"><span class="comment">// Copy our address space and page fault handler setup to the child.</span></span><br><span class="line"><span class="comment">// Then mark the child as runnable and return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns: child's envid to the parent, 0 to the child, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// It is also OK to panic on error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use uvpd, uvpt, and duppage.</span></span><br><span class="line"><span class="comment">//   Remember to fix "thisenv" in the child process.</span></span><br><span class="line"><span class="comment">//   Neither user exception stack should ever be marked copy-on-write,</span></span><br><span class="line"><span class="comment">//   so you must allocate a new page for the child's user exception stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">envid_t</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="type">envid_t</span> ceid;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	set_pgfault_handler(pgfault);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((ceid = sys_exofork())&lt;<span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> ceid; </span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ceid == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//child</span></span><br><span class="line">		thisenv = &amp;(envs[sys_getenvid()&amp;<span class="number">0x3FF</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">uintptr_t</span> va = <span class="number">0</span>; va &lt; UTOP;) </span><br><span class="line">		{</span><br><span class="line">	    	<span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pde_t</span> uvpd[];</span><br><span class="line">    		<span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">pte_t</span> uvpt[];</span><br><span class="line">			<span class="keyword">if</span> ((uvpd[va &gt;&gt; PDXSHIFT] &amp; PTE_P) == <span class="number">0</span>) </span><br><span class="line">			{    <span class="comment">// page table page not found.</span></span><br><span class="line">				va += NPTENTRIES * PGSIZE;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> ((uvpt[va &gt;&gt; PTXSHIFT] &amp; PTE_P) == <span class="number">0</span>) </span><br><span class="line">			{    <span class="comment">// page table entry not found.</span></span><br><span class="line">				va += PGSIZE;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (va == UXSTACKTOP - PGSIZE) </span><br><span class="line">			{    <span class="comment">// UXSTACKTOP is not remmaped!</span></span><br><span class="line">				va += PGSIZE;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">// this page should be duppage()d.</span></span><br><span class="line">			<span class="keyword">if</span> ((result = duppage(ceid, (<span class="type">unsigned</span>)(va/PGSIZE))) &lt; <span class="number">0</span>)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			}</span><br><span class="line">			va += PGSIZE;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">   		 <span class="keyword">if</span> ((result = sys_page_alloc(ceid, (<span class="type">void</span> *)(UXSTACKTOP-PGSIZE), (PTE_U|PTE_W))) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">void</span> _pgfault_upcall(<span class="type">void</span>);</span><br><span class="line">	sys_env_set_pgfault_upcall(ceid,_pgfault_upcall);</span><br><span class="line">		sys_env_set_status(ceid,ENV_RUNNABLE);</span><br><span class="line">		<span class="keyword">return</span> ceid;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="Copy-On-Write流程分析"><a href="#Copy-On-Write流程分析" class="headerlink" title="Copy-On-Write流程分析"></a>Copy-On-Write流程分析</h5><h6 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h6><p>为了开启Copy-On-Write,要为环境安装_pgfault_upcall函数和_pgfault_handler.前者是汇编实现的page fault处理例程的入口点,会调用后者进行page fault的处理并完成traptime状态的恢复.该安装过程由set_pgfault_handler函数完成,且由于上文提过的原因,子进程_pgfault_upcall函数必须由父进程安装.set_pgfault_handler同时为进程分配单独的错误处理堆栈,子进程的错误处理堆栈由父进程分配.</p>
<h6 id="触发Copy-On-Write"><a href="#触发Copy-On-Write" class="headerlink" title="触发Copy-On-Write"></a>触发Copy-On-Write</h6><p>当进程对带有PTE_COW标志的页进行写入操作时,由于没有PTE_W权限,处理器触发pagefault,陷入内核态,由常规的异常处理流程,最终到达内核态的page_fault_handler函数.该函数检查环境的_pgfault_upcall是否安装,是否是递归页面错误,为页面处理准备UTrapFrame结构,最后env_run返回到用户态从_pgfault_upcall开始执行.</p>
<h6 id="处理Copy-On-Write"><a href="#处理Copy-On-Write" class="headerlink" title="处理Copy-On-Write"></a>处理Copy-On-Write</h6><p>_pgfault-upcall函数调用用户安装的_pgfault_handler.本实现中该函数流程如下.检查此次pgfault的类型,是否为写入操作,页面是否是COW…若通过检查便为触发pgfault的虚拟地址重新分配一个物理页,拷贝原页的内容.</p>
<h6 id="恢复到traptime"><a href="#恢复到traptime" class="headerlink" title="恢复到traptime"></a>恢复到traptime</h6><p>现在触发pgfault的地址已经有了独立的一个可写页面,pgfault_upcall函数恢复到traptime状态继续执行,这次的写入操作可以正常进行了.</p>
<h4 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h4><p>本实现中采用的共享方式是:</p>
<ol>
<li>通过envs所在的所有环境共享的可读页传递value.</li>
<li>将sender的某页面映射到recver的页面上<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_try_send</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">uint32_t</span> value, <span class="type">void</span> *srcva, <span class="type">unsigned</span> perm)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">	<span class="type">pte_t</span>* pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">if</span>((result = envid2env(envid,&amp;e,<span class="number">0</span>)))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>((e-&gt;env_status != ENV_NOT_RUNNABLE) || (e-&gt;env_ipc_recving==<span class="number">0</span>))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span>(((<span class="type">uintptr_t</span>)srcva!=<span class="number">-1</span>)&amp;&amp;((<span class="type">uintptr_t</span>)e-&gt;env_ipc_dstva!=<span class="number">-1</span>))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>((<span class="type">uintptr_t</span>)srcva&gt;=UTOP||(srcva!=ROUNDDOWN(srcva,PGSIZE))||((perm&amp;PTE_SYSCALL)!=perm))</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!(page = page_lookup(curenv-&gt;env_pgdir,srcva,&amp;pte)))</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(((*pte&amp;PTE_W)==<span class="number">0</span>)&amp;&amp;((perm&amp;PTE_W)==PTE_W))</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>((result = page_insert(e-&gt;env_pgdir,page,e-&gt;env_ipc_dstva,perm)))</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		}</span><br><span class="line">		e-&gt;env_ipc_perm = perm;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		e-&gt;env_ipc_perm = <span class="number">0</span>;</span><br><span class="line">	e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">	e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">	e-&gt;env_ipc_value = value;</span><br><span class="line"></span><br><span class="line">	e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_recv</span><span class="params">(<span class="type">void</span> *dstva)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uint32_t</span>)dstva != <span class="number">-1</span>) </span><br><span class="line">	{</span><br><span class="line">        <span class="keyword">if</span> (((<span class="type">uintptr_t</span>)dstva &gt;= UTOP) || (dstva!=ROUNDDOWN(dstva,PGSIZE)))</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    }</span><br><span class="line">    curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">    curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    </span><br><span class="line">    curenv-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    sys_yield();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">ipc_recv</span><span class="params">(<span class="type">envid_t</span> *from_env_store, <span class="type">void</span> *pg, <span class="type">int</span> *perm_store)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="keyword">if</span>(pg==<span class="literal">NULL</span>)</span><br><span class="line">		pg = (<span class="type">void</span>*)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>((result = sys_ipc_recv(pg))&lt;<span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(from_env_store!=<span class="literal">NULL</span>)</span><br><span class="line">			*from_env_store = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(perm_store!=<span class="literal">NULL</span>)</span><br><span class="line">			*perm_store=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(from_env_store!=<span class="literal">NULL</span>)</span><br><span class="line">			*from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">		<span class="keyword">if</span>(perm_store!=<span class="literal">NULL</span>)</span><br><span class="line">			*perm_store=thisenv-&gt;env_ipc_perm;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_send</span><span class="params">(<span class="type">envid_t</span> to_env, <span class="type">uint32_t</span> val, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="keyword">if</span>(pg == <span class="literal">NULL</span>)</span><br><span class="line">		pg = (<span class="type">void</span>*)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		result = sys_ipc_try_send(to_env,val,pg,perm);</span><br><span class="line">		<span class="keyword">if</span>(!result)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span>(result == -E_IPC_NOT_RECV)</span><br><span class="line">		{</span><br><span class="line">			sys_yield();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line">		panic(<span class="string">"ipc_send: fail in send--%e\n"</span>,result);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://polaris-snowfall.github.io/2023/6.828-Lab4/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/6%C2%B7828/" rel="tag">6·828</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2023/Shanghai-Master-WP/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            中华武数杯2023 WP
          
        </div>
      </a>
    
    
      <a href="/2023/Lexical-Analysis/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">词法分析</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> 翰青HanQi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="北极落小雪"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/About">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>