<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
        
      <meta name="description" content="Boom? PWN ! ! !" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Dig into Netfilter (一)  —— nf_tables核心概念 |  北极落小雪</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>
  </html>
</html>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Dig into Netfilter (1)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Dig into Netfilter (一)  —— nf_tables核心概念
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/Dig%20into%20Netfilter%20(1)/" class="article-date">
  <time datetime="2024-11-27T16:00:00.000Z" itemprop="datePublished">2024-11-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Pwn/">Pwn</a> / <a class="article-category-link" href="/categories/Pwn/Kernel/">Kernel</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">24 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>xtables? iptables? nf_tables !</p>
<h2 id="nf-tables核心概念"><a href="#nf-tables核心概念" class="headerlink" title="nf_tables核心概念"></a>nf_tables核心概念</h2><p> 源码版本为v5.8或v5.11</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>根据作用及协议族, 在netfilter中分成不同的table., 每个table只能看到自己所属协议族的包.<br>每个table在其有的每一个hook点上有一条chain. 用户也可以添加自定义的chain, 但由于没有对应的hook点, 只能从内置的chain的rule中跳转到(其实从自定义的chain跳转到也行, 前提是前者能被触发).  实际上之前内置chain的说法并不准确, 不同于iptables, nft并不存在预定义的chain, 需要创建nft_base_chain并将其注册到hook点上.<br>多条rule可能在同一个hook点触发, 即属于同一条chain.<br>处理一条rule的过程实际是对rule中包含的expr求值(eval).</p>
<span id="more"></span>


<p>举个例子, 拦截收到的所有目标端口是5000的ipv4数据包.<br>由于作用是拦截(过滤)ipv4, 所以对应的table应该是ip族的某个tale..<br>拦截的hook点应该是在NF_IP_PRE_ROUTING, 那么chain就对应filter表中的PREROUTING.<br>“拦截所有目标端口是5000的ipv4数据包”其实就是rule,<br>为了实现这一rule, 需要的expr有获取数据包中的端口, 将其与5000比较, 若相同则DROP.<br>执行过程以状态机的形式实现, expr是一条”指令”, rule是一个实现特定的目的”函数”,  chain是一系列函数的调用点, 以nf_hook_ops注册到hook点上. 执行一个chain的过程使用一个寄存器集合. 数据包是该状态机的输入输出设备.</p>
<h3 id="规则执行"><a href="#规则执行" class="headerlink" title="规则执行"></a>规则执行</h3><p>每个table的base_chain具有类型nft_chain_type(面向对象),  指示这个table的协议, 注册到各个hook点的nf_hook_ops等.<br>当base_chain被创建时, base_chain-&gt;ops-&gt;hook被设置为type-&gt;hooks[ops-&gt;hooknum].<br>并通过nf_tables_register_hook(net, table, chain);在对应hook点进行注册.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain_type</span> <span class="title">nft_chain_nat_inet</span> =</span> {</span><br><span class="line">	.name		= <span class="string">"nat"</span>,</span><br><span class="line">	.type		= NFT_CHAIN_T_NAT,</span><br><span class="line">	.family		= NFPROTO_INET,</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">	.hook_mask	= (<span class="number">1</span> &lt;&lt; NF_INET_PRE_ROUTING) |</span><br><span class="line">			  (<span class="number">1</span> &lt;&lt; NF_INET_LOCAL_IN) |</span><br><span class="line">			  (<span class="number">1</span> &lt;&lt; NF_INET_LOCAL_OUT) |</span><br><span class="line">			  (<span class="number">1</span> &lt;&lt; NF_INET_POST_ROUTING),</span><br><span class="line">	.hooks		= {</span><br><span class="line">		[NF_INET_PRE_ROUTING]	= nft_nat_do_chain,</span><br><span class="line">		[NF_INET_LOCAL_IN]	= nft_nat_do_chain,</span><br><span class="line">		[NF_INET_LOCAL_OUT]	= nft_nat_do_chain,</span><br><span class="line">		[NF_INET_POST_ROUTING]	= nft_nat_do_chain,</span><br><span class="line">	},</span><br><span class="line">	.ops_register		= nft_nat_inet_reg,</span><br><span class="line">	.ops_unregister		= nft_nat_inet_unreg,</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nft_basechain_hook_init</span><span class="params">(<span class="keyword">struct</span> nf_hook_ops *ops, u8 family,</span></span><br><span class="line"><span class="params">				    <span class="type">const</span> <span class="keyword">struct</span> nft_chain_hook *hook,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> nft_chain *chain)</span></span><br><span class="line">{</span><br><span class="line">	ops-&gt;pf			= family;</span><br><span class="line">	ops-&gt;hooknum		= hook-&gt;num;</span><br><span class="line">	ops-&gt;priority		= hook-&gt;priority;</span><br><span class="line">	ops-&gt;priv		= chain;</span><br><span class="line">	ops-&gt;hook		= hook-&gt;type-&gt;hooks[ops-&gt;hooknum];</span><br><span class="line">	ops-&gt;hook_ops_type	= NF_HOOK_OP_NF_TABLES;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nf_tables_register_hook</span><span class="params">(<span class="keyword">struct</span> net *net,</span></span><br><span class="line"><span class="params">				   <span class="type">const</span> <span class="keyword">struct</span> nft_table *table,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> nft_chain *chain)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_base_chain</span> *<span class="title">basechain</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (table-&gt;flags &amp; NFT_TABLE_F_DORMANT ||</span><br><span class="line">	    !nft_is_base_chain(chain))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	basechain = nft_base_chain(chain);</span><br><span class="line">	ops = &amp;basechain-&gt;ops;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (basechain-&gt;type-&gt;ops_register)</span><br><span class="line">		<span class="keyword">return</span> basechain-&gt;type-&gt;ops_register(net, ops);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nft_base_chain_netdev(table-&gt;family, basechain-&gt;ops.hooknum))</span><br><span class="line">		<span class="keyword">return</span> nft_netdev_register_hooks(net, &amp;basechain-&gt;hook_list);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nf_register_net_hook(net, &amp;basechain-&gt;ops);</span><br></pre></td></tr></tbody></table></figure>


<p>nf_register_net_hook在netns_nf在nf_hook_entries对应的hook点处添加一个hook.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nf_register_net_hook</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_ops *reg)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (reg-&gt;pf == NFPROTO_INET) {</span><br><span class="line">		<span class="keyword">if</span> (reg-&gt;hooknum == NF_INET_INGRESS) {</span><br><span class="line">			err = __nf_register_net_hook(net, NFPROTO_INET, reg);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			err = __nf_register_net_hook(net, NFPROTO_IPV4, reg);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">			err = __nf_register_net_hook(net, NFPROTO_IPV6, reg);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>) {</span><br><span class="line">				__nf_unregister_net_hook(net, NFPROTO_IPV4, reg);</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		err = __nf_register_net_hook(net, reg-&gt;pf, reg);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL(nf_register_net_hook);</span><br></pre></td></tr></tbody></table></figure>



<p>当到达某个hook点, 会调用NF_HOOK或NF_HOOK_LIST调用该hook点所有的hook函数.<br>根据nf_hook的返回值是否为1, 决定是否允许这个包继续通行.若可以继续通行, 调用okfn.如果不能继续通行, 则直接返回, 数据包将不会进行下一阶段的处理. 数据包处理阶段的衔接是通过okfn完成的.<br>比如在ip_recv中, okfn是ip_rcv_finish, 然后将数据包放行到ip_local_deliver, 进入下一阶段的处理.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">NF_HOOK</span><span class="params">(<span class="type">uint8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> net_device *in, <span class="keyword">struct</span> net_device *out,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">		ret = okfn(net, sk, skb);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IP receive entry point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt,</span></span><br><span class="line"><span class="params">	   <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(dev);</span><br><span class="line"></span><br><span class="line">	skb = ip_rcv_core(skb, net);</span><br><span class="line">	<span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,</span><br><span class="line">		       net, <span class="literal">NULL</span>, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">		       ip_rcv_finish);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_rcv_finish</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> skb-&gt;dev;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if ingress device is enslaved to an L3 master device pass the</span></span><br><span class="line"><span class="comment">	 * skb to its handler for processing</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	skb = l3mdev_ip_rcv(skb);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line"></span><br><span class="line">	ret = ip_rcv_finish_core(net, sk, skb, dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret != NET_RX_DROP)</span><br><span class="line">		ret = dst_input(skb);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Input packet from network to transport.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">dst_input</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> INDIRECT_CALL_INET(skb_dst(skb)-&gt;input,</span><br><span class="line">				  ip6_input, ip_local_deliver, skb);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p>nf_hook函数根据协议类型和hook点, 从netns_nf取出对应的nf_hook_entries, 转入nf_hook_slow函数</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	nf_hook - call a netfilter hook</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Returns 1 if the hook has allowed the packet to pass.  The function</span></span><br><span class="line"><span class="comment"> *	okfn must be invoked by the caller in this case.  Any other return</span></span><br><span class="line"><span class="comment"> *	value indicates the packet has been consumed by the hook.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">nf_hook</span><span class="params">(<span class="type">u_int8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> net *net,</span></span><br><span class="line"><span class="params">			  <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">			  <span class="keyword">struct</span> net_device *indev, <span class="keyword">struct</span> net_device *outdev,</span></span><br><span class="line"><span class="params">			  <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> net *, <span class="keyword">struct</span> sock *, <span class="keyword">struct</span> sk_buff *))</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entries</span> *<span class="title">hook_head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_JUMP_LABEL</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_constant_p(pf) &amp;&amp;</span><br><span class="line">	    __builtin_constant_p(hook) &amp;&amp;</span><br><span class="line">	    !static_key_false(&amp;nf_hooks_needed[pf][hook]))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	<span class="keyword">switch</span> (pf) {</span><br><span class="line">	<span class="keyword">case</span> NFPROTO_IPV4:</span><br><span class="line">		hook_head = rcu_dereference(net-&gt;nf.hooks_ipv4[hook]);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFPROTO_IPV6:</span><br><span class="line">		hook_head = rcu_dereference(net-&gt;nf.hooks_ipv6[hook]);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFPROTO_ARP:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NETFILTER_FAMILY_ARP</span></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(hook &gt;= ARRAY_SIZE(net-&gt;nf.hooks_arp)))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		hook_head = rcu_dereference(net-&gt;nf.hooks_arp[hook]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFPROTO_BRIDGE:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NETFILTER_FAMILY_BRIDGE</span></span><br><span class="line">		hook_head = rcu_dereference(net-&gt;nf.hooks_bridge[hook]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hook_head) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_state</span> <span class="title">state</span>;</span></span><br><span class="line"></span><br><span class="line">		nf_hook_state_init(&amp;state, hook, pf, indev, outdev,</span><br><span class="line">				   sk, net, okfn);</span><br><span class="line"></span><br><span class="line">		ret = nf_hook_slow(skb, &amp;state, hook_head, <span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netns_nf</span> {</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_PROC_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">proc_netfilter</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_logger</span> __<span class="title">rcu</span> *<span class="title">nf_loggers</span>[<span class="title">NFPROTO_NUMPROTO</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSCTL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ctl_table_header</span> *<span class="title">nf_log_dir_header</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entries</span> __<span class="title">rcu</span> *<span class="title">hooks_ipv4</span>[<span class="title">NF_INET_NUMHOOKS</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entries</span> __<span class="title">rcu</span> *<span class="title">hooks_ipv6</span>[<span class="title">NF_INET_NUMHOOKS</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NETFILTER_FAMILY_ARP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entries</span> __<span class="title">rcu</span> *<span class="title">hooks_arp</span>[<span class="title">NF_ARP_NUMHOOKS</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NETFILTER_FAMILY_BRIDGE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entries</span> __<span class="title">rcu</span> *<span class="title">hooks_bridge</span>[<span class="title">NF_INET_NUMHOOKS</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_NF_DEFRAG_IPV4)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> defrag_ipv4_users;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_NF_DEFRAG_IPV6)</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> defrag_ipv6_users;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>


<p>nf_hook_slow遍历nf_hook_entries中的每一个hook, 调用hookfn. 并根据返回的verdict决定数据包的进一步处理.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns 1 if okfn() needs to be executed by the caller,</span></span><br><span class="line"><span class="comment"> * -EPERM for NF_DROP, 0 otherwise.  Caller must hold rcu_read_lock. */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nf_hook_slow</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> nf_hook_state *state,</span></span><br><span class="line"><span class="params">		 <span class="type">const</span> <span class="keyword">struct</span> nf_hook_entries *e, <span class="type">unsigned</span> <span class="type">int</span> s)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> verdict;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (; s &lt; e-&gt;num_hook_entries; s++) {</span><br><span class="line">		verdict = nf_hook_entry_hookfn(&amp;e-&gt;hooks[s], skb, state);</span><br><span class="line">		<span class="keyword">switch</span> (verdict &amp; NF_VERDICT_MASK) {</span><br><span class="line">		<span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> NF_DROP:</span><br><span class="line">			kfree_skb_reason(skb,</span><br><span class="line">					 SKB_DROP_REASON_NETFILTER_DROP);</span><br><span class="line">			ret = NF_DROP_GETERR(verdict);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">				ret = -EPERM;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		<span class="keyword">case</span> NF_QUEUE:</span><br><span class="line">			ret = nf_queue(skb, state, s, verdict);</span><br><span class="line">			<span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">/* Implicit handling for NF_STOLEN, as well as any other</span></span><br><span class="line"><span class="comment">			 * non conventional verdicts.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL(nf_hook_slow);</span><br></pre></td></tr></tbody></table></figure>

<p>通过base_chain创建时注册的hook, 在这里进入到对一个chain中一系列rule的执行, 即状态机从这里开始运行.比如对于nft_chain_filter_ipv4类型的chain来说, 这里注册的hook函数是nft_do_chain_ipv4.做一些特化的工作后, 转到nft_do_chain函数.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nft_do_chain_ipv4</span><span class="params">(<span class="type">void</span> *priv,</span></span><br><span class="line"><span class="params">				      <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">				      <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_pktinfo</span> <span class="title">pkt</span>;</span></span><br><span class="line"></span><br><span class="line">	nft_set_pktinfo(&amp;pkt, skb, state);</span><br><span class="line">	nft_set_pktinfo_ipv4(&amp;pkt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nft_do_chain(&amp;pkt, priv);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p>nft_do_chain函数遍历chain中的rule中的每一条expr, 进行求值. 根据每次求值后的verdict决定是否继续求值或如何继续求值(状态机执行流的分支).</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">nft_do_chain</span><span class="params">(<span class="keyword">struct</span> nft_pktinfo *pkt, <span class="type">void</span> *priv)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> =</span> priv, *basechain = chain;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_dp</span> *<span class="title">rule</span>, *<span class="title">last_rule</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> nft_net(pkt);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>, *<span class="title">last</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_regs</span> <span class="title">regs</span> =</span> {};</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> stackptr = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_jumpstack</span> <span class="title">jumpstack</span>[<span class="title">NFT_JUMP_STACK_SIZE</span>];</span></span><br><span class="line">	<span class="type">bool</span> genbit = READ_ONCE(net-&gt;nft.gencursor);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span> *<span class="title">blob</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_traceinfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">	info.trace = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;nft_trace_enabled))</span><br><span class="line">		nft_trace_init(&amp;info, pkt, &amp;regs.verdict, basechain);</span><br><span class="line">do_chain:</span><br><span class="line">	<span class="keyword">if</span> (genbit)</span><br><span class="line">		blob = rcu_dereference(chain-&gt;blob_gen_1);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		blob = rcu_dereference(chain-&gt;blob_gen_0);</span><br><span class="line"></span><br><span class="line">	rule = (<span class="keyword">struct</span> nft_rule_dp *)blob-&gt;data;</span><br><span class="line">	last_rule = (<span class="type">void</span> *)blob-&gt;data + blob-&gt;size;</span><br><span class="line">next_rule:</span><br><span class="line">	regs.verdict.code = NFT_CONTINUE;</span><br><span class="line">	<span class="keyword">for</span> (; rule &lt; last_rule; rule = nft_rule_next(rule)) {</span><br><span class="line">		nft_rule_dp_for_each_expr(expr, last, rule) {</span><br><span class="line">			<span class="keyword">if</span> (expr-&gt;ops == &amp;nft_cmp_fast_ops)</span><br><span class="line">				nft_cmp_fast_eval(expr, &amp;regs);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops == &amp;nft_cmp16_fast_ops)</span><br><span class="line">				nft_cmp16_fast_eval(expr, &amp;regs);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops == &amp;nft_bitwise_fast_ops)</span><br><span class="line">				nft_bitwise_fast_eval(expr, &amp;regs);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (expr-&gt;ops != &amp;nft_payload_fast_ops ||</span><br><span class="line">				 !nft_payload_fast_eval(expr, &amp;regs, pkt))</span><br><span class="line">				expr_call_ops_eval(expr, &amp;regs, pkt);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (regs.verdict.code != NFT_CONTINUE)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (regs.verdict.code) {</span><br><span class="line">		<span class="keyword">case</span> NFT_BREAK:</span><br><span class="line">			regs.verdict.code = NFT_CONTINUE;</span><br><span class="line">			nft_trace_copy_nftrace(pkt, &amp;info);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">case</span> NFT_CONTINUE:</span><br><span class="line">			nft_trace_packet(pkt, &amp;info, chain, rule,</span><br><span class="line">					 NFT_TRACETYPE_RULE);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	nft_trace_verdict(&amp;info, chain, rule, &amp;regs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (regs.verdict.code &amp; NF_VERDICT_MASK) {</span><br><span class="line">	<span class="keyword">case</span> NF_ACCEPT:</span><br><span class="line">	<span class="keyword">case</span> NF_DROP:</span><br><span class="line">	<span class="keyword">case</span> NF_QUEUE:</span><br><span class="line">	<span class="keyword">case</span> NF_STOLEN:</span><br><span class="line">		<span class="keyword">return</span> regs.verdict.code;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (regs.verdict.code) {</span><br><span class="line">	<span class="keyword">case</span> NFT_JUMP:</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(stackptr &gt;= NFT_JUMP_STACK_SIZE))</span><br><span class="line">			<span class="keyword">return</span> NF_DROP;</span><br><span class="line">		jumpstack[stackptr].chain = chain;</span><br><span class="line">		jumpstack[stackptr].rule = nft_rule_next(rule);</span><br><span class="line">		jumpstack[stackptr].last_rule = last_rule;</span><br><span class="line">		stackptr++;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">case</span> NFT_GOTO:</span><br><span class="line">		chain = regs.verdict.chain;</span><br><span class="line">		<span class="keyword">goto</span> do_chain;</span><br><span class="line">	<span class="keyword">case</span> NFT_CONTINUE:</span><br><span class="line">	<span class="keyword">case</span> NFT_RETURN:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		WARN_ON_ONCE(<span class="number">1</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (stackptr &gt; <span class="number">0</span>) {</span><br><span class="line">		stackptr--;</span><br><span class="line">		chain = jumpstack[stackptr].chain;</span><br><span class="line">		rule = jumpstack[stackptr].rule;</span><br><span class="line">		last_rule = jumpstack[stackptr].last_rule;</span><br><span class="line">		<span class="keyword">goto</span> next_rule;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	nft_trace_packet(pkt, &amp;info, basechain, <span class="literal">NULL</span>, NFT_TRACETYPE_POLICY);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (static_branch_unlikely(&amp;nft_counters_enabled))</span><br><span class="line">		nft_update_chain_stats(basechain, pkt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nft_base_chain(basechain)-&gt;policy;</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_do_chain);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="新增规则"><a href="#新增规则" class="headerlink" title="新增规则"></a>新增规则</h3><p>通过netlink发起新增规则的请求会调用到nf_tables_newrule函数. 先通过nlattr中的NFTA_RULE_TABLE, NFTA_RULE_CHAIN两个字段查找对应table中的对应chain.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nf_tables_newrule</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *nlsk,</span></span><br><span class="line"><span class="params">			     <span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nlmsghdr *nlh,</span></span><br><span class="line"><span class="params">			     <span class="type">const</span> <span class="keyword">struct</span> nlattr * <span class="type">const</span> nla[],</span></span><br><span class="line"><span class="params">			     <span class="keyword">struct</span> netlink_ext_ack *extack)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nfgenmsg</span> *<span class="title">nfmsg</span> =</span> nlmsg_data(nlh);</span><br><span class="line">	u8 genmask = nft_genmask_next(net);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_info</span> *<span class="title">info</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> family = nfmsg-&gt;nfgen_family;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_flow_rule</span> *<span class="title">flow</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span> *<span class="title">table</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule</span> *<span class="title">rule</span>, *<span class="title">old_rule</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_userdata</span> *<span class="title">udata</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_trans</span> *<span class="title">trans</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tmp</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size, i, n, ulen = <span class="number">0</span>, usize = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> err, rem;</span><br><span class="line">	u64 handle, pos_handle;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;net-&gt;nft.commit_mutex);</span><br><span class="line"></span><br><span class="line">	table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(table)) {</span><br><span class="line">		NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(table);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN], genmask);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(chain)) {</span><br><span class="line">		NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(chain);</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来是个分支.</p>
<ul>
<li>如果在nla中指定了NFTA_RULE_HANDLE, 意味着是要在已有的rule上进行替换.通过查找NFTA_RULE_HANDLE值找到对应rule, 并检查nlh-&gt;nlmsg_flags是否允许在已有规则上操作.</li>
<li>否则是添加一个新的规则. 同样检查nlh-&gt;nlmsg_flags后, 分配一个handle值(实际就是++table-&gt;hgenerator).  然后获取上一条规则(即确定插入位置), 有两种获取方式, 通过handle值NFTA_RULE_POSITION或上一条规则被添加时的NFTA_RULE_POSITION_ID.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_HANDLE]) {</span><br><span class="line">	handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_HANDLE]));</span><br><span class="line">	rule = __nft_rule_lookup(chain, handle);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(rule)) {</span><br><span class="line">		NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(rule);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) {</span><br><span class="line">		NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]);</span><br><span class="line">		<span class="keyword">return</span> -EEXIST;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line">		old_rule = rule;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">	<span class="keyword">if</span> (!(nlh-&gt;nlmsg_flags &amp; NLM_F_CREATE) ||</span><br><span class="line">	    nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	handle = nf_tables_alloc_handle(table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chain-&gt;use == UINT_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nla[NFTA_RULE_POSITION]) {</span><br><span class="line">		pos_handle = be64_to_cpu(nla_get_be64(nla[NFTA_RULE_POSITION]));</span><br><span class="line">		old_rule = __nft_rule_lookup(chain, pos_handle);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(old_rule)) {</span><br><span class="line">			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION]);</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(old_rule);</span><br><span class="line">		}</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (nla[NFTA_RULE_POSITION_ID]) {</span><br><span class="line">		old_rule = nft_rule_lookup_byid(net, nla[NFTA_RULE_POSITION_ID]);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(old_rule)) {</span><br><span class="line">			NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_POSITION_ID]);</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(old_rule);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>接下来进入到实际rule的解析部分.<br>先是表达式解析, 代码比较难理解.</p>
<p>一个表达式属性具有多种属性, 所以表达式属性本身的类型是一个嵌套属性.而nla[NFTA_RULE_EXPRESSIONS]中存储了一条rule中的所有表达式属性, 其类型是嵌套属性数组(虽然nft_policy中表示其类型是嵌套属性, 但笔者认为应该是后者). </p>
<blockquote>
<p>NL_ATTR_TYPE_NESTED<br>  nested, i.e. the content of this attribute consists of sub-attributes. The nested policy and maxtype inside may be specified.</p>
<p>   NL_ATTR_TYPE_NESTED_ARRAY<br>  nested array, i.e. the content of this attribute contains sub-attributes whose type is irrelevant (just used to separate the array entries) and each such array entry has attributes again, the policy for those inner ones and the corresponding maxtype may be specified.</p>
</blockquote>
<p>先分配NFT_RULE_MAXEXPRS个nft_expr_info的空间, 遍历nla[NFTA_RULE_EXPRESSIONS]嵌套属性数组中的嵌套属性, 调用nf_tables_expr_parse函数进行parse, parse的结果即存储在nft_expr_info中.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">nft_ctx_init(&amp;ctx, net, skb, nlh, family, table, chain, nla);</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_EXPRESSIONS]) {</span><br><span class="line">	info = kvmalloc_array(NFT_RULE_MAXEXPRS,</span><br><span class="line">			      <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nft_expr_info),</span><br><span class="line">			      GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!info)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	nla_for_each_nested(tmp, nla[NFTA_RULE_EXPRESSIONS], rem) {</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (nla_type(tmp) != NFTA_LIST_ELEM)</span><br><span class="line">			<span class="keyword">goto</span> err1;</span><br><span class="line">		<span class="keyword">if</span> (n == NFT_RULE_MAXEXPRS)</span><br><span class="line">			<span class="keyword">goto</span> err1;</span><br><span class="line">		err = nf_tables_expr_parse(&amp;ctx, tmp, &amp;info[n]);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> err1;</span><br><span class="line">		size += info[n].ops-&gt;size;</span><br><span class="line">		n++;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* Check for overflow of dlen field */</span></span><br><span class="line">err = -EFBIG;</span><br><span class="line"><span class="keyword">if</span> (size &gt;= <span class="number">1</span> &lt;&lt; <span class="number">12</span>)</span><br><span class="line">	<span class="keyword">goto</span> err1;</span><br></pre></td></tr></tbody></table></figure>


<p>审计到这里时, 发现ulen来自属性NFTA_RULE_USERDATA且在此处缺乏验证,若可控可能会在kzalloc处造成整型溢出.  但实际上对于每一种属性, 都在对应的nla_policy中有相应的类型定义和限制. 如nft_rule_policy中就限制了ulen的最大值为NFT_USERDATA_MAXLEN.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nla[NFTA_RULE_USERDATA]) {</span><br><span class="line">	ulen = nla_len(nla[NFTA_RULE_USERDATA]);</span><br><span class="line">	<span class="keyword">if</span> (ulen &gt; <span class="number">0</span>)</span><br><span class="line">		usize = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nft_userdata) + ulen;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">err = -ENOMEM;</span><br><span class="line">rule = kzalloc(<span class="keyword">sizeof</span>(*rule) + size + usize, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (rule == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line">nft_activate_next(net, rule);</span><br><span class="line"></span><br><span class="line">rule-&gt;handle = handle;</span><br><span class="line">rule-&gt;dlen   = size;</span><br><span class="line">rule-&gt;udata  = ulen ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ulen) {</span><br><span class="line">	udata = nft_userdata(rule);</span><br><span class="line">	udata-&gt;len = ulen - <span class="number">1</span>;</span><br><span class="line">	nla_memcpy(udata-&gt;data, nla[NFTA_RULE_USERDATA], ulen);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>根据nft_expr_info数组生成对应的expr. nf_tables_newexpr函数设置expr-&gt;ops=info-&gt;ops, 并调用ops-&gt;init函数构造表达式.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">expr = nft_expr_first(rule);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">	err = nf_tables_newexpr(&amp;ctx, &amp;info[i], expr);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info[i].ops-&gt;validate)</span><br><span class="line">		nft_validate_state_update(net, NFT_VALIDATE_NEED);</span><br><span class="line"></span><br><span class="line">	info[i].ops = <span class="literal">NULL</span>;</span><br><span class="line">	expr = nft_expr_next(expr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>将rule加入或替换到chain中, 做一些收尾工作.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE) {</span><br><span class="line">		trans = nft_trans_rule_add(&amp;ctx, NFT_MSG_NEWRULE, rule);</span><br><span class="line">		<span class="keyword">if</span> (trans == <span class="literal">NULL</span>) {</span><br><span class="line">			err = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> err2;</span><br><span class="line">		}</span><br><span class="line">		err = nft_delrule(&amp;ctx, old_rule);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>) {</span><br><span class="line">			nft_trans_destroy(trans);</span><br><span class="line">			<span class="keyword">goto</span> err2;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		trans = nft_trans_rule_add(&amp;ctx, NFT_MSG_NEWRULE, rule);</span><br><span class="line">		<span class="keyword">if</span> (!trans) {</span><br><span class="line">			err = -ENOMEM;</span><br><span class="line">			<span class="keyword">goto</span> err2;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nlh-&gt;nlmsg_flags &amp; NLM_F_APPEND) {</span><br><span class="line">			<span class="keyword">if</span> (old_rule)</span><br><span class="line">				list_add_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;chain-&gt;rules);</span><br><span class="line">		 } <span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">if</span> (old_rule)</span><br><span class="line">				list_add_tail_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;old_rule-&gt;<span class="built_in">list</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				list_add_rcu(&amp;rule-&gt;<span class="built_in">list</span>, &amp;chain-&gt;rules);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	kvfree(info);</span><br><span class="line">	chain-&gt;use++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (net-&gt;nft.validate_state == NFT_VALIDATE_DO)</span><br><span class="line">		<span class="keyword">return</span> nft_table_validate(net, table);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (chain-&gt;flags &amp; NFT_CHAIN_HW_OFFLOAD) {</span><br><span class="line">		flow = nft_flow_rule_create(net, rule);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(flow))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(flow);</span><br><span class="line"></span><br><span class="line">		nft_trans_flow_rule(trans) = flow;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line">	nf_tables_rule_release(&amp;ctx, rule);</span><br><span class="line">err1:</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">		<span class="keyword">if</span> (info[i].ops) {</span><br><span class="line">			module_put(info[i].ops-&gt;type-&gt;owner);</span><br><span class="line">			<span class="keyword">if</span> (info[i].ops-&gt;type-&gt;release_ops)</span><br><span class="line">				info[i].ops-&gt;type-&gt;release_ops(info[i].ops);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	kvfree(info);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>下面来看看一个表达式嵌套属性的parse过程.<br>nf_tables_expr_parse函数.</p>
<ul>
<li>调用nla_parse_nested_deprecated将嵌套属性nla中的各属性起始位置解析到tb中, tb是nlattr类型的指针数组.</li>
<li>根据ctx-&gt;net, ctx-&gt;family, tb[NFTA_EXPR_NAME]获取nft_expr_type.</li>
<li>如果有tb[NFTA_EXPR_DATA]嵌套属性,  调用nla_parse_nested_deprecated将其parse到nft_expr_info-&gt;tb, 否则将info-&gt;tb清空.</li>
<li>设置info-&gt;ops<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nf_tables_expr_parse</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="keyword">struct</span> nlattr *nla,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> nft_expr_info *info)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_type</span> *<span class="title">type</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tb</span>[<span class="title">NFTA_EXPR_MAX</span> + 1];</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,</span><br><span class="line">					  nft_expr_policy, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	type = nft_expr_type_get(ctx-&gt;net, ctx-&gt;family, tb[NFTA_EXPR_NAME]);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(type))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(type);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tb[NFTA_EXPR_DATA]) {</span><br><span class="line">		err = nla_parse_nested_deprecated(info-&gt;tb, type-&gt;maxattr,</span><br><span class="line">						  tb[NFTA_EXPR_DATA],</span><br><span class="line">						  type-&gt;policy, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> err1;</span><br><span class="line">	} <span class="keyword">else</span></span><br><span class="line">		<span class="built_in">memset</span>(info-&gt;tb, <span class="number">0</span>, <span class="keyword">sizeof</span>(info-&gt;tb[<span class="number">0</span>]) * (type-&gt;maxattr + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type-&gt;select_ops != <span class="literal">NULL</span>) {</span><br><span class="line">		ops = type-&gt;select_ops(ctx,</span><br><span class="line">				       (<span class="type">const</span> <span class="keyword">struct</span> nlattr * <span class="type">const</span> *)info-&gt;tb);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(ops)) {</span><br><span class="line">			err = PTR_ERR(ops);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MODULES</span></span><br><span class="line">			<span class="keyword">if</span> (err == -EAGAIN)</span><br><span class="line">				<span class="keyword">if</span> (nft_expr_type_request_module(ctx-&gt;net,</span><br><span class="line">								 ctx-&gt;family,</span><br><span class="line">								 tb[NFTA_EXPR_NAME]) != -EAGAIN)</span><br><span class="line">					err = -ENOENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">goto</span> err1;</span><br><span class="line">		}</span><br><span class="line">	} <span class="keyword">else</span></span><br><span class="line">		ops = type-&gt;ops;</span><br><span class="line"></span><br><span class="line">	info-&gt;ops = ops;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err1:</span><br><span class="line">	module_put(type-&gt;owner);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nla_parse_nested_deprecated - parse nested attributes</span></span><br><span class="line"><span class="comment"> * @tb: destination array with maxtype+1 elements</span></span><br><span class="line"><span class="comment"> * @maxtype: maximum attribute type to be expected</span></span><br><span class="line"><span class="comment"> * @nla: attribute containing the nested attributes</span></span><br><span class="line"><span class="comment"> * @policy: validation policy</span></span><br><span class="line"><span class="comment"> * @extack: extended ACK report struct</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See nla_parse_deprecated()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">nla_parse_nested_deprecated</span><span class="params">(<span class="keyword">struct</span> nlattr *tb[], <span class="type">int</span> maxtype,</span></span><br><span class="line"><span class="params">					      <span class="type">const</span> <span class="keyword">struct</span> nlattr *nla,</span></span><br><span class="line"><span class="params">					      <span class="type">const</span> <span class="keyword">struct</span> nla_policy *policy,</span></span><br><span class="line"><span class="params">					      <span class="keyword">struct</span> netlink_ext_ack *extack)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> __nla_parse(tb, maxtype, nla_data(nla), nla_len(nla), policy,</span><br><span class="line">			   NL_VALIDATE_LIBERAL, extack);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __nla_parse - Parse a stream of attributes into a tb buffer</span></span><br><span class="line"><span class="comment"> * @tb: destination array with maxtype+1 elements</span></span><br><span class="line"><span class="comment"> * @maxtype: maximum attribute type to be expected</span></span><br><span class="line"><span class="comment"> * @head: head of attribute stream</span></span><br><span class="line"><span class="comment"> * @len: length of attribute stream</span></span><br><span class="line"><span class="comment"> * @policy: validation policy</span></span><br><span class="line"><span class="comment"> * @validate: validation strictness</span></span><br><span class="line"><span class="comment"> * @extack: extended ACK pointer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parses a stream of attributes and stores a pointer to each attribute in</span></span><br><span class="line"><span class="comment"> * the tb array accessible via the attribute type.</span></span><br><span class="line"><span class="comment"> * Validation is controlled by the @validate parameter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success or a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __nla_parse(<span class="keyword">struct</span> nlattr **tb, <span class="type">int</span> maxtype,</span><br><span class="line">		<span class="type">const</span> <span class="keyword">struct</span> nlattr *head, <span class="type">int</span> len,</span><br><span class="line">		<span class="type">const</span> <span class="keyword">struct</span> nla_policy *policy, <span class="type">unsigned</span> <span class="type">int</span> validate,</span><br><span class="line">		<span class="keyword">struct</span> netlink_ext_ack *extack)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> __nla_validate_parse(head, len, maxtype, policy, validate,</span><br><span class="line">				    extack, tb, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL(__nla_parse);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __nla_validate_parse(<span class="type">const</span> <span class="keyword">struct</span> nlattr *head, <span class="type">int</span> len, <span class="type">int</span> maxtype,</span><br><span class="line">				<span class="type">const</span> <span class="keyword">struct</span> nla_policy *policy,</span><br><span class="line">				<span class="type">unsigned</span> <span class="type">int</span> validate,</span><br><span class="line">				<span class="keyword">struct</span> netlink_ext_ack *extack,</span><br><span class="line">				<span class="keyword">struct</span> nlattr **tb, <span class="type">unsigned</span> <span class="type">int</span> depth)</span><br><span class="line">{</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">nla</span>;</span></span><br><span class="line">	<span class="type">int</span> rem;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (depth &gt;= MAX_POLICY_RECURSION_DEPTH) {</span><br><span class="line">		NL_SET_ERR_MSG(extack,</span><br><span class="line">			       <span class="string">"allowed policy recursion depth exceeded"</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tb)</span><br><span class="line">		<span class="built_in">memset</span>(tb, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nlattr *) * (maxtype + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	nla_for_each_attr(nla, head, len, rem) {</span><br><span class="line">		u16 type = nla_type(nla);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (type == <span class="number">0</span> || type &gt; maxtype) {</span><br><span class="line">			<span class="keyword">if</span> (validate &amp; NL_VALIDATE_MAXTYPE) {</span><br><span class="line">				NL_SET_ERR_MSG_ATTR(extack, nla,</span><br><span class="line">						    <span class="string">"Unknown attribute type"</span>);</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (policy) {</span><br><span class="line">			<span class="type">int</span> err = validate_nla(nla, maxtype, policy,</span><br><span class="line">					       validate, extack, depth);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tb)</span><br><span class="line">			tb[type] = (<span class="keyword">struct</span> nlattr *)nla;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(rem &gt; <span class="number">0</span>)) {</span><br><span class="line">		pr_warn_ratelimited(<span class="string">"netlink: %d bytes leftover after parsing attributes in process `%s'.\n"</span>,</span><br><span class="line">				    rem, current-&gt;comm);</span><br><span class="line">		NL_SET_ERR_MSG(extack, <span class="string">"bytes leftover after parsing attributes"</span>);</span><br><span class="line">		<span class="keyword">if</span> (validate &amp; NL_VALIDATE_TRAILING)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>最终在validate_nla中完成对单个属性的校验, 校验依据是对应的nla_policy.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">validate_nla</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nlattr *nla, <span class="type">int</span> maxtype,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> nla_policy *policy, <span class="type">unsigned</span> <span class="type">int</span> validate,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> netlink_ext_ack *extack, <span class="type">unsigned</span> <span class="type">int</span> depth)</span></span><br><span class="line">{</span><br><span class="line">	u16 strict_start_type = policy[<span class="number">0</span>].strict_start_type;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nla_policy</span> *<span class="title">pt</span>;</span></span><br><span class="line">	<span class="type">int</span> minlen = <span class="number">0</span>, attrlen = nla_len(nla), type = nla_type(nla);</span><br><span class="line">	<span class="type">int</span> err = -ERANGE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (strict_start_type &amp;&amp; type &gt;= strict_start_type)</span><br><span class="line">		validate |= NL_VALIDATE_STRICT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (type &lt;= <span class="number">0</span> || type &gt; maxtype)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pt = &amp;policy[type];</span><br><span class="line"></span><br><span class="line">	BUG_ON(pt-&gt;type &gt; NLA_TYPE_MAX);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((nla_attr_len[pt-&gt;type] &amp;&amp; attrlen != nla_attr_len[pt-&gt;type]) ||</span><br><span class="line">	    (pt-&gt;type == NLA_EXACT_LEN &amp;&amp;</span><br><span class="line">	     pt-&gt;validation_type == NLA_VALIDATE_WARN_TOO_LONG &amp;&amp;</span><br><span class="line">	     attrlen != pt-&gt;len)) {</span><br><span class="line">		pr_warn_ratelimited(<span class="string">"netlink: '%s': attribute type %d has an invalid length.\n"</span>,</span><br><span class="line">				    current-&gt;comm, type);</span><br><span class="line">		<span class="keyword">if</span> (validate &amp; NL_VALIDATE_STRICT_ATTRS) {</span><br><span class="line">			NL_SET_ERR_MSG_ATTR(extack, nla,</span><br><span class="line">					    <span class="string">"invalid attribute length"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (validate &amp; NL_VALIDATE_NESTED) {</span><br><span class="line">		<span class="keyword">if</span> ((pt-&gt;type == NLA_NESTED || pt-&gt;type == NLA_NESTED_ARRAY) &amp;&amp;</span><br><span class="line">		    !(nla-&gt;nla_type &amp; NLA_F_NESTED)) {</span><br><span class="line">			NL_SET_ERR_MSG_ATTR(extack, nla,</span><br><span class="line">					    <span class="string">"NLA_F_NESTED is missing"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (pt-&gt;type != NLA_NESTED &amp;&amp; pt-&gt;type != NLA_NESTED_ARRAY &amp;&amp;</span><br><span class="line">		    pt-&gt;type != NLA_UNSPEC &amp;&amp; (nla-&gt;nla_type &amp; NLA_F_NESTED)) {</span><br><span class="line">			NL_SET_ERR_MSG_ATTR(extack, nla,</span><br><span class="line">					    <span class="string">"NLA_F_NESTED not expected"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (pt-&gt;type) {</span><br><span class="line">	<span class="keyword">case</span> NLA_REJECT:</span><br><span class="line">		<span class="keyword">if</span> (extack &amp;&amp; pt-&gt;reject_message) {</span><br><span class="line">			NL_SET_BAD_ATTR(extack, nla);</span><br><span class="line">			extack-&gt;_msg = pt-&gt;reject_message;</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		}</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> NLA_FLAG:</span><br><span class="line">		<span class="keyword">if</span> (attrlen &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> NLA_BITFIELD32:</span><br><span class="line">		<span class="keyword">if</span> (attrlen != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> nla_bitfield32))</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">		err = validate_nla_bitfield32(nla, pt-&gt;bitfield32_valid);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> NLA_NUL_STRING:</span><br><span class="line">		<span class="keyword">if</span> (pt-&gt;len)</span><br><span class="line">			minlen = <span class="type">min_t</span>(<span class="type">int</span>, attrlen, pt-&gt;len + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			minlen = attrlen;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!minlen || <span class="built_in">memchr</span>(nla_data(nla), <span class="string">'\0'</span>, minlen) == <span class="literal">NULL</span>) {</span><br><span class="line">			err = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">/* fall through */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> NLA_STRING:</span><br><span class="line">		<span class="keyword">if</span> (attrlen &lt; <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pt-&gt;len) {</span><br><span class="line">			<span class="type">char</span> *buf = nla_data(nla);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (buf[attrlen - <span class="number">1</span>] == <span class="string">'\0'</span>)</span><br><span class="line">				attrlen--;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (attrlen &gt; pt-&gt;len)</span><br><span class="line">				<span class="keyword">goto</span> out_err;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> NLA_BINARY:</span><br><span class="line">		<span class="keyword">if</span> (pt-&gt;len &amp;&amp; attrlen &gt; pt-&gt;len)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> NLA_NESTED:</span><br><span class="line">		<span class="comment">/* a nested attributes is allowed to be empty; if its not,</span></span><br><span class="line"><span class="comment">		 * it must have a size of at least NLA_HDRLEN.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (attrlen == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (attrlen &lt; NLA_HDRLEN)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		<span class="keyword">if</span> (pt-&gt;nested_policy) {</span><br><span class="line">			err = __nla_validate_parse(nla_data(nla), nla_len(nla),</span><br><span class="line">						   pt-&gt;len, pt-&gt;nested_policy,</span><br><span class="line">						   validate, extack, <span class="literal">NULL</span>,</span><br><span class="line">						   depth + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>) {</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * return directly to preserve the inner</span></span><br><span class="line"><span class="comment">				 * error message/attribute pointer</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NLA_NESTED_ARRAY:</span><br><span class="line">		<span class="comment">/* a nested array attribute is allowed to be empty; if its not,</span></span><br><span class="line"><span class="comment">		 * it must have a size of at least NLA_HDRLEN.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (attrlen == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (attrlen &lt; NLA_HDRLEN)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		<span class="keyword">if</span> (pt-&gt;nested_policy) {</span><br><span class="line">			<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">			err = nla_validate_array(nla_data(nla), nla_len(nla),</span><br><span class="line">						 pt-&gt;len, pt-&gt;nested_policy,</span><br><span class="line">						 extack, validate, depth);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>) {</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * return directly to preserve the inner</span></span><br><span class="line"><span class="comment">				 * error message/attribute pointer</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> NLA_UNSPEC:</span><br><span class="line">		<span class="keyword">if</span> (validate &amp; NL_VALIDATE_UNSPEC) {</span><br><span class="line">			NL_SET_ERR_MSG_ATTR(extack, nla,</span><br><span class="line">					    <span class="string">"Unsupported attribute"</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">/* fall through */</span></span><br><span class="line">	<span class="keyword">case</span> NLA_MIN_LEN:</span><br><span class="line">		<span class="keyword">if</span> (attrlen &lt; pt-&gt;len)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> NLA_EXACT_LEN:</span><br><span class="line">		<span class="keyword">if</span> (pt-&gt;validation_type != NLA_VALIDATE_WARN_TOO_LONG) {</span><br><span class="line">			<span class="keyword">if</span> (attrlen != pt-&gt;len)</span><br><span class="line">				<span class="keyword">goto</span> out_err;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">/* fall through */</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (pt-&gt;len)</span><br><span class="line">			minlen = pt-&gt;len;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			minlen = nla_attr_minlen[pt-&gt;type];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (attrlen &lt; minlen)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* further validation */</span></span><br><span class="line">	<span class="keyword">switch</span> (pt-&gt;validation_type) {</span><br><span class="line">	<span class="keyword">case</span> NLA_VALIDATE_NONE:</span><br><span class="line">		<span class="comment">/* nothing to do */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NLA_VALIDATE_RANGE_PTR:</span><br><span class="line">	<span class="keyword">case</span> NLA_VALIDATE_RANGE:</span><br><span class="line">	<span class="keyword">case</span> NLA_VALIDATE_MIN:</span><br><span class="line">	<span class="keyword">case</span> NLA_VALIDATE_MAX:</span><br><span class="line">		err = nla_validate_int_range(pt, nla, extack);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NLA_VALIDATE_FUNCTION:</span><br><span class="line">		<span class="keyword">if</span> (pt-&gt;validate) {</span><br><span class="line">			err = pt-&gt;validate(nla, extack);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">out_err:</span><br><span class="line">	NL_SET_ERR_MSG_ATTR(extack, nla, <span class="string">"Attribute failed policy validation"</span>);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="expr校验"><a href="#expr校验" class="headerlink" title="expr校验"></a>expr校验</h3><p>既然netfilter实际上是一个执行由用户提供的指令的vm, 就必然需要对用户数据的校验.<br>基本有这样几处:</p>
<ol>
<li><p>validate_nla中根据nft_policy对属性进行校验.<br>比如之前提过的, NFTA_RULE_USERDATA属性的长度有NFT_USERDATA_MAXLEN的限制.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nla_policy</span> <span class="title">nft_rule_policy</span>[<span class="title">NFTA_RULE_MAX</span> + 1] =</span> {</span><br><span class="line">	[NFTA_RULE_TABLE]	= { .type = NLA_STRING,</span><br><span class="line">				    .len = NFT_TABLE_MAXNAMELEN - <span class="number">1</span> },</span><br><span class="line">	[NFTA_RULE_CHAIN]	= { .type = NLA_STRING,</span><br><span class="line">				    .len = NFT_CHAIN_MAXNAMELEN - <span class="number">1</span> },</span><br><span class="line">	[NFTA_RULE_HANDLE]	= { .type = NLA_U64 },</span><br><span class="line">	[NFTA_RULE_EXPRESSIONS]	= { .type = NLA_NESTED },</span><br><span class="line">	[NFTA_RULE_COMPAT]	= { .type = NLA_NESTED },</span><br><span class="line">	[NFTA_RULE_POSITION]	= { .type = NLA_U64 },</span><br><span class="line">	[NFTA_RULE_USERDATA]	= { .type = NLA_BINARY,</span><br><span class="line">				    .len = NFT_USERDATA_MAXLEN },</span><br><span class="line">	[NFTA_RULE_ID]		= { .type = NLA_U32 },</span><br><span class="line">	[NFTA_RULE_POSITION_ID]	= { .type = NLA_U32 },</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>nft_xxx_init中构造expr时的校验.<br>expr求值的过程中不是直接使用用户提供的属性, 而是在构造函数中校验/转换后存入<br>nft_xx_expr的private数据中.</p>
</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nft_cmp_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx, <span class="type">const</span> <span class="keyword">struct</span> nft_expr *expr,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> nlattr * <span class="type">const</span> tb[])</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_cmp_expr</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_data_desc</span> <span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = nft_data_init(<span class="literal">NULL</span>, &amp;priv-&gt;data, <span class="keyword">sizeof</span>(priv-&gt;data), &amp;desc,</span><br><span class="line">			    tb[NFTA_CMP_DATA]);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (desc.type != NFT_DATA_VALUE) {</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		nft_data_release(&amp;priv-&gt;data, desc.type);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	priv-&gt;sreg = nft_parse_register(tb[NFTA_CMP_SREG]);</span><br><span class="line">	err = nft_validate_register_load(priv-&gt;sreg, desc.len);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	priv-&gt;op  = ntohl(nla_get_be32(tb[NFTA_CMP_OP]));</span><br><span class="line">	priv-&gt;len = desc.len;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li>nft_xxx_eval求值时校验.<br>由于一些与packet相关的信息只能在求值时获取, 所以一些校验工作需要推迟到求值时.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nft_payload_eval</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_expr *expr,</span></span><br><span class="line"><span class="params">		      <span class="keyword">struct</span> nft_regs *regs,</span></span><br><span class="line"><span class="params">		      <span class="type">const</span> <span class="keyword">struct</span> nft_pktinfo *pkt)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_payload</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> =</span> pkt-&gt;skb;</span><br><span class="line">	u32 *dest = &amp;regs-&gt;data[priv-&gt;dreg];</span><br><span class="line">	<span class="type">int</span> offset;</span><br><span class="line"></span><br><span class="line">	dest[priv-&gt;len / NFT_REG32_SIZE] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">switch</span> (priv-&gt;base) {</span><br><span class="line">	<span class="keyword">case</span> NFT_PAYLOAD_LL_HEADER:</span><br><span class="line">		<span class="keyword">if</span> (!skb_mac_header_was_set(skb))</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (skb_vlan_tag_present(skb)) {</span><br><span class="line">			<span class="keyword">if</span> (!nft_payload_copy_vlan(dest, skb,</span><br><span class="line">						   priv-&gt;offset, priv-&gt;len))</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		offset = skb_mac_header(skb) - skb-&gt;data;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_PAYLOAD_NETWORK_HEADER:</span><br><span class="line">		offset = skb_network_offset(skb);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_PAYLOAD_TRANSPORT_HEADER:</span><br><span class="line">		<span class="keyword">if</span> (!pkt-&gt;tprot_set)</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		offset = pkt-&gt;xt.thoff;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		BUG();</span><br><span class="line">	}</span><br><span class="line">	offset += priv-&gt;offset;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (skb_copy_bits(skb, offset, dest, priv-&gt;len) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">err:</span><br><span class="line">	regs-&gt;verdict.code = NFT_BREAK;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://polaris-snowfall.github.io/2024/Dig%20into%20Netfilter%20(1)/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netfilter/" rel="tag">Netfilter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pwn/" rel="tag">Pwn</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/Dig%20into%20Netfilter%20(2)/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Dig into Netfilter (二) —— CVE-2022-1015 / CVE-2022-1016
          
        </div>
      </a>
    
    
      <a href="/2024/Linux%20-%20KSM%20--%20ARM64%20v5.0/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Linux内核 KSM机制 -- ARM64 v5.0</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> 翰青HanQi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="北极落小雪"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/About">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>