<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
        
      <meta name="description" content="Boom? PWN ! ! !" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>CS144 Lab |  北极落小雪</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>
  </html>
</html>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-CS144 Lab"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  CS144 Lab
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/CS144%20Lab/" class="article-date">
  <time datetime="2024-04-16T16:00:00.000Z" itemprop="datePublished">2024-04-17</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">3.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">21 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>学二进制的不懂计网很正常吧…<br>潦草记录,只是证明没在摆烂…</p>
<span id="more"></span>

<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202404171302061.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202404162128670.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202404171357696.png"></p>
<h1 id="Checkpoint-0-networking-warmup"><a href="#Checkpoint-0-networking-warmup" class="headerlink" title="Checkpoint 0: networking warmup"></a>Checkpoint 0: networking warmup</h1><h2 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h2><p>使用telnet发http报文<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202404091047579.png"></p>
<p>nc监听并与telnet交互:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202404091055577.png"></p>
<h2 id="webget"><a href="#webget" class="headerlink" title="webget"></a>webget</h2><p>编写webget,刚开始时报getaddrinfo(cs144.keithw.org, http): Servname not supported for ai_socktype,查阅发现getaddrinfo是从/etc/services查询服务对应的端口,而我使用的docker环境中没有这一文件,从主机上拷贝过来即可.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">( <span class="type">const</span> string&amp; host, <span class="type">const</span> string&amp; path )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  cerr &lt;&lt; <span class="string">"Function called: get_URL("</span> &lt;&lt; host &lt;&lt; <span class="string">", "</span> &lt;&lt; path &lt;&lt; <span class="string">")\n"</span>;</span><br><span class="line">  TCPSocket tsocket;</span><br><span class="line">  string read_buf;</span><br><span class="line">  tsocket.<span class="built_in">connect</span>( Address { host, <span class="string">"http"</span> } );</span><br><span class="line"></span><br><span class="line">  tsocket.<span class="built_in">write</span>( <span class="string">"GET "</span> + path + <span class="string">" HTTP/1.1\r\n"</span> );</span><br><span class="line">  tsocket.<span class="built_in">write</span>( <span class="string">"Host: "</span> + host + <span class="string">"\r\n"</span> );</span><br><span class="line">  tsocket.<span class="built_in">write</span>( <span class="string">"Connection: close\r\n"</span> );</span><br><span class="line">  tsocket.<span class="built_in">write</span>( <span class="string">"\r\n"</span> );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( !tsocket.<span class="built_in">eof</span>() ) {</span><br><span class="line">    tsocket.<span class="built_in">read</span>( read_buf );</span><br><span class="line">    cout &lt;&lt; read_buf;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  tsocket.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="byte-stream"><a href="#byte-stream" class="headerlink" title="byte_stream"></a>byte_stream</h2><p>编写内存中可靠的字节流(其实不可靠,容量满了直接丢了).<br>使用deque做底层缓冲区: 双端开口,”连续”空间.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Writer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ByteStream</span><span class="params">( <span class="type">uint64_t</span> capacity )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Helper functions (provided) to access the ByteStream's Reader and Writer interfaces</span></span><br><span class="line">  <span class="function">Reader&amp; <span class="title">reader</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> Reader&amp; <span class="title">reader</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">Writer&amp; <span class="title">writer</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> Writer&amp; <span class="title">writer</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_error</span><span class="params">()</span> </span>{ error_ = <span class="literal">true</span>; };       <span class="comment">// Signal that the stream suffered an error.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">has_error</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> error_; }; <span class="comment">// Has the stream had an error?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// Please add any additional state to the ByteStream here, and not to the Writer and Reader interfaces.</span></span><br><span class="line">  <span class="type">uint64_t</span> capacity_;</span><br><span class="line">  std::deque&lt;<span class="type">char</span>&gt; buffer_ {};</span><br><span class="line">  <span class="type">bool</span> error_ {};</span><br><span class="line">  <span class="type">bool</span> closed_ {};</span><br><span class="line">  <span class="type">uint64_t</span> bytes_pushed_ {};</span><br><span class="line">  <span class="type">uint64_t</span> bytes_popped_ {};</span><br><span class="line">  std::string tmp_buf_;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Writer</span> : <span class="keyword">public</span> ByteStream</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">( std::string data )</span></span>; <span class="comment">// Push data to stream, but only as much as available capacity allows.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;                  <span class="comment">// Signal that the stream has reached its ending. Nothing more will be written.</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_closed</span><span class="params">()</span> <span class="type">const</span></span>;              <span class="comment">// Has the stream been closed?</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">available_capacity</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// How many bytes can be pushed to the stream right now?</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">bytes_pushed</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// Total number of bytes cumulatively pushed to the stream</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span> : <span class="keyword">public</span> ByteStream</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::string_view <span class="title">peek</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// Peek at the next bytes in the buffer</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">( <span class="type">uint64_t</span> len )</span></span>;      <span class="comment">// Remove `len` bytes from the buffer</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_finished</span><span class="params">()</span> <span class="type">const</span></span>;        <span class="comment">// Is the stream finished (closed and fully popped)?</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">bytes_buffered</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// Number of bytes currently buffered (pushed and not popped)</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">bytes_popped</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">// Total number of bytes cumulatively popped from stream</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * read: A (provided) helper function thats peeks and pops up to `len` bytes</span></span><br><span class="line"><span class="comment"> * from a ByteStream Reader into a string;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">( Reader&amp; reader, <span class="type">uint64_t</span> len, std::string&amp; out )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"byte_stream.hh"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ByteStream::<span class="built_in">ByteStream</span>( <span class="type">uint64_t</span> capacity ) : </span><br><span class="line"><span class="built_in">capacity_</span>( capacity ) {}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Writer::is_closed</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> closed_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Writer::push</span><span class="params">( string data )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> ch : data)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">available_capacity</span>())</span><br><span class="line">    {</span><br><span class="line">      buffer_.<span class="built_in">push_back</span>(ch);</span><br><span class="line">      bytes_pushed_++;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  tmp_buf_ = <span class="built_in">string</span>(buffer_.<span class="built_in">begin</span>(),buffer_.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Writer::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  closed_ = <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Writer::available_capacity</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> capacity_-buffer_.<span class="built_in">size</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Writer::bytes_pushed</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> bytes_pushed_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Reader::is_finished</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> closed_&amp;&amp;!<span class="built_in">bytes_buffered</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Reader::bytes_popped</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> bytes_popped_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">string_view <span class="title">Reader::peek</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">string_view</span>(tmp_buf_);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reader::pop</span><span class="params">( <span class="type">uint64_t</span> len )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">while</span> ((buffer_.<span class="built_in">size</span>()&amp;&amp;len--))</span><br><span class="line">  {</span><br><span class="line">    buffer_.<span class="built_in">pop_front</span>();</span><br><span class="line">    bytes_popped_++;</span><br><span class="line">  }</span><br><span class="line">  tmp_buf_ = <span class="built_in">string</span>(buffer_.<span class="built_in">begin</span>(),buffer_.<span class="built_in">end</span>());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Reader::bytes_buffered</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> buffer_.<span class="built_in">size</span>();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>但是效率非常慢,0.11Gbit/s勉强过最低要求</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        Start 38: byte_stream_speed_test</span><br><span class="line">             ByteStream throughput: 0.11 Gbit/s</span><br><span class="line">10/10 Test #38: byte_stream_speed_test ...........   Passed    0.80 sec</span><br><span class="line"></span><br><span class="line">100% tests passed, 0 tests failed out of 10</span><br><span class="line"></span><br><span class="line">Total Test time (real) =   3.60 sec</span><br><span class="line">Built target check0</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Checkpoint-1-stitching-substrings-into-a-byte-stream"><a href="#Checkpoint-1-stitching-substrings-into-a-byte-stream" class="headerlink" title="Checkpoint 1: stitching substrings into a byte stream"></a>Checkpoint 1: stitching substrings into a byte stream</h1><h2 id="调试准备"><a href="#调试准备" class="headerlink" title="调试准备"></a>调试准备</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wpedantic -Wextra -Weffc++ -Werror -Wshadow -Wpointer-arith -Wcast-qual -Wformat=2 -Wno-unqualified-std-cast-call -Wno-non-virtual-dtor -g -O0 -fdebug-prefix-map='/root/minnow/build'='.'")</span><br></pre></td></tr></tbody></table></figure>

<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>用vector&lt;char&gt;做缓冲区,接受[unassembled_idx,unassembled_idx+capacity)区间内的数据并保存,其余的丢弃,使用valid_mask标识对应位置的数据是否已经保存到Reassembler中.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Reassembler</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Construct Reassembler to write into given ByteStream.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Reassembler</span><span class="params">( ByteStream&amp;&amp; output )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Insert a new substring to be reassembled into a ByteStream.</span></span><br><span class="line"><span class="comment">   *   `first_index`: the index of the first byte of the substring</span></span><br><span class="line"><span class="comment">   *   `data`: the substring itself</span></span><br><span class="line"><span class="comment">   *   `is_last_substring`: this substring represents the end of the stream</span></span><br><span class="line"><span class="comment">   *   `output`: a mutable reference to the Writer</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The Reassembler's job is to reassemble the indexed substrings (possibly out-of-order</span></span><br><span class="line"><span class="comment">   * and possibly overlapping) back into the original ByteStream. As soon as the Reassembler</span></span><br><span class="line"><span class="comment">   * learns the next byte in the stream, it should write it to the output.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * If the Reassembler learns about bytes that fit within the stream's available capacity</span></span><br><span class="line"><span class="comment">   * but can't yet be written (because earlier bytes remain unknown), it should store them</span></span><br><span class="line"><span class="comment">   * internally until the gaps are filled in.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The Reassembler should discard any bytes that lie beyond the stream's available capacity</span></span><br><span class="line"><span class="comment">   * (i.e., bytes that couldn't be written even if earlier gaps get filled in).</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The Reassembler should close the stream after writing the last byte.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">( <span class="type">uint64_t</span> first_index, std::string data, <span class="type">bool</span> is_last_substring )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// How many bytes are stored in the Reassembler itself?</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">bytes_pending</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Access output stream reader</span></span><br><span class="line">  <span class="function">Reader&amp; <span class="title">reader</span><span class="params">()</span> </span>{ <span class="keyword">return</span> output_.<span class="built_in">reader</span>(); }</span><br><span class="line">  <span class="function"><span class="type">const</span> Reader&amp; <span class="title">reader</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> output_.<span class="built_in">reader</span>(); }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Access output stream writer, but const-only (can't write from outside)</span></span><br><span class="line">  <span class="function"><span class="type">const</span> Writer&amp; <span class="title">writer</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> output_.<span class="built_in">writer</span>(); }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ByteStream output_; <span class="comment">// the Reassembler writes to this ByteStream</span></span><br><span class="line">  <span class="type">size_t</span> capacity {};</span><br><span class="line">  std::vector&lt;<span class="type">char</span>&gt; buffer;</span><br><span class="line">  std::vector&lt;<span class="type">bool</span>&gt; valid_mask;</span><br><span class="line">  <span class="type">size_t</span> unassembled_idx {};</span><br><span class="line">  <span class="type">uint64_t</span> total_bytes {};</span><br><span class="line">  <span class="type">bool</span> total_bytes_mask {};</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"reassembler.hh"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reassembler::insert</span><span class="params">( <span class="type">uint64_t</span> first_index, string data, <span class="type">bool</span> is_last_substring )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">//重组数据</span></span><br><span class="line">  <span class="comment">//data是否有在当前buffer区域内的部分</span></span><br><span class="line">  <span class="keyword">if</span>(first_index+data.<span class="built_in">size</span>()&gt;=unassembled_idx &amp;&amp; first_index&lt;unassembled_idx+capacity)</span><br><span class="line">  {</span><br><span class="line">    <span class="comment">//截断unassembled_idx之前的部分</span></span><br><span class="line">    <span class="keyword">if</span>(first_index &lt; unassembled_idx)</span><br><span class="line">    {</span><br><span class="line">      data = data.<span class="built_in">substr</span>(unassembled_idx-first_index);</span><br><span class="line">      first_index = unassembled_idx;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存最后一个字节的位置</span></span><br><span class="line">    <span class="keyword">if</span>(is_last_substring)</span><br><span class="line">    {</span><br><span class="line">      total_bytes_mask = <span class="literal">true</span>;</span><br><span class="line">      total_bytes = first_index+data.<span class="built_in">size</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">auto</span> psize = <span class="built_in">min</span>(data.<span class="built_in">size</span>(),</span><br><span class="line">    unassembled_idx+capacity-first_index);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = std::<span class="built_in">next</span>(buffer.<span class="built_in">begin</span>(),first_index-unassembled_idx);</span><br><span class="line">    std::<span class="built_in">copy_n</span>(data.<span class="built_in">begin</span>(),psize,start);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> mask_start = std::<span class="built_in">next</span>(valid_mask.<span class="built_in">begin</span>(),first_index-unassembled_idx);</span><br><span class="line">    std::<span class="built_in">fill_n</span>(mask_start,psize,<span class="literal">true</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">//尝试output</span></span><br><span class="line">  <span class="keyword">auto</span> mask_iter = valid_mask.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">auto</span>&amp; writer_ref = <span class="built_in">static_cast</span>&lt;Writer&amp;&gt;(output_);</span><br><span class="line">  <span class="keyword">for</span>(;mask_iter!=valid_mask.<span class="built_in">end</span>()&amp;&amp;*mask_iter==<span class="literal">true</span>;++mask_iter);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(mask_iter != valid_mask.<span class="built_in">begin</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">auto</span> output_end = std::<span class="built_in">next</span>(buffer.<span class="built_in">begin</span>(),(mask_iter-valid_mask.<span class="built_in">begin</span>()));</span><br><span class="line"></span><br><span class="line">    writer_ref.<span class="built_in">push</span>(std::<span class="built_in">string</span>(buffer.<span class="built_in">begin</span>(),output_end));</span><br><span class="line">    unassembled_idx = writer_ref.<span class="built_in">bytes_pushed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出完成后移动unassembled的数据</span></span><br><span class="line">    std::<span class="built_in">copy</span>(output_end,buffer.<span class="built_in">end</span>(),buffer.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">auto</span> invalid_iter = std::<span class="built_in">copy</span>(mask_iter,valid_mask.<span class="built_in">end</span>(),valid_mask.<span class="built_in">begin</span>());</span><br><span class="line">    std::<span class="built_in">fill</span>(invalid_iter,valid_mask.<span class="built_in">end</span>(),<span class="literal">false</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(total_bytes_mask&amp;&amp;writer_ref.<span class="built_in">bytes_pushed</span>() == total_bytes)</span><br><span class="line">      writer_ref.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Reassembler::bytes_pending</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="type">uint64_t</span> pendings = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> b : valid_mask)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(b)</span><br><span class="line">      ++pendings;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> pendings;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Reassembler::<span class="built_in">Reassembler</span>( ByteStream&amp;&amp; output ): </span><br><span class="line"><span class="built_in">output_</span>( std::<span class="built_in">move</span>( output ) ),<span class="built_in">capacity</span>(<span class="built_in">writer</span>().<span class="built_in">available_capacity</span>()),</span><br><span class="line"><span class="built_in">buffer</span>(capacity) , <span class="built_in">valid_mask</span>(capacity,<span class="literal">false</span>) </span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>平均用时8秒多,1.10 Gbit/s,非常慢了.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">15/17 Test #37: compile with optimization ........   Passed    0.07 sec</span><br><span class="line">      Start 38: byte_stream_speed_test</span><br><span class="line">             ByteStream throughput: 0.10 Gbit/s</span><br><span class="line">16/17 Test #38: byte_stream_speed_test ...........   Passed    0.84 sec</span><br><span class="line">      Start 39: reassembler_speed_test</span><br><span class="line">             Reassembler throughput: 1.10 Gbit/s</span><br><span class="line">17/17 Test #39: reassembler_speed_test ...........   Passed    0.22 sec</span><br><span class="line"></span><br><span class="line">100% tests passed, 0 tests failed out of 17</span><br><span class="line"></span><br><span class="line">Total Test time (real) =   8.56 sec</span><br><span class="line">Built target check1</span><br></pre></td></tr></tbody></table></figure>

<h1 id="CheckPoint-1-5-Optimizing-ByteStream"><a href="#CheckPoint-1-5-Optimizing-ByteStream" class="headerlink" title="CheckPoint 1.5 Optimizing  ByteStream"></a>CheckPoint 1.5 Optimizing  ByteStream</h1><h2 id="1-5-1-一次性insert和erase"><a href="#1-5-1-一次性insert和erase" class="headerlink" title="1.5.1 一次性insert和erase"></a>1.5.1 一次性insert和erase</h2><p>把push和pop改成一次性insert和erase,Reassembler throughput提升到4.40 Gbit/s,ByteStream throughput仍为0.1</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Writer::push</span><span class="params">( string data )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">size_t</span> ilen = <span class="built_in">min</span>(data.<span class="built_in">size</span>(),<span class="built_in">available_capacity</span>());</span><br><span class="line">  buffer_.<span class="built_in">insert</span>(buffer_.<span class="built_in">end</span>(),data.<span class="built_in">begin</span>(),data.<span class="built_in">begin</span>()+ilen);</span><br><span class="line">  bytes_pushed_ += ilen;</span><br><span class="line">  tmp_buf_ = <span class="built_in">string</span>(buffer_.<span class="built_in">begin</span>(),buffer_.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reader::pop</span><span class="params">( <span class="type">uint64_t</span> len )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">size_t</span> rlen = <span class="built_in">min</span>(len,buffer_.<span class="built_in">size</span>());</span><br><span class="line">  buffer_.<span class="built_in">erase</span>(buffer_.<span class="built_in">begin</span>(),buffer_.<span class="built_in">begin</span>()+rlen);</span><br><span class="line">  bytes_popped_ += rlen;</span><br><span class="line">  tmp_buf_ = <span class="built_in">string</span>(buffer_.<span class="built_in">begin</span>(),buffer_.<span class="built_in">end</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-5-2-以string替代char作为字节流基本单元"><a href="#1-5-2-以string替代char作为字节流基本单元" class="headerlink" title="1.5.2 以string替代char作为字节流基本单元"></a>1.5.2 以string替代char作为字节流基本单元</h2><p>全部重构了,改为直接插入string能节省大量对deque的插入操作.<br>能这么写是peek不要求返回字节流内所有的字节.<br>ByteStream throughput: 10.21 Gbit/s,Reassembler throughput: 5.36 Gbit/s.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;std::string&gt; buffer_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Writer::push</span><span class="params">( string data )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">size_t</span> ilen = <span class="built_in">min</span>(data.<span class="built_in">size</span>(),<span class="built_in">available_capacity</span>());</span><br><span class="line">  <span class="keyword">if</span>(ilen)</span><br><span class="line">  {</span><br><span class="line">    data.<span class="built_in">resize</span>(ilen);</span><br><span class="line"></span><br><span class="line">    buffer_.<span class="built_in">push</span>(data);</span><br><span class="line">    bytes_pushed_ += ilen;</span><br><span class="line">    size_ += ilen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(buffer_.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">    {</span><br><span class="line">      view_buf_ = std::<span class="built_in">string</span>(buffer_.<span class="built_in">front</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">string_view <span class="title">Reader::peek</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> view_buf_;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reader::pop</span><span class="params">( <span class="type">uint64_t</span> len )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">size_t</span> rlen = <span class="built_in">min</span>(len,size_);</span><br><span class="line">  <span class="type">size_t</span> rlen_remaind = rlen;</span><br><span class="line">  <span class="keyword">if</span>(rlen)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">while</span>(!buffer_.<span class="built_in">empty</span>() &amp;&amp; rlen_remaind &gt;= buffer_.<span class="built_in">front</span>().<span class="built_in">size</span>())</span><br><span class="line">    {</span><br><span class="line">      rlen_remaind -= buffer_.<span class="built_in">front</span>().<span class="built_in">size</span>();</span><br><span class="line">      buffer_.<span class="built_in">pop</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    bytes_popped_ += rlen;</span><br><span class="line">    size_ -= rlen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!buffer_.<span class="built_in">empty</span>())</span><br><span class="line">    {</span><br><span class="line">      buffer_.<span class="built_in">front</span>() = buffer_.<span class="built_in">front</span>().<span class="built_in">substr</span>(rlen_remaind);</span><br><span class="line">      view_buf_ = std::<span class="built_in">string</span>(buffer_.<span class="built_in">front</span>());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      view_buf_ = std::<span class="built_in">string</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p>Reassembler的优化放到之后,大概看了一下是vector容量过大时,每一次输出会导致大量的数据拷贝和填充.</p>
<h1 id="Check2"><a href="#Check2" class="headerlink" title="Check2"></a>Check2</h1><p>实现TCP接收端的数据重组.</p>
<h2 id="2-1-Translating-between-64-bit-indexes-and-32-bit-seqnos"><a href="#2-1-Translating-between-64-bit-indexes-and-32-bit-seqnos" class="headerlink" title="2.1 Translating between 64-bit indexes and 32-bit seqnos"></a>2.1 Translating between 64-bit indexes and 32-bit seqnos</h2><p>wrap直接用cpp本身的截断即可.unwrap主要基于 A-B的结果再截断与先将A,B截断再相减(再截断)的值是相同的.<br>(我是数学白痴…</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"wrapping_integers.hh"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">Wrap32 <span class="title">Wrap32::wrap</span><span class="params">( <span class="type">uint64_t</span> n, Wrap32 zero_point )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> Wrap32 { zero_point+n };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Wrap32::unwrap</span><span class="params">( Wrap32 zero_point, <span class="type">uint64_t</span> checkpoint )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">uint32_t</span> ckmod = <span class="built_in">wrap</span>(checkpoint,zero_point).raw_value_;</span><br><span class="line">  <span class="type">uint32_t</span> off = raw_value_-ckmod;</span><br><span class="line">  <span class="type">uint64_t</span> upper = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(UINT32_MAX)+<span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(off &lt;= (upper&gt;&gt;<span class="number">1</span>) || checkpoint+off&lt;upper)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(checkpoint+off);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(checkpoint+off-upper);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>很乱的草稿..<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202404131909587.png"></p>
<h2 id="2-2-Implementing-the-TCP-receive"><a href="#2-2-Implementing-the-TCP-receive" class="headerlink" title="2.2 Implementing the TCP receive"></a>2.2 Implementing the TCP receive</h2><p>实验文档挺模糊的,甚至感觉有歧义,大概写完对着测试改一改.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPReceiver::receive</span><span class="params">( TCPSenderMessage message )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">if</span>(message.SYN)</span><br><span class="line">    ISN = message.seqno;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(ISN.<span class="built_in">has_value</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="type">uint64_t</span> first_index = message.seqno.<span class="built_in">unwrap</span>(*ISN,<span class="built_in">writer</span>().<span class="built_in">bytes_pushed</span>())+message.SYN<span class="number">-1</span>;</span><br><span class="line">    reassembler_.<span class="built_in">insert</span>(first_index,message.payload,message.FIN);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(message.RST)</span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">reader</span>().<span class="built_in">set_error</span>();</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">TCPReceiverMessage <span class="title">TCPReceiver::send</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  TCPReceiverMessage message {};</span><br><span class="line">  <span class="keyword">if</span>(ISN.<span class="built_in">has_value</span>())</span><br><span class="line">  {</span><br><span class="line">    message.ackno = Wrap32::<span class="built_in">wrap</span>(<span class="built_in">writer</span>().<span class="built_in">bytes_pushed</span>()+<span class="number">1</span>+<span class="built_in">writer</span>().<span class="built_in">is_closed</span>(),*ISN);</span><br><span class="line">  }</span><br><span class="line">  message.window_size = <span class="built_in">min</span>(<span class="built_in">writer</span>().<span class="built_in">available_capacity</span>(),<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(UINT16_MAX));</span><br><span class="line"></span><br><span class="line">  message.RST = <span class="built_in">writer</span>().<span class="built_in">has_error</span>(); </span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="Check-3"><a href="#Check-3" class="headerlink" title="Check 3"></a>Check 3</h1><p>实现TCP的超时重传,建立与断开连接,所以需要在内部保存发送的message.选择什么样的数据结构呢?<br>在两个情形下会查找内部保存的message,1是tick时重发超时的message,这是过期时间与message的对应关系.<br>2是收到对某消息的确认时,需要从内部移除该message,这是ackno与message的对应.<br>两种情形都偏向有排序和查找的意思,这里使用map&lt;ackno,pair&lt;expire_time,message&gt; &gt;的数据结构来保存消息.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCPSender</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/* Construct TCP sender with given default Retransmission Timeout and possible ISN */</span></span><br><span class="line">  <span class="built_in">TCPSender</span>( ByteStream&amp;&amp; input, Wrap32 isn, <span class="type">uint64_t</span> initial_RTO_ms )</span><br><span class="line">    : <span class="built_in">input_</span>( std::<span class="built_in">move</span>( input ) ), <span class="built_in">isn_</span>( isn ), <span class="built_in">initial_RTO_ms_</span>( initial_RTO_ms ),<span class="built_in">RTO_ms</span>(initial_RTO_ms)</span><br><span class="line">  {}</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Generate an empty TCPSenderMessage */</span></span><br><span class="line">  <span class="function">TCPSenderMessage <span class="title">make_empty_message</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Receive and process a TCPReceiverMessage from the peer's receiver */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">receive</span><span class="params">( <span class="type">const</span> TCPReceiverMessage&amp; msg )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Type of the `transmit` function that the push and tick methods can use to send messages */</span></span><br><span class="line">  <span class="keyword">using</span> TransmitFunction = std::function&lt;<span class="built_in">void</span>( <span class="type">const</span> TCPSenderMessage&amp; )&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Push bytes from the outbound stream */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">( <span class="type">const</span> TransmitFunction&amp; transmit )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Time has passed by the given # of milliseconds since the last time the tick() method was called */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">( <span class="type">uint64_t</span> ms_since_last_tick, <span class="type">const</span> TransmitFunction&amp; transmit )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Accessors</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">sequence_numbers_in_flight</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// How many sequence numbers are outstanding?</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">consecutive_retransmissions</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// How many consecutive *re*transmissions have happened?</span></span><br><span class="line">  <span class="function">Writer&amp; <span class="title">writer</span><span class="params">()</span> </span>{ <span class="keyword">return</span> input_.<span class="built_in">writer</span>(); }</span><br><span class="line">  <span class="function"><span class="type">const</span> Writer&amp; <span class="title">writer</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> input_.<span class="built_in">writer</span>(); }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Access input stream reader, but const-only (can't read from outside)</span></span><br><span class="line">  <span class="function"><span class="type">const</span> Reader&amp; <span class="title">reader</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> input_.<span class="built_in">reader</span>(); }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Variables initialized in constructor</span></span><br><span class="line">  ByteStream input_;</span><br><span class="line">  Wrap32 isn_;</span><br><span class="line">  <span class="type">uint64_t</span> initial_RTO_ms_;</span><br><span class="line"></span><br><span class="line">  std::map&lt;Wrap32,std::pair&lt;<span class="type">uint64_t</span>,TCPSenderMessage&gt; &gt; rt_segments;</span><br><span class="line">  <span class="type">uint64_t</span> RTO_ms;</span><br><span class="line">  <span class="type">uint64_t</span> cur_ms;</span><br><span class="line">  std::optional&lt;<span class="type">uint64_t</span>&gt; window_size {};</span><br><span class="line">  <span class="type">uint64_t</span> retransmissions_cnt {};</span><br><span class="line">  <span class="type">uint64_t</span> in_flight_cnt;</span><br><span class="line">  <span class="type">bool</span> syned {};</span><br><span class="line">  <span class="type">bool</span> fined {};</span><br><span class="line">  <span class="type">bool</span> zero_window {};</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"tcp_sender.hh"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"tcp_config.hh"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TCPSender::sequence_numbers_in_flight</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> in_flight_cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">return</span> retransmissions_cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::push</span><span class="params">( <span class="type">const</span> TransmitFunction&amp; transmit )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!syned || ((<span class="built_in">reader</span>().<span class="built_in">bytes_buffered</span>() || (<span class="built_in">reader</span>().<span class="built_in">is_finished</span>() &amp;&amp; !fined)) &amp;&amp; *window_size) )</span><br><span class="line">  {</span><br><span class="line">    TCPSenderMessage msg {};</span><br><span class="line">    <span class="type">uint64_t</span> tmp_window_size = window_size.<span class="built_in">has_value</span>() ? *window_size : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!syned)</span><br><span class="line">      msg.SYN = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    msg.seqno = Wrap32::<span class="built_in">wrap</span>(<span class="built_in">reader</span>().<span class="built_in">bytes_popped</span>()+syned,isn_);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> max_payload_len = <span class="built_in">min</span>(TCPConfig::MAX_PAYLOAD_SIZE,tmp_window_size);</span><br><span class="line">    max_payload_len -= msg.SYN;</span><br><span class="line">    <span class="built_in">read</span>(input_.<span class="built_in">reader</span>(),max_payload_len,msg.payload);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">reader</span>().<span class="built_in">is_finished</span>() &amp;&amp; ((tmp_window_size-msg.SYN) &gt; msg.<span class="built_in">sequence_length</span>()))</span><br><span class="line">    {</span><br><span class="line">      msg.FIN = <span class="literal">true</span>;  </span><br><span class="line">      fined = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">reader</span>().<span class="built_in">has_error</span>())</span><br><span class="line">      msg.RST = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    rt_segments.<span class="built_in">insert</span>( {Wrap32::<span class="built_in">wrap</span>(<span class="built_in">reader</span>().<span class="built_in">bytes_popped</span>()+syned+msg.SYN+msg.FIN,isn_), {cur_ms+RTO_ms,msg} } );</span><br><span class="line">    <span class="built_in">transmit</span>(msg);</span><br><span class="line"></span><br><span class="line">    syned = <span class="literal">true</span>;</span><br><span class="line">    in_flight_cnt += msg.<span class="built_in">sequence_length</span>();</span><br><span class="line">    <span class="keyword">if</span>(window_size.<span class="built_in">has_value</span>())</span><br><span class="line">      *window_size -= msg.<span class="built_in">sequence_length</span>();</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">TCPSenderMessage <span class="title">TCPSender::make_empty_message</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  TCPSenderMessage message {};</span><br><span class="line">  </span><br><span class="line">  message.seqno = Wrap32::<span class="built_in">wrap</span>(<span class="built_in">reader</span>().<span class="built_in">bytes_popped</span>()+syned+fined,isn_);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">reader</span>().<span class="built_in">has_error</span>())</span><br><span class="line">    message.RST = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::receive</span><span class="params">( <span class="type">const</span> TCPReceiverMessage&amp; msg )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="type">bool</span> newdata_flag = (msg.ackno.<span class="built_in">has_value</span>() &amp;&amp; msg.ackno &gt;= (*rt_segments.<span class="built_in">begin</span>()).first);</span><br><span class="line">  <span class="keyword">if</span>(msg.ackno.<span class="built_in">has_value</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">if</span>(!rt_segments.<span class="built_in">empty</span>() &amp;&amp; msg.ackno &lt;= (*rt_segments.<span class="built_in">rbegin</span>()).first)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> iter = rt_segments.<span class="built_in">begin</span>();iter!=rt_segments.<span class="built_in">upper_bound</span>(*msg.ackno);++iter)</span><br><span class="line">      {</span><br><span class="line">        in_flight_cnt -= (*iter).second.second.<span class="built_in">sequence_length</span>();</span><br><span class="line">        rt_segments.<span class="built_in">erase</span>(iter);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(newdata_flag)</span><br><span class="line">  {</span><br><span class="line">    RTO_ms = initial_RTO_ms_;</span><br><span class="line">    retransmissions_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; f : rt_segments)</span><br><span class="line">    {</span><br><span class="line">      f.second.first = cur_ms+RTO_ms;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  window_size = msg.ackno-&gt;<span class="built_in">unwrap</span>(isn_,<span class="built_in">reader</span>().<span class="built_in">bytes_popped</span>()+syned+fined)  - (<span class="built_in">reader</span>().<span class="built_in">bytes_popped</span>()+syned+fined) + (msg.window_size ? msg.window_size : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  zero_window = !msg.window_size;</span><br><span class="line">  <span class="keyword">if</span>(msg.RST)</span><br><span class="line">    input_.<span class="built_in">reader</span>().<span class="built_in">set_error</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TCPSender::tick</span><span class="params">( <span class="type">uint64_t</span> ms_since_last_tick, <span class="type">const</span> TransmitFunction&amp; transmit )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  cur_ms += ms_since_last_tick;</span><br><span class="line">  <span class="keyword">if</span>(!rt_segments.<span class="built_in">empty</span>())</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">auto</span>&amp; f = *rt_segments.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span>(f.second.first &lt;= cur_ms)</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">if</span>(!zero_window)</span><br><span class="line">        RTO_ms += RTO_ms;</span><br><span class="line">      f.second.first = cur_ms+RTO_ms;</span><br><span class="line">      <span class="built_in">transmit</span>(f.second.second);</span><br><span class="line">      ++retransmissions_cnt;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<h1 id="Check-5"><a href="#Check-5" class="headerlink" title="Check 5"></a>Check 5</h1><p>实现ARP协议,将IP数据报发送给下一跳.<br>核心数据结构如下.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*从IP地址到以太网地址的映射,由于对每条记录要维护一个过期时间,所以值是air&lt;expire_time,EthernetAddress&gt;*/</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">uint32_t</span>,std::pair&lt;<span class="type">uint64_t</span>, EthernetAddress&gt; &gt; ARP_table {};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待目的IP地址的ARP解析中的IP数据报,便于获取到某个IP地址对应的EthernetAddress后发送对应数据报</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  std::unordered_multimap&lt;<span class="type">uint32_t</span>,InternetDatagram&gt; dgrams_waiting {}; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对某IP发送ARP解析时的时间,避免flooding.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">uint32_t</span>,<span class="type">uint64_t</span>&gt; ips_waiting {};</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"address.hh"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ethernet_frame.hh"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"ipv4_datagram.hh"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A "network interface" that connects IP (the internet layer, or network layer)</span></span><br><span class="line"><span class="comment">// with Ethernet (the network access layer, or link layer).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This module is the lowest layer of a TCP/IP stack</span></span><br><span class="line"><span class="comment">// (connecting IP with the lower-layer network protocol,</span></span><br><span class="line"><span class="comment">// e.g. Ethernet). But the same module is also used repeatedly</span></span><br><span class="line"><span class="comment">// as part of a router: a router generally has many network</span></span><br><span class="line"><span class="comment">// interfaces, and the router's job is to route Internet datagrams</span></span><br><span class="line"><span class="comment">// between the different interfaces.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The network interface translates datagrams (coming from the</span></span><br><span class="line"><span class="comment">// "customer," e.g. a TCP/IP stack or router) into Ethernet</span></span><br><span class="line"><span class="comment">// frames. To fill in the Ethernet destination address, it looks up</span></span><br><span class="line"><span class="comment">// the Ethernet address of the next IP hop of each datagram, making</span></span><br><span class="line"><span class="comment">// requests with the [Address Resolution Protocol](\ref rfc::rfc826).</span></span><br><span class="line"><span class="comment">// In the opposite direction, the network interface accepts Ethernet</span></span><br><span class="line"><span class="comment">// frames, checks if they are intended for it, and if so, processes</span></span><br><span class="line"><span class="comment">// the the payload depending on its type. If it's an IPv4 datagram,</span></span><br><span class="line"><span class="comment">// the network interface passes it up the stack. If it's an ARP</span></span><br><span class="line"><span class="comment">// request or reply, the network interface processes the frame</span></span><br><span class="line"><span class="comment">// and learns or replies as necessary.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkInterface</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// An abstraction for the physical output port where the NetworkInterface sends Ethernet frames</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">OutputPort</span></span><br><span class="line">  {</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">transmit</span><span class="params">( <span class="type">const</span> NetworkInterface&amp; sender, <span class="type">const</span> EthernetFrame&amp; frame )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">OutputPort</span>() = <span class="keyword">default</span>;</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct a network interface with given Ethernet (network-access-layer) and IP (internet-layer)</span></span><br><span class="line">  <span class="comment">// addresses</span></span><br><span class="line">  <span class="built_in">NetworkInterface</span>( std::string_view name,</span><br><span class="line">                    std::shared_ptr&lt;OutputPort&gt; port,</span><br><span class="line">                    <span class="type">const</span> EthernetAddress&amp; ethernet_address,</span><br><span class="line">                    <span class="type">const</span> Address&amp; ip_address );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sends an Internet datagram, encapsulated in an Ethernet frame (if it knows the Ethernet destination</span></span><br><span class="line">  <span class="comment">// address). Will need to use [ARP](\ref rfc::rfc826) to look up the Ethernet destination address for the next</span></span><br><span class="line">  <span class="comment">// hop. Sending is accomplished by calling `transmit()` (a member variable) on the frame.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send_datagram</span><span class="params">( <span class="type">const</span> InternetDatagram&amp; dgram, <span class="type">const</span> Address&amp; next_hop )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Receives an Ethernet frame and responds appropriately.</span></span><br><span class="line">  <span class="comment">// If type is IPv4, pushes the datagram to the datagrams_in queue.</span></span><br><span class="line">  <span class="comment">// If type is ARP request, learn a mapping from the "sender" fields, and send an ARP reply.</span></span><br><span class="line">  <span class="comment">// If type is ARP reply, learn a mapping from the "sender" fields.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">recv_frame</span><span class="params">( <span class="type">const</span> EthernetFrame&amp; frame )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Called periodically when time elapses</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">tick</span><span class="params">( <span class="type">size_t</span> ms_since_last_tick )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Accessors</span></span><br><span class="line">  <span class="function"><span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> name_; }</span><br><span class="line">  <span class="function"><span class="type">const</span> OutputPort&amp; <span class="title">output</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> *port_; }</span><br><span class="line">  <span class="function">OutputPort&amp; <span class="title">output</span><span class="params">()</span> </span>{ <span class="keyword">return</span> *port_; }</span><br><span class="line">  <span class="function">std::queue&lt;InternetDatagram&gt;&amp; <span class="title">datagrams_received</span><span class="params">()</span> </span>{ <span class="keyword">return</span> datagrams_received_; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Human-readable name of the interface</span></span><br><span class="line">  std::string name_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The physical output port (+ a helper function `transmit` that uses it to send an Ethernet frame)</span></span><br><span class="line">  std::shared_ptr&lt;OutputPort&gt; port_;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">transmit</span><span class="params">( <span class="type">const</span> EthernetFrame&amp; frame )</span> <span class="type">const</span> </span>{ port_-&gt;<span class="built_in">transmit</span>( *<span class="keyword">this</span>, frame ); }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ethernet (known as hardware, network-access-layer, or link-layer) address of the interface</span></span><br><span class="line">  EthernetAddress ethernet_address_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IP (known as internet-layer or network-layer) address of the interface</span></span><br><span class="line">  Address ip_address_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Datagrams that have been received</span></span><br><span class="line">  std::queue&lt;InternetDatagram&gt; datagrams_received_ {};</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> cur_ms {};</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从IP地址到以太网地址的映射,由于对每条记录要维护一个过期时间,所以值是air&lt;expire_time,EthernetAddress&gt;*/</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">uint32_t</span>,std::pair&lt;<span class="type">uint64_t</span>, EthernetAddress&gt; &gt; ARP_table {};</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待目的IP地址的ARP解析中的IP数据报,便于获取到某个IP地址对应的EthernetAddress后发送对应数据报</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  std::unordered_multimap&lt;<span class="type">uint32_t</span>,InternetDatagram&gt; dgrams_waiting {}; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对某IP发送ARP解析时的时间,避免flooding.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">uint32_t</span>,<span class="type">uint64_t</span>&gt; ips_waiting {};</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="Check6"><a href="#Check6" class="headerlink" title="Check6"></a>Check6</h1><p>根据最长前缀匹配进行路由转发(不包括路由选择).也就是为Check5那一层选择next_hop的ip.</p>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202404171241700.png"></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"exception.hh"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"network_interface.hh"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// \brief A router that has multiple network interfaces and</span></span><br><span class="line"><span class="comment">// performs longest-prefix-match routing between them.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Add an interface to the router</span></span><br><span class="line">  <span class="comment">// \param[in] interface an already-constructed network interface</span></span><br><span class="line">  <span class="comment">// \returns The index of the interface after it has been added to the router</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">add_interface</span><span class="params">( std::shared_ptr&lt;NetworkInterface&gt; interface )</span></span></span><br><span class="line"><span class="function">  </span>{</span><br><span class="line">    _interfaces.<span class="built_in">push_back</span>( <span class="built_in">notnull</span>( <span class="string">"add_interface"</span>, std::<span class="built_in">move</span>( interface ) ) );</span><br><span class="line">    <span class="keyword">return</span> _interfaces.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Access an interface by index</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;NetworkInterface&gt; <span class="title">interface</span><span class="params">( <span class="type">const</span> <span class="type">size_t</span> N )</span> </span>{ <span class="keyword">return</span> _interfaces.<span class="built_in">at</span>( N ); }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add a route (a forwarding rule)</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_route</span><span class="params">( <span class="type">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                  std::optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">size_t</span> interface_num )</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Route packets between the interfaces</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">route</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// The router's collection of network interfaces</span></span><br><span class="line">  std::vector&lt;std::shared_ptr&lt;NetworkInterface&gt;&gt; _interfaces {};</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">prefix_info</span></span><br><span class="line">  {</span><br><span class="line">    <span class="built_in">prefix_info</span>(<span class="type">const</span> <span class="type">uint8_t</span> prefix_lenth,<span class="type">const</span> <span class="type">uint32_t</span> route_prefix) :</span><br><span class="line">    <span class="built_in">mask</span>(~(UINT32_MAX &gt;&gt; (prefix_lenth))),<span class="built_in">prefix</span>(route_prefix) {}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> prefix_info&amp; other) <span class="type">const</span></span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">return</span> mask != other.mask ? (mask &gt; other.mask)</span><br><span class="line">                 : (prefix &gt; other.prefix);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">uint32_t</span> mask;</span><br><span class="line">    <span class="type">uint32_t</span> prefix;</span><br><span class="line">  };</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">using</span> RouterT = std::map&lt;prefix_info,std::pair&lt;<span class="type">size_t</span>,std::optional&lt;Address&gt; &gt;,std::greater&lt;prefix_info&gt;&gt;;</span><br><span class="line"></span><br><span class="line">  RouterT RouterTable {};</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"router.hh"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// route_prefix: The "up-to-32-bit" IPv4 address prefix to match the datagram's destination address against</span></span><br><span class="line"><span class="comment">// prefix_length: For this route to be applicable, how many high-order (most-significant) bits of</span></span><br><span class="line"><span class="comment">//    the route_prefix will need to match the corresponding bits of the datagram's destination address?</span></span><br><span class="line"><span class="comment">// next_hop: The IP address of the next hop. Will be empty if the network is directly attached to the router (in</span></span><br><span class="line"><span class="comment">//    which case, the next hop address should be the datagram's final destination).</span></span><br><span class="line"><span class="comment">// interface_num: The index of the interface to send the datagram out on.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::add_route</span><span class="params">( <span class="type">const</span> <span class="type">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">size_t</span> interface_num )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  cerr &lt;&lt; <span class="string">"DEBUG: adding route "</span> &lt;&lt; Address::<span class="built_in">from_ipv4_numeric</span>( route_prefix ).<span class="built_in">ip</span>() &lt;&lt; <span class="string">"/"</span></span><br><span class="line">       &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;( prefix_length ) &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; ( next_hop.<span class="built_in">has_value</span>() ? next_hop-&gt;<span class="built_in">ip</span>() : <span class="string">"(direct)"</span> )</span><br><span class="line">       &lt;&lt; <span class="string">" on interface "</span> &lt;&lt; interface_num &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  RouterTable.<span class="built_in">emplace</span>(<span class="built_in">prefix_info</span>(prefix_length,route_prefix),</span><br><span class="line">                                <span class="built_in">make_pair</span>(interface_num,next_hop));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go through all the interfaces, and route every incoming datagram to its proper outgoing interface.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Router::route</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> pNetInterface : _interfaces)</span><br><span class="line">  {</span><br><span class="line">    <span class="keyword">auto</span>&amp; incoming_dgrams = pNetInterface-&gt;<span class="built_in">datagrams_received</span>();</span><br><span class="line">    <span class="keyword">while</span>(!incoming_dgrams.<span class="built_in">empty</span>())</span><br><span class="line">    {</span><br><span class="line">      <span class="keyword">auto</span>&amp; dgram = incoming_dgrams.<span class="built_in">front</span>();</span><br><span class="line">      <span class="keyword">if</span>(dgram.header.ttl &lt;= <span class="number">1</span>)</span><br><span class="line">      {</span><br><span class="line">        incoming_dgrams.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      }</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; RTE : RouterTable)</span><br><span class="line">      {</span><br><span class="line">        <span class="keyword">if</span>((dgram.header.dst &amp; RTE.first.mask) == RTE.first.prefix)</span><br><span class="line">        {</span><br><span class="line">          --dgram.header.ttl;</span><br><span class="line">          dgram.header.<span class="built_in">compute_checksum</span>();</span><br><span class="line"></span><br><span class="line">          <span class="type">const</span> <span class="keyword">auto</span>&amp; [interface_num,next_hop] = RTE.second;</span><br><span class="line">          _interfaces[interface_num]-&gt;<span class="built_in">send_datagram</span>(dgram,(next_hop.<span class="built_in">has_value</span>() ? *next_hop : Address::<span class="built_in">from_ipv4_numeric</span>(dgram.header.dst)));</span><br><span class="line"></span><br><span class="line">          incoming_dgrams.<span class="built_in">pop</span>();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="Check-7"><a href="#Check-7" class="headerlink" title="Check 7"></a>Check 7</h1><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202404171302061.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202404171310373.png"></p>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202404171310288.png"></p>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202404171317851.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://polaris-snowfall.github.io/2024/CS144%20Lab/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%BD%91/" rel="tag">计网</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/ret2hbp/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            ret2hbp 将任意地址写转为堆栈越界读写
          
        </div>
      </a>
    
    
      <a href="/2024/AliyunCTF2024%20Exploit%20Netatalk%20v3.1.12%20by%20CVE-2022-23121/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">AliyunCTF2024 Netatalk v3.1.12 越界读写利用</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> 翰青HanQi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="北极落小雪"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/About">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>