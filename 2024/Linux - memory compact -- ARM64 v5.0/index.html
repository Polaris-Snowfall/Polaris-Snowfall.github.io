<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
        
      <meta name="description" content="Boom? PWN ! ! !" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Linux内核 内存规整 -- ARM64 v5.0 |  北极落小雪</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
  </html>
</html>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Linux - memory compact -- ARM64 v5.0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Linux内核 内存规整 -- ARM64 v5.0
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/Linux%20-%20memory%20compact%20--%20ARM64%20v5.0/" class="article-date">
  <time datetime="2024-09-28T16:00:00.000Z" itemprop="datePublished">2024-09-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux%E5%86%85%E6%A0%B8/">Linux内核</a> / <a class="article-category-link" href="/categories/Linux%E5%86%85%E6%A0%B8/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">5.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">29 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ol>
<li>内存规整的目的?</li>
<li>内存规整和页面迁移的区别?</li>
<li>为什么将页面划分不同的迁移类型?</li>
<li>页面规整的流程?<span id="more"></span></li>
</ol>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>系统长时间运行后, 页面变得越来越分散, 分配一大块连续的物理内存变得越来越困难, 而有时又需要分配大块连续物理内存, 所以需要解决内存碎片化的问题, 这一过程叫做内存规整(内存紧缩).</p>
<p>内存去碎片化的基本原理是按照页面的可移动性将页面分组. 迁移内核本身使用的物理内存的实现难度和复杂度都很大, 因此目前的内核不迁移内核本身使用的物理页面. 对于用户进程使用的页面, 实际上是通过用户页表的映射访问的, 用户页表移动和修改映射关系不会影响到用户进程, 因此内存规整是基于页面迁移实现的.</p>
<p>内存页面被划分为可移动, 可回收, 不可移动等迁移类型. 可移动的页面通常是指用户态进程分配的内存, 移动这些页面仅仅需要修改页表映射关系. 可回收的页面是指不可以移动但可以释放的页面.</p>
<p>内存规整的过程是页面迁移的一种, 而内核为页面迁移提供了一个migrate_pages的接口, 被调用者只需提供需要迁移的页面集合, 要迁移到的空闲页面集合(获取及释放要迁移到的空闲页面的函数指针).<br>内存规整的实现即是获取这两个集合.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * migrate_pages - migrate the pages specified in a list, to the free pages</span></span><br><span class="line"><span class="comment"> *		   supplied as the target for the page migration</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @from:		The list of pages to be migrated.</span></span><br><span class="line"><span class="comment"> * @get_new_page:	The function used to allocate free pages to be used</span></span><br><span class="line"><span class="comment"> *			as the target of the page migration.</span></span><br><span class="line"><span class="comment"> * @put_new_page:	The function used to free target pages if migration</span></span><br><span class="line"><span class="comment"> *			fails, or NULL if no special handling is necessary.</span></span><br><span class="line"><span class="comment"> * @private:		Private data to be passed on to get_new_page()</span></span><br><span class="line"><span class="comment"> * @mode:		The migration mode that specifies the constraints for</span></span><br><span class="line"><span class="comment"> *			page migration, if any.</span></span><br><span class="line"><span class="comment"> * @reason:		The reason for page migration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns after 10 attempts or if no pages are movable any more</span></span><br><span class="line"><span class="comment"> * because the list has become empty or no retryable pages exist any more.</span></span><br><span class="line"><span class="comment"> * The caller should call putback_movable_pages() to return pages to the LRU</span></span><br><span class="line"><span class="comment"> * or free list only if ret != 0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the number of pages that were not migrated, or an error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">migrate_pages</span><span class="params">(<span class="keyword">struct</span> list_head *from, <span class="type">new_page_t</span> get_new_page,</span></span><br><span class="line"><span class="params">		<span class="type">free_page_t</span> put_new_page, <span class="type">unsigned</span> <span class="type">long</span> private,</span></span><br><span class="line"><span class="params">		<span class="keyword">enum</span> migrate_mode mode, <span class="type">int</span> reason)</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>直接内存整形的入口点在__alloc_pages_direct_compact, 进一步调用到try_to_compact_pages.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try memory compaction for high-order allocations before reclaim */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_direct_compact</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">		<span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>, <span class="title">const</span> <span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>,</span></span><br><span class="line"><span class="class">		<span class="title">enum</span> <span class="title">compact_priority</span> <span class="title">prio</span>, <span class="title">enum</span> <span class="title">compact_result</span> *<span class="title">compa</span> <span class="title">ct_result</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pflags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> noreclaim_flag;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!order)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	psi_memstall_enter(&amp;pflags);</span><br><span class="line">	noreclaim_flag = memalloc_noreclaim_save();</span><br><span class="line"></span><br><span class="line">	*compact_result = try_to_compact_pages(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">									prio);</span><br></pre></td></tr></tbody></table></figure>

<p>try_to_compact_pages遍历ac-&gt;zonlist中的每个(符合nodemask的)zone, 进行compact_zone_order.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * try_to_compact_pages - Direct compact to satisfy a high-order allocation</span></span><br><span class="line"><span class="comment"> * @gfp_mask: The GFP mask of the current allocation</span></span><br><span class="line"><span class="comment"> * @order: The order of the current allocation</span></span><br><span class="line"><span class="comment"> * @alloc_flags: The allocation flags of the current allocation</span></span><br><span class="line"><span class="comment"> * @ac: The context of current allocation</span></span><br><span class="line"><span class="comment"> * @prio: Determines how hard direct compaction should try to succeed</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is the main entry point for direct page compaction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> compact_result <span class="title function_">try_to_compact_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> alloc_flags, <span class="type">const</span> <span class="keyword">struct</span> alloc_context *ac,</span></span><br><span class="line"><span class="params">		<span class="keyword">enum</span> compact_priority prio)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Compact each zone in the list */</span></span><br><span class="line">	for_each_zone_zonelist_nodemask(zone, z, ac-&gt;zonelist, ac-&gt;high_zoneidx,</span><br><span class="line">								ac-&gt;nodemask) {</span><br><span class="line">		<span class="class"><span class="keyword">enum</span> <span class="title">compact_result</span> <span class="title">status</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (prio &gt; MIN_COMPACT_PRIORITY</span><br><span class="line">					&amp;&amp; compaction_deferred(zone, order)) {</span><br><span class="line">			rc = <span class="type">max_t</span>(<span class="keyword">enum</span> compact_result, COMPACT_DEFERRED, rc);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		status = compact_zone_order(zone, order, gfp_mask, prio,</span><br><span class="line">					alloc_flags, ac_classzone_idx(ac));</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure>

<p>这里还涉及到一个推迟规整的概念, 如果本次对该zone的内存规整失败, 会调用defer_compaction. 下次对该zone整形之前, 会调用compaction_deferred判断是否进行推迟.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> </span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这两个用于推迟内存碎片整理处理，只有当内存碎片整理时使用的order大于compact_order_failed才会推迟 </span></span><br><span class="line"><span class="comment">     * 只有一种情况会重置这两个值:在zone执行内存碎片整理后，从此zone中分配到了内存，会重置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 用于判断是否需要推迟，每次推迟会++，然后判断是否超过 1UL &lt;&lt; compact_defer_shift，超过了则要进行内存碎片整理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        compact_considered;</span><br><span class="line">    <span class="comment">/* 用于定量推迟计数，主要用于内存碎片整理分为compact_considered &lt; compact_defer_shift和compact_considered &gt;= compact_defer_shift两种情况，当次管理区的内存碎片整理成功后被置0，不会大于COMPACT_MAX_DEFER_SHIFT</span></span><br><span class="line"><span class="comment">     * 只有在同步和轻同步模式下进行内存碎片整理后，zone的空闲页框数量没达到 (low阀值 + 1&lt;&lt;order + 保留内存) 时，才会增加此值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        compact_defer_shift;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 表示zone内存碎片整理失败时使用的最大order值，此值会影响是否推迟内存碎片整理</span></span><br><span class="line"><span class="comment">     * 当进行内存碎片整理时，使用的order小于此值，则允许进行内存碎片整理，否则记一次推迟</span></span><br><span class="line"><span class="comment">     * 当内存碎片整理完成时，此值为使用的order值+1，意思是假设大一级的order在整理中会失败</span></span><br><span class="line"><span class="comment">     * 当内存碎片整理失败时，此值则是等于order值，表示使用此大小的order值，有可能会导致失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span>            compact_order_failed;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Compaction is deferred when compaction fails to result in a page</span></span><br><span class="line"><span class="comment"> * allocation success. 1 &lt;&lt; compact_defer_limit compactions are skipped up</span></span><br><span class="line"><span class="comment"> * to a limit of 1 &lt;&lt; COMPACT_MAX_DEFER_SHIFT</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">defer_compaction</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="type">int</span> order)</span></span><br><span class="line">{</span><br><span class="line">	zone-&gt;compact_considered = <span class="number">0</span>;</span><br><span class="line">	zone-&gt;compact_defer_shift++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (order &lt; zone-&gt;compact_order_failed)</span><br><span class="line">		zone-&gt;compact_order_failed = order;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (zone-&gt;compact_defer_shift &gt; COMPACT_MAX_DEFER_SHIFT)</span><br><span class="line">		zone-&gt;compact_defer_shift = COMPACT_MAX_DEFER_SHIFT;</span><br><span class="line"></span><br><span class="line">	trace_mm_compaction_defer_compaction(zone, order);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns true if compaction should be skipped this time */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">compaction_deferred</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="type">int</span> order)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> defer_limit = <span class="number">1UL</span> &lt;&lt; zone-&gt;compact_defer_shift;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (order &lt; zone-&gt;compact_order_failed)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Avoid possible overflow */</span></span><br><span class="line">	<span class="keyword">if</span> (++zone-&gt;compact_considered &gt; defer_limit)</span><br><span class="line">		zone-&gt;compact_considered = defer_limit;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (zone-&gt;compact_considered &gt;= defer_limit)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	trace_mm_compaction_deferred(zone, order);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>compact_zone_order设置compact_control后转入compact_zone.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">enum</span> compact_result <span class="title function_">compact_zone_order</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">		<span class="type">gfp_t</span> gfp_mask, <span class="keyword">enum</span> compact_priority prio,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> alloc_flags, <span class="type">int</span> classzone_idx)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">compact_result</span> <span class="title">ret</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">compact_control</span> <span class="title">cc</span> =</span> {</span><br><span class="line">		.nr_freepages = <span class="number">0</span>,</span><br><span class="line">		.nr_migratepages = <span class="number">0</span>,</span><br><span class="line">		.total_migrate_scanned = <span class="number">0</span>,</span><br><span class="line">		.total_free_scanned = <span class="number">0</span>,</span><br><span class="line">		.order = order,</span><br><span class="line">		.gfp_mask = gfp_mask,</span><br><span class="line">		.zone = zone,</span><br><span class="line">		.mode = (prio == COMPACT_PRIO_ASYNC) ?</span><br><span class="line">					MIGRATE_ASYNC :	MIGRATE_SYNC_LIGHT,</span><br><span class="line">		.alloc_flags = alloc_flags,</span><br><span class="line">		.classzone_idx = classzone_idx,</span><br><span class="line">		.direct_compaction = <span class="literal">true</span>,</span><br><span class="line">		.whole_zone = (prio == MIN_COMPACT_PRIORITY),</span><br><span class="line">		.ignore_skip_hint = (prio == MIN_COMPACT_PRIORITY),</span><br><span class="line">		.ignore_block_suitable = (prio == MIN_COMPACT_PRIORITY)</span><br><span class="line">	};</span><br><span class="line">	INIT_LIST_HEAD(&amp;cc.freepages);</span><br><span class="line">	INIT_LIST_HEAD(&amp;cc.migratepages);</span><br><span class="line"></span><br><span class="line">	ret = compact_zone(zone, &amp;cc);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(!list_empty(&amp;cc.freepages));</span><br><span class="line">	VM_BUG_ON(!list_empty(&amp;cc.migratepages));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>compact_zone是内存规整的核心函数, 也是各内存规整路径的会合点. 归纳起来就是分两个方向扫描zone, 查找哪些页面可迁移的, 哪些页面是空闲的, 直到两个方向的扫描会合时或已经满足分配大块内存的需求时(能分配出所需要的大块内存并且满足最低的水位要求)时退出扫描.</p>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20240930214159.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20240930232830.png"></p>
<p>首先调用compaction_suitable预估一下本次规整的必要性和可能性.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * compaction_suitable: Is this suitable to run compaction on this zone now?</span></span><br><span class="line"><span class="comment"> * Returns</span></span><br><span class="line"><span class="comment"> *   COMPACT_SKIPPED  - If there are too few free pages for compaction</span></span><br><span class="line"><span class="comment"> *   COMPACT_SUCCESS  - If the allocation would succeed without compaction</span></span><br><span class="line"><span class="comment"> *   COMPACT_CONTINUE - If compaction should run now</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">compact_result</span> __<span class="title">compaction_suitable</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">					<span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class">					<span class="title">int</span> <span class="title">classzone_idx</span>,</span></span><br><span class="line"><span class="class">					<span class="title">unsigned</span> <span class="title">long</span> <span class="title">wmark_target</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">enum</span> <span class="title">compact_result</span> <span class="title">compact_zone</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="keyword">struct</span> <span class="title">compact_control</span> *<span class="title">cc</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">compact_result</span> <span class="title">ret</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_pfn = zone-&gt;zone_start_pfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> end_pfn = zone_end_pfn(zone);</span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> sync = cc-&gt;mode != MIGRATE_ASYNC;</span><br><span class="line"></span><br><span class="line">	cc-&gt;migratetype = gfpflags_to_migratetype(cc-&gt;gfp_mask);</span><br><span class="line">	ret = compaction_suitable(zone, cc-&gt;order, cc-&gt;alloc_flags,</span><br><span class="line">							cc-&gt;classzone_idx);</span><br><span class="line">	<span class="comment">/* Compaction is likely to fail */</span></span><br><span class="line">	<span class="keyword">if</span> (ret == COMPACT_SUCCESS || ret == COMPACT_SKIPPED)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* huh, compaction_suitable is returning something unexpected */</span></span><br><span class="line">	VM_BUG_ON(ret != COMPACT_CONTINUE);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>接下来是一个清除页块的PB_migrate_skip机制.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Clear pageblock skip if there were failures recently and compaction</span></span><br><span class="line"><span class="comment"> * is about to be retried after being deferred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (compaction_restarting(zone, cc-&gt;order))</span><br><span class="line">	__reset_isolation_suitable(zone);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>如果本次的order&lt; compact_order_failed(zone内存碎片整理失败时使用的最大order值), 那么不用清除.</li>
<li>如果zone-&gt;compact_considered(累计的推迟次数) &gt;= 1UL &lt;&lt; zone-&gt;compact_defer_shift (触发规整的推迟次数阈值的幂数) 并且 zone-&gt;compact_defer_shift已经达到COMPACT_MAX_DEFER_SHIFT, 那么进行清除.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns true if restarting compaction after many failures */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">compaction_restarting</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="type">int</span> order)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (order &lt; zone-&gt;compact_order_failed)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> zone-&gt;compact_defer_shift == COMPACT_MAX_DEFER_SHIFT &amp;&amp;</span><br><span class="line">		zone-&gt;compact_considered &gt;= <span class="number">1UL</span> &lt;&lt; zone-&gt;compact_defer_shift;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>然后是初始化双向扫描的位置. 如果设置了cc-&gt;whole_zone, 则完整的扫描整个zone.否则使用zone中缓存的上一次扫描结束的位置(zone-&gt;compact_cached_migrate_pfn和compact_cached_free_pfn), 当然使用之前还有合法性校验. </p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setup to move all movable pages to the end of the zone. Used cached</span></span><br><span class="line"><span class="comment"> * information on where the scanners should start (unless we explicitly</span></span><br><span class="line"><span class="comment"> * want to compact the whole zone), but check that it is initialised</span></span><br><span class="line"><span class="comment"> * by ensuring the values are within zone boundaries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (cc-&gt;whole_zone) {</span><br><span class="line">	cc-&gt;migrate_pfn = start_pfn;</span><br><span class="line">	cc-&gt;free_pfn = pageblock_start_pfn(end_pfn - <span class="number">1</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">	cc-&gt;migrate_pfn = zone-&gt;compact_cached_migrate_pfn[sync];</span><br><span class="line">	cc-&gt;free_pfn = zone-&gt;compact_cached_free_pfn;</span><br><span class="line">	<span class="keyword">if</span> (cc-&gt;free_pfn &lt; start_pfn || cc-&gt;free_pfn &gt;= end_pfn) {</span><br><span class="line">		cc-&gt;free_pfn = pageblock_start_pfn(end_pfn - <span class="number">1</span>);</span><br><span class="line">		zone-&gt;compact_cached_free_pfn = cc-&gt;free_pfn;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (cc-&gt;migrate_pfn &lt; start_pfn || cc-&gt;migrate_pfn &gt;= end_pfn) {</span><br><span class="line">		cc-&gt;migrate_pfn = start_pfn;</span><br><span class="line">		zone-&gt;compact_cached_migrate_pfn[<span class="number">0</span>] = cc-&gt;migrate_pfn;</span><br><span class="line">		zone-&gt;compact_cached_migrate_pfn[<span class="number">1</span>] = cc-&gt;migrate_pfn;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cc-&gt;migrate_pfn == start_pfn)</span><br><span class="line">		cc-&gt;whole_zone = <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<h3 id="准备cc-migratepages"><a href="#准备cc-migratepages" class="headerlink" title="准备cc->migratepages"></a>准备cc-&gt;migratepages</h3><p>接下来是一个大循环, 不断进行内存规整直到compact_finished不再返回COMPACT_CONTINUE.其中isolate_migratepages隔离出要进行迁移的页面</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((ret = compact_finished(zone, cc)) == COMPACT_CONTINUE) {</span><br><span class="line">		<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (isolate_migratepages(zone, cc)) {</span><br><span class="line">		<span class="keyword">case</span> ISOLATE_ABORT:</span><br><span class="line">			ret = COMPACT_CONTENDED;</span><br><span class="line">			putback_movable_pages(&amp;cc-&gt;migratepages);</span><br><span class="line">			cc-&gt;nr_migratepages = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		<span class="keyword">case</span> ISOLATE_NONE:</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We haven't isolated and migrated anything, but</span></span><br><span class="line"><span class="comment">			 * there might still be unflushed migrations from</span></span><br><span class="line"><span class="comment">			 * previous cc-&gt;order aligned block.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">goto</span> check_drain;</span><br><span class="line">		<span class="keyword">case</span> ISOLATE_SUCCESS:</span><br><span class="line">			;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		err = migrate_pages(&amp;cc-&gt;migratepages, compaction_alloc,</span><br><span class="line">				compaction_free, (<span class="type">unsigned</span> <span class="type">long</span>)cc, cc-&gt;mode,</span><br><span class="line">				MR_COMPACTION);</span><br><span class="line"></span><br><span class="line">		trace_mm_compaction_migratepages(cc-&gt;nr_migratepages, err,</span><br><span class="line">							&amp;cc-&gt;migratepages);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* All pages were either migrated or will be released */</span></span><br><span class="line">		cc-&gt;nr_migratepages = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (err) {</span><br><span class="line">			putback_movable_pages(&amp;cc-&gt;migratepages);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * migrate_pages() may return -ENOMEM when scanners meet</span></span><br><span class="line"><span class="comment">			 * and we want compact_finished() to detect it</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (err == -ENOMEM &amp;&amp; !compact_scanners_met(cc)) {</span><br><span class="line">				ret = COMPACT_CONTENDED;</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We failed to migrate at least one page in the current</span></span><br><span class="line"><span class="comment">			 * order-aligned block, so skip the rest of it.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (cc-&gt;direct_compaction &amp;&amp;</span><br><span class="line">						(cc-&gt;mode == MIGRATE_ASYNC)) {</span><br><span class="line">				cc-&gt;migrate_pfn = block_end_pfn(</span><br><span class="line">						cc-&gt;migrate_pfn - <span class="number">1</span>, cc-&gt;order);</span><br><span class="line">				<span class="comment">/* Draining pcplists is useless in this case */</span></span><br><span class="line">				cc-&gt;last_migrated_pfn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">check_drain:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Has the migration scanner moved away from the previous</span></span><br><span class="line"><span class="comment">		 * cc-&gt;order aligned block where we migrated from? If yes,</span></span><br><span class="line"><span class="comment">		 * flush the pages that were freed, so that they can merge and</span></span><br><span class="line"><span class="comment">		 * compact_finished() can detect immediately if allocation</span></span><br><span class="line"><span class="comment">		 * would succeed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (cc-&gt;order &gt; <span class="number">0</span> &amp;&amp; cc-&gt;last_migrated_pfn) {</span><br><span class="line">			<span class="type">int</span> cpu;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> current_block_start =</span><br><span class="line">				block_start_pfn(cc-&gt;migrate_pfn, cc-&gt;order);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (cc-&gt;last_migrated_pfn &lt; current_block_start) {</span><br><span class="line">				cpu = get_cpu();</span><br><span class="line">				lru_add_drain_cpu(cpu);</span><br><span class="line">				drain_local_pages(zone);</span><br><span class="line">				put_cpu();</span><br><span class="line">				<span class="comment">/* No more flushing until we migrate again */</span></span><br><span class="line">				cc-&gt;last_migrated_pfn = <span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>


<p>扫描范围内的所有页块, 跳过被标记PB_migrate_skip(最近隔离失败)的页块和本次规整不应使用的页块(见suitable_migration_source函数), 对单个页块调用isolate_migratepages_block.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Isolate all pages that can be migrated from the first suitable block,</span></span><br><span class="line"><span class="comment"> * starting at the block pointed to by the migrate scanner pfn within</span></span><br><span class="line"><span class="comment"> * compact_control.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">isolate_migrate_t</span> <span class="title function_">isolate_migratepages</span><span class="params">(<span class="keyword">struct</span> zone *zone,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> compact_control *cc)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> block_start_pfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> block_end_pfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> low_pfn;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">isolate_mode_t</span> isolate_mode =</span><br><span class="line">		(sysctl_compact_unevictable_allowed ? ISOLATE_UNEVICTABLE : <span class="number">0</span>) |</span><br><span class="line">		(cc-&gt;mode != MIGRATE_SYNC ? ISOLATE_ASYNC_MIGRATE : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Start at where we last stopped, or beginning of the zone as</span></span><br><span class="line"><span class="comment">	 * initialized by compact_zone()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	low_pfn = cc-&gt;migrate_pfn;</span><br><span class="line">	block_start_pfn = pageblock_start_pfn(low_pfn);</span><br><span class="line">	<span class="keyword">if</span> (block_start_pfn &lt; zone-&gt;zone_start_pfn)</span><br><span class="line">		block_start_pfn = zone-&gt;zone_start_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Only scan within a pageblock boundary */</span></span><br><span class="line">	block_end_pfn = pageblock_end_pfn(low_pfn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Iterate over whole pageblocks until we find the first suitable.</span></span><br><span class="line"><span class="comment">	 * Do not cross the free scanner.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (; block_end_pfn &lt;= cc-&gt;free_pfn;</span><br><span class="line">			low_pfn = block_end_pfn,</span><br><span class="line">			block_start_pfn = block_end_pfn,</span><br><span class="line">			block_end_pfn += pageblock_nr_pages) {</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This can potentially iterate a massively long zone with</span></span><br><span class="line"><span class="comment">		 * many pageblocks unsuitable, so periodically check if we</span></span><br><span class="line"><span class="comment">		 * need to schedule, or even abort async compaction.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(low_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))</span><br><span class="line">						&amp;&amp; compact_should_abort(cc))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		page = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,</span><br><span class="line">									zone);</span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If isolation recently failed, do not retry */</span></span><br><span class="line">		<span class="keyword">if</span> (!isolation_suitable(cc, page))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For async compaction, also only scan in MOVABLE blocks.</span></span><br><span class="line"><span class="comment">		 * Async compaction is optimistic to see if the minimum amount</span></span><br><span class="line"><span class="comment">		 * of work satisfies the allocation.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!suitable_migration_source(cc, page))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Perform the isolation */</span></span><br><span class="line">		low_pfn = isolate_migratepages_block(cc, low_pfn,</span><br><span class="line">						block_end_pfn, isolate_mode);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!low_pfn || cc-&gt;contended)</span><br><span class="line">			<span class="keyword">return</span> ISOLATE_ABORT;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Either we isolated something and proceed with migration. Or</span></span><br><span class="line"><span class="comment">		 * we failed and compact_zone should decide if we should</span></span><br><span class="line"><span class="comment">		 * continue or not.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Record where migration scanner will be restarted. */</span></span><br><span class="line">	cc-&gt;migrate_pfn = low_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cc-&gt;nr_migratepages ? ISOLATE_SUCCESS : ISOLATE_NONE;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">suitable_migration_source</span><span class="params">(<span class="keyword">struct</span> compact_control *cc,</span></span><br><span class="line"><span class="params">							<span class="keyword">struct</span> page *page)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> block_mt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((cc-&gt;mode != MIGRATE_ASYNC) || !cc-&gt;direct_compaction)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	block_mt = get_pageblock_migratetype(page);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cc-&gt;migratetype == MIGRATE_MOVABLE)</span><br><span class="line">		<span class="keyword">return</span> is_migrate_movable(block_mt);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> block_mt == cc-&gt;migratetype;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>isolate_migratepages_block进行单个页块内页面的扫描和隔离.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20240930232803.png"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * isolate_migratepages_block() - isolate all migrate-able pages within</span></span><br><span class="line"><span class="comment"> *				  a single pageblock</span></span><br><span class="line"><span class="comment"> * @cc:		Compaction control structure.</span></span><br><span class="line"><span class="comment"> * @low_pfn:	The first PFN to isolate</span></span><br><span class="line"><span class="comment"> * @end_pfn:	The one-past-the-last PFN to isolate, within same pageblock</span></span><br><span class="line"><span class="comment"> * @isolate_mode: Isolation mode to be used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Isolate all pages that can be migrated from the range specified by</span></span><br><span class="line"><span class="comment"> * [low_pfn, end_pfn). The range is expected to be within same pageblock.</span></span><br><span class="line"><span class="comment"> * Returns zero if there is a fatal signal pending, otherwise PFN of the</span></span><br><span class="line"><span class="comment"> * first page that was not scanned (which may be both less, equal to or more</span></span><br><span class="line"><span class="comment"> * than end_pfn).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The pages are isolated on cc-&gt;migratepages list (not required to be empty),</span></span><br><span class="line"><span class="comment"> * and cc-&gt;nr_migratepages is updated accordingly. The cc-&gt;migrate_pfn field</span></span><br><span class="line"><span class="comment"> * is neither read nor updated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">isolate_migratepages_block</span><span class="params">(<span class="keyword">struct</span> compact_control *cc, <span class="type">unsigned</span> <span class="type">long</span> low_pfn,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> end_pfn, <span class="type">isolate_mode_t</span> isolate_mode)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span> =</span> cc-&gt;zone;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_scanned = <span class="number">0</span>, nr_isolated = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span> *<span class="title">lruvec</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> locked = <span class="literal">false</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>, *valid_page = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_pfn = low_pfn;</span><br><span class="line">	<span class="type">bool</span> skip_on_failure = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> next_skip_pfn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure that there are not too many pages isolated from the LRU</span></span><br><span class="line"><span class="comment">	 * list by either parallel reclaimers or compaction. If there are,</span></span><br><span class="line"><span class="comment">	 * delay for some time until fewer pages are isolated</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (unlikely(too_many_isolated(zone))) {</span><br><span class="line">		<span class="comment">/* async migration should just abort */</span></span><br><span class="line">		<span class="keyword">if</span> (cc-&gt;mode == MIGRATE_ASYNC)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		congestion_wait(BLK_RW_ASYNC, HZ/<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fatal_signal_pending(current))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (compact_should_abort(cc))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cc-&gt;direct_compaction &amp;&amp; (cc-&gt;mode == MIGRATE_ASYNC)) {</span><br><span class="line">		skip_on_failure = <span class="literal">true</span>;</span><br><span class="line">		next_skip_pfn = block_end_pfn(low_pfn, cc-&gt;order);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Time to isolate some pages for migration */</span></span><br><span class="line">	<span class="keyword">for</span> (; low_pfn &lt; end_pfn; low_pfn++) {</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (skip_on_failure &amp;&amp; low_pfn &gt;= next_skip_pfn) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We have isolated all migration candidates in the</span></span><br><span class="line"><span class="comment">			 * previous order-aligned block, and did not skip it due</span></span><br><span class="line"><span class="comment">			 * to failure. We should migrate the pages now and</span></span><br><span class="line"><span class="comment">			 * hopefully succeed compaction.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (nr_isolated)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We failed to isolate in the previous order-aligned</span></span><br><span class="line"><span class="comment">			 * block. Set the new boundary to the end of the</span></span><br><span class="line"><span class="comment">			 * current block. Note we can't simply increase</span></span><br><span class="line"><span class="comment">			 * next_skip_pfn by 1 &lt;&lt; order, as low_pfn might have</span></span><br><span class="line"><span class="comment">			 * been incremented by a higher number due to skipping</span></span><br><span class="line"><span class="comment">			 * a compound or a high-order buddy page in the</span></span><br><span class="line"><span class="comment">			 * previous loop iteration.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			next_skip_pfn = block_end_pfn(low_pfn, cc-&gt;order);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Periodically drop the lock (if held) regardless of its</span></span><br><span class="line"><span class="comment">		 * contention, to give chance to IRQs. Abort async compaction</span></span><br><span class="line"><span class="comment">		 * if contended.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(low_pfn % SWAP_CLUSTER_MAX)</span><br><span class="line">		    &amp;&amp; compact_unlock_should_abort(zone_lru_lock(zone), flags,</span><br><span class="line">								&amp;locked, cc))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pfn_valid_within(low_pfn))</span><br><span class="line">			<span class="keyword">goto</span> isolate_fail;</span><br><span class="line">		nr_scanned++;</span><br><span class="line"></span><br><span class="line">		page = pfn_to_page(low_pfn);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!valid_page)</span><br><span class="line">			valid_page = page;</span><br></pre></td></tr></tbody></table></figure>

<p>跳过空闲页面</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Skip if free. We read page order here without zone lock</span></span><br><span class="line"><span class="comment"> * which is generally unsafe, but the race window is small and</span></span><br><span class="line"><span class="comment"> * the worst thing that can happen is that we skip some</span></span><br><span class="line"><span class="comment"> * potential isolation targets.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (PageBuddy(page)) {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> freepage_order = page_order_unsafe(page);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Without lock, we cannot be sure that what we got is</span></span><br><span class="line"><span class="comment">	 * a valid page order. Consider only values in the</span></span><br><span class="line"><span class="comment">	 * valid order range to prevent low_pfn overflow.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (freepage_order &gt; <span class="number">0</span> &amp;&amp; freepage_order &lt; MAX_ORDER)</span><br><span class="line">		low_pfn += (<span class="number">1UL</span> &lt;&lt; freepage_order) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>跳过混合页面</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Regardless of being on LRU, compound pages such as THP and</span></span><br><span class="line"><span class="comment"> * hugetlbfs are not to be compacted. We can potentially save</span></span><br><span class="line"><span class="comment"> * a lot of iterations if we skip them at once. The check is</span></span><br><span class="line"><span class="comment"> * racy, but we can consider only valid values and the only</span></span><br><span class="line"><span class="comment"> * danger is skipping too much.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (PageCompound(page)) {</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> order = compound_order(page);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(order &lt; MAX_ORDER))</span><br><span class="line">		low_pfn += (<span class="number">1UL</span> &lt;&lt; order) - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">goto</span> isolate_fail;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>接下来处理不在LRU链表中的页面, 这类页面一般不适合迁移, 但可移动(__PageMovable)且还没有被隔离(!PageIsolated)的页面, 是可以进行迁移的.这些是特殊的可迁移页面, 如virtio-balloon页面, isolate_movable_page会调用对应驱动程序的isolate_page方法隔离这些页面.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check may be lockless but that's ok as we recheck later.</span></span><br><span class="line"><span class="comment"> * It's possible to migrate LRU and non-lru movable pages.</span></span><br><span class="line"><span class="comment"> * Skip any other type of page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!PageLRU(page)) {</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * __PageMovable can return false positive so we need</span></span><br><span class="line"><span class="comment">	 * to verify it under page_lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(__PageMovable(page)) &amp;&amp;</span><br><span class="line">			!PageIsolated(page)) {</span><br><span class="line">		<span class="keyword">if</span> (locked) {</span><br><span class="line">			spin_unlock_irqrestore(zone_lru_lock(zone),</span><br><span class="line">							flags);</span><br><span class="line">			locked = <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!isolate_movable_page(page, isolate_mode))</span><br><span class="line">			<span class="keyword">goto</span> isolate_success;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> isolate_fail;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>固定在内存中的匿名页面也不适合迁移. !page_mapping(page)指匿名页面.page_count(page) &gt; page_mapcount(page)说明内核中使用了这个匿名页面, 可能是通过get_user_pages对其进行锁定.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Migration will fail if an anonymous page is pinned in memory,</span></span><br><span class="line"><span class="comment"> * so avoid taking lru_lock and isolating it unnecessarily in an</span></span><br><span class="line"><span class="comment"> * admittedly racy check.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!page_mapping(page) &amp;&amp;</span><br><span class="line">    page_count(page) &gt; page_mapcount(page))</span><br><span class="line">	<span class="keyword">goto</span> isolate_fail;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Only allow to migrate anonymous pages in GFP_NOFS context</span></span><br><span class="line"><span class="comment"> * because those do not depend on fs locks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(cc-&gt;gfp_mask &amp; __GFP_FS) &amp;&amp; page_mapping(page))</span><br><span class="line">	<span class="keyword">goto</span> isolate_fail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we already hold the lock, we can skip some rechecking */</span></span><br><span class="line"><span class="keyword">if</span> (!locked) {</span><br><span class="line">	locked = compact_trylock_irqsave(zone_lru_lock(zone),</span><br><span class="line">						&amp;flags, cc);</span><br><span class="line">	<span class="keyword">if</span> (!locked)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Recheck PageLRU and PageCompound under lock */</span></span><br><span class="line">	<span class="keyword">if</span> (!PageLRU(page))</span><br><span class="line">		<span class="keyword">goto</span> isolate_fail;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Page become compound since the non-locked check,</span></span><br><span class="line"><span class="comment">	 * and it's on LRU. It can only be a THP so the order</span></span><br><span class="line"><span class="comment">	 * is safe to read and it's 0 for tail pages.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(PageCompound(page))) {</span><br><span class="line">		low_pfn += (<span class="number">1UL</span> &lt;&lt; compound_order(page)) - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> isolate_fail;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来处理LRU的页面, 简单的清除PG_LRU标志并从LRU链表中移除.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">lruvec = mem_cgroup_page_lruvec(page, zone-&gt;zone_pgdat);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try isolate the page */</span></span><br><span class="line"><span class="keyword">if</span> (__isolate_lru_page(page, isolate_mode) != <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">goto</span> isolate_fail;</span><br><span class="line"></span><br><span class="line">VM_BUG_ON_PAGE(PageCompound(page), page);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Successfully isolated */</span></span><br><span class="line">del_page_from_lru_list(page, lruvec, page_lru(page));</span><br><span class="line">inc_node_page_state(page,</span><br><span class="line">		NR_ISOLATED_ANON + page_is_file_cache(page));</span><br></pre></td></tr></tbody></table></figure>

<p>对于隔离成功的页面, 加入cc-&gt;migratepages</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">isolate_success:</span><br><span class="line">		list_add(&amp;page-&gt;lru, &amp;cc-&gt;migratepages);</span><br><span class="line">		cc-&gt;nr_migratepages++;</span><br><span class="line">		nr_isolated++;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Record where we could have freed pages by migration and not</span></span><br><span class="line"><span class="comment">		 * yet flushed them to buddy allocator.</span></span><br><span class="line"><span class="comment">		 * - this is the lowest page that was isolated and likely be</span></span><br><span class="line"><span class="comment">		 * then freed by migration.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!cc-&gt;last_migrated_pfn)</span><br><span class="line">			cc-&gt;last_migrated_pfn = low_pfn;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Avoid isolating too much */</span></span><br><span class="line">		<span class="keyword">if</span> (cc-&gt;nr_migratepages == COMPACT_CLUSTER_MAX) {</span><br><span class="line">			++low_pfn;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">continue</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>对于隔离失败的情况, 应该将隔离出的cc-&gt;migratepages重新放回.并更新compact_cached_migrate_pfn.如果扫描了整个页块却没有成功隔离出页面, 应该对页块标记PB_migrate_skip</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">isolate_fail:</span><br><span class="line">		<span class="keyword">if</span> (!skip_on_failure)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We have isolated some pages, but then failed. Release them</span></span><br><span class="line"><span class="comment">		 * instead of migrating, as we cannot form the cc-&gt;order buddy</span></span><br><span class="line"><span class="comment">		 * page anyway.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (nr_isolated) {</span><br><span class="line">			<span class="keyword">if</span> (locked) {</span><br><span class="line">				spin_unlock_irqrestore(zone_lru_lock(zone), flags);</span><br><span class="line">				locked = <span class="literal">false</span>;</span><br><span class="line">			}</span><br><span class="line">			putback_movable_pages(&amp;cc-&gt;migratepages);</span><br><span class="line">			cc-&gt;nr_migratepages = <span class="number">0</span>;</span><br><span class="line">			cc-&gt;last_migrated_pfn = <span class="number">0</span>;</span><br><span class="line">			nr_isolated = <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (low_pfn &lt; next_skip_pfn) {</span><br><span class="line">			low_pfn = next_skip_pfn - <span class="number">1</span>;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The check near the loop beginning would have updated</span></span><br><span class="line"><span class="comment">			 * next_skip_pfn too, but this is a bit simpler.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			next_skip_pfn += <span class="number">1UL</span> &lt;&lt; cc-&gt;order;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The PageBuddy() check could have potentially brought us outside</span></span><br><span class="line"><span class="comment">	 * the range to be scanned.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(low_pfn &gt; end_pfn))</span><br><span class="line">		low_pfn = end_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (locked)</span><br><span class="line">		spin_unlock_irqrestore(zone_lru_lock(zone), flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Update the pageblock-skip information and cached scanner pfn,</span></span><br><span class="line"><span class="comment">	 * if the whole pageblock was scanned without isolating any page.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (low_pfn == end_pfn)</span><br><span class="line">		update_pageblock_skip(cc, valid_page, nr_isolated, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	trace_mm_compaction_isolate_migratepages(start_pfn, low_pfn,</span><br><span class="line">						nr_scanned, nr_isolated);</span><br><span class="line"></span><br><span class="line">	cc-&gt;total_migrate_scanned += nr_scanned;</span><br><span class="line">	<span class="keyword">if</span> (nr_isolated)</span><br><span class="line">		count_compact_events(COMPACTISOLATED, nr_isolated);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> low_pfn;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="准备cc-free-pages"><a href="#准备cc-free-pages" class="headerlink" title="准备cc->free_pages"></a>准备cc-&gt;free_pages</h3><p>准备cc-&gt;free_pages的过程, 实际上是通过在页面迁移接口migrate_pages中回调进行的.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a migrate-callback that "allocates" freepages by taking pages</span></span><br><span class="line"><span class="comment"> * from the isolated freelists in the block we are migrating to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">compaction_alloc</span><span class="params">(<span class="keyword">struct</span> page *migratepage,</span></span><br><span class="line"><span class="params">					<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">compact_control</span> *<span class="title">cc</span> =</span> (<span class="keyword">struct</span> compact_control *)data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">freepage</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Isolate free pages if necessary, and if we are not aborting due to</span></span><br><span class="line"><span class="comment">	 * contention.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (list_empty(&amp;cc-&gt;freepages)) {</span><br><span class="line">		<span class="keyword">if</span> (!cc-&gt;contended)</span><br><span class="line">			isolate_freepages(cc);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (list_empty(&amp;cc-&gt;freepages))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	freepage = list_entry(cc-&gt;freepages.next, <span class="keyword">struct</span> page, lru);</span><br><span class="line">	list_del(&amp;freepage-&gt;lru);</span><br><span class="line">	cc-&gt;nr_freepages--;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> freepage;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>核心过程在isolate_freepages中完成, 和cc-&gt;migratepages的隔离过程类似.<br>首先进行扫描区间的初始化.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Based on information in the current compact_control, find blocks</span></span><br><span class="line"><span class="comment"> * suitable for isolating free pages from and then isolate them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">isolate_freepages</span><span class="params">(<span class="keyword">struct</span> compact_control *cc)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span> =</span> cc-&gt;zone;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> block_start_pfn;	<span class="comment">/* start of current pageblock */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> isolate_start_pfn; <span class="comment">/* exact pfn we start at */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> block_end_pfn;	<span class="comment">/* end of current pageblock */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> low_pfn;	     <span class="comment">/* lowest pfn scanner is able to scan */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">freelist</span> =</span> &amp;cc-&gt;freepages;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialise the free scanner. The starting point is where we last</span></span><br><span class="line"><span class="comment">	 * successfully isolated from, zone-cached value, or the end of the</span></span><br><span class="line"><span class="comment">	 * zone when isolating for the first time. For looping we also need</span></span><br><span class="line"><span class="comment">	 * this pfn aligned down to the pageblock boundary, because we do</span></span><br><span class="line"><span class="comment">	 * block_start_pfn -= pageblock_nr_pages in the for loop.</span></span><br><span class="line"><span class="comment">	 * For ending point, take care when isolating in last pageblock of a</span></span><br><span class="line"><span class="comment">	 * a zone which ends in the middle of a pageblock.</span></span><br><span class="line"><span class="comment">	 * The low boundary is the end of the pageblock the migration scanner</span></span><br><span class="line"><span class="comment">	 * is using.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	isolate_start_pfn = cc-&gt;free_pfn;</span><br><span class="line">	block_start_pfn = pageblock_start_pfn(cc-&gt;free_pfn);</span><br><span class="line">	block_end_pfn = min(block_start_pfn + pageblock_nr_pages,</span><br><span class="line">						zone_end_pfn(zone));</span><br><span class="line">	low_pfn = pageblock_end_pfn(cc-&gt;migrate_pfn);</span><br></pre></td></tr></tbody></table></figure>

<p>然后进入从zone末尾开始向zone首部循环扫描的过程.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Isolate free pages until enough are available to migrate the</span></span><br><span class="line"><span class="comment"> * pages on cc-&gt;migratepages. We stop searching if the migrate</span></span><br><span class="line"><span class="comment"> * and free page scanners meet or enough free pages are isolated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (; block_start_pfn &gt;= low_pfn;</span><br><span class="line">			block_end_pfn = block_start_pfn,</span><br><span class="line">			block_start_pfn -= pageblock_nr_pages,</span><br><span class="line">			isolate_start_pfn = block_start_pfn) {</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This can iterate a massively long zone without finding any</span></span><br><span class="line"><span class="comment">	 * suitable migration targets, so periodically check if we need</span></span><br><span class="line"><span class="comment">	 * to schedule, or even abort async compaction.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(block_start_pfn % (SWAP_CLUSTER_MAX * pageblock_nr_pages))</span><br><span class="line">					&amp;&amp; compact_should_abort(cc))</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	page = pageblock_pfn_to_page(block_start_pfn, block_end_pfn,</span><br><span class="line">								zone);</span><br><span class="line">	<span class="keyword">if</span> (!page)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>检查该页块是否适合成为迁移的目标.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check the block is suitable for migration */</span></span><br><span class="line"><span class="keyword">if</span> (!suitable_migration_target(cc, page))</span><br><span class="line">	<span class="keyword">continue</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>当且仅当 ( (该页面不是空闲) || (是空闲但页面大小小于页块大小) ) &amp;&amp; (迁移类型为MIGRATE_MOVABLE或MIGRATE_CMA)时, 页面适合成为迁移目标.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns true if the page is within a block suitable for migration to */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">suitable_migration_target</span><span class="params">(<span class="keyword">struct</span> compact_control *cc,</span></span><br><span class="line"><span class="params">							<span class="keyword">struct</span> page *page)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">/* If the page is a large free page, then disallow migration */</span></span><br><span class="line">	<span class="keyword">if</span> (PageBuddy(page)) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We are checking page_order without zone-&gt;lock taken. But</span></span><br><span class="line"><span class="comment">		 * the only small danger is that we skip a potentially suitable</span></span><br><span class="line"><span class="comment">		 * pageblock, so it's not worth to check order for valid range.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (page_order_unsafe(page) &gt;= pageblock_order)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (cc-&gt;ignore_block_suitable)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the block is MIGRATE_MOVABLE or MIGRATE_CMA, allow migration */</span></span><br><span class="line">	<span class="keyword">if</span> (is_migrate_movable(get_pageblock_migratetype(page)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Otherwise skip the block */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果该页块近期隔离失败过(被标记PB_migrate_skip), 跳过该页块.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If isolation recently failed, do not retry */</span></span><br><span class="line"><span class="keyword">if</span> (!isolation_suitable(cc, page))</span><br><span class="line">	<span class="keyword">continue</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>然后调用isolate_freepages_block从该页块中隔离出空闲页面.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Found a block suitable for isolating free pages from. */</span></span><br><span class="line">isolate_freepages_block(cc, &amp;isolate_start_pfn, block_end_pfn,</span><br><span class="line">			freelist, <span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure>


<p>循环上述过程直到获取到足够的freepages或扫描结束.map_pages将freelist中的高阶空闲页面拆成order-0的页面.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> ((cc-&gt;nr_freepages &gt;= cc-&gt;nr_migratepages)</span><br><span class="line">						|| cc-&gt;contended) {</span><br><span class="line">		<span class="keyword">if</span> (isolate_start_pfn &gt;= block_end_pfn) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Restart at previous pageblock if more</span></span><br><span class="line"><span class="comment">			 * freepages can be isolated next time.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			isolate_start_pfn =</span><br><span class="line">				block_start_pfn - pageblock_nr_pages;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (isolate_start_pfn &lt; block_end_pfn) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If isolation failed early, do not continue</span></span><br><span class="line"><span class="comment">		 * needlessly.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">   <span class="comment">/* __isolate_free_page() does not map the pages */</span></span><br><span class="line">map_pages(freelist);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Record where the free scanner will restart next time. Either we</span></span><br><span class="line"><span class="comment"> * broke from the loop and set isolate_start_pfn based on the last</span></span><br><span class="line"><span class="comment"> * call to isolate_freepages_block(), or we met the migration scanner</span></span><br><span class="line"><span class="comment"> * and the loop terminated due to isolate_start_pfn &lt; low_pfn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cc-&gt;free_pfn = isolate_start_pfn;</span><br></pre></td></tr></tbody></table></figure>

<p>isolate_freepages_block的过程与isolate_migratepages_block很相似, 不再阐述.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Isolate free pages onto a private freelist. If @strict is true, will abort</span></span><br><span class="line"><span class="comment"> * returning 0 on any invalid PFNs or non-free pages inside of the pageblock</span></span><br><span class="line"><span class="comment"> * (even though it may still end up isolating some pages).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">isolate_freepages_block</span><span class="params">(<span class="keyword">struct</span> compact_control *cc,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> *start_pfn,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> end_pfn,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> list_head *freelist,</span></span><br><span class="line"><span class="params">				<span class="type">bool</span> strict)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> nr_scanned = <span class="number">0</span>, total_isolated = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">cursor</span>, *<span class="title">valid_page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> locked = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> blockpfn = *start_pfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> order;</span><br><span class="line"></span><br><span class="line">	cursor = pfn_to_page(blockpfn);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Isolate free pages. */</span></span><br><span class="line">	<span class="keyword">for</span> (; blockpfn &lt; end_pfn; blockpfn++, cursor++) {</span><br><span class="line">		<span class="type">int</span> isolated;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> cursor;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Periodically drop the lock (if held) regardless of its</span></span><br><span class="line"><span class="comment">		 * contention, to give chance to IRQs. Abort if fatal signal</span></span><br><span class="line"><span class="comment">		 * pending or async compaction detects need_resched()</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(blockpfn % SWAP_CLUSTER_MAX)</span><br><span class="line">		    &amp;&amp; compact_unlock_should_abort(&amp;cc-&gt;zone-&gt;lock, flags,</span><br><span class="line">								&amp;locked, cc))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		nr_scanned++;</span><br><span class="line">		<span class="keyword">if</span> (!pfn_valid_within(blockpfn))</span><br><span class="line">			<span class="keyword">goto</span> isolate_fail;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!valid_page)</span><br><span class="line">			valid_page = page;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For compound pages such as THP and hugetlbfs, we can save</span></span><br><span class="line"><span class="comment">		 * potentially a lot of iterations if we skip them at once.</span></span><br><span class="line"><span class="comment">		 * The check is racy, but we can consider only valid values</span></span><br><span class="line"><span class="comment">		 * and the only danger is skipping too much.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (PageCompound(page)) {</span><br><span class="line">			<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> order = compound_order(page);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (likely(order &lt; MAX_ORDER)) {</span><br><span class="line">				blockpfn += (<span class="number">1UL</span> &lt;&lt; order) - <span class="number">1</span>;</span><br><span class="line">				cursor += (<span class="number">1UL</span> &lt;&lt; order) - <span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">goto</span> isolate_fail;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!PageBuddy(page))</span><br><span class="line">			<span class="keyword">goto</span> isolate_fail;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If we already hold the lock, we can skip some rechecking.</span></span><br><span class="line"><span class="comment">		 * Note that if we hold the lock now, checked_pageblock was</span></span><br><span class="line"><span class="comment">		 * already set in some previous iteration (or strict is true),</span></span><br><span class="line"><span class="comment">		 * so it is correct to skip the suitable migration target</span></span><br><span class="line"><span class="comment">		 * recheck as well.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!locked) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The zone lock must be held to isolate freepages.</span></span><br><span class="line"><span class="comment">			 * Unfortunately this is a very coarse lock and can be</span></span><br><span class="line"><span class="comment">			 * heavily contended if there are parallel allocations</span></span><br><span class="line"><span class="comment">			 * or parallel compactions. For async compaction do not</span></span><br><span class="line"><span class="comment">			 * spin on the lock and we acquire the lock as late as</span></span><br><span class="line"><span class="comment">			 * possible.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			locked = compact_trylock_irqsave(&amp;cc-&gt;zone-&gt;lock,</span><br><span class="line">								&amp;flags, cc);</span><br><span class="line">			<span class="keyword">if</span> (!locked)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Recheck this is a buddy page under lock */</span></span><br><span class="line">			<span class="keyword">if</span> (!PageBuddy(page))</span><br><span class="line">				<span class="keyword">goto</span> isolate_fail;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Found a free page, will break it into order-0 pages */</span></span><br><span class="line">		order = page_order(page);</span><br><span class="line">		isolated = __isolate_free_page(page, order);</span><br><span class="line">		<span class="keyword">if</span> (!isolated)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		set_page_private(page, order);</span><br><span class="line"></span><br><span class="line">		total_isolated += isolated;</span><br><span class="line">		cc-&gt;nr_freepages += isolated;</span><br><span class="line">		list_add_tail(&amp;page-&gt;lru, freelist);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!strict &amp;&amp; cc-&gt;nr_migratepages &lt;= cc-&gt;nr_freepages) {</span><br><span class="line">			blockpfn += isolated;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">/* Advance to the end of split page */</span></span><br><span class="line">		blockpfn += isolated - <span class="number">1</span>;</span><br><span class="line">		cursor += isolated - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">isolate_fail:</span><br><span class="line">		<span class="keyword">if</span> (strict)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (locked)</span><br><span class="line">		spin_unlock_irqrestore(&amp;cc-&gt;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There is a tiny chance that we have read bogus compound_order(),</span></span><br><span class="line"><span class="comment">	 * so be careful to not go outside of the pageblock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(blockpfn &gt; end_pfn))</span><br><span class="line">		blockpfn = end_pfn;</span><br><span class="line"></span><br><span class="line">	trace_mm_compaction_isolate_freepages(*start_pfn, blockpfn,</span><br><span class="line">					nr_scanned, total_isolated);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Record how far we have got within the block */</span></span><br><span class="line">	*start_pfn = blockpfn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If strict isolation is requested by CMA then check that all the</span></span><br><span class="line"><span class="comment">	 * pages requested were isolated. If there were any failures, 0 is</span></span><br><span class="line"><span class="comment">	 * returned and CMA will fail.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (strict &amp;&amp; blockpfn &lt; end_pfn)</span><br><span class="line">		total_isolated = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Update the pageblock-skip if the whole pageblock was scanned */</span></span><br><span class="line">	<span class="keyword">if</span> (blockpfn == end_pfn)</span><br><span class="line">		update_pageblock_skip(cc, valid_page, total_isolated, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	cc-&gt;total_free_scanned += nr_scanned;</span><br><span class="line">	<span class="keyword">if</span> (total_isolated)</span><br><span class="line">		count_compact_events(COMPACTISOLATED, total_isolated);</span><br><span class="line">	<span class="keyword">return</span> total_isolated;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tolimit/p/5286663.html">https://www.cnblogs.com/tolimit/p/5286663.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://jamorant12138.github.io/2024/Linux%20-%20memory%20compact%20--%20ARM64%20v5.0/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Memory-Management/" rel="tag">Memory_Management</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/linux%20kernel%20lab%20--%20Notes/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Linux kernel Lab学习笔记
          
        </div>
      </a>
    
    
      <a href="/2024/Linux%20-%20memory%20reclaim%20--%20ARM64%20v5.0/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Linux内核 页面回收 -- ARM64 v5.0</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> 翰青HanQi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="北极落小雪"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/About">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>