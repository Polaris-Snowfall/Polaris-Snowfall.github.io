<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
        
      <meta name="description" content="Boom? PWN ! ! !" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Slub-Allocator 源码分析 |  北极落小雪</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
  </html>
</html>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Slub-Allocator Analysis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Slub-Allocator 源码分析
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/Slub-Allocator%20Analysis/" class="article-date">
  <time datetime="2024-01-28T16:00:00.000Z" itemprop="datePublished">2024-01-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Pwn/">Pwn</a> / <a class="article-category-link" href="/categories/Pwn/Kernel/">Kernel</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">37 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>CONFIG_SLAB_FREELIST_HARDENED毁了我的slub master梦</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写此文的目的,一是两位前辈的劝诫:</p>
<blockquote>
<p>“要是一辈子都只能看分析,那永远也写不出分析”<br>“有问题先看源码,再看文档,一定要有读源码的意识”<br>“做Kernel不读Slub就像做User mode不读Ptmalloc2”.</p>
</blockquote>
<p>二是最近在复现内核漏洞的过程中发现源码阅读有点吃力,遂选取逻辑性较强的内存管理部分的源码进行练习.<br>三是beta24开发的gef插件,方便了我很多工作,我想知道其的实现.</p>
<p>本文主要对Slub Allocator的分配与释放进行流程上的分析.因笔者水平有限且内容过多,难免分析有误,若有错误请师傅们联系我修改.代码来自linux-6.6.7</p>
<p>添加注释的源码:<a target="_blank" rel="noopener" href="https://github.com/Polaris-Snowfall/linux-kernel-comment/blob/main/slub.comment.c">https://github.com/Polaris-Snowfall/linux-kernel-comment/blob/main/slub.comment.c</a>.</p>
<h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><h3 id="kmem-cache-特定大小或特殊用途对象的内存池"><a href="#kmem-cache-特定大小或特殊用途对象的内存池" class="headerlink" title="kmem_cache (特定大小或特殊用途对象的内存池)"></a>kmem_cache (特定大小或特殊用途对象的内存池)</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab cache management.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> {</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SLUB_TINY</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line">	<span class="type">slab_flags_t</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> min_partial; <span class="comment">//node partial 链表上slab数量的下限</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;	<span class="comment">/* The size of an object including metadata */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reciprocal_value</span> <span class="title">reciprocal_size</span>;</span></span><br><span class="line">	<span class="comment">//不同kmem_cache管理的空闲对象,free pointer在对象上的偏移不同,用offset指示</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset;	<span class="comment">/* Free pointer offset */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">	<span class="comment">/*kmem_cache_cpu-&gt;partial最多能保存的对象个数*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cpu_partial;</span><br><span class="line">	<span class="comment">/*kmem_cache_cpu-&gt;partial最多能保存的slab个数*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cpu_partial_slabs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*低16位为@order的slab有多少个大小为@size的对象,高16位为@order*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">	<span class="type">gfp_t</span> allocflags;	<span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line">	<span class="type">int</span> refcount;		<span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line">	<span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> inuse;		<span class="comment">/* Offset to metadata */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> align;		<span class="comment">/* Alignment */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> red_left_pad;	<span class="comment">/* Left redzone padding size */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;	<span class="comment">/* Name (only for display!) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>	<span class="comment">/* List of slab caches */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>	<span class="comment">/* For sysfs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> random; <span class="comment">//用作free pointer加密的异或值</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Defragmentation by allocating from a remote node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> remote_node_defrag_ratio;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN_GENERIC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HARDENED_USERCOPY</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="kmem-cache-cpu"><a href="#kmem-cache-cpu" class="headerlink" title="kmem_cache_cpu"></a>kmem_cache_cpu</h3><p>kmem_cache对于每个cpu有一个kmem_cache_cpu结构,用于快速处理分配释放请求.<br>三个关键结构.<br>freelist: 无锁的空闲链表,快速分配.<br>slab: 当前cpu正在使用的slab<br>partial: 一些未在使用且部分空闲的slab</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">			<span class="type">void</span> **freelist;	<span class="comment">/* Pointer to next available object */</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> tid;	<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">		};</span><br><span class="line">		<span class="type">freelist_aba_t</span> freelist_tid;</span><br><span class="line">	};</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span>	<span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">partial</span>;</span>	<span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">local_lock_t</span> lock;	<span class="comment">/* Protects the fields above */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">	<span class="type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="kmem-cache-node"><a href="#kmem-cache-node" class="headerlink" title="kmem_cache_node"></a>kmem_cache_node</h3><p>对于slub来说,关注partial链表即可.可以看作是kmem_cache_cpu与buddy system的中间层.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The slab lists for all objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> {</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line">	<span class="type">raw_spinlock_t</span> list_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span>	<span class="comment">/* partial list first, better asm code */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> total_slabs;	<span class="comment">/* length of all slab lists */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> free_slabs;	<span class="comment">/* length of free slab list only */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> free_objects;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> colour_next;	<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span>	<span class="comment">/* shared per node */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alien_cache</span> **<span class="title">alien</span>;</span>	<span class="comment">/* on other nodes */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> next_reap;	<span class="comment">/* updated without locking */</span></span><br><span class="line">	<span class="type">int</span> free_touched;		<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">	<span class="type">spinlock_t</span> list_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="type">atomic_long_t</span> nr_slabs;</span><br><span class="line">	<span class="type">atomic_long_t</span> total_objects;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h3><p>向buddy system一次请求的连续页面称作slab.<br>在linux kernel的代码中, struct slab,struct folio,struct page本质上其实是一个东西(之前slab是直接作为联合体嵌入在struct page中).由于一个slab可能是多个连续页面,该结构保存在仅第一个页面中.<br>所以可以直接从虚拟地址转化到对应的slab.</p>
<p>下列是需要关注的结构；<br>slab_cache : 指向对应的kmem_cache.也就实现了虚拟地址转换到kmem_cache.<br>slab_list: 组织kmem_cache_node中双向链表的结构.<br>next: 组织kmeme_cache_cpu中partial单向链表的结构.<br>slabs: 当前slab之后的slab数量,用于kmeme_cache_cpu中partial单向链表的计数.<br>freelist; 记录slab中空闲对象的链表<br>inuse: 当前slab正在使用的对象数<br>objects: 当前slab包含的对象数<br>frozen: 当前slab是否为冻结状态.(解释一下,冻结就是分给特定的cpu了,位于kmem_cache_cpu-&gt;slab或partial)<br>rcu_head: 用于rcu回调的.</p>
<p>inuse,objects,frozen整体用counters来表示(联合体),便于整体更新.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reuses the bits in struct page */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> {</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> __page_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SLAB)</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">			<span class="type">void</span> *freelist;	<span class="comment">/* array of free object indexes */</span></span><br><span class="line">			<span class="type">void</span> *s_mem;	<span class="comment">/* first object */</span></span><br><span class="line">		};</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">	};</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> active;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SLUB)</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">next</span>;</span></span><br><span class="line">					<span class="type">int</span> slabs;	<span class="comment">/* Nr of slabs left */</span></span><br><span class="line">				};</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			};</span><br><span class="line">			<span class="comment">/* Double-word boundary */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">					<span class="type">void</span> *freelist;		<span class="comment">/* first free object */</span></span><br><span class="line">					<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">						<span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">						<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">							<span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">							<span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">							<span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">						};</span><br><span class="line">					};</span><br><span class="line">				};</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> system_has_freelist_aba</span></span><br><span class="line">				<span class="type">freelist_aba_t</span> freelist_counter;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			};</span><br><span class="line">		};</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">	};</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __unused;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">"Unexpected slab allocator configured"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_t</span> __page_refcount;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><h3 id="slab-alloc-node"><a href="#slab-alloc-node" class="headerlink" title="slab_alloc_node"></a>slab_alloc_node</h3><p>内核中通过slab allocator进行内存分配的接口最终都会调用到slab_alloc_node进行实际的内存分配.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401291653009.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401291655418.png"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果无锁的空闲链表可以使用则通过FASTPATH进行分配,</span></span><br><span class="line"><span class="comment">* 否则通过__slab_alloc进行SLOWPATH</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> __fastpath_inline <span class="type">void</span> *<span class="title function_">slab_alloc_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> list_lru *lru,</span></span><br><span class="line"><span class="params">		<span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">size_t</span> orig_size)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">void</span> *object;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">obj_cgroup</span> *<span class="title">objcg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span> init = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	s = slab_pre_alloc_hook(s, lru, &amp;objcg, <span class="number">1</span>, gfpflags);</span><br><span class="line">	<span class="keyword">if</span> (!s)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	object = kfence_alloc(s, orig_size, gfpflags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(object))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	object = __slab_alloc_node(s, gfpflags, node, addr, orig_size);</span><br><span class="line"></span><br><span class="line">	maybe_wipe_obj_freeptr(s, object);</span><br><span class="line">	init = slab_want_init_on_alloc(gfpflags, s);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When init equals 'true', like for kzalloc() family, only</span></span><br><span class="line"><span class="comment">	 * @orig_size bytes might be zeroed instead of s-&gt;object_size</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	slab_post_alloc_hook(s, objcg, gfpflags, <span class="number">1</span>, &amp;object, init, orig_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实际的处理逻辑在__slab_alloc_node.FASTPATH的处理是直接取kmem_cache_cpu-&gt;freelist的第一个对象返回.当然进入FASTPATH的前提是要c-&gt;freelist&amp;&amp;c-&gt;slab.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *__slab_alloc_node(<span class="keyword">struct</span> kmem_cache *s,</span><br><span class="line">		<span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">size_t</span> orig_size)</span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line">	<span class="type">void</span> *object;</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must read kmem_cache cpu data via this cpu ptr. Preemption is</span></span><br><span class="line"><span class="comment">	 * enabled. We may switch back and forth between cpus while</span></span><br><span class="line"><span class="comment">	 * reading from one cpu area. That does not matter as long</span></span><br><span class="line"><span class="comment">	 * as we end up on the original cpu again when doing the cmpxchg.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We must guarantee that tid and kmem_cache_cpu are retrieved on the</span></span><br><span class="line"><span class="comment">	 * same cpu. We read first the kmem_cache_cpu pointer and use it to read</span></span><br><span class="line"><span class="comment">	 * the tid. If we are preempted and switched to another cpu between the</span></span><br><span class="line"><span class="comment">	 * two reads, it's OK as the two are still associated with the same cpu</span></span><br><span class="line"><span class="comment">	 * and cmpxchg later will validate the cpu.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	tid = READ_ONCE(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Irqless object alloc/free algorithm used here depends on sequence</span></span><br><span class="line"><span class="comment">	 * of fetching cpu_slab's data. tid should be fetched before anything</span></span><br><span class="line"><span class="comment">	 * on c to guarantee that object and slab associated with previous tid</span></span><br><span class="line"><span class="comment">	 * won't be used with current tid. If we fetch tid first, object and</span></span><br><span class="line"><span class="comment">	 * slab could be one associated with next tid and our alloc/free</span></span><br><span class="line"><span class="comment">	 * request will be failed. In this case, we will retry. So, no problem.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The transaction ids are globally unique per cpu and per operation on</span></span><br><span class="line"><span class="comment">	 * a per cpu queue. Thus they can be guarantee that the cmpxchg_double</span></span><br><span class="line"><span class="comment">	 * occurs on the right processor and that there was no operation on the</span></span><br><span class="line"><span class="comment">	 * linked list in between.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	object = c-&gt;freelist;</span><br><span class="line">	slab = c-&gt;slab;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!USE_LOCKLESS_FAST_PATH() ||</span><br><span class="line">	    unlikely(!object || !slab || !node_match(slab, node))) {</span><br><span class="line">		<span class="comment">//SLOWPATH</span></span><br><span class="line">		object = __slab_alloc(s, gfpflags, node, addr, c, orig_size);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="comment">//FASTPATH,直接取kmem_cache_cpu-&gt;freelist的第一个对象</span></span><br><span class="line">		<span class="type">void</span> *next_object = get_freepointer_safe(s, object);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The cmpxchg will only match if there was no additional</span></span><br><span class="line"><span class="comment">		 * operation and if we are on the right processor.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * The cmpxchg does the following atomically (without lock</span></span><br><span class="line"><span class="comment">		 * semantics!)</span></span><br><span class="line"><span class="comment">		 * 1. Relocate first pointer to the current per cpu area.</span></span><br><span class="line"><span class="comment">		 * 2. Verify that tid and freelist have not been changed</span></span><br><span class="line"><span class="comment">		 * 3. If they were not changed replace tid and freelist</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Since this is without lock semantics the protection is only</span></span><br><span class="line"><span class="comment">		 * against code executing on this cpu *not* from access by</span></span><br><span class="line"><span class="comment">		 * other cpus.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!__update_cpu_freelist_fast(s, object, next_object, tid))) {</span><br><span class="line">			note_cmpxchg_failure(<span class="string">"slab_alloc"</span>, s, tid);</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		}</span><br><span class="line">		prefetch_freepointer(s, next_object);</span><br><span class="line">		stat(s, ALLOC_FASTPATH);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>函数___slab_alloc是SLOWPATH的主要处理逻辑,由于其比较复杂且本来就是模块化的,这里逐块进行分析.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slow path. 当无锁的空闲链表为空时或进行调试时使用.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 若有新的对象已经被释放到常规的空闲链表中了,处理仍旧非常快.</span></span><br><span class="line"><span class="comment"> * 只需要将常规空闲链表作为无锁的空闲链表并清空常规的空闲链表.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果这不起作用,我们回退到partial链表.</span></span><br><span class="line"><span class="comment"> * 我们取走partial链表中的slab的freelist中的</span></span><br><span class="line"><span class="comment"> * 第一个对象作为本次分配的对象返回,然后将空闲链表中</span></span><br><span class="line"><span class="comment"> * 剩下的对象移动到无锁的空闲链表中.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果我们不能从partial slab链表中获取到新的slab,</span></span><br><span class="line"><span class="comment"> * 则需要分配一个新的slab.这是最慢的路径因为它需要调用</span></span><br><span class="line"><span class="comment"> * 页极分配器并初始化一个新的slab.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * __slab_alloc这一版本是当我们知道抢占已经被禁用时使用的.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *___slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c, <span class="type">unsigned</span> <span class="type">int</span> orig_size)</span><br><span class="line">{</span><br><span class="line">	<span class="type">void</span> *freelist;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">partial_context</span> <span class="title">pc</span>;</span></span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_SLOWPATH);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="reread-slab"><a href="#reread-slab" class="headerlink" title="reread_slab"></a>reread_slab</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取c-&gt;slab到局部变量中,便于访问修改</span></span><br><span class="line">reread_slab:</span><br><span class="line"></span><br><span class="line">	slab = READ_ONCE(c-&gt;slab);</span><br><span class="line">	<span class="keyword">if</span> (!slab) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * if the node is not online or has no normal memory, just</span></span><br><span class="line"><span class="comment">		 * ignore the node constraint</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//该kmem_cache_cpu没有正在使用的slab,跳转到new_slab</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">			     !node_isset(node, slab_nodes)))</span><br><span class="line">			node = NUMA_NO_NODE;</span><br><span class="line">		<span class="keyword">goto</span> new_slab;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="redo"><a href="#redo" class="headerlink" title="redo"></a>redo</h4><p>主要是进行一些检测来将处理逻辑分发到不同处理模块</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">redo:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!node_match(slab, node))) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * same as above but node_match() being false already</span></span><br><span class="line"><span class="comment">		 * implies node != NUMA_NO_NODE</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!node_isset(node, slab_nodes)) {</span><br><span class="line">			node = NUMA_NO_NODE;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			stat(s, ALLOC_NODE_MISMATCH);</span><br><span class="line">			<span class="keyword">goto</span> deactivate_slab;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * By rights, we should be searching for a slab page that was</span></span><br><span class="line"><span class="comment">	 * PFMEMALLOC but right now, we are losing the pfmemalloc</span></span><br><span class="line"><span class="comment">	 * information when the page leaves the per-cpu allocator</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))</span><br><span class="line">		<span class="keyword">goto</span> deactivate_slab;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* must check again c-&gt;slab in case we got preempted and it changed */</span></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) {</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> reread_slab;</span><br><span class="line">	}</span><br><span class="line">	freelist = c-&gt;freelist;</span><br><span class="line">	<span class="keyword">if</span> (freelist)</span><br><span class="line">		<span class="keyword">goto</span> load_freelist;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//kmem_cache_cpu中freelist为空,尝试从kmem_cache_cpu-&gt;slab中获取freelist</span></span><br><span class="line">	freelist = get_freelist(s, slab);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若还是未取到,说明当前正在使用的slab是满的,尝试获取新的slab.</span></span><br><span class="line">	<span class="keyword">if</span> (!freelist) {</span><br><span class="line">		c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		stat(s, DEACTIVATE_BYPASS);</span><br><span class="line">		<span class="keyword">goto</span> new_slab;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_REFILL);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查slab的空闲链表并决定要么将其转移</span></span><br><span class="line"><span class="comment"> * 到per cpu空闲链表中,要么对该slab进行deactivate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 若返回值非空则该slab仍处于冻结状态</span></span><br><span class="line"><span class="comment"> * 若返回值为空则该slab已经解冻.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">get_freelist</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">	<span class="type">void</span> *freelist;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> {</span><br><span class="line">		freelist = slab-&gt;freelist;</span><br><span class="line">		counters = slab-&gt;counters;</span><br><span class="line"></span><br><span class="line">		new.counters = counters;</span><br><span class="line">		VM_BUG_ON(!new.frozen);</span><br><span class="line"></span><br><span class="line">		new.inuse = slab-&gt;objects;</span><br><span class="line">		new.frozen = freelist != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	} <span class="keyword">while</span> (!__slab_update_freelist(s, slab,</span><br><span class="line">		freelist, counters,</span><br><span class="line">		<span class="literal">NULL</span>, new.counters,</span><br><span class="line">		<span class="string">"get_freelist"</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> freelist;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="load-freelist"><a href="#load-freelist" class="headerlink" title="load_freelist"></a>load_freelist</h4><p>这一模块是用来处理通过各种途径后已经获取到freelist之后的逻辑.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 装载freelist链表,更新kmem_cache-&gt;freelist为空闲对象</span></span><br><span class="line"><span class="comment">* 链表中第二个对象,返回当前空闲对象中第一个对象(因为本次</span></span><br><span class="line"><span class="comment">* __alloc_slab会直接分配一个对象).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">load_freelist:</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * freelist is pointing to the list of objects to be used.</span></span><br><span class="line"><span class="comment">	 * slab is pointing to the slab from which the objects are obtained.</span></span><br><span class="line"><span class="comment">	 * That slab must be frozen for per cpu allocations to work.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	VM_BUG_ON(!c-&gt;slab-&gt;frozen);</span><br><span class="line">	c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line">	c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">	local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> freelist;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取该@object对应freelist中下一个对象的地址.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">get_freepointer</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">void</span> *object)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ptr_addr;</span><br><span class="line">	<span class="type">freeptr_t</span> p;</span><br><span class="line"></span><br><span class="line">	object = kasan_reset_tag(object);</span><br><span class="line">	<span class="comment">//freelist的指针在object中有一个kmem_cache-&gt;offset的偏移</span></span><br><span class="line">	ptr_addr = (<span class="type">unsigned</span> <span class="type">long</span>)object + s-&gt;offset;</span><br><span class="line">	p = *(<span class="type">freeptr_t</span> *)(ptr_addr);</span><br><span class="line">	<span class="keyword">return</span> freelist_ptr_decode(s, p, ptr_addr);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h4 id="deactivate-slab"><a href="#deactivate-slab" class="headerlink" title="deactivate_slab"></a>deactivate_slab</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将kmem_cache_cpu-&gt;slab-&gt;freelist合并连接到</span></span><br><span class="line"><span class="comment">* kmem_cache_cpu-&gt;freelist之后,解冻slab并根据合并后</span></span><br><span class="line"><span class="comment">* slab情况放入对应的kmem_cache_node的partial/full</span></span><br><span class="line"><span class="comment">* 链表中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">deactivate_slab:</span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="comment">//处理并发问题</span></span><br><span class="line">	<span class="keyword">if</span> (slab != c-&gt;slab) {</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> reread_slab;</span><br><span class="line">	}</span><br><span class="line">	freelist = c-&gt;freelist;</span><br><span class="line">	c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">	c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">	c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">	local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	deactivate_slab(s, slab, freelist);</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 结束移除cpu slab的操作.将cpu的空闲链表和slab</span></span><br><span class="line"><span class="comment"> * 的空闲链表合并,解冻slab并放到正确的链表中.</span></span><br><span class="line"><span class="comment"> * 假设slab已经被调用者安全的从kmem_cache_cpu中移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deactivate_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab,</span></span><br><span class="line"><span class="params">			    <span class="type">void</span> *freelist)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">slab_modes</span> {</span> M_NONE, M_PARTIAL, M_FREE, M_FULL_NOLIST };</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> get_node(s, slab_nid(slab));</span><br><span class="line">	<span class="type">int</span> free_delta = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">slab_modes</span> <span class="title">mode</span> =</span> M_NONE;</span><br><span class="line">	<span class="type">void</span> *nextfree, *freelist_iter, *freelist_tail;</span><br><span class="line">	<span class="type">int</span> tail = DEACTIVATE_TO_HEAD;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slab-&gt;freelist) {</span><br><span class="line">		stat(s, DEACTIVATE_REMOTE_FREES);</span><br><span class="line">		tail = DEACTIVATE_TO_TAIL;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Stage one: Count the objects on cpu's freelist as free_delta and</span></span><br><span class="line"><span class="comment">	 * remember the last object in freelist_tail for later splicing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	freelist_tail = <span class="literal">NULL</span>;</span><br><span class="line">	freelist_iter = freelist;</span><br><span class="line">	<span class="keyword">while</span> (freelist_iter) {</span><br><span class="line">		nextfree = get_freepointer(s, freelist_iter);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If 'nextfree' is invalid, it is possible that the object at</span></span><br><span class="line"><span class="comment">		 * 'freelist_iter' is already corrupted.  So isolate all objects</span></span><br><span class="line"><span class="comment">		 * starting at 'freelist_iter' by skipping them.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (freelist_corrupted(s, slab, &amp;freelist_iter, nextfree))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		freelist_tail = freelist_iter;</span><br><span class="line">		free_delta++;</span><br><span class="line"></span><br><span class="line">		freelist_iter = nextfree;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Stage two: Unfreeze the slab while splicing the per-cpu</span></span><br><span class="line"><span class="comment">	 * freelist to the head of slab's freelist.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Ensure that the slab is unfrozen while the list presence</span></span><br><span class="line"><span class="comment">	 * reflects the actual number of objects during unfreeze.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We first perform cmpxchg holding lock and insert to list</span></span><br><span class="line"><span class="comment">	 * when it succeed. If there is mismatch then the slab is not</span></span><br><span class="line"><span class="comment">	 * unfrozen and number of objects in the slab may have changed.</span></span><br><span class="line"><span class="comment">	 * Then release lock and retry cmpxchg again.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">redo:</span><br><span class="line"></span><br><span class="line">	old.freelist = READ_ONCE(slab-&gt;freelist);</span><br><span class="line">	old.counters = READ_ONCE(slab-&gt;counters);</span><br><span class="line">	VM_BUG_ON(!old.frozen);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Determine target state of the slab */</span></span><br><span class="line">	new.counters = old.counters;</span><br><span class="line">	<span class="keyword">if</span> (freelist_tail) {</span><br><span class="line">		new.inuse -= free_delta;</span><br><span class="line">		set_freepointer(s, freelist_tail, old.freelist);</span><br><span class="line">		new.freelist = freelist;</span><br><span class="line">	} <span class="keyword">else</span></span><br><span class="line">		new.freelist = old.freelist;</span><br><span class="line"></span><br><span class="line">	new.frozen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial) {</span><br><span class="line">		mode = M_FREE;</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (new.freelist) {</span><br><span class="line">		mode = M_PARTIAL;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Taking the spinlock removes the possibility that</span></span><br><span class="line"><span class="comment">		 * acquire_slab() will see a slab that is frozen</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		mode = M_FULL_NOLIST;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!slab_update_freelist(s, slab,</span><br><span class="line">				old.freelist, old.counters,</span><br><span class="line">				new.freelist, new.counters,</span><br><span class="line">				<span class="string">"unfreezing slab"</span>)) {</span><br><span class="line">		<span class="keyword">if</span> (mode == M_PARTIAL)</span><br><span class="line">			spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> redo;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mode == M_PARTIAL) {</span><br><span class="line">		add_partial(n, slab, tail);</span><br><span class="line">		spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">		stat(s, tail);</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (mode == M_FREE) {</span><br><span class="line">		stat(s, DEACTIVATE_EMPTY);</span><br><span class="line">		discard_slab(s, slab);</span><br><span class="line">		stat(s, FREE_SLAB);</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (mode == M_FULL_NOLIST) {</span><br><span class="line">		stat(s, DEACTIVATE_FULL);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="new-slab"><a href="#new-slab" class="headerlink" title="new_slab"></a>new_slab</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 尝试从kmem_cache_cpu-&gt;partial中获取slab并</span></span><br><span class="line"><span class="comment">* 设置为kmem_cache_cpu-&gt;slab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">new_slab:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slub_percpu_partial(c)) {</span><br><span class="line">		local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(c-&gt;slab)) {</span><br><span class="line">		<span class="comment">//处理并发问题</span></span><br><span class="line">			local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">			<span class="keyword">goto</span> reread_slab;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!slub_percpu_partial(c))) {</span><br><span class="line">		<span class="comment">//处理并发问题</span></span><br><span class="line">			local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">			<span class="comment">/* we were preempted and partial list got empty */</span></span><br><span class="line">			<span class="keyword">goto</span> new_objects;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		slab = c-&gt;slab = slub_percpu_partial(c);</span><br><span class="line">		slub_set_percpu_partial(c, slab); <span class="comment">//更新partial链表</span></span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		stat(s, CPU_PARTIAL_ALLOC);</span><br><span class="line">		<span class="keyword">goto</span> redo;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> slub_percpu_partial(c)		((c)-&gt;partial)</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="new-objects"><a href="#new-objects" class="headerlink" title="new_objects"></a>new_objects</h4><p>如果从kmem_cache_cpu-&gt;partial获取slab失败,则回退到kmem_cache_node进行获取.<br>首先尝试从kmem_cache_node-&gt;partial中获取slab.若失败则调用new_slab函数(注意与上面的new_slab label不是一个东西)向budy system申请新的slab.<br>两种方式获取到的slab都设为full状态并冻结,方便之后装载到kmem_cache_cpu-&gt;slab.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 尝试从kmem_cache_node-&gt;partial中获取slab.</span></span><br><span class="line"><span class="comment">* 若失败则调用new_slab向budy system申请新的slab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">new_objects:</span><br><span class="line"></span><br><span class="line">	pc.flags = gfpflags;</span><br><span class="line">	pc.slab = &amp;slab;</span><br><span class="line">	pc.orig_size = orig_size;</span><br><span class="line">	freelist = get_partial(s, node, &amp;pc);</span><br><span class="line">	<span class="keyword">if</span> (freelist)</span><br><span class="line">		<span class="keyword">goto</span> check_new_slab;</span><br><span class="line"></span><br><span class="line">	slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	slab = new_slab(s, gfpflags, node);</span><br><span class="line">	c = slub_get_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!slab)) {</span><br><span class="line">		slab_out_of_memory(s, gfpflags, node);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_SLAB);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kmem_cache_debug(s)) {</span><br><span class="line">		freelist = alloc_single_from_new_slab(s, slab, orig_size);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!freelist))</span><br><span class="line">			<span class="keyword">goto</span> new_objects;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line">			set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> freelist;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * No other reference to the slab yet so we can</span></span><br><span class="line"><span class="comment">	 * muck around with it freely without cmpxchg</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	freelist = slab-&gt;freelist;</span><br><span class="line">	slab-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">	slab-&gt;inuse = slab-&gt;objects;</span><br><span class="line">	slab-&gt;frozen = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//更新kmem_cache_node-&gt;nr_slabs,total_objects</span></span><br><span class="line">	inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);</span><br></pre></td></tr></tbody></table></figure>

<p>get_partial函数首先尝试get_partial_node从当前的kmem_cache_node中分配slab,若失败且node指定为NUMA_NO_NODE,则进行get_any_partial搜索其他的kmem_cache_node进行分配.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a partial slab, lock it and return it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">get_partial</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">int</span> node, <span class="keyword">struct</span> partial_context *pc)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">void</span> *object;</span><br><span class="line">	<span class="type">int</span> searchnode = node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">		searchnode = numa_mem_id();</span><br><span class="line"></span><br><span class="line">	object = get_partial_node(s, get_node(s, searchnode), pc);</span><br><span class="line">	<span class="keyword">if</span> (object || node != NUMA_NO_NODE)</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> get_any_partial(s, pc);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 遍历kmem_cache_node-&gt;partial尝试获取.</span></span><br><span class="line"><span class="comment"> * Try to allocate a partial slab from a specific node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">get_partial_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> kmem_cache_node *n,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> partial_context *pc)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>, *<span class="title">slab2</span>;</span></span><br><span class="line">	<span class="type">void</span> *object = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> partial_slabs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Racy check. If we mistakenly see no partial slabs then we</span></span><br><span class="line"><span class="comment">	 * just allocate an empty slab. If we mistakenly try to get a</span></span><br><span class="line"><span class="comment">	 * partial slab and there is none available then get_partial()</span></span><br><span class="line"><span class="comment">	 * will return NULL.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!n || !n-&gt;nr_partial)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	list_for_each_entry_safe(slab, slab2, &amp;n-&gt;partial, slab_list) {</span><br><span class="line">		<span class="type">void</span> *t;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pfmemalloc_match(slab, pc-&gt;flags))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) {</span><br><span class="line">			object = alloc_single_from_partial(s, n, slab,</span><br><span class="line">							pc-&gt;orig_size);</span><br><span class="line">			<span class="keyword">if</span> (object)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		t = acquire_slab(s, n, slab, object == <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (!t)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!object) {</span><br><span class="line">			*pc-&gt;slab = slab;</span><br><span class="line">			stat(s, ALLOC_FROM_PARTIAL);</span><br><span class="line">			object = t;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			put_cpu_partial(s, slab, <span class="number">0</span>);</span><br><span class="line">			stat(s, CPU_PARTIAL_NODE);</span><br><span class="line">			partial_slabs++;</span><br><span class="line">		}</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">		<span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s)</span><br><span class="line">			|| partial_slabs &gt; s-&gt;cpu_partial_slabs / <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将slab从kmem_cache_node-&gt;partial中移除.</span></span><br><span class="line"><span class="comment"> * 设置为full状态并冻结该slab,返回slab-&gt;freelist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">acquire_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> kmem_cache_node *n, <span class="keyword">struct</span> slab *slab,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> mode)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">void</span> *freelist;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;n-&gt;list_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Zap the freelist and set the frozen bit.</span></span><br><span class="line"><span class="comment">	 * The old freelist is the list of objects for the</span></span><br><span class="line"><span class="comment">	 * per cpu allocation list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	freelist = slab-&gt;freelist;</span><br><span class="line">	counters = slab-&gt;counters;</span><br><span class="line">	new.counters = counters;</span><br><span class="line">	<span class="keyword">if</span> (mode) {</span><br><span class="line">		new.inuse = slab-&gt;objects;</span><br><span class="line">		new.freelist = <span class="literal">NULL</span>;</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		new.freelist = freelist;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(new.frozen);</span><br><span class="line">	new.frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!__slab_update_freelist(s, slab,</span><br><span class="line">			freelist, counters,</span><br><span class="line">			new.freelist, new.counters,</span><br><span class="line">			<span class="string">"acquire_slab"</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	remove_partial(n, slab);</span><br><span class="line">	WARN_ON(!freelist);</span><br><span class="line">	<span class="keyword">return</span> freelist;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> slab *<span class="title function_">new_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags, <span class="type">int</span> node)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (unlikely(flags &amp; GFP_SLAB_BUG_MASK))</span><br><span class="line">		flags = kmalloc_fix_flags(flags);</span><br><span class="line"></span><br><span class="line">	WARN_ON_ONCE(s-&gt;ctor &amp;&amp; (flags &amp; __GFP_ZERO));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> allocate_slab(s,</span><br><span class="line">		flags &amp; (GFP_RECLAIM_MASK | GFP_CONSTRAINT_MASK), node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>核心的分配slab的过程在allocate_slab中实现.<br>向底层buddy system请求连续页面作为slab,根据请求对slab以及slab-&gt;freelist进行初始化.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> slab *<span class="title function_">allocate_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags, <span class="type">int</span> node)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span> =</span> s-&gt;oo;</span><br><span class="line">	<span class="type">gfp_t</span> alloc_gfp;</span><br><span class="line">	<span class="type">void</span> *start, *p, *next;</span><br><span class="line">	<span class="type">int</span> idx;</span><br><span class="line">	<span class="type">bool</span> shuffle;</span><br><span class="line"></span><br><span class="line">	flags &amp;= gfp_allowed_mask;</span><br><span class="line"></span><br><span class="line">	flags |= s-&gt;allocflags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Let the initial higher-order allocation fail under memory pressure</span></span><br><span class="line"><span class="comment">	 * so we fall-back to the minimum order allocation.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) &amp; ~__GFP_NOFAIL;</span><br><span class="line">	<span class="keyword">if</span> ((alloc_gfp &amp; __GFP_DIRECT_RECLAIM) &amp;&amp; oo_order(oo) &gt; oo_order(s-&gt;min))</span><br><span class="line">		alloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) &amp; ~__GFP_RECLAIM;</span><br><span class="line"></span><br><span class="line">	slab = alloc_slab_page(alloc_gfp, node, oo);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!slab)) {</span><br><span class="line">		oo = s-&gt;min;</span><br><span class="line">		alloc_gfp = flags;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Allocation may have failed due to fragmentation.</span></span><br><span class="line"><span class="comment">		 * Try a lower order alloc if possible</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		slab = alloc_slab_page(alloc_gfp, node, oo);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!slab))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		stat(s, ORDER_FALLBACK);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	slab-&gt;objects = oo_objects(oo);</span><br><span class="line">	slab-&gt;inuse = <span class="number">0</span>;</span><br><span class="line">	slab-&gt;frozen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	account_slab(slab, oo_order(oo), s, flags);</span><br><span class="line"></span><br><span class="line">	slab-&gt;slab_cache = s;</span><br><span class="line"></span><br><span class="line">	kasan_poison_slab(slab);</span><br><span class="line"></span><br><span class="line">	start = slab_address(slab);</span><br><span class="line"></span><br><span class="line">	setup_slab_debug(s, slab, start);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line">	shuffle = shuffle_freelist(s, slab);</span><br><span class="line"><span class="comment">//如果没开就从低地址向高地址串成链表</span></span><br><span class="line">	<span class="keyword">if</span> (!shuffle) {</span><br><span class="line">		start = fixup_red_left(s, start);</span><br><span class="line">		start = setup_object(s, start);</span><br><span class="line">		slab-&gt;freelist = start;</span><br><span class="line">		<span class="keyword">for</span> (idx = <span class="number">0</span>, p = start; idx &lt; slab-&gt;objects - <span class="number">1</span>; idx++) {</span><br><span class="line">			next = p + s-&gt;size;</span><br><span class="line">			next = setup_object(s, next);</span><br><span class="line">			set_freepointer(s, p, next);</span><br><span class="line">			p = next;</span><br><span class="line">		}</span><br><span class="line">		set_freepointer(s, p, <span class="literal">NULL</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slab;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab allocation and freeing</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> slab *<span class="title function_">alloc_slab_page</span><span class="params">(<span class="type">gfp_t</span> flags, <span class="type">int</span> node,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> kmem_cache_order_objects oo)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> order = oo_order(oo);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">		folio = (<span class="keyword">struct</span> folio *)alloc_pages(flags, order);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		folio = (<span class="keyword">struct</span> folio *)__alloc_pages_node(node, flags, order);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!folio)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	slab = folio_slab(folio);</span><br><span class="line">	__folio_set_slab(folio);</span><br><span class="line">	<span class="comment">/* Make the flag visible before any changes to folio-&gt;mapping */</span></span><br><span class="line">	smp_wmb();</span><br><span class="line">	<span class="keyword">if</span> (folio_is_pfmemalloc(folio))</span><br><span class="line">		slab_set_pfmemalloc(slab);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slab;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>对于开启了CONFIG_SLAB_FREELIST_RANDOM,shuffle_freelist会打乱freelist的顺序.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Shuffle the single linked freelist based on a random pre-computed sequence */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">shuffle_freelist</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">void</span> *start;</span><br><span class="line">	<span class="type">void</span> *cur;</span><br><span class="line">	<span class="type">void</span> *next;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> idx, pos, page_limit, freelist_count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slab-&gt;objects &lt; <span class="number">2</span> || !s-&gt;random_seq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	freelist_count = oo_objects(s-&gt;oo);</span><br><span class="line">	pos = get_random_u32_below(freelist_count);</span><br><span class="line"></span><br><span class="line">	page_limit = slab-&gt;objects * s-&gt;size;</span><br><span class="line">	start = fixup_red_left(s, slab_address(slab));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* First entry is used as the base of the freelist */</span></span><br><span class="line">	cur = next_freelist_entry(s, slab, &amp;pos, start, page_limit,</span><br><span class="line">				freelist_count);</span><br><span class="line">	cur = setup_object(s, cur);</span><br><span class="line">	slab-&gt;freelist = cur;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (idx = <span class="number">1</span>; idx &lt; slab-&gt;objects; idx++) {</span><br><span class="line">		next = next_freelist_entry(s, slab, &amp;pos, start, page_limit,</span><br><span class="line">			freelist_count);</span><br><span class="line">		next = setup_object(s, next);</span><br><span class="line">		set_freepointer(s, cur, next);</span><br><span class="line">		cur = next;</span><br><span class="line">	}</span><br><span class="line">	set_freepointer(s, cur, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="check-new-slab"><a href="#check-new-slab" class="headerlink" title="check_new_slab"></a>check_new_slab</h4><p>一些check.检查slab和标志位是否匹配,若不匹配则将其deactivate</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">check_new_slab:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kmem_cache_debug(s)) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For debug caches here we had to go through</span></span><br><span class="line"><span class="comment">		 * alloc_single_from_partial() so just store the tracking info</span></span><br><span class="line"><span class="comment">		 * and return the object</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line">			set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> freelist;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags))) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For !pfmemalloc_match() case we don't load freelist so that</span></span><br><span class="line"><span class="comment">		 * we don't make further mismatched allocations easier.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		deactivate_slab(s, slab, get_freepointer(s, freelist));</span><br><span class="line">		<span class="keyword">return</span> freelist;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="retry-load-slab"><a href="#retry-load-slab" class="headerlink" title="retry_load_slab"></a>retry_load_slab</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 再次尝试装载slab,如果kmem_cache_cpu上已经有</span></span><br><span class="line"><span class="comment">* slab了(并发问题),进行deactivate直到成功装载</span></span><br><span class="line"><span class="comment">* 新的slab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">retry_load_slab:</span><br><span class="line"></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(c-&gt;slab)) {</span><br><span class="line">		<span class="type">void</span> *flush_freelist = c-&gt;freelist;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">flush_slab</span> =</span> c-&gt;slab;</span><br><span class="line"></span><br><span class="line">		c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">		deactivate_slab(s, flush_slab, flush_freelist);</span><br><span class="line"></span><br><span class="line">		stat(s, CPUSLAB_FLUSH);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> retry_load_slab;</span><br><span class="line">	}</span><br><span class="line">	c-&gt;slab = slab;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> load_freelist;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="完整回顾"><a href="#完整回顾" class="headerlink" title="完整回顾"></a>完整回顾</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *___slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c, <span class="type">unsigned</span> <span class="type">int</span> orig_size)</span><br><span class="line">{</span><br><span class="line">	<span class="type">void</span> *freelist;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">partial_context</span> <span class="title">pc</span>;</span></span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_SLOWPATH);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取c-&gt;slab到局部变量中,便于访问修改</span></span><br><span class="line">reread_slab:</span><br><span class="line"></span><br><span class="line">	slab = READ_ONCE(c-&gt;slab);</span><br><span class="line">	<span class="keyword">if</span> (!slab) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * if the node is not online or has no normal memory, just</span></span><br><span class="line"><span class="comment">		 * ignore the node constraint</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//该kmem_cache_cpu没有正在使用的slab,跳转到new_slab</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">			     !node_isset(node, slab_nodes)))</span><br><span class="line">			node = NUMA_NO_NODE;</span><br><span class="line">		<span class="keyword">goto</span> new_slab;</span><br><span class="line">	}</span><br><span class="line">redo:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!node_match(slab, node))) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * same as above but node_match() being false already</span></span><br><span class="line"><span class="comment">		 * implies node != NUMA_NO_NODE</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!node_isset(node, slab_nodes)) {</span><br><span class="line">			node = NUMA_NO_NODE;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			stat(s, ALLOC_NODE_MISMATCH);</span><br><span class="line">			<span class="keyword">goto</span> deactivate_slab;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * By rights, we should be searching for a slab page that was</span></span><br><span class="line"><span class="comment">	 * PFMEMALLOC but right now, we are losing the pfmemalloc</span></span><br><span class="line"><span class="comment">	 * information when the page leaves the per-cpu allocator</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags)))</span><br><span class="line">		<span class="keyword">goto</span> deactivate_slab;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* must check again c-&gt;slab in case we got preempted and it changed */</span></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) {</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> reread_slab;</span><br><span class="line">	}</span><br><span class="line">	freelist = c-&gt;freelist;</span><br><span class="line">	<span class="keyword">if</span> (freelist)</span><br><span class="line">		<span class="keyword">goto</span> load_freelist;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//kmem_cache_cpu中freelist为空,尝试从kmem_cache_cpu-&gt;slab中获取freelist</span></span><br><span class="line">	freelist = get_freelist(s, slab);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//若还是未取到,说明当前正在使用的slab是满的,尝试获取新的slab.</span></span><br><span class="line">	<span class="keyword">if</span> (!freelist) {</span><br><span class="line">		c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		stat(s, DEACTIVATE_BYPASS);</span><br><span class="line">		<span class="keyword">goto</span> new_slab;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_REFILL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 装载freelist链表,更新kmem_cache-&gt;freelist为空闲对象</span></span><br><span class="line"><span class="comment">* 链表中第二个对象,返回当前空闲对象中第一个对象(因为本次</span></span><br><span class="line"><span class="comment">* __alloc_slab会直接分配一个对象).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">load_freelist:</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(this_cpu_ptr(&amp;s-&gt;cpu_slab-&gt;lock));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * freelist is pointing to the list of objects to be used.</span></span><br><span class="line"><span class="comment">	 * slab is pointing to the slab from which the objects are obtained.</span></span><br><span class="line"><span class="comment">	 * That slab must be frozen for per cpu allocations to work.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	VM_BUG_ON(!c-&gt;slab-&gt;frozen);</span><br><span class="line">	c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line">	c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">	local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">return</span> freelist;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 将kmem_cache_cpu-&gt;slab-&gt;freelist合并连接到</span></span><br><span class="line"><span class="comment">* kmem_cache_cpu-&gt;freelist之后,解冻并根据合并后</span></span><br><span class="line"><span class="comment">* slab情况放入对应的kmem_cache_node的partial/full</span></span><br><span class="line"><span class="comment">* 链表中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">deactivate_slab:</span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (slab != c-&gt;slab) {</span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">goto</span> reread_slab;</span><br><span class="line">	}</span><br><span class="line">	freelist = c-&gt;freelist;</span><br><span class="line">	c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">	c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">	c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">	local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	deactivate_slab(s, slab, freelist);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 尝试从kmem_cache_cpu-&gt;partial中获取slab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">new_slab:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slub_percpu_partial(c)) {</span><br><span class="line">		local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(c-&gt;slab)) {</span><br><span class="line">			local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">			<span class="keyword">goto</span> reread_slab;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!slub_percpu_partial(c))) {</span><br><span class="line">			local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">			<span class="comment">/* we were preempted and partial list got empty */</span></span><br><span class="line">			<span class="keyword">goto</span> new_objects;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		slab = c-&gt;slab = slub_percpu_partial(c);</span><br><span class="line">		slub_set_percpu_partial(c, slab); <span class="comment">//更新partial链表</span></span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">		stat(s, CPU_PARTIAL_ALLOC);</span><br><span class="line">		<span class="keyword">goto</span> redo;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 尝试从kmem_cache_node-&gt;partial中获取slab.</span></span><br><span class="line"><span class="comment">* 若失败则调用new_slab向budy system申请新的slab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">new_objects:</span><br><span class="line"></span><br><span class="line">	pc.flags = gfpflags;</span><br><span class="line">	pc.slab = &amp;slab;</span><br><span class="line">	pc.orig_size = orig_size;</span><br><span class="line">	freelist = get_partial(s, node, &amp;pc);</span><br><span class="line">	<span class="keyword">if</span> (freelist)</span><br><span class="line">		<span class="keyword">goto</span> check_new_slab;</span><br><span class="line"></span><br><span class="line">	slub_put_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	slab = new_slab(s, gfpflags, node);</span><br><span class="line">	c = slub_get_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!slab)) {</span><br><span class="line">		slab_out_of_memory(s, gfpflags, node);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	stat(s, ALLOC_SLAB);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kmem_cache_debug(s)) {</span><br><span class="line">		freelist = alloc_single_from_new_slab(s, slab, orig_size);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!freelist))</span><br><span class="line">			<span class="keyword">goto</span> new_objects;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line">			set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> freelist;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * No other reference to the slab yet so we can</span></span><br><span class="line"><span class="comment">	 * muck around with it freely without cmpxchg</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	freelist = slab-&gt;freelist;</span><br><span class="line">	slab-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">	slab-&gt;inuse = slab-&gt;objects;</span><br><span class="line">	slab-&gt;frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新kmem_cache_node-&gt;nr_slabs,total_objects</span></span><br><span class="line">	inc_slabs_node(s, slab_nid(slab), slab-&gt;objects);</span><br><span class="line"></span><br><span class="line">check_new_slab:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kmem_cache_debug(s)) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For debug caches here we had to go through</span></span><br><span class="line"><span class="comment">		 * alloc_single_from_partial() so just store the tracking info</span></span><br><span class="line"><span class="comment">		 * and return the object</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (s-&gt;flags &amp; SLAB_STORE_USER)</span><br><span class="line">			set_track(s, freelist, TRACK_ALLOC, addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> freelist;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pfmemalloc_match(slab, gfpflags))) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For !pfmemalloc_match() case we don't load freelist so that</span></span><br><span class="line"><span class="comment">		 * we don't make further mismatched allocations easier.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		deactivate_slab(s, slab, get_freepointer(s, freelist));</span><br><span class="line">		<span class="keyword">return</span> freelist;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 再次尝试装载slab,如果kmem_cache_cpu上已经有</span></span><br><span class="line"><span class="comment">* slab了(并发问题),进行deactivate直到成功装载</span></span><br><span class="line"><span class="comment">* 新的slab</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">retry_load_slab:</span><br><span class="line"></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(c-&gt;slab)) {</span><br><span class="line">		<span class="type">void</span> *flush_freelist = c-&gt;freelist;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">flush_slab</span> =</span> c-&gt;slab;</span><br><span class="line"></span><br><span class="line">		c-&gt;slab = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">		c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">		local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">		deactivate_slab(s, flush_slab, flush_freelist);</span><br><span class="line"></span><br><span class="line">		stat(s, CPUSLAB_FLUSH);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> retry_load_slab;</span><br><span class="line">	}</span><br><span class="line">	c-&gt;slab = slab;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">goto</span> load_freelist;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="slab-free"><a href="#slab-free" class="headerlink" title="slab_free"></a>slab_free</h3><p>slab中释放内存最终都会调用到slab_free函数.<br>slab_free处理中的判断分支有点复杂,画图不好表示,还是看下面的分析吧.<br>简单概括一下:</p>
<ol>
<li>将对象加入到对应slab的freelist中.</li>
<li>加入到kmem_cache_cpu-&gt;partial 或 回退到kmem_cache_node处理,更新kmem_cache_node的full和partial链表.</li>
</ol>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401292112574.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202401292112387.png"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __fastpath_inline <span class="type">void</span> <span class="title function_">slab_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab,</span></span><br><span class="line"><span class="params">				      <span class="type">void</span> *head, <span class="type">void</span> *tail, <span class="type">void</span> **p, <span class="type">int</span> cnt,</span></span><br><span class="line"><span class="params">				      <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">{</span><br><span class="line">	memcg_slab_free_hook(s, slab, p, cnt);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * With KASAN enabled slab_free_freelist_hook modifies the freelist</span></span><br><span class="line"><span class="comment">	 * to remove objects, whose reuse must be delayed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (slab_free_freelist_hook(s, &amp;head, &amp;tail, &amp;cnt))</span><br><span class="line">		do_slab_free(s, slab, head, tail, cnt, addr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>与分配相同,释放同样有FASTPATH和SLOWPATH.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 仅当我们正在释放到kmem_cache_cpu-&gt;slab时才可能使用FASTPATH.</span></span><br><span class="line"><span class="comment"> * 这通常是当我们才刚刚分配这个对象时.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果不能通过FASTPATH,则回退到__slab_free来进行各种特殊处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通过指示头尾指针以及对象数量,可以批量释放一个空闲链表中的多个</span></span><br><span class="line"><span class="comment"> * 对象(指向同一slab). 通过设置尾指针来指示批量释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">do_slab_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> slab *slab, <span class="type">void</span> *head, <span class="type">void</span> *tail,</span></span><br><span class="line"><span class="params">				<span class="type">int</span> cnt, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">void</span> *tail_obj = tail ? : head;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line">	<span class="type">void</span> **freelist;</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine the currently cpus per cpu slab.</span></span><br><span class="line"><span class="comment">	 * The cpu may change afterward. However that does not matter since</span></span><br><span class="line"><span class="comment">	 * data is retrieved via this pointer. If we are on the same cpu</span></span><br><span class="line"><span class="comment">	 * during the cmpxchg then the free will succeed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">	tid = READ_ONCE(c-&gt;tid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Same with comment on barrier() in slab_alloc_node() */</span></span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否释放到当前cpu的slab,若不是进入SLOWPATH</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) {</span><br><span class="line">		__slab_free(s, slab, head, tail_obj, cnt, addr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FASTPATH,直接将原freelist连到tail之后</span></span><br><span class="line">    <span class="comment">//设置新的freelist为head.下面对应有锁无锁两种处理.</span></span><br><span class="line">	<span class="keyword">if</span> (USE_LOCKLESS_FAST_PATH()) {</span><br><span class="line">		freelist = READ_ONCE(c-&gt;freelist);</span><br><span class="line"></span><br><span class="line">		set_freepointer(s, tail_obj, freelist);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!__update_cpu_freelist_fast(s, freelist, head, tid))) {</span><br><span class="line">			note_cmpxchg_failure(<span class="string">"slab_free"</span>, s, tid);</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		}</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="comment">/* Update the free list under the local lock */</span></span><br><span class="line">		local_lock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">		c = this_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(slab != c-&gt;slab)) {</span><br><span class="line">			local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">			<span class="keyword">goto</span> redo;</span><br><span class="line">		}</span><br><span class="line">		tid = c-&gt;tid;</span><br><span class="line">		freelist = c-&gt;freelist;</span><br><span class="line"></span><br><span class="line">		set_freepointer(s, tail_obj, freelist);</span><br><span class="line">		c-&gt;freelist = head;</span><br><span class="line">		c-&gt;tid = next_tid(tid);</span><br><span class="line"></span><br><span class="line">		local_unlock(&amp;s-&gt;cpu_slab-&gt;lock);</span><br><span class="line">	}</span><br><span class="line">	stat(s, FREE_FASTPATH);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SLOW PATH处理.这条路径仍然经常被调用,因为</span></span><br><span class="line"><span class="comment"> * 在大多数处理中对象比cpu slab有更长的生命周期</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所以我们仍然尽力减少缓存行的使用.只是持有slab lock并释放对象.</span></span><br><span class="line"><span class="comment"> * 如果这里没有额外的partial slab处理需求,我们可以立即返回.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __slab_free(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab,</span><br><span class="line">			<span class="type">void</span> *head, <span class="type">void</span> *tail, <span class="type">int</span> cnt,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> addr)</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">	<span class="type">void</span> *prior;</span><br><span class="line">	<span class="type">int</span> was_frozen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	stat(s, FREE_SLOWPATH);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kfence_free(head))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SLUB_TINY) || kmem_cache_debug(s)) {</span><br><span class="line">		free_to_partial_list(s, slab, head, tail, cnt, addr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> {</span><br><span class="line">		<span class="keyword">if</span> (unlikely(n)) {</span><br><span class="line">			spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">			n = <span class="literal">NULL</span>;</span><br><span class="line">		}</span><br><span class="line">		prior = slab-&gt;freelist;</span><br><span class="line">		counters = slab-&gt;counters;</span><br><span class="line">		set_freepointer(s, tail, prior);</span><br><span class="line">		new.counters = counters;</span><br><span class="line">		was_frozen = new.frozen;</span><br><span class="line">		new.inuse -= cnt;</span><br><span class="line">		<span class="keyword">if</span> ((!new.inuse || !prior) &amp;&amp; !was_frozen) {</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) {</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Slab was on no list before and will be</span></span><br><span class="line"><span class="comment">				 * partially empty</span></span><br><span class="line"><span class="comment">				 * We can defer the list move and instead</span></span><br><span class="line"><span class="comment">				 * freeze it.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="comment">//原slab为full list且未冻结并且</span></span><br><span class="line">				<span class="comment">//将要成为部分空闲</span></span><br><span class="line">				<span class="comment">//我们可以推迟链表移动而是将其冻结</span></span><br><span class="line">				new.frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			} <span class="keyword">else</span> { <span class="comment">/* Needs to be taken off a list */</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			* 需要回退到kmem_cache_node进行处理.条件为:</span></span><br><span class="line"><span class="comment">			* 1. 释放前slab未被冻结.(!was_frozen)</span></span><br><span class="line"><span class="comment">			* 2. (释放后slab完全空闲) || (!(释放前该slab已满&amp;&amp;CONFIG_SLUB_CPU_PARTIAL))</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">				n = get_node(s, slab_nid(slab));</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Speculatively acquire the list_lock.</span></span><br><span class="line"><span class="comment">				 * If the cmpxchg does not succeed then we may</span></span><br><span class="line"><span class="comment">				 * drop the list_lock without any processing.</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 * Otherwise the list_lock will synchronize with</span></span><br><span class="line"><span class="comment">				 * other processors updating the list of slabs.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	} <span class="keyword">while</span> (!slab_update_freelist(s, slab,</span><br><span class="line">		prior, counters,</span><br><span class="line">		head, new.counters,</span><br><span class="line">		<span class="string">"__slab_free"</span>));</span><br><span class="line">	<span class="comment">//至此freelist更新完毕,由于slab的状态可能发生改变,接下来</span></span><br><span class="line">	<span class="comment">//是对slab的移动.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(!n)) {</span><br><span class="line">		<span class="comment">//不需要回退到kmem_cache_node进行处理</span></span><br><span class="line">		<span class="keyword">if</span> (likely(was_frozen)) {</span><br><span class="line">			<span class="comment">//释放前slab为冻结状态,不做处理</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The list lock was not taken therefore no list</span></span><br><span class="line"><span class="comment">			 * activity can be necessary.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			stat(s, FREE_FROZEN);</span><br><span class="line">		} <span class="keyword">else</span> <span class="keyword">if</span> (new.frozen) {</span><br><span class="line">			<span class="comment">//释放后slab已被冻结,加入到当前kmem_cache_cpu-&gt;partial</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we just froze the slab then put it onto the</span></span><br><span class="line"><span class="comment">			 * per cpu partial list.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			put_cpu_partial(s, slab, <span class="number">1</span>);</span><br><span class="line">			stat(s, CPU_PARTIAL_FREE);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))</span><br><span class="line">		<span class="keyword">goto</span> slab_empty;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Objects left in the slab. If it was not on the partial list before</span></span><br><span class="line"><span class="comment">	 * then add it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) {</span><br><span class="line">		<span class="comment">//如果原slab是满的,且释放后不是完全空闲,则从full转移到partial</span></span><br><span class="line">		remove_full(s, n, slab);</span><br><span class="line">		add_partial(n, slab, DEACTIVATE_TO_TAIL);</span><br><span class="line">		stat(s, FREE_ADD_PARTIAL);</span><br><span class="line">	}</span><br><span class="line">	spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">slab_empty:</span><br><span class="line">	<span class="comment">//slab完全空闲且n-&gt;nr_partial大于等于下限min_partial,先移除再销毁</span></span><br><span class="line">	<span class="keyword">if</span> (prior) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Slab on the partial list.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		remove_partial(n, slab);</span><br><span class="line">		stat(s, FREE_REMOVE_PARTIAL);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="comment">/* Slab must be on the full list */</span></span><br><span class="line">		remove_full(s, n, slab);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">	stat(s, FREE_SLAB);</span><br><span class="line">	discard_slab(s, slab);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将刚刚冻结的slab移动到keme_cache_cpu-&gt;partial中</span></span><br><span class="line"><span class="comment"> * 若已满则将旧的partial链表(old_slab)解冻并放到kmem_cache_node</span></span><br><span class="line"><span class="comment"> * 中或销毁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_cpu_partial</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab, <span class="type">int</span> drain)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">oldslab</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab_to_unfreeze</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">int</span> slabs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	local_lock_irqsave(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	oldslab = this_cpu_read(s-&gt;cpu_slab-&gt;partial);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (oldslab) {</span><br><span class="line">		<span class="keyword">if</span> (drain &amp;&amp; oldslab-&gt;slabs &gt;= s-&gt;cpu_partial_slabs) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Partial array is full. Move the existing set to the</span></span><br><span class="line"><span class="comment">			 * per node partial list. Postpone the actual unfreezing</span></span><br><span class="line"><span class="comment">			 * outside of the critical section.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">//如果kmem_cache_node中slabs已经超过cpu_partial_slabs,</span></span><br><span class="line">			<span class="comment">//则使用slab替换old_slab,解冻old_slab并移动到</span></span><br><span class="line">			<span class="comment">//kmem_cache_node-&gt;partial.注意这里的slab_to_unfreeze</span></span><br><span class="line">			<span class="comment">//是一个链表</span></span><br><span class="line">			slab_to_unfreeze = oldslab;</span><br><span class="line">			oldslab = <span class="literal">NULL</span>;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			slabs = oldslab-&gt;slabs;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	slabs++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//slab插入到oldslab之前(这里oldslab可能为空)</span></span><br><span class="line">	slab-&gt;slabs = slabs;</span><br><span class="line">	slab-&gt;next = oldslab;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//slab移动到kmem_cache_cpu-&gt;partial中</span></span><br><span class="line">	this_cpu_write(s-&gt;cpu_slab-&gt;partial, slab);</span><br><span class="line"></span><br><span class="line">	local_unlock_irqrestore(&amp;s-&gt;cpu_slab-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slab_to_unfreeze) {</span><br><span class="line">	<span class="comment">//解冻slab_to_unfreeze并移动到</span></span><br><span class="line">	<span class="comment">//kmem_cache_node-&gt;partial或销毁.</span></span><br><span class="line">	<span class="comment">//注意这里的slab_to_unfreeze是一个链表</span></span><br><span class="line">		__unfreeze_partials(s, slab_to_unfreeze);</span><br><span class="line">		stat(s, CPU_PARTIAL_DRAIN);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解冻partial_slab并移动到</span></span><br><span class="line"><span class="comment">//kmem_cache_node-&gt;partial或销毁.</span></span><br><span class="line"><span class="comment">//注意这里的partial_slab是一个链表</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __unfreeze_partials(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *partial_slab)</span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> <span class="literal">NULL</span>, *n2 = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>, *<span class="title">slab_to_discard</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (partial_slab) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">new</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> <span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line">		slab = partial_slab;</span><br><span class="line">		partial_slab = slab-&gt;next;</span><br><span class="line"></span><br><span class="line">		n2 = get_node(s, slab_nid(slab));</span><br><span class="line">		<span class="keyword">if</span> (n != n2) {</span><br><span class="line">			<span class="keyword">if</span> (n)</span><br><span class="line">				spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line">			n = n2;</span><br><span class="line">			spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span> {</span><br><span class="line"></span><br><span class="line">			old.freelist = slab-&gt;freelist;</span><br><span class="line">			old.counters = slab-&gt;counters;</span><br><span class="line">			VM_BUG_ON(!old.frozen);</span><br><span class="line"></span><br><span class="line">			new.counters = old.counters;</span><br><span class="line">			new.freelist = old.freelist;</span><br><span class="line"></span><br><span class="line">			new.frozen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		} <span class="keyword">while</span> (!__slab_update_freelist(s, slab,</span><br><span class="line">				old.freelist, old.counters,</span><br><span class="line">				new.freelist, new.counters,</span><br><span class="line">				<span class="string">"unfreezing slab"</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial)) {</span><br><span class="line">			<span class="comment">//如果该slab完全空闲且当前节点的nr_partial超过了下限min_partial</span></span><br><span class="line">			<span class="comment">//则销毁该slab</span></span><br><span class="line">			slab-&gt;next = slab_to_discard;</span><br><span class="line">			slab_to_discard = slab;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="comment">//否则加入到kmem_cache_node-&gt;partial中.</span></span><br><span class="line">			<span class="comment">//注意这里的标志DEACTIVATE_TO_TAIL,即插入到末尾</span></span><br><span class="line">			add_partial(n, slab, DEACTIVATE_TO_TAIL);</span><br><span class="line">			stat(s, FREE_ADD_PARTIAL);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n)</span><br><span class="line">		spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (slab_to_discard) {</span><br><span class="line">		slab = slab_to_discard;</span><br><span class="line">		slab_to_discard = slab_to_discard-&gt;next;</span><br><span class="line"></span><br><span class="line">		stat(s, DEACTIVATE_EMPTY);</span><br><span class="line">		discard_slab(s, slab);</span><br><span class="line">		stat(s, FREE_SLAB);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>释放回底层buddy system,没啥好分析的.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">discard_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> slab *slab)</span></span><br><span class="line">{</span><br><span class="line">	dec_slabs_node(s, slab_nid(slab), slab-&gt;objects);</span><br><span class="line">	free_slab(s, slab);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://jamorant12138.github.io/2024/Slub-Allocator%20Analysis/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SLUB/" rel="tag">SLUB</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/CVE-2018-10387%20TFTP%20Server-HeapOverflow/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            CVE-2018-10387 TFTP Server 堆溢出
          
        </div>
      </a>
    
    
      <a href="/2024/CVE-2018-1160%20Netatalk-OOB/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">CVE-2018-1160 Netatalk 越界写入</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2024
        <i class="ri-heart-fill heart_icon"></i> 翰青HanQi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="北极落小雪"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/About">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>