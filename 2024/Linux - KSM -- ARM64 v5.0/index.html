<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
        
      <meta name="description" content="Boom? PWN ! ! !" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Linux内核 KSM机制 -- ARM64 v5.0 |  北极落小雪</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
  </html>
</html>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Linux - KSM -- ARM64 v5.0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Linux内核 KSM机制 -- ARM64 v5.0
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/Linux%20-%20KSM%20--%20ARM64%20v5.0/" class="article-date">
  <time datetime="2024-10-31T16:00:00.000Z" itemprop="datePublished">2024-11-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux%E5%86%85%E6%A0%B8/">Linux内核</a> / <a class="article-category-link" href="/categories/Linux%E5%86%85%E6%A0%B8/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">8.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">42 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>(<del>看源码看得最难受的一集</del>)</p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ul>
<li>KSM机制的流程?</li>
<li>如何理解KSM机制中的数据结构?</li>
</ul>
<h2 id="KSM概述"><a href="#KSM概述" class="headerlink" title="KSM概述"></a>KSM概述</h2><blockquote>
<p>KSM指Kernel SamePage Merging，即内核同页合并，用于合<br>并内容相同的页面。KSM的出现是为了优化虚拟化中产生的冗余页面，<br>因为虚拟化的实际应用中在同一台主机上会有许多相同的操作系统和<br>应用程序，许多内存页面的内容可能是相同的，所以它们可以合并，<br>从而释放内存供其他应用程序使用。</p>
<p>KSM允许合并同一个进程或不同进程之间内容相同的匿名页面，这<br>对应用程序来说是不可见的。把这些相同的页面合并成一个只读的页<br>面，从而释放出多余的物理页面，当应用程序需要改变页面内容时，<br>会发生写时复制。</p>
</blockquote>
<span id="more"></span>

<p>KSM的流程其实并不复杂, 但编码中大量复用的数据结构, 没有注释的术语, 多种功能糅杂的函数, 使得源码分析比较困难. 源码分析部分推荐先看整体流程, 然后每调用一个子函数, 先去后文看看子函数做了什么.</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>KSM系统维护一个稳定节点树和一个不稳定节点树.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20241103165238.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20241103165209.png"></p>
<p>不稳定节点树节点元素的数据结构是struct rmap_item. 它将一个普通节点对应的page反向映射到一个虚拟地址.  </p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct rmap_item - reverse mapping item for virtual addresses</span></span><br><span class="line"><span class="comment"> * @rmap_list: next rmap_item in mm_slot's singly-linked rmap_list</span></span><br><span class="line"><span class="comment"> * @anon_vma: pointer to anon_vma for this mm,address, when in stable tree</span></span><br><span class="line"><span class="comment"> * @nid: NUMA node id of unstable tree in which linked (may not match page)</span></span><br><span class="line"><span class="comment"> * @mm: the memory structure this rmap_item is pointing into</span></span><br><span class="line"><span class="comment"> * @address: the virtual address this rmap_item tracks (+ flags in low bits)</span></span><br><span class="line"><span class="comment"> * @oldchecksum: previous checksum of the page at that virtual address</span></span><br><span class="line"><span class="comment"> * @node: rb node of this rmap_item in the unstable tree</span></span><br><span class="line"><span class="comment"> * @head: pointer to stable_node heading this list in the stable tree</span></span><br><span class="line"><span class="comment"> * @hlist: link into hlist of rmap_items hanging off that stable_node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rmap_item</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rmap_item</span> *<span class="title">rmap_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>	<span class="comment">/* when stable */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">		<span class="type">int</span> nid;		<span class="comment">/* when node of unstable tree */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	};</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> address;		<span class="comment">/* + low bits used for flags below */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> oldchecksum;	<span class="comment">/* when unstable */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">node</span>;</span>	<span class="comment">/* when node of unstable tree */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> {</span>		<span class="comment">/* when listed from stable tree */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">stable_node</span> *<span class="title">head</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist</span>;</span></span><br><span class="line">		};</span><br><span class="line">	};</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>稳定节点树的节点元素是struct stable_node, 但它有三种形态. 一种是普通节点, 一种是链式节点的头节点, 一种是链式节点的链表元素.<br>虽然有三种形态, 但只有前两种会真正挂载到稳定节点树上. 第三种实质是挂载位置不同的普通节点.<br>变量名stable_node指挂载到稳定节点树上的节点, 可能是一,二形态.<br>变量名stable_node_dup指存放rmap_item的节点, 可能是一, 三形态.</p>
<p>作为普通节点和链式节点的头节点时结构均如下图, 但字段意义不同. </p>
<ul>
<li>普通节点: hlist为使用该节点对应的ksm页面的rmap_item的链表, rmap_hlist_len为对应的rmap_item链表长度, 该长度上限为ksm_max_page_sharing(默认256,<del>但似乎可以超出这个上限</del>).</li>
<li>链式节点头节点: hlist为该链式节点管理的节点链表的链表头. rmap_hlist_len标识该节点为链式节点头结点, 值为STABLE_NODE_CHAIN<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stable_node</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">node</span>;</span></span><br><span class="line">    </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">hlist</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> kpfn;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> chain_prune_time;</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> rmap_hlist_len;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="type">int</span> nid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>作为链式节点链表元素时, hlist_dup维护这一节点链表, 为使用该节点对应的ksm页面的rmap_item的链表, rmap_hlist_len为rmap_item链表长度.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stable_node</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">head</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hlist_dup</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">        };</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">hlist</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> kpfn;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> chain_prune_time;</span><br><span class="line">	};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STABLE_NODE_CHAIN -1024</span></span><br><span class="line">	<span class="type">int</span> rmap_hlist_len;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="type">int</span> nid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>由于稳定节点树上的一个普通节点(包括之前提到的一,三形态)对应一个kpage, 在下方笔者会有类似”将page合并到某节点”的表述.<br>以及表述”组成链式节点”有两种情况, 形成一个新的链式节点或将其中一个节点插入到另一个原有链式节点的链表中.</p>
<h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><p>ksmd内核线程扫描加入到KSM系统的页面page(加入到KSM系统是一个比较抽象的说法), 调用<code>cmp_and_merge_page</code>进行相同页面合并.</p>
<ul>
<li>先调用<code>stable_tree_search</code>, 查找稳定节点树中是否有能与page合并的节点, 以及对应的kpage. <ul>
<li>如果有, 则调用 <code>try_to_merge_with_ksm_page</code>进行合并. 合并完成后, 调用<code>stable_tree_append</code>将page对应的rmap_item加入到kpage对应节点中.</li>
<li>如果没有, 计算该page的checksum, 如果和上次保存在rmap_item-&gt;oldchecksum中的值不同, 那么说明该page的内容可能是频繁变化的, 没有必要进行合并.直接返回.</li>
<li>如果该page的checksum == zero_checksum, 则调用<code>try_to_merge_one_page</code>将其与系统零页合并后返回.</li>
<li>稳定节点树中没有, 那就调用<code>unstable_tree_search_insert</code>在不稳定节点树中搜索能合并到的tree_page. <ul>
<li>如果找到了, 调用<code>try_to_merge_two_pages</code>进行合并, 合并后的kpage再调用<code>stable_tree_insert</code>插入到稳定节点树中. 然后调用<code>stable_tree_append</code>把合并前的tree_rmap_item, rmap_item加入到稳定节点树上新产生的对应节点中.</li>
<li>如果没找到, 把rmap_item插入不稳定节点树中.</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cmp_and_merge_page - first see if page can be merged into the stable tree;</span></span><br><span class="line"><span class="comment"> * if not, compare checksum to previous and if it's the same, see if page can</span></span><br><span class="line"><span class="comment"> * be inserted into the unstable tree, or merged with a page already there and</span></span><br><span class="line"><span class="comment"> * both transferred to the stable tree.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @page: the page that we are searching identical page to.</span></span><br><span class="line"><span class="comment"> * @rmap_item: the reverse mapping into the virtual address of this page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cmp_and_merge_page</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="keyword">struct</span> rmap_item *rmap_item)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> rmap_item-&gt;mm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rmap_item</span> *<span class="title">tree_rmap_item</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tree_page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stable_node</span> *<span class="title">stable_node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">kpage</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> checksum;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">bool</span> max_page_sharing_bypass = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	stable_node = page_stable_node(page);</span><br><span class="line">	<span class="keyword">if</span> (stable_node) {</span><br><span class="line">		<span class="keyword">if</span> (stable_node-&gt;head != &amp;migrate_nodes &amp;&amp;</span><br><span class="line">		    get_kpfn_nid(READ_ONCE(stable_node-&gt;kpfn)) !=</span><br><span class="line">		    NUMA(stable_node-&gt;nid)) {</span><br><span class="line">			stable_node_dup_del(stable_node);</span><br><span class="line">			stable_node-&gt;head = &amp;migrate_nodes;</span><br><span class="line">			list_add(&amp;stable_node-&gt;<span class="built_in">list</span>, stable_node-&gt;head);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (stable_node-&gt;head != &amp;migrate_nodes &amp;&amp;</span><br><span class="line">		    rmap_item-&gt;head == stable_node)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If it's a KSM fork, allow it to go over the sharing limit</span></span><br><span class="line"><span class="comment">		 * without warnings.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!is_page_sharing_candidate(stable_node))</span><br><span class="line">			max_page_sharing_bypass = <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We first start with searching the page inside the stable tree */</span></span><br><span class="line">	kpage = stable_tree_search(page);</span><br><span class="line">	<span class="keyword">if</span> (kpage == page &amp;&amp; rmap_item-&gt;head == stable_node) {</span><br><span class="line">		put_page(kpage);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	remove_rmap_item_from_tree(rmap_item);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (kpage) {</span><br><span class="line">		err = try_to_merge_with_ksm_page(rmap_item, page, kpage);</span><br><span class="line">		<span class="keyword">if</span> (!err) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The page was successfully merged:</span></span><br><span class="line"><span class="comment">			 * add its rmap_item to the stable tree.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			lock_page(kpage);</span><br><span class="line">			stable_tree_append(rmap_item, page_stable_node(kpage),</span><br><span class="line">					   max_page_sharing_bypass);</span><br><span class="line">			unlock_page(kpage);</span><br><span class="line">		}</span><br><span class="line">		put_page(kpage);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If the hash value of the page has changed from the last time</span></span><br><span class="line"><span class="comment">	 * we calculated it, this page is changing frequently: therefore we</span></span><br><span class="line"><span class="comment">	 * don't want to insert it in the unstable tree, and we don't want</span></span><br><span class="line"><span class="comment">	 * to waste our time searching for something identical to it there.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	checksum = calc_checksum(page);</span><br><span class="line">	<span class="keyword">if</span> (rmap_item-&gt;oldchecksum != checksum) {</span><br><span class="line">		rmap_item-&gt;oldchecksum = checksum;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Same checksum as an empty page. We attempt to merge it with the</span></span><br><span class="line"><span class="comment">	 * appropriate zero page if the user enabled this via sysfs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ksm_use_zero_pages &amp;&amp; (checksum == zero_checksum)) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line"></span><br><span class="line">		down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		vma = find_mergeable_vma(mm, rmap_item-&gt;address);</span><br><span class="line">		err = try_to_merge_one_page(vma, page,</span><br><span class="line">					    ZERO_PAGE(rmap_item-&gt;address));</span><br><span class="line">		up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * In case of failure, the page was not really empty, so we</span></span><br><span class="line"><span class="comment">		 * need to continue. Otherwise we're done.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!err)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	tree_rmap_item =</span><br><span class="line">		unstable_tree_search_insert(rmap_item, page, &amp;tree_page);</span><br><span class="line">	<span class="keyword">if</span> (tree_rmap_item) {</span><br><span class="line">		<span class="type">bool</span> split;</span><br><span class="line"></span><br><span class="line">		kpage = try_to_merge_two_pages(rmap_item, page,</span><br><span class="line">						tree_rmap_item, tree_page);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If both pages we tried to merge belong to the same compound</span></span><br><span class="line"><span class="comment">		 * page, then we actually ended up increasing the reference</span></span><br><span class="line"><span class="comment">		 * count of the same compound page twice, and split_huge_page</span></span><br><span class="line"><span class="comment">		 * failed.</span></span><br><span class="line"><span class="comment">		 * Here we set a flag if that happened, and we use it later to</span></span><br><span class="line"><span class="comment">		 * try split_huge_page again. Since we call put_page right</span></span><br><span class="line"><span class="comment">		 * afterwards, the reference count will be correct and</span></span><br><span class="line"><span class="comment">		 * split_huge_page should succeed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		split = PageTransCompound(page)</span><br><span class="line">			&amp;&amp; compound_head(page) == compound_head(tree_page);</span><br><span class="line">		put_page(tree_page);</span><br><span class="line">		<span class="keyword">if</span> (kpage) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The pages were successfully merged: insert new</span></span><br><span class="line"><span class="comment">			 * node in the stable tree and add both rmap_items.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			lock_page(kpage);</span><br><span class="line">			stable_node = stable_tree_insert(kpage);</span><br><span class="line">			<span class="keyword">if</span> (stable_node) {</span><br><span class="line">				stable_tree_append(tree_rmap_item, stable_node,</span><br><span class="line">						   <span class="literal">false</span>);</span><br><span class="line">				stable_tree_append(rmap_item, stable_node,</span><br><span class="line">						   <span class="literal">false</span>);</span><br><span class="line">			}</span><br><span class="line">			unlock_page(kpage);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we fail to insert the page into the stable tree,</span></span><br><span class="line"><span class="comment">			 * we will have 2 virtual addresses that are pointing</span></span><br><span class="line"><span class="comment">			 * to a ksm page left outside the stable tree,</span></span><br><span class="line"><span class="comment">			 * in which case we need to break_cow on both.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!stable_node) {</span><br><span class="line">				break_cow(tree_rmap_item);</span><br><span class="line">				break_cow(rmap_item);</span><br><span class="line">			}</span><br><span class="line">		} <span class="keyword">else</span> <span class="keyword">if</span> (split) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We are here if we tried to merge two pages and</span></span><br><span class="line"><span class="comment">			 * failed because they both belonged to the same</span></span><br><span class="line"><span class="comment">			 * compound page. We will split the page now, but no</span></span><br><span class="line"><span class="comment">			 * merging will take place.</span></span><br><span class="line"><span class="comment">			 * We do not want to add the cost of a full lock; if</span></span><br><span class="line"><span class="comment">			 * the page is locked, it is better to skip it and</span></span><br><span class="line"><span class="comment">			 * perhaps try again later.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!trylock_page(page))</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			split_huge_page(page);</span><br><span class="line">			unlock_page(page);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="KSM系统初始化"><a href="#KSM系统初始化" class="headerlink" title="KSM系统初始化"></a>KSM系统初始化</h3><p>ksm_init完成初始化.</p>
<ul>
<li>计算系统零页的checksum.</li>
<li>创建rmap_item, stable_node, mmslot对应的kmem_cache.</li>
<li>创建内核线程ksmd.</li>
<li>创建sysfs的属性组.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ksm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">ksm_thread</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The correct value depends on page size and endianness */</span></span><br><span class="line">	zero_checksum = calc_checksum(ZERO_PAGE(<span class="number">0</span>));</span><br><span class="line">	<span class="comment">/* Default to false for backwards compatibility */</span></span><br><span class="line">	ksm_use_zero_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	err = ksm_slab_init();</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	ksm_thread = kthread_run(ksm_scan_thread, <span class="literal">NULL</span>, <span class="string">"ksmd"</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ksm_thread)) {</span><br><span class="line">		pr_err(<span class="string">"ksm: creating kthread failed\n"</span>);</span><br><span class="line">		err = PTR_ERR(ksm_thread);</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	err = sysfs_create_group(mm_kobj, &amp;ksm_attr_group);</span><br><span class="line">	<span class="keyword">if</span> (err) {</span><br><span class="line">		pr_err(<span class="string">"ksm: register sysfs failed\n"</span>);</span><br><span class="line">		kthread_stop(ksm_thread);</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line">	}</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	ksm_run = KSM_RUN_MERGE;	<span class="comment">/* no way for user to start it */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SYSFS */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTREMOVE</span></span><br><span class="line">	<span class="comment">/* There is no significance to this priority 100 */</span></span><br><span class="line">	hotplug_memory_notifier(ksm_memory_callback, <span class="number">100</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_free:</span><br><span class="line">	ksm_slab_free();</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">}</span><br><span class="line">subsys_initcall(ksm_init);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="madvise-添加mm-vma到KSM系统"><a href="#madvise-添加mm-vma到KSM系统" class="headerlink" title="madvise 添加mm, vma到KSM系统"></a>madvise 添加mm, vma到KSM系统</h3><p>通过在madvise系统调用中指定MADV_MERGEABLE/MADV_UNMERGEABLE在KSM系统中添加/移除内存区域.</p>
<ul>
<li><p>如果是MADV_MERGEABLE</p>
<ul>
<li>如果vma是DAX(direct access), VM_SAO(Strong Access Ordering (powerpc)), VM_SPARC_ADI(Uses ADI tag for access control), 直接返回.</li>
<li>如果该mm_struct没被添加到KSM系统中, 调用__ksm_enter.</li>
<li>将该vma标记为VM_MERGEABLE.</li>
</ul>
</li>
<li><p>如果是MADV_UNMERGEABLE</p>
<ul>
<li>如果该vma不带VM_MERGEABLE标志, 直接返回.</li>
<li>如果vma-&gt;anon_vma, 调用unmerge_ksm_pages取消合并.</li>
<li>移除vma的VM_MERGEABLE标记.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ksm_madvise</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> start,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> end, <span class="type">int</span> advice, <span class="type">unsigned</span> <span class="type">long</span> *vm_flags)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> vma-&gt;vm_mm;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (advice) {</span><br><span class="line">	<span class="keyword">case</span> MADV_MERGEABLE:</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Be somewhat over-protective for now!</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (*vm_flags &amp; (VM_MERGEABLE | VM_SHARED  | VM_MAYSHARE   |</span><br><span class="line">				 VM_PFNMAP    | VM_IO      | VM_DONTEXPAND |</span><br><span class="line">				 VM_HUGETLB | VM_MIXEDMAP))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;		<span class="comment">/* just ignore the advice */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vma_is_dax(vma))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VM_SAO</span></span><br><span class="line">		<span class="keyword">if</span> (*vm_flags &amp; VM_SAO)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VM_SPARC_ADI</span></span><br><span class="line">		<span class="keyword">if</span> (*vm_flags &amp; VM_SPARC_ADI)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!test_bit(MMF_VM_MERGEABLE, &amp;mm-&gt;flags)) {</span><br><span class="line">			err = __ksm_enter(mm);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		*vm_flags |= VM_MERGEABLE;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> MADV_UNMERGEABLE:</span><br><span class="line">		<span class="keyword">if</span> (!(*vm_flags &amp; VM_MERGEABLE))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;		<span class="comment">/* just ignore the advice */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (vma-&gt;anon_vma) {</span><br><span class="line">			err = unmerge_ksm_pages(vma, start, end);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		*vm_flags &amp;= ~VM_MERGEABLE;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>分配一个mm_slot, 设置mm_slot-&gt;mm后插入mm_slot_hash的哈希表.</p>
</li>
<li><p>根据KSM线程的状态, 将该mm_slots插入链表中的不同位置.</p>
<ul>
<li>如果当前状态是KSM_RUN_MERGE或者KSM_RUN_STOP, 插入到cursor的前面, 这样可以避免ksm在一个fork后立刻执行exec的进程里浪费时间.</li>
<li>如果当前状态是KSM_RUN_UNMERGE, 那么必须插到链表的尾部, 以确保KSM能遍历到这个新插入的mm_slot.</li>
</ul>
</li>
<li><p>给mm标记MMF_VM_MERGEABLE, 表示已经加入到KSM系统中了.</p>
</li>
<li><p>如果在本次添加之前, mm_slots链表为空, 那么需要唤醒ksmd线程.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __ksm_enter(<span class="keyword">struct</span> mm_struct *mm)</span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_slot</span> *<span class="title">mm_slot</span>;</span></span><br><span class="line">	<span class="type">int</span> needs_wakeup;</span><br><span class="line"></span><br><span class="line">	mm_slot = alloc_mm_slot();</span><br><span class="line">	<span class="keyword">if</span> (!mm_slot)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check ksm_run too?  Would need tighter locking */</span></span><br><span class="line">	needs_wakeup = list_empty(&amp;ksm_mm_head.mm_list);</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;ksm_mmlist_lock);</span><br><span class="line">	insert_to_mm_slots_hash(mm, mm_slot);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When KSM_RUN_MERGE (or KSM_RUN_STOP),</span></span><br><span class="line"><span class="comment">	 * insert just behind the scanning cursor, to let the area settle</span></span><br><span class="line"><span class="comment">	 * down a little; when fork is followed by immediate exec, we don't</span></span><br><span class="line"><span class="comment">	 * want ksmd to waste time setting up and tearing down an rmap_list.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * But when KSM_RUN_UNMERGE, it's important to insert ahead of its</span></span><br><span class="line"><span class="comment">	 * scanning cursor, otherwise KSM pages in newly forked mms will be</span></span><br><span class="line"><span class="comment">	 * missed: then we might as well insert at the end of the list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ksm_run &amp; KSM_RUN_UNMERGE)</span><br><span class="line">		list_add_tail(&amp;mm_slot-&gt;mm_list, &amp;ksm_mm_head.mm_list);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		list_add_tail(&amp;mm_slot-&gt;mm_list, &amp;ksm_scan.mm_slot-&gt;mm_list);</span><br><span class="line">	spin_unlock(&amp;ksm_mmlist_lock);</span><br><span class="line"></span><br><span class="line">	set_bit(MMF_VM_MERGEABLE, &amp;mm-&gt;flags);</span><br><span class="line">	mmgrab(mm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (needs_wakeup)</span><br><span class="line">		wake_up_interruptible(&amp;ksm_thread_wait);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h3 id="ksm辅助函数分析"><a href="#ksm辅助函数分析" class="headerlink" title="ksm辅助函数分析"></a>ksm辅助函数分析</h3><h4 id="try-to-merge-xxxxxx"><a href="#try-to-merge-xxxxxx" class="headerlink" title="try_to_merge_xxxxxx"></a>try_to_merge_xxxxxx</h4><p>try_to_merge_two_pages和try_to_merge_with_ksm_page比较像, 只是try_to_merge_with_ksm_page要求后一个页面必须是KSM页面.</p>
<p>try_to_merge_two_pages传入空的kpage调用try_to_merge_with_ksm_page尝试将page提升为ksm_page, 然后以其为kpage, 再次调用try_to_merge_with_ksm_page与tree_page进行合并.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * try_to_merge_two_pages - take two identical pages and prepare them</span></span><br><span class="line"><span class="comment"> * to be merged into one page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function returns the kpage if we successfully merged two identical</span></span><br><span class="line"><span class="comment"> * pages into one ksm page, NULL otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function upgrades page to ksm page: if one of the pages</span></span><br><span class="line"><span class="comment"> * is already a ksm page, try_to_merge_with_ksm_page should be used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">try_to_merge_two_pages</span><span class="params">(<span class="keyword">struct</span> rmap_item *rmap_item,</span></span><br><span class="line"><span class="params">					   <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">					   <span class="keyword">struct</span> rmap_item *tree_rmap_item,</span></span><br><span class="line"><span class="params">					   <span class="keyword">struct</span> page *tree_page)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = try_to_merge_with_ksm_page(rmap_item, page, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!err) {</span><br><span class="line">		err = try_to_merge_with_ksm_page(tree_rmap_item,</span><br><span class="line">							tree_page, page);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If that fails, we have a ksm page with only one pte</span></span><br><span class="line"><span class="comment">		 * pointing to it: so break it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			break_cow(rmap_item);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> err ? <span class="literal">NULL</span> : page;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>try_to_merge_with_ksm_page函数调用try_to_merge_one_page完成合并,<br>再调用remove_rmap_item_from_tree从节点树上移除rmap_item(前提是rmap_item已经在树上了).</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * try_to_merge_with_ksm_page - like try_to_merge_two_pages,</span></span><br><span class="line"><span class="comment"> * but no new kernel page is allocated: kpage must already be a ksm page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function returns 0 if the pages were merged, -EFAULT otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">try_to_merge_with_ksm_page</span><span class="params">(<span class="keyword">struct</span> rmap_item *rmap_item,</span></span><br><span class="line"><span class="params">				      <span class="keyword">struct</span> page *page, <span class="keyword">struct</span> page *kpage)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> rmap_item-&gt;mm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">	<span class="type">int</span> err = -EFAULT;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	vma = find_mergeable_vma(mm, rmap_item-&gt;address);</span><br><span class="line">	<span class="keyword">if</span> (!vma)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	err = try_to_merge_one_page(vma, page, kpage);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Unstable nid is in union with stable anon_vma: remove first */</span></span><br><span class="line">	remove_rmap_item_from_tree(rmap_item);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Must get reference to anon_vma while still holding mmap_sem */</span></span><br><span class="line">	rmap_item-&gt;anon_vma = vma-&gt;anon_vma;</span><br><span class="line">	get_anon_vma(vma-&gt;anon_vma);</span><br><span class="line">out:</span><br><span class="line">	up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>try_to_merge_one_page尝试将page合并到kpage或将page变成KSM页面.</p>
<ul>
<li>如果page == kpage, 这说明本次扫描到的page就是KSM中的kpage, 这是fork导致的. 直接返回.</li>
<li>如果page不是匿名页, 直接返回.</li>
<li>判断kpage是否为空<ul>
<li>如果为空, 意味着本次调用是为了将page变成KSM页面.<ul>
<li>把当前page设置为KSM页面(page-&gt;mapping |= PAGE_MAPPING_KSM), 但此时不指定对应的stable_node而是置空.</li>
<li>设置脏位, 防止页面回收释放该页面, 而是将它交换出去.</li>
</ul>
</li>
<li>如果不为空<ul>
<li>为page和kpage建立临时映射, 并memcmp比较内容是否相同<ul>
<li>如果相同, 调用replace_page进行合并(替换).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果原vma有VM_LOCKED标志, 将其解锁并将kpage对应的vma内存锁定.</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * try_to_merge_one_page - take two pages and merge them into one</span></span><br><span class="line"><span class="comment"> * @vma: the vma that holds the pte pointing to page</span></span><br><span class="line"><span class="comment"> * @page: the PageAnon page that we want to replace with kpage</span></span><br><span class="line"><span class="comment"> * @kpage: the PageKsm page that we want to map instead of page,</span></span><br><span class="line"><span class="comment"> *         or NULL the first time when we want to use page as kpage.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function returns 0 if the pages were merged, -EFAULT otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">try_to_merge_one_page</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">				 <span class="keyword">struct</span> page *page, <span class="keyword">struct</span> page *kpage)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">pte_t</span> orig_pte = __pte(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> err = -EFAULT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (page == kpage)			<span class="comment">/* ksm page forked */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!PageAnon(page))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need the page lock to read a stable PageSwapCache in</span></span><br><span class="line"><span class="comment">	 * write_protect_page().  We use trylock_page() instead of</span></span><br><span class="line"><span class="comment">	 * lock_page() because we don't want to wait here - we</span></span><br><span class="line"><span class="comment">	 * prefer to continue scanning and merging different pages,</span></span><br><span class="line"><span class="comment">	 * then come back to this page when it is unlocked.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!trylock_page(page))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PageTransCompound(page)) {</span><br><span class="line">		<span class="keyword">if</span> (split_huge_page(page))</span><br><span class="line">			<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If this anonymous page is mapped only here, its pte may need</span></span><br><span class="line"><span class="comment">	 * to be write-protected.  If it's mapped elsewhere, all of its</span></span><br><span class="line"><span class="comment">	 * ptes are necessarily already write-protected.  But in either</span></span><br><span class="line"><span class="comment">	 * case, we need to lock and check page_count is not raised.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (write_protect_page(vma, page, &amp;orig_pte) == <span class="number">0</span>) {</span><br><span class="line">		<span class="keyword">if</span> (!kpage) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * While we hold page lock, upgrade page from</span></span><br><span class="line"><span class="comment">			 * PageAnon+anon_vma to PageKsm+NULL stable_node:</span></span><br><span class="line"><span class="comment">			 * stable_tree_insert() will update stable_node.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			set_page_stable_node(page, <span class="literal">NULL</span>);</span><br><span class="line">			mark_page_accessed(page);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Page reclaim just frees a clean page with no dirty</span></span><br><span class="line"><span class="comment">			 * ptes: make sure that the ksm page would be swapped.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!PageDirty(page))</span><br><span class="line">				SetPageDirty(page);</span><br><span class="line">			err = <span class="number">0</span>;</span><br><span class="line">		} <span class="keyword">else</span> <span class="keyword">if</span> (pages_identical(page, kpage))</span><br><span class="line">			err = replace_page(vma, page, kpage, orig_pte);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((vma-&gt;vm_flags &amp; VM_LOCKED) &amp;&amp; kpage &amp;&amp; !err) {</span><br><span class="line">		munlock_vma_page(page);</span><br><span class="line">		<span class="keyword">if</span> (!PageMlocked(kpage)) {</span><br><span class="line">			unlock_page(page);</span><br><span class="line">			lock_page(kpage);</span><br><span class="line">			mlock_vma_page(kpage);</span><br><span class="line">			page = kpage;		<span class="comment">/* for final unlock */</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	unlock_page(page);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>replace_page函数</p>
<ul>
<li>创建PTE条目, 使得原来指向page的PTE指向新的kpage.</li>
<li>对kpage调用page_add_anon_rmap.(感觉在这里只有增加_mapcount和NR_ANON_MAPPED的作用)</li>
<li>对page调用page_remove_rmap.(感觉在这里只有减少_mapcount和NR_ANON_MAPPED的作用)</li>
<li>如果该page不再被映射了, 尝试释放对应的swap空间.</li>
<li>释放对该page的一次引用.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * replace_page - replace page in vma by new ksm page</span></span><br><span class="line"><span class="comment"> * @vma:      vma that holds the pte pointing to page</span></span><br><span class="line"><span class="comment"> * @page:     the page we are replacing by kpage</span></span><br><span class="line"><span class="comment"> * @kpage:    the ksm page we replace page by</span></span><br><span class="line"><span class="comment"> * @orig_pte: the original value of the pte</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 on success, -EFAULT on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">replace_page</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> page *kpage, <span class="type">pte_t</span> orig_pte)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> vma-&gt;vm_mm;</span><br><span class="line">	<span class="type">pmd_t</span> *pmd;</span><br><span class="line">	<span class="type">pte_t</span> *ptep;</span><br><span class="line">	<span class="type">pte_t</span> newpte;</span><br><span class="line">	<span class="type">spinlock_t</span> *ptl;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> addr;</span><br><span class="line">	<span class="type">int</span> err = -EFAULT;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier_range</span> <span class="title">range</span>;</span></span><br><span class="line"></span><br><span class="line">	addr = page_address_in_vma(page, vma);</span><br><span class="line">	<span class="keyword">if</span> (addr == -EFAULT)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	pmd = mm_find_pmd(mm, addr);</span><br><span class="line">	<span class="keyword">if</span> (!pmd)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	mmu_notifier_range_init(&amp;range, mm, addr, addr + PAGE_SIZE);</span><br><span class="line">	mmu_notifier_invalidate_range_start(&amp;range);</span><br><span class="line"></span><br><span class="line">	ptep = pte_offset_map_lock(mm, pmd, addr, &amp;ptl);</span><br><span class="line">	<span class="keyword">if</span> (!pte_same(*ptep, orig_pte)) {</span><br><span class="line">		pte_unmap_unlock(ptep, ptl);</span><br><span class="line">		<span class="keyword">goto</span> out_mn;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * No need to check ksm_use_zero_pages here: we can only have a</span></span><br><span class="line"><span class="comment">	 * zero_page here if ksm_use_zero_pages was enabled alreaady.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!is_zero_pfn(page_to_pfn(kpage))) {</span><br><span class="line">		get_page(kpage);</span><br><span class="line">		page_add_anon_rmap(kpage, vma, addr, <span class="literal">false</span>);</span><br><span class="line">		newpte = mk_pte(kpage, vma-&gt;vm_page_prot);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		newpte = pte_mkspecial(pfn_pte(page_to_pfn(kpage),</span><br><span class="line">					       vma-&gt;vm_page_prot));</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We're replacing an anonymous page with a zero page, which is</span></span><br><span class="line"><span class="comment">		 * not anonymous. We need to do proper accounting otherwise we</span></span><br><span class="line"><span class="comment">		 * will get wrong values in /proc, and a BUG message in dmesg</span></span><br><span class="line"><span class="comment">		 * when tearing down the mm.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dec_mm_counter(mm, MM_ANONPAGES);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	flush_cache_page(vma, addr, pte_pfn(*ptep));</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * No need to notify as we are replacing a read only page with another</span></span><br><span class="line"><span class="comment">	 * read only page with the same content.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * See Documentation/vm/mmu_notifier.rst</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ptep_clear_flush(vma, addr, ptep);</span><br><span class="line">	set_pte_at_notify(mm, addr, ptep, newpte);</span><br><span class="line"></span><br><span class="line">	page_remove_rmap(page, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (!page_mapped(page))</span><br><span class="line">		try_to_free_swap(page);</span><br><span class="line">	put_page(page);</span><br><span class="line"></span><br><span class="line">	pte_unmap_unlock(ptep, ptl);</span><br><span class="line">	err = <span class="number">0</span>;</span><br><span class="line">out_mn:</span><br><span class="line">	mmu_notifier_invalidate_range_end(&amp;range);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h4 id="get-ksm-page"><a href="#get-ksm-page" class="headerlink" title="get_ksm_page"></a>get_ksm_page</h4><p>get_ksm_page尝试获取节点对应的KSM页面(所谓KSM页面就是page-&gt;mapping带有PAGE_MAPPING_KSM的页面).<br>这是因为stable_node并没有持有它对应的KSM页面的引用, 它可能被释放或变更.我们通过get_ksm_page来保证对该页面的访问仍然安全且正确.该函数同时会移除已经过时的节点, 这会导致节点树的rebalance, 这个过程就是修剪(prune).</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * get_ksm_page: checks if the page indicated by the stable node</span></span><br><span class="line"><span class="comment"> * is still its ksm page, despite having held no reference to it.</span></span><br><span class="line"><span class="comment"> * In which case we can trust the content of the page, and it</span></span><br><span class="line"><span class="comment"> * returns the gotten page; but if the page has now been zapped,</span></span><br><span class="line"><span class="comment"> * remove the stale node from the stable tree and return NULL.</span></span><br><span class="line"><span class="comment"> * But beware, the stable node's page might be being migrated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You would expect the stable_node to hold a reference to the ksm page.</span></span><br><span class="line"><span class="comment"> * But if it increments the page's count, swapping out has to wait for</span></span><br><span class="line"><span class="comment"> * ksmd to come around again before it can free the page, which may take</span></span><br><span class="line"><span class="comment"> * seconds or even minutes: much too unresponsive.  So instead we use a</span></span><br><span class="line"><span class="comment"> * "keyhole reference": access to the ksm page from the stable node peeps</span></span><br><span class="line"><span class="comment"> * out through its keyhole to see if that page still holds the right key,</span></span><br><span class="line"><span class="comment"> * pointing back to this stable node.  This relies on freeing a PageAnon</span></span><br><span class="line"><span class="comment"> * page to reset its page-&gt;mapping to NULL, and relies on no other use of</span></span><br><span class="line"><span class="comment"> * a page to put something that might look like our key in page-&gt;mapping.</span></span><br><span class="line"><span class="comment"> * is on its way to being freed; but it is an anomaly to bear in mind.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">get_ksm_page</span><span class="params">(<span class="keyword">struct</span> stable_node *stable_node, <span class="type">bool</span> lock_it)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">void</span> *expected_mapping;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> kpfn;</span><br><span class="line"></span><br><span class="line">	expected_mapping = (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)stable_node |</span><br><span class="line">					PAGE_MAPPING_KSM);</span><br><span class="line">again:</span><br><span class="line">	kpfn = READ_ONCE(stable_node-&gt;kpfn); <span class="comment">/* Address dependency. */</span></span><br><span class="line">	page = pfn_to_page(kpfn);</span><br><span class="line">	<span class="keyword">if</span> (READ_ONCE(page-&gt;mapping) != expected_mapping)</span><br><span class="line">		<span class="keyword">goto</span> stale;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We cannot do anything with the page while its refcount is 0.</span></span><br><span class="line"><span class="comment">	 * Usually 0 means free, or tail of a higher-order page: in which</span></span><br><span class="line"><span class="comment">	 * case this node is no longer referenced, and should be freed;</span></span><br><span class="line"><span class="comment">	 * however, it might mean that the page is under page_ref_freeze().</span></span><br><span class="line"><span class="comment">	 * The __remove_mapping() case is easy, again the node is now stale;</span></span><br><span class="line"><span class="comment">	 * but if page is swapcache in migrate_page_move_mapping(), it might</span></span><br><span class="line"><span class="comment">	 * still be our page, in which case it's essential to keep the node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (!get_page_unless_zero(page)) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Another check for page-&gt;mapping != expected_mapping would</span></span><br><span class="line"><span class="comment">		 * work here too.  We have chosen the !PageSwapCache test to</span></span><br><span class="line"><span class="comment">		 * optimize the common case, when the page is or is about to</span></span><br><span class="line"><span class="comment">		 * be freed: PageSwapCache is cleared (under spin_lock_irq)</span></span><br><span class="line"><span class="comment">		 * in the ref_freeze section of __remove_mapping(); but Anon</span></span><br><span class="line"><span class="comment">		 * page-&gt;mapping reset to NULL later, in free_pages_prepare().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!PageSwapCache(page))</span><br><span class="line">			<span class="keyword">goto</span> stale;</span><br><span class="line">		cpu_relax();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (READ_ONCE(page-&gt;mapping) != expected_mapping) {</span><br><span class="line">		put_page(page);</span><br><span class="line">		<span class="keyword">goto</span> stale;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lock_it) {</span><br><span class="line">		lock_page(page);</span><br><span class="line">		<span class="keyword">if</span> (READ_ONCE(page-&gt;mapping) != expected_mapping) {</span><br><span class="line">			unlock_page(page);</span><br><span class="line">			put_page(page);</span><br><span class="line">			<span class="keyword">goto</span> stale;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line"></span><br><span class="line">stale:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We come here from above when page-&gt;mapping or !PageSwapCache</span></span><br><span class="line"><span class="comment">	 * suggests that the node is stale; but it might be under migration.</span></span><br><span class="line"><span class="comment">	 * We need smp_rmb(), matching the smp_wmb() in ksm_migrate_page(),</span></span><br><span class="line"><span class="comment">	 * before checking whether node-&gt;kpfn has been changed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_rmb();</span><br><span class="line">	<span class="keyword">if</span> (READ_ONCE(stable_node-&gt;kpfn) != kpfn)</span><br><span class="line">		<span class="keyword">goto</span> again;</span><br><span class="line">	remove_node_from_stable_tree(stable_node);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="ksmd流程"><a href="#ksmd流程" class="headerlink" title="ksmd流程"></a>ksmd流程</h3><p>ksmd和其他内核线程一样循环调用对应的主处理函数 – ksm_do_scan.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ksm_scan_thread</span><span class="params">(<span class="type">void</span> *nothing)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sleep_ms;</span><br><span class="line"></span><br><span class="line">	set_freezable();</span><br><span class="line">	set_user_nice(current, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!kthread_should_stop()) {</span><br><span class="line">		mutex_lock(&amp;ksm_thread_mutex);</span><br><span class="line">		wait_while_offlining();</span><br><span class="line">		<span class="keyword">if</span> (ksmd_should_run())</span><br><span class="line">			ksm_do_scan(ksm_thread_pages_to_scan);</span><br><span class="line">		mutex_unlock(&amp;ksm_thread_mutex);</span><br><span class="line"></span><br><span class="line">		try_to_freeze();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ksmd_should_run()) {</span><br><span class="line">			sleep_ms = READ_ONCE(ksm_thread_sleep_millisecs);</span><br><span class="line">			wait_event_interruptible_timeout(ksm_iter_wait,</span><br><span class="line">				sleep_ms != READ_ONCE(ksm_thread_sleep_millisecs),</span><br><span class="line">				msecs_to_jiffies(sleep_ms));</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			wait_event_freezable(ksm_thread_wait,</span><br><span class="line">				ksmd_should_run() || kthread_should_stop());</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>每次被唤醒, ksm扫描ksm_thread_pages_to_scan张页面.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ksm_do_scan  - the ksm scanner main worker function.</span></span><br><span class="line"><span class="comment"> * @scan_npages:  number of pages we want to scan before we return.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ksm_do_scan</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> scan_npages)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rmap_item</span> *<span class="title">rmap_item</span>;</span></span><br><span class="line">	<span class="keyword">struct</span> page *<span class="title function_">uninitialized_var</span><span class="params">(page)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (scan_npages-- &amp;&amp; likely(!freezing(current))) {</span><br><span class="line">		cond_resched();</span><br><span class="line">		rmap_item = scan_get_next_rmap_item(&amp;page);</span><br><span class="line">		<span class="keyword">if</span> (!rmap_item)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		cmp_and_merge_page(page, rmap_item);</span><br><span class="line">		put_page(page);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>unstable_tree_search_insert函数在不稳定节点树上搜索与指定page内容相同的tree_page以及对应的tree_rmap_item. 如果不存在, 则将该page的rmap_item插入到不稳定节点树中.</p>
<ul>
<li>首先根据page对应的nid选中对应的不稳定节点树的根节点.</li>
<li>从根节点开始遍历(tree_rmap_item作遍历时的cursor)<ul>
<li>调用get_mergeable_page获取cursor对应的可合并匿名页tree_page, 这是将rmap_item-&gt;address传给follow_page爬页表来获取的.</li>
<li>如果没获取到, 直接返回.(<del>这里笔者有点没理解为啥直接返回而不是继续遍历下一个节点</del>)</li>
<li>如果page==tree_page(fork导致), 直接返回.</li>
<li>使用memcmp比较page和tree_page的内容, 并根据memcmp的返回值来决定是否需要继续遍历, 以及继续遍历时左右节点的选择.<ul>
<li>如果内容相同, 则完成本次搜索.</li>
<li>否则继续遍历.</li>
</ul>
</li>
</ul>
</li>
<li>若遍历完成还是没找到相同的tree_page, 那么将该rmap_item插入到不稳定节点树中.</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * unstable_tree_search_insert - search for identical page,</span></span><br><span class="line"><span class="comment"> * else insert rmap_item into the unstable tree.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function searches for a page in the unstable tree identical to the</span></span><br><span class="line"><span class="comment"> * page currently being scanned; and if no identical page is found in the</span></span><br><span class="line"><span class="comment"> * tree, we insert rmap_item as a new object into the unstable tree.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function returns pointer to rmap_item found to be identical</span></span><br><span class="line"><span class="comment"> * to the currently scanned page, NULL otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function does both searching and inserting, because they share</span></span><br><span class="line"><span class="comment"> * the same walking algorithm in an rbtree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span></span><br><span class="line"><span class="keyword">struct</span> rmap_item *<span class="title function_">unstable_tree_search_insert</span><span class="params">(<span class="keyword">struct</span> rmap_item *rmap_item,</span></span><br><span class="line"><span class="params">					      <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">					      <span class="keyword">struct</span> page **tree_pagep)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">new</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> *<span class="title">root</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> nid;</span><br><span class="line"></span><br><span class="line">	nid = get_kpfn_nid(page_to_pfn(page));</span><br><span class="line">	root = root_unstable_tree + nid;</span><br><span class="line">	new = &amp;root-&gt;rb_node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*new) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rmap_item</span> *<span class="title">tree_rmap_item</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tree_page</span>;</span></span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line">		tree_rmap_item = rb_entry(*new, <span class="keyword">struct</span> rmap_item, node);</span><br><span class="line">		tree_page = get_mergeable_page(tree_rmap_item);</span><br><span class="line">		<span class="keyword">if</span> (!tree_page)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Don't substitute a ksm page for a forked page.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (page == tree_page) {</span><br><span class="line">			put_page(tree_page);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		ret = memcmp_pages(page, tree_page);</span><br><span class="line"></span><br><span class="line">		parent = *new;</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) {</span><br><span class="line">			put_page(tree_page);</span><br><span class="line">			new = &amp;parent-&gt;rb_left;</span><br><span class="line">		} <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) {</span><br><span class="line">			put_page(tree_page);</span><br><span class="line">			new = &amp;parent-&gt;rb_right;</span><br><span class="line">		} <span class="keyword">else</span> <span class="keyword">if</span> (!ksm_merge_across_nodes &amp;&amp;</span><br><span class="line">			   page_to_nid(tree_page) != nid) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If tree_page has been migrated to another NUMA node,</span></span><br><span class="line"><span class="comment">			 * it will be flushed out and put in the right unstable</span></span><br><span class="line"><span class="comment">			 * tree next time: only merge with it when across_nodes.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			put_page(tree_page);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			*tree_pagep = tree_page;</span><br><span class="line">			<span class="keyword">return</span> tree_rmap_item;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	rmap_item-&gt;address |= UNSTABLE_FLAG;</span><br><span class="line">	rmap_item-&gt;address |= (ksm_scan.seqnr &amp; SEQNR_MASK);</span><br><span class="line">	DO_NUMA(rmap_item-&gt;nid = nid);</span><br><span class="line">	rb_link_node(&amp;rmap_item-&gt;node, parent, new);</span><br><span class="line">	rb_insert_color(&amp;rmap_item-&gt;node, root);</span><br><span class="line"></span><br><span class="line">	ksm_pages_unshared++;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p>在这里插入一个页面共享候选者(candidate)的概念, 后面会大量提及.<br>依据是 0 &lt; stable_node-&gt;rmap_hlist_len &lt; ksm_max_page_sharing , 说人话就是该节点的rmap_hlist还没到上限.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline</span><br><span class="line"><span class="type">bool</span> __is_page_sharing_candidate(<span class="keyword">struct</span> stable_node *stable_node, <span class="type">int</span> offset)</span><br><span class="line">{</span><br><span class="line">	VM_BUG_ON(stable_node-&gt;rmap_hlist_len &lt; <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Check that at least one mapping still exists, otherwise</span></span><br><span class="line"><span class="comment">	 * there's no much point to merge and share with this</span></span><br><span class="line"><span class="comment">	 * stable_node, as the underlying tree_page of the other</span></span><br><span class="line"><span class="comment">	 * sharer is going to be freed soon.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> stable_node-&gt;rmap_hlist_len &amp;&amp;</span><br><span class="line">		stable_node-&gt;rmap_hlist_len + offset &lt; ksm_max_page_sharing;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>stable_tree_search比较类似.</p>
<ul>
<li>尝试获取page对应的稳定节点树的节点page_node<ul>
<li>如果获取到了, 说明该page已经在稳定节点树中. 如果page_node-&gt;head != migrate_nodes, 则说明本次扫描到该page是fork导致的, 直接返回.</li>
</ul>
</li>
<li>从稳定节点树的根节点开始遍历<ul>
<li>调用chain_prune函数获取本次能够合并到的节点(stable_node_dup), 以及对应的tree_page, 并对稳定节点树进行修剪(见后文).<ul>
<li>如果没获取到, 证明本节点不能成为本次合并的候选者(普通) 或者 其中没有能成为本次合并的候选者(candidate, 见后文解释)的节点了(链式). 调用stable_node_dup_any无限制的获取一个节点, 可能是该节点本身(普通), 也可能是该节点中的第一个节点(链式).<ul>
<li>如果这次获取到了, 将tree_page设置成新获取到的节点的ksm_page.继续执行</li>
<li>还是没获取到,证明这个节点是一个空的链式节点, 而stable_node_dup_any会对空的链式节点进行rb_erase导致树的rebalance, 所以重新从根节点开始遍历.</li>
</ul>
</li>
</ul>
</li>
<li>如果tree_page为空, 意味着刚刚的过程中在一个过时的节点上调用了get_ksm_page, 这会导致从稳定节点树中移除掉这个节点, 所以稳定节点树可能重新进行了平衡操作, 所以重新从根节点开始遍历.</li>
<li>到这里说明我们已经找到了可能可以用来合并的tree_page, memcmp比较内容并根据结果来决定继续遍历的方向.<ul>
<li>如果内容相同<ul>
<li>如果之前获取到了page_node(即该page本来就在稳定节点树中, 但正在迁移), 且page-&gt;_mapcount &gt; 1, 则跳转到chain_append, 将该page_node与找到的stable_node组成链式节点.  如果page_node是候选者, 返回page, 否则返回空.</li>
<li>如果没有可以合并的节点, 返回空.</li>
<li>尝试获取stable_node_dup的ksm页面, 如果没获取到, 从头开始遍历, 否则返回tree_page.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>遍历结束, 如果page_node是候选者, 返回page, 否则返回空.</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stable_tree_search - search for page inside the stable tree</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function checks if there is a page inside the stable tree</span></span><br><span class="line"><span class="comment"> * with identical content to the page that we are scanning right now.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function returns the stable tree node of identical content if found,</span></span><br><span class="line"><span class="comment"> * NULL otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">stable_tree_search</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> nid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> *<span class="title">root</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">new</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stable_node</span> *<span class="title">stable_node</span>, *<span class="title">stable_node_dup</span>, *<span class="title">stable_node_any</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stable_node</span> *<span class="title">page_node</span>;</span></span><br><span class="line"></span><br><span class="line">	page_node = page_stable_node(page);</span><br><span class="line">	<span class="keyword">if</span> (page_node &amp;&amp; page_node-&gt;head != &amp;migrate_nodes) {</span><br><span class="line">		<span class="comment">/* ksm page forked */</span></span><br><span class="line">		get_page(page);</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	nid = get_kpfn_nid(page_to_pfn(page));</span><br><span class="line">	root = root_stable_tree + nid;</span><br><span class="line">again:</span><br><span class="line">	new = &amp;root-&gt;rb_node;</span><br><span class="line">	parent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*new) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tree_page</span>;</span></span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line">		stable_node = rb_entry(*new, <span class="keyword">struct</span> stable_node, node);</span><br><span class="line">		stable_node_any = <span class="literal">NULL</span>;</span><br><span class="line">		tree_page = chain_prune(&amp;stable_node_dup, &amp;stable_node,	root);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">NOTE:</span> stable_node may have been freed by</span></span><br><span class="line"><span class="comment">		 * chain_prune() if the returned stable_node_dup is</span></span><br><span class="line"><span class="comment">		 * not NULL. stable_node_dup may have been inserted in</span></span><br><span class="line"><span class="comment">		 * the rbtree instead as a regular stable_node (in</span></span><br><span class="line"><span class="comment">		 * order to collapse the stable_node chain if a single</span></span><br><span class="line"><span class="comment">		 * stable_node dup was found in it). In such case the</span></span><br><span class="line"><span class="comment">		 * stable_node is overwritten by the calleee to point</span></span><br><span class="line"><span class="comment">		 * to the stable_node_dup that was collapsed in the</span></span><br><span class="line"><span class="comment">		 * stable rbtree and stable_node will be equal to</span></span><br><span class="line"><span class="comment">		 * stable_node_dup like if the chain never existed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!stable_node_dup) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Either all stable_node dups were full in</span></span><br><span class="line"><span class="comment">			 * this stable_node chain, or this chain was</span></span><br><span class="line"><span class="comment">			 * empty and should be rb_erased.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			stable_node_any = stable_node_dup_any(stable_node,</span><br><span class="line">							      root);</span><br><span class="line">			<span class="keyword">if</span> (!stable_node_any) {</span><br><span class="line">				<span class="comment">/* rb_erase just run */</span></span><br><span class="line">				<span class="keyword">goto</span> again;</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Take any of the stable_node dups page of</span></span><br><span class="line"><span class="comment">			 * this stable_node chain to let the tree walk</span></span><br><span class="line"><span class="comment">			 * continue. All KSM pages belonging to the</span></span><br><span class="line"><span class="comment">			 * stable_node dups in a stable_node chain</span></span><br><span class="line"><span class="comment">			 * have the same content and they're</span></span><br><span class="line"><span class="comment">			 * wrprotected at all times. Any will work</span></span><br><span class="line"><span class="comment">			 * fine to continue the walk.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			tree_page = get_ksm_page(stable_node_any, <span class="literal">false</span>);</span><br><span class="line">		}</span><br><span class="line">		VM_BUG_ON(!stable_node_dup ^ !!stable_node_any);</span><br><span class="line">		<span class="keyword">if</span> (!tree_page) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we walked over a stale stable_node,</span></span><br><span class="line"><span class="comment">			 * get_ksm_page() will call rb_erase() and it</span></span><br><span class="line"><span class="comment">			 * may rebalance the tree from under us. So</span></span><br><span class="line"><span class="comment">			 * restart the search from scratch. Returning</span></span><br><span class="line"><span class="comment">			 * NULL would be safe too, but we'd generate</span></span><br><span class="line"><span class="comment">			 * false negative insertions just because some</span></span><br><span class="line"><span class="comment">			 * stable_node was stale.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		ret = memcmp_pages(page, tree_page);</span><br><span class="line">		put_page(tree_page);</span><br><span class="line"></span><br><span class="line">		parent = *new;</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			new = &amp;parent-&gt;rb_left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">			new = &amp;parent-&gt;rb_right;</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">if</span> (page_node) {</span><br><span class="line">				VM_BUG_ON(page_node-&gt;head != &amp;migrate_nodes);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Test if the migrated page should be merged</span></span><br><span class="line"><span class="comment">				 * into a stable node dup. If the mapcount is</span></span><br><span class="line"><span class="comment">				 * 1 we can migrate it with another KSM page</span></span><br><span class="line"><span class="comment">				 * without adding it to the chain.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (page_mapcount(page) &gt; <span class="number">1</span>)</span><br><span class="line">					<span class="keyword">goto</span> chain_append;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!stable_node_dup) {</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * If the stable_node is a chain and</span></span><br><span class="line"><span class="comment">				 * we got a payload match in memcmp</span></span><br><span class="line"><span class="comment">				 * but we cannot merge the scanned</span></span><br><span class="line"><span class="comment">				 * page in any of the existing</span></span><br><span class="line"><span class="comment">				 * stable_node dups because they're</span></span><br><span class="line"><span class="comment">				 * all full, we need to wait the</span></span><br><span class="line"><span class="comment">				 * scanned page to find itself a match</span></span><br><span class="line"><span class="comment">				 * in the unstable tree to create a</span></span><br><span class="line"><span class="comment">				 * brand new KSM page to add later to</span></span><br><span class="line"><span class="comment">				 * the dups of this stable_node.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Lock and unlock the stable_node's page (which</span></span><br><span class="line"><span class="comment">			 * might already have been migrated) so that page</span></span><br><span class="line"><span class="comment">			 * migration is sure to notice its raised count.</span></span><br><span class="line"><span class="comment">			 * It would be more elegant to return stable_node</span></span><br><span class="line"><span class="comment">			 * than kpage, but that involves more changes.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			tree_page = get_ksm_page(stable_node_dup, <span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(!tree_page))</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * The tree may have been rebalanced,</span></span><br><span class="line"><span class="comment">				 * so re-evaluate parent and new.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">goto</span> again;</span><br><span class="line">			unlock_page(tree_page);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (get_kpfn_nid(stable_node_dup-&gt;kpfn) !=</span><br><span class="line">			    NUMA(stable_node_dup-&gt;nid)) {</span><br><span class="line">				put_page(tree_page);</span><br><span class="line">				<span class="keyword">goto</span> replace;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span> tree_page;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!page_node)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	list_del(&amp;page_node-&gt;<span class="built_in">list</span>);</span><br><span class="line">	DO_NUMA(page_node-&gt;nid = nid);</span><br><span class="line">	rb_link_node(&amp;page_node-&gt;node, parent, new);</span><br><span class="line">	rb_insert_color(&amp;page_node-&gt;node, root);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (is_page_sharing_candidate(page_node)) {</span><br><span class="line">		get_page(page);</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	} <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">replace:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If stable_node was a chain and chain_prune collapsed it,</span></span><br><span class="line"><span class="comment">	 * stable_node has been updated to be the new regular</span></span><br><span class="line"><span class="comment">	 * stable_node. A collapse of the chain is indistinguishable</span></span><br><span class="line"><span class="comment">	 * from the case there was no chain in the stable</span></span><br><span class="line"><span class="comment">	 * rbtree. Otherwise stable_node is the chain and</span></span><br><span class="line"><span class="comment">	 * stable_node_dup is the dup to replace.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (stable_node_dup == stable_node) {</span><br><span class="line">		VM_BUG_ON(is_stable_node_chain(stable_node_dup));</span><br><span class="line">		VM_BUG_ON(is_stable_node_dup(stable_node_dup));</span><br><span class="line">		<span class="comment">/* there is no chain */</span></span><br><span class="line">		<span class="keyword">if</span> (page_node) {</span><br><span class="line">			VM_BUG_ON(page_node-&gt;head != &amp;migrate_nodes);</span><br><span class="line">			list_del(&amp;page_node-&gt;<span class="built_in">list</span>);</span><br><span class="line">			DO_NUMA(page_node-&gt;nid = nid);</span><br><span class="line">			rb_replace_node(&amp;stable_node_dup-&gt;node,</span><br><span class="line">					&amp;page_node-&gt;node,</span><br><span class="line">					root);</span><br><span class="line">			<span class="keyword">if</span> (is_page_sharing_candidate(page_node))</span><br><span class="line">				get_page(page);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				page = <span class="literal">NULL</span>;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			rb_erase(&amp;stable_node_dup-&gt;node, root);</span><br><span class="line">			page = <span class="literal">NULL</span>;</span><br><span class="line">		}</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		VM_BUG_ON(!is_stable_node_chain(stable_node));</span><br><span class="line">		__stable_node_dup_del(stable_node_dup);</span><br><span class="line">		<span class="keyword">if</span> (page_node) {</span><br><span class="line">			VM_BUG_ON(page_node-&gt;head != &amp;migrate_nodes);</span><br><span class="line">			list_del(&amp;page_node-&gt;<span class="built_in">list</span>);</span><br><span class="line">			DO_NUMA(page_node-&gt;nid = nid);</span><br><span class="line">			stable_node_chain_add_dup(page_node, stable_node);</span><br><span class="line">			<span class="keyword">if</span> (is_page_sharing_candidate(page_node))</span><br><span class="line">				get_page(page);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				page = <span class="literal">NULL</span>;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			page = <span class="literal">NULL</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	stable_node_dup-&gt;head = &amp;migrate_nodes;</span><br><span class="line">	list_add(&amp;stable_node_dup-&gt;<span class="built_in">list</span>, stable_node_dup-&gt;head);</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line"></span><br><span class="line">chain_append:</span><br><span class="line">	<span class="comment">/* stable_node_dup could be null if it reached the limit */</span></span><br><span class="line">	<span class="keyword">if</span> (!stable_node_dup)</span><br><span class="line">		stable_node_dup = stable_node_any;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If stable_node was a chain and chain_prune collapsed it,</span></span><br><span class="line"><span class="comment">	 * stable_node has been updated to be the new regular</span></span><br><span class="line"><span class="comment">	 * stable_node. A collapse of the chain is indistinguishable</span></span><br><span class="line"><span class="comment">	 * from the case there was no chain in the stable</span></span><br><span class="line"><span class="comment">	 * rbtree. Otherwise stable_node is the chain and</span></span><br><span class="line"><span class="comment">	 * stable_node_dup is the dup to replace.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (stable_node_dup == stable_node) {</span><br><span class="line">		VM_BUG_ON(is_stable_node_chain(stable_node_dup));</span><br><span class="line">		VM_BUG_ON(is_stable_node_dup(stable_node_dup));</span><br><span class="line">		<span class="comment">/* chain is missing so create it */</span></span><br><span class="line">		stable_node = alloc_stable_node_chain(stable_node_dup,</span><br><span class="line">						      root);</span><br><span class="line">		<span class="keyword">if</span> (!stable_node)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Add this stable_node dup that was</span></span><br><span class="line"><span class="comment">	 * migrated to the stable_node chain</span></span><br><span class="line"><span class="comment">	 * of the current nid for this page</span></span><br><span class="line"><span class="comment">	 * content.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	VM_BUG_ON(!is_stable_node_chain(stable_node));</span><br><span class="line">	VM_BUG_ON(!is_stable_node_dup(stable_node_dup));</span><br><span class="line">	VM_BUG_ON(page_node-&gt;head != &amp;migrate_nodes);</span><br><span class="line">	list_del(&amp;page_node-&gt;<span class="built_in">list</span>);</span><br><span class="line">	DO_NUMA(page_node-&gt;nid = nid);</span><br><span class="line">	stable_node_chain_add_dup(page_node, stable_node);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p>chain_prune和chain作用相同, 获取s_n节点中的候选者(可能是该普通节点本身, 也可能是该链式节点链表中的一个节点)存入s_n_d. 同时, 该函数可能导致一个长度为1的链式节点坍缩到一个普通节点, 所以s_n的值可能被更新.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> page *<span class="title function_">chain</span><span class="params">(<span class="keyword">struct</span> stable_node **s_n_d,</span></span><br><span class="line"><span class="params">					  <span class="keyword">struct</span> stable_node *s_n,</span></span><br><span class="line"><span class="params">					  <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stable_node</span> *<span class="title">old_stable_node</span> =</span> s_n;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tree_page</span>;</span></span><br><span class="line"></span><br><span class="line">	tree_page = __stable_node_chain(s_n_d, &amp;s_n, root, <span class="literal">false</span>);</span><br><span class="line">	<span class="comment">/* not pruning dups so s_n cannot have changed */</span></span><br><span class="line">	VM_BUG_ON(s_n != old_stable_node);</span><br><span class="line">	<span class="keyword">return</span> tree_page;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> page *<span class="title function_">chain_prune</span><span class="params">(<span class="keyword">struct</span> stable_node **s_n_d,</span></span><br><span class="line"><span class="params">						<span class="keyword">struct</span> stable_node **s_n,</span></span><br><span class="line"><span class="params">						<span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> __stable_node_chain(s_n_d, s_n, root, <span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>__stable_node_chain函数</p>
<ul>
<li>判断当前节点是链式节点还是普通节点(链式节点的rmap_hlist_len==STABLE_NODE_CHAIN)<ul>
<li>如果是普通节点, 判断是否是页面共享的候选者(candidate).<ul>
<li>如果是候选者, 返回对应的ksm_page并将参数中的_stable_node设置为当前stable_node.</li>
<li>否则将参数中的_stable_node设置为空, 并返回空.</li>
</ul>
</li>
<li>如果是链式节点, 转入stable_node_dup.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Like for get_ksm_page, this function can free the *_stable_node and</span></span><br><span class="line"><span class="comment"> * *_stable_node_dup if the returned tree_page is NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It can also free and overwrite *_stable_node with the found</span></span><br><span class="line"><span class="comment"> * stable_node_dup if the chain is collapsed (in which case</span></span><br><span class="line"><span class="comment"> * *_stable_node will be equal to *_stable_node_dup like if the chain</span></span><br><span class="line"><span class="comment"> * never existed). It's up to the caller to verify tree_page is not</span></span><br><span class="line"><span class="comment"> * NULL before dereferencing *_stable_node or *_stable_node_dup.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * *_stable_node_dup is really a second output parameter of this</span></span><br><span class="line"><span class="comment"> * function and will be overwritten in all cases, the caller doesn't</span></span><br><span class="line"><span class="comment"> * need to initialize it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">stable_node_chain</span>(<span class="keyword">struct</span> <span class="title">stable_node</span> **_<span class="title">stable_node_dup</span>,</span></span><br><span class="line"><span class="class">					<span class="keyword">struct</span> <span class="title">stable_node</span> **_<span class="title">stable_node</span>,</span></span><br><span class="line"><span class="class">					<span class="keyword">struct</span> <span class="title">rb_root</span> *<span class="title">root</span>,</span></span><br><span class="line"><span class="class">					<span class="title">bool</span> <span class="title">prune_stale_stable_nodes</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stable_node</span> *<span class="title">stable_node</span> =</span> *_stable_node;</span><br><span class="line">	<span class="keyword">if</span> (!is_stable_node_chain(stable_node)) {</span><br><span class="line">		<span class="keyword">if</span> (is_page_sharing_candidate(stable_node)) {</span><br><span class="line">			*_stable_node_dup = stable_node;</span><br><span class="line">			<span class="keyword">return</span> get_ksm_page(stable_node, <span class="literal">false</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * _stable_node_dup set to NULL means the stable_node</span></span><br><span class="line"><span class="comment">		 * reached the ksm_max_page_sharing limit.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		*_stable_node_dup = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> stable_node_dup(_stable_node_dup, _stable_node, root,</span><br><span class="line">			       prune_stale_stable_nodes);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<p>stable_node_dup函数</p>
<ul>
<li>遍历这一链式节点的链表<ul>
<li>调用get_ksm_page尝试获取对应的KSM页面</li>
<li>若没获取到则跳过本节点(因为我们不是对真正挂载在树上的节点调用get_ksm_page, 不用从头开始).</li>
<li>如果是页面共享的候选者<ul>
<li>如果没有在之前的遍历中找到过符合的节点 或者 本节点的rmap_hlist_len比上次找到的长<ul>
<li>将本节点设为found, 对应的page设置为tree_page,更新found_rmap_hlist_len.</li>
<li>释放上一次找到的page的一次引用</li>
<li>如果不需要修建过时的节点, 结束遍历.</li>
</ul>
</li>
</ul>
</li>
<li>释放本次遍历节点的一次引用.</li>
</ul>
</li>
<li>接下来对找到的节点进行处理<ul>
<li>如果有修剪的要求, 且刚才的遍历只有一个节点获取到了对应的ksm页面, 那么这个链式节点就应该回退到普通节点, 进行替换并释放原链式节点, 更新统计信息.将_stable_node设为该节点.</li>
<li>否则<ul>
<li>如果找到的节点不是该链式节点的第一个节点, 并且至少还能继续合并一次, 将其作为链式节点的第一个节点, 加速下一次不需要修剪的情况.</li>
</ul>
</li>
</ul>
</li>
<li>将_stable_node_dup设置为found, 这是rmap_hlist_len最长的候选者.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">stable_node_dup</span><span class="params">(<span class="keyword">struct</span> stable_node **_stable_node_dup,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> stable_node **_stable_node,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> rb_root *root,</span></span><br><span class="line"><span class="params">				    <span class="type">bool</span> prune_stale_stable_nodes)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stable_node</span> *<span class="title">dup</span>, *<span class="title">found</span> =</span> <span class="literal">NULL</span>, *stable_node = *_stable_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">hlist_safe</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *_<span class="title">tree_page</span>, *<span class="title">tree_page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> nr = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> found_rmap_hlist_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!prune_stale_stable_nodes ||</span><br><span class="line">	    time_before(jiffies, stable_node-&gt;chain_prune_time +</span><br><span class="line">			msecs_to_jiffies(</span><br><span class="line">				ksm_stable_node_chains_prune_millisecs)))</span><br><span class="line">		prune_stale_stable_nodes = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		stable_node-&gt;chain_prune_time = jiffies;</span><br><span class="line"></span><br><span class="line">	hlist_for_each_entry_safe(dup, hlist_safe,</span><br><span class="line">				  &amp;stable_node-&gt;hlist, hlist_dup) {</span><br><span class="line">		cond_resched();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We must walk all stable_node_dup to prune the stale</span></span><br><span class="line"><span class="comment">		 * stable nodes during lookup.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * get_ksm_page can drop the nodes from the</span></span><br><span class="line"><span class="comment">		 * stable_node-&gt;hlist if they point to freed pages</span></span><br><span class="line"><span class="comment">		 * (that's why we do a _safe walk). The "dup"</span></span><br><span class="line"><span class="comment">		 * stable_node parameter itself will be freed from</span></span><br><span class="line"><span class="comment">		 * under us if it returns NULL.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		_tree_page = get_ksm_page(dup, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (!_tree_page)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		nr += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (is_page_sharing_candidate(dup)) {</span><br><span class="line">			<span class="keyword">if</span> (!found ||</span><br><span class="line">			    dup-&gt;rmap_hlist_len &gt; found_rmap_hlist_len) {</span><br><span class="line">				<span class="keyword">if</span> (found)</span><br><span class="line">					put_page(tree_page);</span><br><span class="line">				found = dup;</span><br><span class="line">				found_rmap_hlist_len = found-&gt;rmap_hlist_len;</span><br><span class="line">				tree_page = _tree_page;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* skip put_page for found dup */</span></span><br><span class="line">				<span class="keyword">if</span> (!prune_stale_stable_nodes)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		put_page(_tree_page);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (found) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * nr is counting all dups in the chain only if</span></span><br><span class="line"><span class="comment">		 * prune_stale_stable_nodes is true, otherwise we may</span></span><br><span class="line"><span class="comment">		 * break the loop at nr == 1 even if there are</span></span><br><span class="line"><span class="comment">		 * multiple entries.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (prune_stale_stable_nodes &amp;&amp; nr == <span class="number">1</span>) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If there's not just one entry it would</span></span><br><span class="line"><span class="comment">			 * corrupt memory, better BUG_ON. In KSM</span></span><br><span class="line"><span class="comment">			 * context with no lock held it's not even</span></span><br><span class="line"><span class="comment">			 * fatal.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			BUG_ON(stable_node-&gt;hlist.first-&gt;next);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * There's just one entry and it is below the</span></span><br><span class="line"><span class="comment">			 * deduplication limit so drop the chain.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			rb_replace_node(&amp;stable_node-&gt;node, &amp;found-&gt;node,</span><br><span class="line">					root);</span><br><span class="line">			free_stable_node(stable_node);</span><br><span class="line">			ksm_stable_node_chains--;</span><br><span class="line">			ksm_stable_node_dups--;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * <span class="doctag">NOTE:</span> the caller depends on the stable_node</span></span><br><span class="line"><span class="comment">			 * to be equal to stable_node_dup if the chain</span></span><br><span class="line"><span class="comment">			 * was collapsed.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			*_stable_node = found;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Just for robustneess as stable_node is</span></span><br><span class="line"><span class="comment">			 * otherwise left as a stable pointer, the</span></span><br><span class="line"><span class="comment">			 * compiler shall optimize it away at build</span></span><br><span class="line"><span class="comment">			 * time.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			stable_node = <span class="literal">NULL</span>;</span><br><span class="line">		} <span class="keyword">else</span> <span class="keyword">if</span> (stable_node-&gt;hlist.first != &amp;found-&gt;hlist_dup &amp;&amp;</span><br><span class="line">			   __is_page_sharing_candidate(found, <span class="number">1</span>)) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If the found stable_node dup can accept one</span></span><br><span class="line"><span class="comment">			 * more future merge (in addition to the one</span></span><br><span class="line"><span class="comment">			 * that is underway) and is not at the head of</span></span><br><span class="line"><span class="comment">			 * the chain, put it there so next search will</span></span><br><span class="line"><span class="comment">			 * be quicker in the !prune_stale_stable_nodes</span></span><br><span class="line"><span class="comment">			 * case.</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 * <span class="doctag">NOTE:</span> it would be inaccurate to use nr &gt; 1</span></span><br><span class="line"><span class="comment">			 * instead of checking the hlist.first pointer</span></span><br><span class="line"><span class="comment">			 * directly, because in the</span></span><br><span class="line"><span class="comment">			 * prune_stale_stable_nodes case "nr" isn't</span></span><br><span class="line"><span class="comment">			 * the position of the found dup in the chain,</span></span><br><span class="line"><span class="comment">			 * but the total number of dups in the chain.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			hlist_del(&amp;found-&gt;hlist_dup);</span><br><span class="line">			hlist_add_head(&amp;found-&gt;hlist_dup,</span><br><span class="line">				       &amp;stable_node-&gt;hlist);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	*_stable_node_dup = found;</span><br><span class="line">	<span class="keyword">return</span> tree_page;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>stable_tree_insert比较类似.</p>
<ul>
<li>获取kpage对应的稳定节点树的根节点</li>
<li>从根节点开始遍历<ul>
<li>调用chain函数获取本次能够合并到的节点(stable_node_dup), 以及对应的tree_page<ul>
<li>如果没获取到, 证明本节点不能成为本次合并的候选(普通) 或者 其中没有能成为本次合并的候选者(candidate)的节点了(链式). 调用stable_node_dup_any无限制的获取一个节点, 可能是该节点本身(普通), 也可能是该节点中的第一个节点(链式).<ul>
<li>如果这次获取到了, 将tree_page设置成新获取到的节点的ksm_page.继续执行</li>
<li>还是没获取到, 重新从根节点开始遍历.</li>
</ul>
</li>
</ul>
</li>
<li>如果tree_page为空, 意味着刚刚的过程中在一个过时的节点上调用了get_ksm_page, 这会导致从稳定节点树中移除掉这个节点, 所以稳定节点树可能重新进行了平衡操作, 所以重新从根节点开始遍历.</li>
<li>到这里说明我们已经找到了可能可以用来合并的tree_page, 和之前类似的操作, memcmp比较内容并根据结果来决定继续遍历的方向.如果内容相同, 跳出遍历循环.</li>
</ul>
</li>
<li>分配一个新的节点, 与kpage互相关联. 遍历结束有两种情况, 如果是遍历到了终点导致结束, 证明我们没有在稳定节点树上找到可以与kpage合并的节点, 那么我们将这个节点作为一个普通节点, 挂载到稳定节点树上. 如果是找到了用来合并的节点而结束遍历的, 那么将新节点与找到的节点组成链式节点, 或者将新节点直接加入找到的链式节点的链表中.</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stable_tree_insert - insert stable tree node pointing to new ksm page</span></span><br><span class="line"><span class="comment"> * into the stable tree.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function returns the stable tree node just allocated on success,</span></span><br><span class="line"><span class="comment"> * NULL otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> stable_node *<span class="title function_">stable_tree_insert</span><span class="params">(<span class="keyword">struct</span> page *kpage)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> nid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> kpfn;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> *<span class="title">root</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">new</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stable_node</span> *<span class="title">stable_node</span>, *<span class="title">stable_node_dup</span>, *<span class="title">stable_node_any</span>;</span></span><br><span class="line">	<span class="type">bool</span> need_chain = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	kpfn = page_to_pfn(kpage);</span><br><span class="line">	nid = get_kpfn_nid(kpfn);</span><br><span class="line">	root = root_stable_tree + nid;</span><br><span class="line">again:</span><br><span class="line">	parent = <span class="literal">NULL</span>;</span><br><span class="line">	new = &amp;root-&gt;rb_node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (*new) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tree_page</span>;</span></span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line">		stable_node = rb_entry(*new, <span class="keyword">struct</span> stable_node, node);</span><br><span class="line">		stable_node_any = <span class="literal">NULL</span>;</span><br><span class="line">		tree_page = chain(&amp;stable_node_dup, stable_node, root);</span><br><span class="line">		<span class="keyword">if</span> (!stable_node_dup) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Either all stable_node dups were full in</span></span><br><span class="line"><span class="comment">			 * this stable_node chain, or this chain was</span></span><br><span class="line"><span class="comment">			 * empty and should be rb_erased.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			stable_node_any = stable_node_dup_any(stable_node,</span><br><span class="line">							      root);</span><br><span class="line">			<span class="keyword">if</span> (!stable_node_any) {</span><br><span class="line">				<span class="comment">/* rb_erase just run */</span></span><br><span class="line">				<span class="keyword">goto</span> again;</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Take any of the stable_node dups page of</span></span><br><span class="line"><span class="comment">			 * this stable_node chain to let the tree walk</span></span><br><span class="line"><span class="comment">			 * continue. All KSM pages belonging to the</span></span><br><span class="line"><span class="comment">			 * stable_node dups in a stable_node chain</span></span><br><span class="line"><span class="comment">			 * have the same content and they're</span></span><br><span class="line"><span class="comment">			 * wrprotected at all times. Any will work</span></span><br><span class="line"><span class="comment">			 * fine to continue the walk.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			tree_page = get_ksm_page(stable_node_any, <span class="literal">false</span>);</span><br><span class="line">		}</span><br><span class="line">		VM_BUG_ON(!stable_node_dup ^ !!stable_node_any);</span><br><span class="line">		<span class="keyword">if</span> (!tree_page) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we walked over a stale stable_node,</span></span><br><span class="line"><span class="comment">			 * get_ksm_page() will call rb_erase() and it</span></span><br><span class="line"><span class="comment">			 * may rebalance the tree from under us. So</span></span><br><span class="line"><span class="comment">			 * restart the search from scratch. Returning</span></span><br><span class="line"><span class="comment">			 * NULL would be safe too, but we'd generate</span></span><br><span class="line"><span class="comment">			 * false negative insertions just because some</span></span><br><span class="line"><span class="comment">			 * stable_node was stale.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		ret = memcmp_pages(kpage, tree_page);</span><br><span class="line">		put_page(tree_page);</span><br><span class="line"></span><br><span class="line">		parent = *new;</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			new = &amp;parent-&gt;rb_left;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">			new = &amp;parent-&gt;rb_right;</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			need_chain = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	stable_node_dup = alloc_stable_node();</span><br><span class="line">	<span class="keyword">if</span> (!stable_node_dup)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	INIT_HLIST_HEAD(&amp;stable_node_dup-&gt;hlist);</span><br><span class="line">	stable_node_dup-&gt;kpfn = kpfn;</span><br><span class="line">	set_page_stable_node(kpage, stable_node_dup);</span><br><span class="line">	stable_node_dup-&gt;rmap_hlist_len = <span class="number">0</span>;</span><br><span class="line">	DO_NUMA(stable_node_dup-&gt;nid = nid);</span><br><span class="line">	<span class="keyword">if</span> (!need_chain) {</span><br><span class="line">		rb_link_node(&amp;stable_node_dup-&gt;node, parent, new);</span><br><span class="line">		rb_insert_color(&amp;stable_node_dup-&gt;node, root);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="keyword">if</span> (!is_stable_node_chain(stable_node)) {</span><br><span class="line">			<span class="keyword">struct</span> stable_node *orig = stable_node;</span><br><span class="line">			<span class="comment">/* chain is missing so create it */</span></span><br><span class="line">			stable_node = alloc_stable_node_chain(orig, root);</span><br><span class="line">			<span class="keyword">if</span> (!stable_node) {</span><br><span class="line">				free_stable_node(stable_node_dup);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		stable_node_chain_add_dup(stable_node_dup, stable_node);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> stable_node_dup;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://polaris-snowfall.github.io/2024/Linux%20-%20KSM%20--%20ARM64%20v5.0/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Memory-Management/" rel="tag">Memory_Management</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/Dig%20into%20Netfilter%20(1)/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Dig into Netfilter (一)  —— nf_tables核心概念
          
        </div>
      </a>
    
    
      <a href="/2024/linux%20kernel%20lab%20--%20Notes/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Linux kernel Lab学习笔记</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> 翰青HanQi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="北极落小雪"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/About">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>