<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
        
      <meta name="description" content="Boom? PWN ! ! !" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Dig into Netfilter (五) —— CVE-2022-32250 |  北极落小雪</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
  </html>
</html>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Dig into Netfilter (5)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Dig into Netfilter (五) —— CVE-2022-32250
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/Dig%20into%20Netfilter%20(5)/" class="article-date">
  <time datetime="2024-12-13T16:00:00.000Z" itemprop="datePublished">2024-12-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Pwn/">Pwn</a> / <a class="article-category-link" href="/categories/Pwn/Kernel/">Kernel</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">4.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">20 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="CVE-2022-32250"><a href="#CVE-2022-32250" class="headerlink" title="CVE-2022-32250"></a>CVE-2022-32250</h3><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><h5 id="完整的表达式析构过程-nft-set-binding"><a href="#完整的表达式析构过程-nft-set-binding" class="headerlink" title="完整的表达式析构过程 / nft_set_binding"></a>完整的表达式析构过程 / nft_set_binding</h5><p>一些规则可以与集合绑定, 但其实真正绑定的是表达式和集合, 这类表达式有nft_lookup, nft_dynset, nft_objref.</p>
<p>代表这一关系的结构是nft_set_binding. </p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct nft_set_binding - nf_tables set binding</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	@list: set bindings list node</span></span><br><span class="line"><span class="comment"> *	@chain: chain containing the rule bound to the set</span></span><br><span class="line"><span class="comment"> *	@flags: set action flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	A set binding contains all information necessary for validation</span></span><br><span class="line"><span class="comment"> *	of new elements added to a bound set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">list</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span>		*<span class="title">chain</span>;</span></span><br><span class="line">	u32				flags;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<span id="more"></span>

<p>实话说笔者暂时没太理解这个binding的作用, 能看出来的一是校验NFT_SET_MAP类型的集合中的NFT_DATA_VERDICT元素, 二是管理集合(特别是匿名集合)的生命周期.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nf_tables_bind_set</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx, <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">		       <span class="keyword">struct</span> nft_set_binding *binding)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span> *<span class="title">i</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_set_iter</span> <span class="title">iter</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">set</span>-&gt;use == UINT_MAX)</span><br><span class="line">		<span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;<span class="built_in">set</span>-&gt;bindings) &amp;&amp; nft_set_is_anonymous(<span class="built_in">set</span>))</span><br><span class="line">		<span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (binding-&gt;flags &amp; NFT_SET_MAP) {</span><br><span class="line">		<span class="comment">/* If the set is already bound to the same chain all</span></span><br><span class="line"><span class="comment">		 * jumps are already validated for that chain.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		list_for_each_entry(i, &amp;<span class="built_in">set</span>-&gt;bindings, <span class="built_in">list</span>) {</span><br><span class="line">			<span class="keyword">if</span> (i-&gt;flags &amp; NFT_SET_MAP &amp;&amp;</span><br><span class="line">			    i-&gt;chain == binding-&gt;chain)</span><br><span class="line">				<span class="keyword">goto</span> bind;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		iter.genmask	= nft_genmask_next(ctx-&gt;net);</span><br><span class="line">		iter.skip 	= <span class="number">0</span>;</span><br><span class="line">		iter.count	= <span class="number">0</span>;</span><br><span class="line">		iter.err	= <span class="number">0</span>;</span><br><span class="line">		iter.fn		= nf_tables_bind_check_setelem;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">set</span>-&gt;ops-&gt;walk(ctx, <span class="built_in">set</span>, &amp;iter);</span><br><span class="line">		<span class="keyword">if</span> (!iter.err)</span><br><span class="line">			iter.err = nft_set_catchall_bind_check(ctx, <span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (iter.err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> iter.err;</span><br><span class="line">	}</span><br><span class="line">bind:</span><br><span class="line">	binding-&gt;chain = ctx-&gt;chain;</span><br><span class="line">	list_add_tail_rcu(&amp;binding-&gt;<span class="built_in">list</span>, &amp;<span class="built_in">set</span>-&gt;bindings);</span><br><span class="line">	nft_set_trans_bind(ctx, <span class="built_in">set</span>);</span><br><span class="line">	<span class="built_in">set</span>-&gt;use++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL_GPL(nf_tables_bind_set);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nf_tables_unbind_set</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx, <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">				 <span class="keyword">struct</span> nft_set_binding *binding, <span class="type">bool</span> event)</span></span><br><span class="line">{</span><br><span class="line">	list_del_rcu(&amp;binding-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (list_empty(&amp;<span class="built_in">set</span>-&gt;bindings) &amp;&amp; nft_set_is_anonymous(<span class="built_in">set</span>)) {</span><br><span class="line">		list_del_rcu(&amp;<span class="built_in">set</span>-&gt;<span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (event)</span><br><span class="line">			nf_tables_set_notify(ctx, <span class="built_in">set</span>, NFT_MSG_DELSET,</span><br><span class="line">					     GFP_KERNEL);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/_diagrams-normal-set-bindingsdrawio.png"></p>
<p>这个绑定关系在表达式构造时建立, 在表达式析构时解除, 但在这条commit中 <a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/net/netfilter?id=cd5125d8f51882279f50506bb9c7e5e89dc9bef3">“netfilter: nf_tables: split set destruction in deactivate and destroy phase”</a> , 将析构分成了两部分, deactivate(禁用)和destroy(销毁). </p>
<p>前者保证表达式在下次迭代时不会被遍历到, 后者使用rcu销毁表达式. 这么设计的原因和netfilter中使用的”事务”概念有关.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*	@deactivate: deactivate expression in next generation</span><br><span class="line">*	@destroy: destruction function, called after synchronize_rcu</span><br></pre></td></tr></tbody></table></figure>


<p>一次完整的析构如下nf_tables_rule_release函数所示(deactivate + destroy).</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nf_tables_rule_destroy</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> nft_rule *rule)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Careful: some expressions might not be initialized in case this</span></span><br><span class="line"><span class="comment">	 * is called on error from nf_tables_newrule().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	expr = nft_expr_first(rule);</span><br><span class="line">	<span class="keyword">while</span> (nft_expr_more(rule, expr)) {</span><br><span class="line">		next = nft_expr_next(expr);</span><br><span class="line">		nf_tables_expr_destroy(ctx, expr);</span><br><span class="line">		expr = next;</span><br><span class="line">	}</span><br><span class="line">	kfree(rule);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">nf_tables_rule_release</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx, <span class="keyword">struct</span> nft_rule *rule)</span></span><br><span class="line">{</span><br><span class="line">	nft_rule_expr_deactivate(ctx, rule, NFT_TRANS_RELEASE);</span><br><span class="line">	nf_tables_rule_destroy(ctx, rule);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>但其实并不是所有的表达式析构都需要有deactivate这一步骤, 使用如下正则可以搜索到需要deactivate的表达式.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\s*\.deactivate\s*=</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nft_rule_expr_deactivate</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span></span><br><span class="line"><span class="params">				     <span class="keyword">struct</span> nft_rule *rule,</span></span><br><span class="line"><span class="params">				     <span class="keyword">enum</span> nft_trans_phase phase)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line"></span><br><span class="line">	expr = nft_expr_first(rule);</span><br><span class="line">	<span class="keyword">while</span> (nft_expr_more(rule, expr)) {</span><br><span class="line">		<span class="keyword">if</span> (expr-&gt;ops-&gt;deactivate)</span><br><span class="line">			expr-&gt;ops-&gt;deactivate(ctx, expr, phase);</span><br><span class="line"></span><br><span class="line">		expr = nft_expr_next(expr);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nft_dynset_deactivate</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="keyword">struct</span> nft_expr *expr,</span></span><br><span class="line"><span class="params">				  <span class="keyword">enum</span> nft_trans_phase phase)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_dynset</span> *<span class="title">priv</span> =</span> nft_expr_priv(expr);</span><br><span class="line"></span><br><span class="line">	nf_tables_deactivate_set(ctx, priv-&gt;<span class="built_in">set</span>, &amp;priv-&gt;binding, phase);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">nf_tables_deactivate_set</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx, <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">			      <span class="keyword">struct</span> nft_set_binding *binding,</span></span><br><span class="line"><span class="params">			      <span class="keyword">enum</span> nft_trans_phase phase)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">switch</span> (phase) {</span><br><span class="line">	<span class="keyword">case</span> NFT_TRANS_PREPARE:</span><br><span class="line">		<span class="built_in">set</span>-&gt;use--;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">case</span> NFT_TRANS_ABORT:</span><br><span class="line">	<span class="keyword">case</span> NFT_TRANS_RELEASE:</span><br><span class="line">		<span class="built_in">set</span>-&gt;use--;</span><br><span class="line">		fallthrough;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		nf_tables_unbind_set(ctx, <span class="built_in">set</span>, binding,</span><br><span class="line">				     phase == NFT_TRANS_COMMIT);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="有状态表达式"><a href="#有状态表达式" class="headerlink" title="有状态表达式"></a>有状态表达式</h5><p>在 nft_set中, 有一个expr字段, 用来存放与该set相关的有状态表达式(stateful expression). 常用的有状态表达式有 limit, counter等</p>
<blockquote>
<p>Stateful objects is nftables’s umbrella term for objects that maintain information about packet flows and connection states, that are updated by each packet that “hits” them, and that share a common syntax. Strictly speaking, stateful object refers to a named object that is attached to a table. More loosely, anonymous stateful objects can also be used, e.g. an unnamed counter used in a rule. Anonymous stateful objects exist only in the context of the object (i.e. rule) in which they are used. </p>
</blockquote>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	struct nft_set - nf_tables set instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	@list: table set list node</span></span><br><span class="line"><span class="comment"> *	@bindings: list of set bindings</span></span><br><span class="line"><span class="comment"> *	@table: table this set belongs to</span></span><br><span class="line"><span class="comment"> *	@net: netnamespace this set belongs to</span></span><br><span class="line"><span class="comment"> * 	@name: name of the set</span></span><br><span class="line"><span class="comment"> *	@handle: unique handle of the set</span></span><br><span class="line"><span class="comment"> * 	@ktype: key type (numeric type defined by userspace, not used in the kernel)</span></span><br><span class="line"><span class="comment"> * 	@dtype: data type (verdict or numeric type defined by userspace)</span></span><br><span class="line"><span class="comment"> * 	@objtype: object type (see NFT_OBJECT_* definitions)</span></span><br><span class="line"><span class="comment"> * 	@size: maximum set size</span></span><br><span class="line"><span class="comment"> *	@field_len: length of each field in concatenation, bytes</span></span><br><span class="line"><span class="comment"> *	@field_count: number of concatenated fields in element</span></span><br><span class="line"><span class="comment"> *	@use: number of rules references to this set</span></span><br><span class="line"><span class="comment"> * 	@nelems: number of elements</span></span><br><span class="line"><span class="comment"> * 	@ndeact: number of deactivated elements queued for removal</span></span><br><span class="line"><span class="comment"> *	@timeout: default timeout value in jiffies</span></span><br><span class="line"><span class="comment"> * 	@gc_int: garbage collection interval in msecs</span></span><br><span class="line"><span class="comment"> *	@policy: set parameterization (see enum nft_set_policies)</span></span><br><span class="line"><span class="comment"> *	@udlen: user data length</span></span><br><span class="line"><span class="comment"> *	@udata: user data</span></span><br><span class="line"><span class="comment"> *	@expr: stateful expression</span></span><br><span class="line"><span class="comment"> * 	@ops: set ops</span></span><br><span class="line"><span class="comment"> * 	@flags: set flags</span></span><br><span class="line"><span class="comment"> *	@genmask: generation mask</span></span><br><span class="line"><span class="comment"> * 	@klen: key length</span></span><br><span class="line"><span class="comment"> * 	@dlen: data length</span></span><br><span class="line"><span class="comment"> * 	@data: private set data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> {</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">bindings</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_table</span>		*<span class="title">table</span>;</span></span><br><span class="line">	<span class="type">possible_net_t</span>			net;</span><br><span class="line">	<span class="type">char</span>				*name;</span><br><span class="line">	u64				handle;</span><br><span class="line">	u32				ktype;</span><br><span class="line">	u32				dtype;</span><br><span class="line">	u32				objtype;</span><br><span class="line">	u32				size;</span><br><span class="line">	u8				field_len[NFT_REG32_COUNT];</span><br><span class="line">	u8				field_count;</span><br><span class="line">	u32				use;</span><br><span class="line">	<span class="type">atomic_t</span>			nelems;</span><br><span class="line">	u32				ndeact;</span><br><span class="line">	u64				timeout;</span><br><span class="line">	u32				gc_int;</span><br><span class="line">	u16				policy;</span><br><span class="line">	u16				udlen;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>			*udata;</span><br><span class="line">	<span class="comment">/* runtime data below here */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ops</span>	*<span class="title">ops</span> ____<span class="title">cacheline_aligned</span>;</span></span><br><span class="line">	u16				flags:<span class="number">14</span>,</span><br><span class="line">					genmask:<span class="number">2</span>;</span><br><span class="line">	u8				klen;</span><br><span class="line">	u8				dlen;</span><br><span class="line">	u8				num_exprs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span>			*<span class="title">exprs</span>[<span class="title">NFT_SET_EXPR_MAX</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">catchall_list</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>			data[]</span><br><span class="line">		__attribute__((aligned(__alignof__(u64))));</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>该字段在nf_tables_newset时根据nla[NFTA_SET_EXPR]或nla[NFTA_SET_EXPRESSIONS]进行创建. 如果创建失败, 跳转到err_set_expr_alloc进行销毁工作.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (nla[NFTA_SET_EXPR]) {</span><br><span class="line">		expr = nft_set_elem_expr_alloc(&amp;ctx, <span class="built_in">set</span>, nla[NFTA_SET_EXPR]);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(expr)) {</span><br><span class="line">			err = PTR_ERR(expr);</span><br><span class="line">			<span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">		}</span><br><span class="line">		<span class="built_in">set</span>-&gt;exprs[<span class="number">0</span>] = expr;</span><br><span class="line">		<span class="built_in">set</span>-&gt;num_exprs++;</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (nla[NFTA_SET_EXPRESSIONS]) {</span><br><span class="line">		<span class="keyword">struct</span> nft_expr *expr;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">nlattr</span> *<span class="title">tmp</span>;</span></span><br><span class="line">		<span class="type">int</span> left;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!(flags &amp; NFT_SET_EXPR)) {</span><br><span class="line">			err = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">		}</span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		nla_for_each_nested(tmp, nla[NFTA_SET_EXPRESSIONS], left) {</span><br><span class="line">			<span class="keyword">if</span> (i == NFT_SET_EXPR_MAX) {</span><br><span class="line">				err = -E2BIG;</span><br><span class="line">				<span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (nla_type(tmp) != NFTA_LIST_ELEM) {</span><br><span class="line">				err = -EINVAL;</span><br><span class="line">				<span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">			}</span><br><span class="line">			expr = nft_set_elem_expr_alloc(&amp;ctx, <span class="built_in">set</span>, tmp);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(expr)) {</span><br><span class="line">				err = PTR_ERR(expr);</span><br><span class="line">				<span class="keyword">goto</span> err_set_expr_alloc;</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">set</span>-&gt;exprs[i++] = expr;</span><br><span class="line">			<span class="built_in">set</span>-&gt;num_exprs++;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">err_set_expr_alloc:</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">set</span>-&gt;num_exprs; i++)</span><br><span class="line">		nft_expr_destroy(&amp;ctx, <span class="built_in">set</span>-&gt;exprs[i]);</span><br><span class="line"></span><br><span class="line">	ops-&gt;destroy(<span class="built_in">set</span>);</span><br><span class="line">err_set_init:</span><br><span class="line">	kfree(<span class="built_in">set</span>-&gt;name);</span><br><span class="line">err_set_name:</span><br><span class="line">	kvfree(<span class="built_in">set</span>);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>创建工作由nft_set_elem_expr_alloc函数完成.</p>
<ul>
<li>先调用nft_expr_init创建表达式<ul>
<li>nf_tables_expr_parse从nla中解析出对应expr_info</li>
<li>为表达式分配空间</li>
<li>nf_tables_newexpr根据expr_info构造实际表达式</li>
</ul>
</li>
<li>检查是否是有状态表达式(NFT_EXPR_STATEFUL), 如果不是调用nft_expr_destroy销毁表达式.</li>
<li>检查是否具有垃圾回收标志, 如果有继续检查一些相关信息, 如相关信息不符则调用nft_expr_destroy销毁表达式.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> nft_expr *<span class="title function_">nft_expr_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span></span><br><span class="line"><span class="params">				      <span class="type">const</span> <span class="keyword">struct</span> nlattr *nla)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_info</span> <span class="title">expr_info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	err = nf_tables_expr_parse(ctx, nla, &amp;expr_info);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err1;</span><br><span class="line"></span><br><span class="line">	err = -ENOMEM;</span><br><span class="line">	expr = kzalloc(expr_info.ops-&gt;size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (expr == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> err2;</span><br><span class="line"></span><br><span class="line">	err = nf_tables_newexpr(ctx, &amp;expr_info, expr);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err3;</span><br><span class="line">......</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> nft_expr *<span class="title function_">nft_set_elem_expr_alloc</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span></span><br><span class="line"><span class="params">					 <span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">					 <span class="type">const</span> <span class="keyword">struct</span> nlattr *attr)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	expr = nft_expr_init(ctx, attr);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(expr))</span><br><span class="line">		<span class="keyword">return</span> expr;</span><br><span class="line"></span><br><span class="line">	err = -EOPNOTSUPP;</span><br><span class="line">	<span class="keyword">if</span> (!(expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_STATEFUL))</span><br><span class="line">		<span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_GC) {</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_TIMEOUT)</span><br><span class="line">			<span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">set</span>-&gt;ops-&gt;gc_init)</span><br><span class="line">			<span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line">		<span class="built_in">set</span>-&gt;ops-&gt;gc_init(<span class="built_in">set</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> expr;</span><br><span class="line"></span><br><span class="line">err_set_elem_expr:</span><br><span class="line">	nft_expr_destroy(ctx, expr);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
表达式的destroy分两步, 调用表达式本身的析构函数和释放表达式占用的内存.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nft_expr_destroy</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx, <span class="keyword">struct</span> nft_expr *expr)</span></span><br><span class="line">{</span><br><span class="line">	nf_tables_expr_destroy(ctx, expr);</span><br><span class="line">	kfree(expr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h5 id="缺失的deactivate-任意表达式构造"><a href="#缺失的deactivate-任意表达式构造" class="headerlink" title="缺失的deactivate / 任意表达式构造"></a>缺失的deactivate / 任意表达式构造</h5><p>综合以上两个主题, 可以发现在err_set_elem_expr中进行的析构操作并不完整, 因为其只有destroy而缺少了deactivate. 但正如之前所说, 并不是所有的表达式都需要deactivate操作, 于是查看所有的有状态表达式, 均不需要deactivate, 所以这里的析构操作没问题.</p>
<p>但和nft_set_elem_expr_alloc配合起来就有问题了, 该函数是先构造表达式, 再进行类型check, 这给了任意表达式构造的原语. 如果构造一个需要deactivate操作的表达式, 这里将只会destroy释放其的空间, 而该表达式依旧悬垂在set-&gt;bindings链表中.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> nft_expr *<span class="title function_">nft_set_elem_expr_alloc</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span></span><br><span class="line"><span class="params">					 <span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">					 <span class="type">const</span> <span class="keyword">struct</span> nlattr *attr)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	expr = nft_expr_init(ctx, attr);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(expr))</span><br><span class="line">		<span class="keyword">return</span> expr;</span><br><span class="line"></span><br><span class="line">	err = -EOPNOTSUPP;</span><br><span class="line">	<span class="keyword">if</span> (!(expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_STATEFUL))</span><br><span class="line">		<span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_GC) {</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_TIMEOUT)</span><br><span class="line">			<span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">set</span>-&gt;ops-&gt;gc_init)</span><br><span class="line">			<span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line">		<span class="built_in">set</span>-&gt;ops-&gt;gc_init(<span class="built_in">set</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> expr;</span><br><span class="line"></span><br><span class="line">err_set_elem_expr:</span><br><span class="line">	nft_expr_destroy(ctx, expr);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h4><p>笔者看完文章后认为原作者的利用方式略显繁琐, 但调繁琐的exp也算是一种锻炼吧. 所以利用过程基本复现原作者的文章.</p>
<p>对于UAF漏洞, 肯定是先看我们还能对UAF的对象进行什么操作. 搜索对set-&gt;bindings的引用, 发现大部分使用的地方都是一些遍历读取和check, 仅有的两处写入是nf_tables_bind_set函数中的入链操作和nf_tables_unbind_set函数中的脱链操作.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">list_add_tail_rcu(&amp;binding-&gt;<span class="built_in">list</span>, &amp;<span class="built_in">set</span>-&gt;bindings);</span><br><span class="line"></span><br><span class="line">list_del_rcu(&amp;binding-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Insert a new entry between two known consecutive entries.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is only for internal list manipulation where we know</span></span><br><span class="line"><span class="comment"> * the prev/next entries already!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_add_rcu(<span class="keyword">struct</span> list_head *new,</span><br><span class="line">		<span class="keyword">struct</span> list_head *prev, <span class="keyword">struct</span> list_head *next)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (!__list_add_valid(new, prev, next))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	new-&gt;next = next;</span><br><span class="line">	new-&gt;prev = prev;</span><br><span class="line">	rcu_assign_pointer(list_next_rcu(prev), new);</span><br><span class="line">	next-&gt;prev = new;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这让我们能构造出类似如下的原语, 即在UAF的表达式的binding链表位置写上另一个表达式或nft_set链表的地址.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nft_xxxx0.nft_set_binding.list_head.prev = &amp;nft_xxxx1.nft_set_binding.list_head</span><br><span class="line"></span><br><span class="line">nft_xxxx0.nft_set_binding.list_head.next = &amp;nft_set.bindings</span><br></pre></td></tr></tbody></table></figure>

<p>查看链表结构在对应表达式中的位置,  nft_lookup的偏移在0x18和0x20, nft_dynset的偏移在0x40和0x48.<br>(排版可能有点难受, maybe你可以将它复制到文本框里查看)</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_lookup</span> {</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *           <span class="title">set</span>;</span>                                                  <span class="comment">/*     0   0x8 */</span></span><br><span class="line">        <span class="comment">/* typedef u8 -&gt; __u8 */</span> <span class="type">unsigned</span> <span class="type">char</span>              sreg;                        <span class="comment">/*   0x8   0x1 */</span></span><br><span class="line">        <span class="comment">/* typedef u8 -&gt; __u8 */</span> <span class="type">unsigned</span> <span class="type">char</span>              dreg;                        <span class="comment">/*   0x9   0x1 */</span></span><br><span class="line">        <span class="comment">/* typedef bool */</span> <span class="type">_Bool</span>                      invert;                            <span class="comment">/*   0xa   0x1 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* XXX 5 bytes hole, try to pack */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span> {</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> {</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> * <span class="title">next</span>;</span>                                         <span class="comment">/*  0x10   0x8 */</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> * <span class="title">prev</span>;</span>                                         <span class="comment">/*  0x18   0x8 */</span></span><br><span class="line">                }<span class="built_in">list</span>; <span class="comment">/*  0x10  0x10 */</span></span><br><span class="line">                <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span>  * <span class="title">chain</span>;</span>                                         <span class="comment">/*  0x20   0x8 */</span></span><br><span class="line">                <span class="comment">/* typedef u32 -&gt; __u32 */</span> <span class="type">unsigned</span> <span class="type">int</span>       flags;                     <span class="comment">/*  0x28   0x4 */</span></span><br><span class="line">        }binding; <span class="comment">/*  0x10  0x20 */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_dynset</span> {</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nft_set</span> *           <span class="title">set</span>;</span>                                                  <span class="comment">/*     0   0x8 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ext_tmpl</span> {</span></span><br><span class="line">                <span class="comment">/* typedef u16 -&gt; __u16 */</span> <span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> len;                       <span class="comment">/*   0x8   0x2 */</span></span><br><span class="line">                <span class="comment">/* typedef u8 -&gt; __u8 */</span> <span class="type">unsigned</span> <span class="type">char</span>      offset[<span class="number">9</span>];                   <span class="comment">/*   0xa   0x9 */</span></span><br><span class="line">        }tmpl; <span class="comment">/*   0x8   0xc */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* XXX last struct has 1 byte of padding */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">nft_dynset_ops</span>        <span class="title">op</span>:</span><span class="number">8</span>;                                                 <span class="comment">/*  0x14: 0 0x4 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Bitfield combined with next fields */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* typedef u8 -&gt; __u8 */</span> <span class="type">unsigned</span> <span class="type">char</span>              sreg_key;                    <span class="comment">/*  0x15   0x1 */</span></span><br><span class="line">        <span class="comment">/* typedef u8 -&gt; __u8 */</span> <span class="type">unsigned</span> <span class="type">char</span>              sreg_data;                   <span class="comment">/*  0x16   0x1 */</span></span><br><span class="line">        <span class="comment">/* typedef bool */</span> <span class="type">_Bool</span>                      invert;                            <span class="comment">/*  0x17   0x1 */</span></span><br><span class="line">        <span class="comment">/* typedef bool */</span> <span class="type">_Bool</span>                      expr;                              <span class="comment">/*  0x18   0x1 */</span></span><br><span class="line">        <span class="comment">/* typedef u8 -&gt; __u8 */</span> <span class="type">unsigned</span> <span class="type">char</span>              num_exprs;                   <span class="comment">/*  0x19   0x1 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* XXX 6 bytes hole, try to pack */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* typedef u64 -&gt; __u64 */</span> <span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>     timeout;                   <span class="comment">/*  0x20   0x8 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *          <span class="title">expr_array</span>[2];</span>                                        <span class="comment">/*  0x28  0x10 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nft_set_binding</span> {</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> {</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> * <span class="title">next</span>;</span>                                         <span class="comment">/*  0x38   0x8 */</span></span><br><span class="line">                        <span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> * <span class="title">prev</span>;</span>                                         <span class="comment">/*  0x40   0x8 */</span></span><br><span class="line">                }<span class="built_in">list</span>; <span class="comment">/*  0x38  0x10 */</span></span><br><span class="line">                <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_chain</span>  * <span class="title">chain</span>;</span>                                         <span class="comment">/*  0x48   0x8 */</span></span><br><span class="line">                <span class="comment">/* typedef u32 -&gt; __u32 */</span> <span class="type">unsigned</span> <span class="type">int</span>       flags;                     <span class="comment">/*  0x50   0x4 */</span></span><br><span class="line">        }binding; <span class="comment">/*  0x38  0x20 */</span></span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> {</span></span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nft_expr_ops</span>  * <span class="title">ops</span>;</span>                <span class="comment">/*     0   0x8 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>              data[] __attribute__((__aligned__(<span class="number">8</span>))); <span class="comment">/*   0x8     0 */</span></span><br><span class="line">} __attribute__((__aligned__(<span class="number">8</span>)));</span><br></pre></td></tr></tbody></table></figure>


<p>以dynset为例, 原作者使用类似如下codeql查询偏移0x40,0x48,0x20,0x28处有指针字段的从kmalloc-(cg)-96中分配的对象</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name kmalloc-96</span></span><br><span class="line"><span class="comment"> * @kind problem</span></span><br><span class="line"><span class="comment"> * @problem.severity warning</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">import cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> FunctionCall fc, Type t, Variable v, Field f, Type t2</span><br><span class="line"><span class="keyword">where</span> (fc.getTarget().hasName("kmalloc") <span class="keyword">or</span></span><br><span class="line">       fc.getTarget().hasName("kzalloc") <span class="keyword">or</span></span><br><span class="line">       fc.getTarget().hasName("kcalloc"))</span><br><span class="line">      <span class="keyword">and</span></span><br><span class="line">      <span class="keyword">exists</span>(Assignment assign <span class="operator">|</span> assign.getRValue() <span class="operator">=</span> fc <span class="keyword">and</span></span><br><span class="line">             assign.getLValue() <span class="operator">=</span> v.getAnAccess() <span class="keyword">and</span></span><br><span class="line">             v.getType().(PointerType).refersToDirectly(t)) <span class="keyword">and</span></span><br><span class="line">      t.getSize() <span class="operator">&lt;=</span> <span class="number">96</span> <span class="keyword">and</span> t.getSize() <span class="operator">&gt;</span> <span class="number">64</span> <span class="keyword">and</span> t.fromSource() <span class="keyword">and</span></span><br><span class="line">      f.getDeclaringType() <span class="operator">=</span> t <span class="keyword">and</span></span><br><span class="line">      (f.getType().(PointerType).refersTo(t2) <span class="keyword">and</span> t2.getSize() <span class="operator">&lt;=</span> <span class="number">8</span>) <span class="keyword">and</span></span><br><span class="line">      (f.getByteOffset() <span class="operator">=</span> <span class="number">72</span>)</span><br><span class="line"><span class="keyword">select</span> fc, t, fc.getLocation()</span><br></pre></td></tr></tbody></table></figure>

<p>最终锁定到了cgroup_fs_context对象, 用cgroup_fs_context占位我们释放的表达式, 再触发入链或脱链操作, 即可修改name或release_agent指针, 再触发cgroup_fs_context_free即可释放掉修改后指针指向的空间.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cgroup_fs_context</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernfs_fs_context</span>   <span class="title">kfc</span>;</span>                  <span class="comment">/*     0    32 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX last struct has 7 bytes of padding */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_root</span> *       <span class="title">root</span>;</span>                 <span class="comment">/*    32     8 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_namespace</span> *  <span class="title">ns</span>;</span>                   <span class="comment">/*    40     8 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>               flags;                <span class="comment">/*    48     4 */</span></span><br><span class="line">    <span class="type">bool</span>                       cpuset_clone_children; <span class="comment">/*    52     1 */</span></span><br><span class="line">    <span class="type">bool</span>                       none;                 <span class="comment">/*    53     1 */</span></span><br><span class="line">    <span class="type">bool</span>                       all_ss;               <span class="comment">/*    54     1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX 1 byte hole, try to pack */</span></span><br><span class="line"></span><br><span class="line">    u16                        subsys_mask;          <span class="comment">/*    56     2 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* XXX 6 bytes hole, try to pack */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">    <span class="type">char</span> *                     name;                 <span class="comment">/*    64     8 */</span></span><br><span class="line">    <span class="type">char</span> *                     release_agent;        <span class="comment">/*    72     8 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size: 80, cachelines: 2, members: 10 */</span></span><br><span class="line">    <span class="comment">/* sum members: 73, holes: 2, sum holes: 7 */</span></span><br><span class="line">    <span class="comment">/* paddings: 1, sum paddings: 7 */</span></span><br><span class="line">    <span class="comment">/* last cacheline: 16 bytes */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cgroup_fs_context_free</span><span class="params">(<span class="keyword">struct</span> fs_context *fc)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_fs_context</span> *<span class="title">ctx</span> =</span> cgroup_fc2context(fc);</span><br><span class="line"></span><br><span class="line">    kfree(ctx-&gt;name);</span><br><span class="line">    kfree(ctx-&gt;release_agent);</span><br><span class="line">    put_cgroup_ns(ctx-&gt;ns);</span><br><span class="line">    kernfs_free_fs_context(fc);</span><br><span class="line">    kfree(ctx);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而如前所述, 该指针有两种可能, &amp;nft_xxxx.nft_set_binding.list_head 和 &amp;nft_set.bindings.</p>
<p>释放前者可以造出下图中的空洞, 再通过如setxattr之类的写入原语即可部分覆写与表达式相邻的目标对象. </p>
<p>但按原作者的想法, 这并不稳定因为不一定能控制target与expression正好相邻.<br>(依我贫瘠的kernel pwn经验, 这种情形其实还算比较稳定, 而且在覆写不致命的情况下完全可以多次覆写, 如<a target="_blank" rel="noopener" href="https://hanqi-blogs.cn/2024/Dig%20into%20Netfilter%20(4)/#EXP">CVE-2022-34918的利用</a>)</p>
<blockquote>
<p>it means we can potentially replace and corrupt the contents of an adjacent target object. It is somewhat bad in that the randomized layout of slabs doesn’t necessarily let us know exactly which target object we will be able to corrupt, which adds extra complexity. We can’t leak what target object is adjacent or test whether or not the expression we are freeing is the last of one slab cache, so using this approach would be blind.</p>
</blockquote>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/_diagrams-overlapping-chunk-3drawio.png"></p>
<p>于是作者决定释放后者, &amp;nft_set.bindings. 这将在nft_set结构中挖出一个0x200大小的空洞. 由于nft_set.bindings仅位于nft_set+0x10的位置, 所以我们近似拥有整个set的控制能力.</p>
<p>其中我们感兴趣的字段有: </p>
<ol>
<li>udata, udlen, 配合可以完成任意虚拟地址读(set没有更新udata的功能, 所以没办法写).</li>
<li>ops, 可以劫持RIP.</li>
</ol>
<p>在任意虚拟地址读之前, 我们需要泄露一些虚拟地址信息. 通过使用user_key_payload来占位UAF的表达式, 触发脱链操作即可在data区域写入一个set地址.</p>
<p>然后用任意虚拟地址读原语读出set的内容即可泄露内核基址.由于测试环境中的nf_tables是直接编译到内核中的, 所以可以直接拿到内核基址. 如果是以模块形式的话, 可能还得修改udlen进行堆上越界读泄露内核基址.</p>
<p>接下来是劫持ops, 其实随意选择即可. 原作者选用gc_init指针, 调用时rdi指向内容可控的set.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nft_set_ops</span> {</span></span><br><span class="line">	<span class="type">bool</span>				(*lookup)(<span class="type">const</span> <span class="keyword">struct</span> net *net,</span><br><span class="line">						  <span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span><br><span class="line">						  <span class="type">const</span> u32 *key,</span><br><span class="line">						  <span class="type">const</span> <span class="keyword">struct</span> nft_set_ext **ext);</span><br><span class="line">	<span class="type">bool</span>				(*update)(<span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span><br><span class="line">						  <span class="type">const</span> u32 *key,</span><br><span class="line">						  <span class="type">void</span> *(*new)(<span class="keyword">struct</span> nft_set *,</span><br><span class="line">							       <span class="type">const</span> <span class="keyword">struct</span> nft_expr *,</span><br><span class="line">							       <span class="keyword">struct</span> nft_regs *),</span><br><span class="line">						  <span class="type">const</span> <span class="keyword">struct</span> nft_expr *expr,</span><br><span class="line">						  <span class="keyword">struct</span> nft_regs *regs,</span><br><span class="line">						  <span class="type">const</span> <span class="keyword">struct</span> nft_set_ext **ext);</span><br><span class="line">	<span class="type">bool</span>				(*delete)(<span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span><br><span class="line">						  <span class="type">const</span> u32 *key);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>				(*insert)(<span class="type">const</span> <span class="keyword">struct</span> net *net,</span><br><span class="line">						  <span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span><br><span class="line">						  <span class="type">const</span> <span class="keyword">struct</span> nft_set_elem *elem,</span><br><span class="line">						  <span class="keyword">struct</span> nft_set_ext **ext);</span><br><span class="line">	<span class="type">void</span>				(*activate)(<span class="type">const</span> <span class="keyword">struct</span> net *net,</span><br><span class="line">						    <span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span><br><span class="line">						    <span class="type">const</span> <span class="keyword">struct</span> nft_set_elem *elem);</span><br><span class="line">	<span class="type">void</span> *				(*deactivate)(<span class="type">const</span> <span class="keyword">struct</span> net *net,</span><br><span class="line">						      <span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span><br><span class="line">						      <span class="type">const</span> <span class="keyword">struct</span> nft_set_elem *elem);</span><br><span class="line">	<span class="type">bool</span>				(*flush)(<span class="type">const</span> <span class="keyword">struct</span> net *net,</span><br><span class="line">						 <span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span><br><span class="line">						 <span class="type">void</span> *priv);</span><br><span class="line">	<span class="type">void</span>				(*remove)(<span class="type">const</span> <span class="keyword">struct</span> net *net,</span><br><span class="line">						  <span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span><br><span class="line">						  <span class="type">const</span> <span class="keyword">struct</span> nft_set_elem *elem);</span><br><span class="line">	<span class="type">void</span>				(*walk)(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span><br><span class="line">						<span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span><br><span class="line">						<span class="keyword">struct</span> nft_set_iter *iter);</span><br><span class="line">	<span class="type">void</span> *				(*get)(<span class="type">const</span> <span class="keyword">struct</span> net *net,</span><br><span class="line">					       <span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span><br><span class="line">					       <span class="type">const</span> <span class="keyword">struct</span> nft_set_elem *elem,</span><br><span class="line">					       <span class="type">unsigned</span> <span class="type">int</span> flags);</span><br><span class="line"></span><br><span class="line">	u64				(*privsize)(<span class="type">const</span> <span class="keyword">struct</span> nlattr * <span class="type">const</span> nla[],</span><br><span class="line">						    <span class="type">const</span> <span class="keyword">struct</span> nft_set_desc *desc);</span><br><span class="line">	<span class="type">bool</span>				(*estimate)(<span class="type">const</span> <span class="keyword">struct</span> nft_set_desc *desc,</span><br><span class="line">						    u32 features,</span><br><span class="line">						    <span class="keyword">struct</span> nft_set_estimate *est);</span><br><span class="line">	<span class="type">int</span>				(*init)(<span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span><br><span class="line">						<span class="type">const</span> <span class="keyword">struct</span> nft_set_desc *desc,</span><br><span class="line">						<span class="type">const</span> <span class="keyword">struct</span> nlattr * <span class="type">const</span> nla[]);</span><br><span class="line">	<span class="type">void</span>				(*destroy)(<span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>);</span><br><span class="line">	<span class="type">void</span>				(*gc_init)(<span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			elemsize;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>gc_init函数在nft_set_elem_expr_alloc中触发, 且表达式需要带有NFT_EXPR_GC标志, 在该版本内核中仅有nft_connlimit表达式带有这一标志. 添加一个nft_connlimit表达式的集合元素, 即可在nf_tables_new_setelem时触发. 注意nft_connlimit表达式对应的内核代码默认是以模块形式编译的, 所以需要提前申请一次, 触发该模块的加载.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> nft_expr *<span class="title function_">nft_set_elem_expr_alloc</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> nft_ctx *ctx,</span></span><br><span class="line"><span class="params">					 <span class="type">const</span> <span class="keyword">struct</span> nft_set *<span class="built_in">set</span>,</span></span><br><span class="line"><span class="params">					 <span class="type">const</span> <span class="keyword">struct</span> nlattr *attr)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nft_expr</span> *<span class="title">expr</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	expr = nft_expr_init(ctx, attr);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(expr))</span><br><span class="line">		<span class="keyword">return</span> expr;</span><br><span class="line"></span><br><span class="line">	err = -EOPNOTSUPP;</span><br><span class="line">	<span class="keyword">if</span> (!(expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_STATEFUL))</span><br><span class="line">		<span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (expr-&gt;ops-&gt;type-&gt;flags &amp; NFT_EXPR_GC) {</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">set</span>-&gt;flags &amp; NFT_SET_TIMEOUT)</span><br><span class="line">			<span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">set</span>-&gt;ops-&gt;gc_init)</span><br><span class="line">			<span class="keyword">goto</span> err_set_elem_expr;</span><br><span class="line">		<span class="built_in">set</span>-&gt;ops-&gt;gc_init(<span class="built_in">set</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> expr;</span><br><span class="line"></span><br><span class="line">err_set_elem_expr:</span><br><span class="line">	nft_expr_destroy(ctx, expr);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>原作者将gc_init指向perf_swevent_del函数, 制造一个任意地址写改modprobe_path提权. 这会造成oops但一般情况下(!panic_on_oops)不会导致内核崩溃.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20241213221454.png"></p>
<p>笔者在这里选择经典的work_for_cpu_fn, 调用一次commit_creds(init_cred)提权.<br>在unshare后这样能否提到”真正”的root笔者暂时还不太确定, 但至少完成user_namespace的切换是没问题的, 因为user_namespace的指针在cred结构中而不是nsproxy. (maybe 接下来会去学一下linux权限控制和namespace的东西).</p>
<p>笔者也尝试了一些传统意义上需要root权限的操作, 也确实都成功了.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20241213221629.png"></p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p>写得比较杂乱(临近期末+写这个exp的用时超出预期, 没时间再改), 这里不贴了, 讲一下流程和细节.<br>完整EXP及测试环境可在这里获取: <a target="_blank" rel="noopener" href="https://github.com/Polaris-Snowfall/kernel_exploit/tree/main/CVE-2022-32250">CVE-2022-32250</a></p>
<ol>
<li>第一次触发UAF write, 将binding_set的地址写入user_key_payload再读出.</li>
<li>第二次触发UAF write, 将binding_set2的地址写入cgroup_fs_context-&gt;release_agent, 释放掉binding_set2.</li>
<li>通过setxattr+fuse修改binding_set2, 使得udata指向刚泄露出的binding_set的地址, nf_tables_getset读出binding_set的内容, 其中可以泄露binding_set.list.prev指向的binding_set2的地址, 以及binding_set.ops.  (一个细节, 为了能dump binding_set2, 需要提前在binding_set的userdata中存放一个name字符串)</li>
<li>再次通过setxattr+fuse修改binding_set2, 劫持ops, 使得在调用gc_init时调用到work_for_cpu_fn(rdi为binding_set2的地址), 调用commit_creds(init_cred)完成提权.</li>
</ol>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20241213214445.png"></p>
<h4 id="something"><a href="#something" class="headerlink" title="something"></a>something</h4><ol>
<li>theori在 <a target="_blank" rel="noopener" href="https://web.archive.org/web/20221126100444/https://blog.theori.io/research/CVE-2022-32250-linux-kernel-lpe-2022/">这篇文章</a>中采用了与原作者不同的利用方式,主要使用了posix_msg_tree_node结构. 先制造一个UAF的expr1, 使用posix_msg_tree_node占据expr1的空间,通过一次UAF write将posix_msg_tree_node.msg_list.next指向另一个UAF的表达式expr2, 用user_key_payload占据expr2空间.  此时user_key_payload.data区域就会被当作msg_msg结构来解释. 这给了我们越界读的机会(由于hardened user copy , 还是只能读相邻的泄露).泄露基址后, 通过msg_msg脱链时进行unlink attack, 改写modprobe_path.</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posix_msg_tree_node</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>      <span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">msg_list</span>;</span></span><br><span class="line">    <span class="type">int</span>         priority;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">long</span> m_type;</span><br><span class="line">    <span class="type">size_t</span> m_ts;        <span class="comment">/* message text size */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> *security;</span><br><span class="line">    <span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* 0    10*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  datalen;    <span class="comment">/* 10   2 */</span></span><br><span class="line">    <span class="comment">/*          padding         */</span></span><br><span class="line">    <span class="type">char</span>    data[] __aligned(__alignof__(u64)); <span class="comment">/* 18   -- */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a target="_blank" rel="noopener" href="https://www.nccgroup.com/us/research-blog/settlers-of-netlink-exploiting-a-limited-uaf-in-nf_tables-cve-2022-32250/">https://www.nccgroup.com/us/research-blog/settlers-of-netlink-exploiting-a-limited-uaf-in-nf_tables-cve-2022-32250/</a><br><a target="_blank" rel="noopener" href="https://web.archive.org/web/20221126100444/https://blog.theori.io/research/CVE-2022-32250-linux-kernel-lpe-2022/">https://web.archive.org/web/20221126100444/https://blog.theori.io/research/CVE-2022-32250-linux-kernel-lpe-2022/</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://polaris-snowfall.github.io/2024/Dig%20into%20Netfilter%20(5)/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Netfilter/" rel="tag">Netfilter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pwn/" rel="tag">Pwn</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2025/Dig%20into%20ebpf(1)/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Dig into ebpf (一)  —— AliyunCTF2025 beebee
          
        </div>
      </a>
    
    
      <a href="/2024/Dig%20into%20Netfilter%20(4)/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Dig into Netfilter (四) —— CVE-2022-34918</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> 翰青HanQi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="北极落小雪"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/About">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>