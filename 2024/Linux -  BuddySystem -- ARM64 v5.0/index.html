<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
        
      <meta name="description" content="Boom? PWN ! ! !" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Linux内核 BuddySystem -- ARM64 v5.0 |  北极落小雪</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
  </html>
</html>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Linux -  BuddySystem -- ARM64 v5.0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Linux内核 BuddySystem -- ARM64 v5.0
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/Linux%20-%20%20BuddySystem%20--%20ARM64%20v5.0/" class="article-date">
  <time datetime="2024-09-17T16:00:00.000Z" itemprop="datePublished">2024-09-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux%E5%86%85%E6%A0%B8/">Linux内核</a> / <a class="article-category-link" href="/categories/Linux%E5%86%85%E6%A0%B8/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">8.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">46 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>ps: 在BuddySystem中所说的”page”指的是order-n的pages.</p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ol>
<li>物理内存是什么时候交给BuddySystem中管理的, 哪些物理内存会由BuddySystem管理?</li>
<li>BuddySystem如何完成一次分配? 由理想情况到恶劣情况?</li>
<li>BuddySystem如何完成一次释放?</li>
</ol>
<span id="more"></span>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="free-area初始化"><a href="#free-area初始化" class="headerlink" title="free_area初始化"></a>free_area初始化</h3><p>free_area管理一个zone中的所有空闲链表, 按照order分成多个 空闲链表的集合 , 每个集合中有MIGRATE_TYPES条链表.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;start_kernel()-&gt;setup_arch()-&gt;bootmem_init()-&gt;zone_sizes_init()-&gt;...-&gt;zone_init_free_lists()&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_migratetype_order(order, type) \</span></span><br><span class="line"><span class="meta">	for (order = 0; order &lt; MAX_ORDER; order++) \</span></span><br><span class="line"><span class="meta">		for (type = 0; type &lt; MIGRATE_TYPES; type++)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __meminit <span class="title function_">zone_init_free_lists</span><span class="params">(<span class="keyword">struct</span> zone *zone)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> order, t;</span><br><span class="line">	for_each_migratetype_order(order, t) {</span><br><span class="line">		INIT_LIST_HEAD(&amp;zone-&gt;free_area[order].free_list[t]);</span><br><span class="line">		zone-&gt;free_area[order].nr_free = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="build-all-zonelists-init"><a href="#build-all-zonelists-init" class="headerlink" title="build_all_zonelists_init"></a>build_all_zonelists_init</h3><p>完成内存分配时需要的node-&gt;zonelists的建立.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;start_kernel()-&gt;build_all_zonelists()&gt;</span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __init</span><br><span class="line"><span class="title function_">build_all_zonelists_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">	__build_all_zonelists(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the boot_pagesets that are going to be used</span></span><br><span class="line"><span class="comment">	 * for bootstrapping processors. The real pagesets for</span></span><br><span class="line"><span class="comment">	 * each zone will be allocated later when the per cpu</span></span><br><span class="line"><span class="comment">	 * allocator is available.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * boot_pagesets are used also for bootstrapping offline</span></span><br><span class="line"><span class="comment">	 * cpus if the system is already booted because the pagesets</span></span><br><span class="line"><span class="comment">	 * are needed to initialize allocators on a specific cpu too.</span></span><br><span class="line"><span class="comment">	 * F.e. the percpu allocator needs the page allocator which</span></span><br><span class="line"><span class="comment">	 * needs the percpu allocator in order to allocate its pagesets</span></span><br><span class="line"><span class="comment">	 * (a chicken-egg dilemma).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	for_each_possible_cpu(cpu)</span><br><span class="line">		setup_pageset(&amp;per_cpu(boot_pageset, cpu), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	mminit_verify_zonelist();</span><br><span class="line">	cpuset_init_current_mems_allowed();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>__build_all_zonelists遍历所有的节点调用build_zonelists</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __build_all_zonelists(<span class="type">void</span> *data)</span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> nid;</span><br><span class="line">	<span class="type">int</span> __maybe_unused cpu;</span><br><span class="line">	<span class="type">pg_data_t</span> *self = data;</span><br><span class="line">	<span class="type">static</span> <span class="title function_">DEFINE_SPINLOCK</span><span class="params">(lock)</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="built_in">memset</span>(node_load, <span class="number">0</span>, <span class="keyword">sizeof</span>(node_load));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This node is hotadded and no memory is yet present.   So just</span></span><br><span class="line"><span class="comment">	 * building zonelists is fine - no need to touch other nodes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (self &amp;&amp; !node_online(self-&gt;node_id)) {</span><br><span class="line">		build_zonelists(self);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		for_each_online_node(nid) {</span><br><span class="line">			<span class="type">pg_data_t</span> *pgdat = NODE_DATA(nid);</span><br><span class="line"></span><br><span class="line">			build_zonelists(pgdat);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_MEMORYLESS_NODES</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We now know the "local memory node" for each node--</span></span><br><span class="line"><span class="comment">		 * i.e., the node of the first zone in the generic zonelist.</span></span><br><span class="line"><span class="comment">		 * Set up numa_mem percpu variable for on-line cpus.  During</span></span><br><span class="line"><span class="comment">		 * boot, only the boot cpu should be on-line;  we'll init the</span></span><br><span class="line"><span class="comment">		 * secondary cpus' numa_mem as they come on-line.  During</span></span><br><span class="line"><span class="comment">		 * node/memory hotplug, we'll fixup all on-line cpus.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		for_each_online_cpu(cpu)</span><br><span class="line">			set_cpu_numa_mem(cpu, local_memory_node(cpu_to_node(cpu)));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	spin_unlock(&amp;lock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>build_zonelists先根据node_distance递增顺序计算出node_order数组,调用build_zonelists_in_node_order.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">build_zonelists</span><span class="params">(<span class="type">pg_data_t</span> *pgdat)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> node_order[MAX_NUMNODES];</span><br><span class="line">	<span class="type">int</span> node, load, nr_nodes = <span class="number">0</span>;</span><br><span class="line">	<span class="type">nodemask_t</span> used_mask;</span><br><span class="line">	<span class="type">int</span> local_node, prev_node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* NUMA-aware ordering of nodes */</span></span><br><span class="line">	local_node = pgdat-&gt;node_id;</span><br><span class="line">	load = nr_online_nodes;</span><br><span class="line">	prev_node = local_node;</span><br><span class="line">	nodes_clear(used_mask);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(node_order, <span class="number">0</span>, <span class="keyword">sizeof</span>(node_order));</span><br><span class="line">	<span class="keyword">while</span> ((node = find_next_best_node(local_node, &amp;used_mask)) &gt;= <span class="number">0</span>) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We don't want to pressure a particular node.</span></span><br><span class="line"><span class="comment">		 * So adding penalty to the first node in same</span></span><br><span class="line"><span class="comment">		 * distance group to make it round-robin.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (node_distance(local_node, node) !=</span><br><span class="line">		    node_distance(local_node, prev_node))</span><br><span class="line">			node_load[node] = load;</span><br><span class="line"></span><br><span class="line">		node_order[nr_nodes++] = node;</span><br><span class="line">		prev_node = node;</span><br><span class="line">		load--;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	build_zonelists_in_node_order(pgdat, node_order, nr_nodes);</span><br><span class="line">	build_thisnode_zonelists(pgdat);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>build_zonelists_in_node_order按顺序遍历node_order数组, 将这些node中被BuddySystem管理的zone加入pgdat-&gt;node_zonelists[ZONELIST_FALLBACK]._zonerefs, 用作内存不足时的回退zone.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Build zonelists ordered by node and zones within node.</span></span><br><span class="line"><span class="comment"> * This results in maximum locality--normal zone overflows into local</span></span><br><span class="line"><span class="comment"> * DMA zone, if any--but risks exhausting DMA zone.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">build_zonelists_in_node_order</span><span class="params">(<span class="type">pg_data_t</span> *pgdat, <span class="type">int</span> *node_order,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> nr_nodes)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">zonerefs</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	zonerefs = pgdat-&gt;node_zonelists[ZONELIST_FALLBACK]._zonerefs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_nodes; i++) {</span><br><span class="line">		<span class="type">int</span> nr_zones;</span><br><span class="line"></span><br><span class="line">		<span class="type">pg_data_t</span> *node = NODE_DATA(node_order[i]);</span><br><span class="line"></span><br><span class="line">		nr_zones = build_zonerefs_node(node, zonerefs);</span><br><span class="line">		zonerefs += nr_zones;</span><br><span class="line">	}</span><br><span class="line">	zonerefs-&gt;zone = <span class="literal">NULL</span>;</span><br><span class="line">	zonerefs-&gt;zone_idx = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>而对于不允许回退的分配(__GFP_THISNODE)来说, 则只允许使用thisnode的zone.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Build gfp_thisnode zonelists</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">build_thisnode_zonelists</span><span class="params">(<span class="type">pg_data_t</span> *pgdat)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">zonerefs</span>;</span></span><br><span class="line">	<span class="type">int</span> nr_zones;</span><br><span class="line"></span><br><span class="line">	zonerefs = pgdat-&gt;node_zonelists[ZONELIST_NOFALLBACK]._zonerefs;</span><br><span class="line">	nr_zones = build_zonerefs_node(pgdat, zonerefs);</span><br><span class="line">	zonerefs += nr_zones;</span><br><span class="line">	zonerefs-&gt;zone = <span class="literal">NULL</span>;</span><br><span class="line">	zonerefs-&gt;zone_idx = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="物理内存交接"><a href="#物理内存交接" class="headerlink" title="物理内存交接"></a>物理内存交接</h3><p>BuddySystem内管理的空间从哪来? 在mem_init时, 通过memblock_free_all释放空闲的物理内存到BuddySystem中.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mem_init() marks the free areas in the mem_map and tells us how much memory</span></span><br><span class="line"><span class="comment"> * is free.  This is done after various parts of the system have claimed their</span></span><br><span class="line"><span class="comment"> * memory after the kernel image.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">mem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (swiotlb_force == SWIOTLB_FORCE ||</span><br><span class="line">	    max_pfn &gt; (arm64_dma_phys_limit &gt;&gt; PAGE_SHIFT))</span><br><span class="line">		swiotlb_init(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		swiotlb_force = SWIOTLB_NO_FORCE;</span><br><span class="line"></span><br><span class="line">	set_max_mapnr(pfn_to_page(max_pfn) - mem_map);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPARSEMEM_VMEMMAP</span></span><br><span class="line">	free_unused_memmap();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* this will put all unused low memory onto the freelists */</span></span><br><span class="line">	memblock_free_all();</span><br><span class="line"></span><br><span class="line">	kexec_reserve_crashkres_pages();</span><br><span class="line"></span><br><span class="line">	mem_init_print_info(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Check boundaries twice: Some fundamental inconsistencies can be</span></span><br><span class="line"><span class="comment">	 * detected at build time already.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	BUILD_BUG_ON(TASK_SIZE_32 &gt; DEFAULT_MAP_WINDOW_64);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (PAGE_SIZE &gt;= <span class="number">16384</span> &amp;&amp; get_num_physpages() &lt;= <span class="number">128</span>) {</span><br><span class="line">		<span class="keyword">extern</span> <span class="type">int</span> sysctl_overcommit_memory;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * On a machine this small we won't get anywhere without</span></span><br><span class="line"><span class="comment">		 * overcommit, so turn it on by default.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sysctl_overcommit_memory = OVERCOMMIT_ALWAYS;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>每个online node的每个zone的managed_pages置0.</li>
<li>free_low_memory_core_early<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * memblock_free_all - release free pages to the buddy allocator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: the number of pages actually released.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __init <span class="title function_">memblock_free_all</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pages;</span><br><span class="line"></span><br><span class="line">	reset_all_zones_managed_pages();</span><br><span class="line"></span><br><span class="line">	pages = free_low_memory_core_early();</span><br><span class="line">	totalram_pages_add(pages);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pages;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>free_low_memory_core_early将memblock中空闲的内存通过__free_pages送入BuddySystem.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> __init <span class="title function_">free_low_memory_core_early</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="type">phys_addr_t</span> start, end;</span><br><span class="line">	u64 i;</span><br><span class="line"></span><br><span class="line">	memblock_clear_hotplug(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	for_each_reserved_mem_region(i, &amp;start, &amp;end)</span><br><span class="line">		reserve_bootmem_region(start, end);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to use NUMA_NO_NODE instead of NODE_DATA(0)-&gt;node_id</span></span><br><span class="line"><span class="comment">	 *  because in some case like Node0 doesn't have RAM installed</span></span><br><span class="line"><span class="comment">	 *  low ram will be on Node1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	for_each_free_mem_range(i, NUMA_NO_NODE, MEMBLOCK_NONE, &amp;start, &amp;end,</span><br><span class="line">				<span class="literal">NULL</span>)</span><br><span class="line">		count += __free_memory_core(start, end);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init __free_pages_boot_core(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order)</span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nr_pages = <span class="number">1</span> &lt;&lt; order;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">p</span> =</span> page;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> loop;</span><br><span class="line"></span><br><span class="line">	prefetchw(p);</span><br><span class="line">	<span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; (nr_pages - <span class="number">1</span>); loop++, p++) {</span><br><span class="line">		prefetchw(p + <span class="number">1</span>);</span><br><span class="line">		__ClearPageReserved(p);</span><br><span class="line">		set_page_count(p, <span class="number">0</span>);</span><br><span class="line">	}</span><br><span class="line">	__ClearPageReserved(p);</span><br><span class="line">	set_page_count(p, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	atomic_long_add(nr_pages, &amp;page_zone(page)-&gt;managed_pages);</span><br><span class="line">	set_page_refcounted(page);</span><br><span class="line">	__free_pages(page, order);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="页面分配"><a href="#页面分配" class="headerlink" title="页面分配"></a>页面分配</h2><p>页面分配的最外层api是alloc_pages.<br>它获取当前CPU对应的node,调用alloc_pages_node.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_pages(gfp_mask, order) \</span></span><br><span class="line"><span class="meta">		alloc_pages_node(numa_node_id(), gfp_mask, order) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the number of the current Node. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">numa_node_id</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> raw_cpu_read(numa_node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>再转入页面分配的核心函数__alloc_pages_nodemask.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the 'heart' of the zoned buddy allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">							<span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> alloc_flags = ALLOC_WMARK_LOW; <span class="comment">//水位至少达到LOW才进行本次分配</span></span><br><span class="line">	<span class="type">gfp_t</span> alloc_mask; <span class="comment">/* The gfp_t that was actually used for allocation */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> { };</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * There are several places where we assume that the order value is sane</span></span><br><span class="line"><span class="comment">	 * so bail out early if the request is out of bound.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) {</span><br><span class="line">		WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	gfp_mask &amp;= gfp_allowed_mask;</span><br><span class="line">	alloc_mask = gfp_mask;</span><br><span class="line">	<span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	finalise_ac(gfp_mask, &amp;ac);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Forbid the first pass from falling back to types that fragment</span></span><br><span class="line"><span class="comment">	 * memory until all local zones are considered.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* First allocation attempt */</span></span><br><span class="line">	page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">	<span class="keyword">if</span> (likely(page))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Apply scoped allocation constraints. This is mainly about GFP_NOFS</span></span><br><span class="line"><span class="comment">	 * resp. GFP_NOIO which has to be inherited for all allocation requests</span></span><br><span class="line"><span class="comment">	 * from a particular context which has been marked by</span></span><br><span class="line"><span class="comment">	 * memalloc_no{fs,io}_{save,restore}.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_mask = current_gfp_context(gfp_mask);</span><br><span class="line">	ac.spread_dirty_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Restore the original nodemask if it was potentially replaced with</span></span><br><span class="line"><span class="comment">	 * &amp;cpuset_current_mems_allowed to optimize the fast-path attempt.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ac.nodemask != nodemask))</span><br><span class="line">		ac.nodemask = nodemask;</span><br><span class="line"></span><br><span class="line">	page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp_mask &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;</span><br><span class="line">	    unlikely(memcg_kmem_charge(page, gfp_mask, order) != <span class="number">0</span>)) {</span><br><span class="line">		__free_pages(page, order);</span><br><span class="line">		page = <span class="literal">NULL</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL(__alloc_pages_nodemask);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="内存分配准备"><a href="#内存分配准备" class="headerlink" title="内存分配准备"></a>内存分配准备</h3><p>首先prepare_alloc_pages设置alloc_flags和alloc_context, 并进行一些早期的检查.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">prepare_alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> preferred_nid, <span class="type">nodemask_t</span> *nodemask,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> alloc_context *ac, <span class="type">gfp_t</span> *alloc_mask,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> *alloc_flags)</span></span><br><span class="line">{</span><br><span class="line">	ac-&gt;high_zoneidx = gfp_zone(gfp_mask); <span class="comment">//内存分配最高优先级的zone</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//当前CPU所在节点以及其所有备用节点中允许内存分配的内存区域.若指定了__GFP_THISNODE, 则只使用当前node的zonelist.</span></span><br><span class="line">	ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask); </span><br><span class="line">	ac-&gt;nodemask = nodemask;</span><br><span class="line">	ac-&gt;migratetype = gfpflags_to_migratetype(gfp_mask);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果当前进程被绑定到了某些CPU上, 则内存分配只能在这些CPU对应的node中进行</span></span><br><span class="line">	<span class="keyword">if</span> (cpusets_enabled()) {</span><br><span class="line">		*alloc_mask |= __GFP_HARDWALL;</span><br><span class="line">		<span class="keyword">if</span> (!ac-&gt;nodemask)</span><br><span class="line">			ac-&gt;nodemask = &amp;cpuset_current_mems_allowed;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*alloc_flags |= ALLOC_CPUSET;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	fs_reclaim_acquire(gfp_mask);</span><br><span class="line">	fs_reclaim_release(gfp_mask);</span><br><span class="line"></span><br><span class="line">	might_sleep_if(gfp_mask &amp; __GFP_DIRECT_RECLAIM);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (should_fail_alloc_page(gfp_mask, order))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_CMA) &amp;&amp; ac-&gt;migratetype == MIGRATE_MOVABLE)</span><br><span class="line">		*alloc_flags |= ALLOC_CMA;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>finalise_ac进一步设置ac的spread_dirty_pages,preferred_zoneref, 确定首选的zone.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine whether to spread dirty pages and what the first usable zone */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">finalise_ac</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="keyword">struct</span> alloc_context *ac)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">/* Dirty zone balancing only done in the fast path */</span></span><br><span class="line">	ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The preferred zone is used for statistics but crucially it is</span></span><br><span class="line"><span class="comment">	 * also used as the starting point for the zonelist iterator. It</span></span><br><span class="line"><span class="comment">	 * may get reset for allocations that ignore memory policies.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">					ac-&gt;high_zoneidx, ac-&gt;nodemask);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h3 id="get-page-from-freelist-fastpath"><a href="#get-page-from-freelist-fastpath" class="headerlink" title="get_page_from_freelist (fastpath)"></a>get_page_from_freelist (fastpath)</h3><ul>
<li>遍历符合high_zoneidx和nodemask的zone<ul>
<li>检查当前允许的CPU是否在zone所在节点上</li>
<li>检查分配后该zone是否满足脏页限制</li>
<li>判断本次分配是否需要允许内存碎片</li>
<li>检查当前zone剩余空间是否在指定水位线以上<ul>
<li>若否则进行内存回收</li>
<li>若是则尝试从该zone进行分配</li>
</ul>
</li>
</ul>
</li>
<li>尝试从该zone进行分配<ul>
<li>rmqueue从zone中取出page</li>
<li>prep_new_page初始化新页面</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * get_page_from_freelist goes through the zonelist trying to allocate</span></span><br><span class="line"><span class="comment"> * a page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *</span><br><span class="line"><span class="title function_">get_page_from_freelist</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">						<span class="type">const</span> <span class="keyword">struct</span> alloc_context *ac)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">last_pgdat_dirty_limit</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span> no_fallback;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Scan zonelist, looking for a zone with enough free.</span></span><br><span class="line"><span class="comment">	 * See also __cpuset_node_allowed() comment in kernel/cpuset.c.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;</span><br><span class="line">	z = ac-&gt;preferred_zoneref;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历符合high_zoneidx和nodemask的zone.</span></span><br><span class="line">	for_next_zone_zonelist_nodemask(zone, z, ac-&gt;zonelist, ac-&gt;high_zoneidx,</span><br><span class="line">								ac-&gt;nodemask) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> mark;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前允许的CPU是否在zone所在节点上</span></span><br><span class="line">		<span class="keyword">if</span> (cpusets_enabled() &amp;&amp;</span><br><span class="line">			(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;</span><br><span class="line">			!__cpuset_zone_allowed(zone, gfp_mask))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * When allocating a page cache page for writing, we</span></span><br><span class="line"><span class="comment">		 * want to get it from a node that is within its dirty</span></span><br><span class="line"><span class="comment">		 * limit, such that no single node holds more than its</span></span><br><span class="line"><span class="comment">		 * proportional share of globally allowed dirty pages.</span></span><br><span class="line"><span class="comment">		 * The dirty limits take into account the node's</span></span><br><span class="line"><span class="comment">		 * lowmem reserves and high watermark so that kswapd</span></span><br><span class="line"><span class="comment">		 * should be able to balance it without having to</span></span><br><span class="line"><span class="comment">		 * write pages from its LRU list.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">XXX:</span> For now, allow allocations to potentially</span></span><br><span class="line"><span class="comment">		 * exceed the per-node dirty limit in the slowpath</span></span><br><span class="line"><span class="comment">		 * (spread_dirty_pages unset) before going into reclaim,</span></span><br><span class="line"><span class="comment">		 * which is important when on a NUMA setup the allowed</span></span><br><span class="line"><span class="comment">		 * nodes are together not big enough to reach the</span></span><br><span class="line"><span class="comment">		 * global limit.  The proper fix for these situations</span></span><br><span class="line"><span class="comment">		 * will require awareness of nodes in the</span></span><br><span class="line"><span class="comment">		 * dirty-throttling and the flusher threads.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// 脏页限制, 见上方解释</span></span><br><span class="line">		<span class="keyword">if</span> (ac-&gt;spread_dirty_pages) {</span><br><span class="line">			<span class="keyword">if</span> (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!node_dirty_ok(zone-&gt;zone_pgdat)) {</span><br><span class="line">				last_pgdat_dirty_limit = zone-&gt;zone_pgdat;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要回退到其他节点分配, 那么允许内存碎片, 因为内核认为本地性比避免内存碎片更重要</span></span><br><span class="line">        <span class="comment">// (笔者并没看出在这里这么设计的作用...)</span></span><br><span class="line">		<span class="keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">		    zone != ac-&gt;preferred_zoneref-&gt;zone) {</span><br><span class="line">			<span class="type">int</span> local_nid;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If moving to a remote node, retry but allow</span></span><br><span class="line"><span class="comment">			 * fragmenting fallbacks. Locality is more important</span></span><br><span class="line"><span class="comment">			 * than fragmentation avoidance.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);</span><br><span class="line">			<span class="keyword">if</span> (zone_to_nid(zone) != local_nid) {</span><br><span class="line">				alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">				<span class="keyword">goto</span> retry;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line">        <span class="comment">// 检查当前zone剩余空间是否在指定水位线以上, 满足返回true.</span></span><br><span class="line">		<span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">				       ac_classzone_idx(ac), alloc_flags)) {</span><br><span class="line">			<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Watermark failed for this zone, but see if we can</span></span><br><span class="line"><span class="comment">			 * grow this zone if it contains deferred pages.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) {</span><br><span class="line">				<span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line">			}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="comment">/* Checked here to keep the fast path fast */</span></span><br><span class="line">			BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);</span><br><span class="line">			<span class="comment">// 如果制定了ALLOC_NO_WATERMARKS, 直接尝试从该zone分配</span></span><br><span class="line">			<span class="keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)</span><br><span class="line">				<span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (node_reclaim_mode == <span class="number">0</span> ||</span><br><span class="line">			    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行内存回收</span></span><br><span class="line">			ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line">			<span class="keyword">switch</span> (ret) {</span><br><span class="line">			<span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line">				<span class="comment">/* did not scan */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line">				<span class="comment">/* scanned but unreclaimable */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">/* did we reclaim enough */</span></span><br><span class="line">				<span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,</span><br><span class="line">						ac_classzone_idx(ac), alloc_flags))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">try_this_zone:</span><br><span class="line">        <span class="comment">// 尝试从该zone进行分配</span></span><br><span class="line">		page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">				gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化新页面</span></span><br><span class="line">		<span class="keyword">if</span> (page) {</span><br><span class="line">			prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If this is a high-order atomic allocation then check</span></span><br><span class="line"><span class="comment">			 * if the pageblock should be reserved for the future</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))</span><br><span class="line">				reserve_highatomic_pageblock(page, zone, order);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> page;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">			<span class="comment">/* Try again if zone has deferred pages */</span></span><br><span class="line">			<span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) {</span><br><span class="line">				<span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line">			}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It's possible on a UMA machine to get through all zones that are</span></span><br><span class="line"><span class="comment">	 * fragmented. If avoiding fragmentation, reset and try again.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (no_fallback) {</span><br><span class="line">		alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prep_new_page</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">gfp_t</span> gfp_flags,</span></span><br><span class="line"><span class="params">							<span class="type">unsigned</span> <span class="type">int</span> alloc_flags)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	post_alloc_hook(page, order, gfp_flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!free_pages_prezeroed() &amp;&amp; (gfp_flags &amp; __GFP_ZERO))</span><br><span class="line">    <span class="comment">// 清空页面</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; order); i++)</span><br><span class="line">			clear_highpage(page + i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (order &amp;&amp; (gfp_flags &amp; __GFP_COMP))</span><br><span class="line">	<span class="comment">// 初始化复合页</span></span><br><span class="line">		prep_compound_page(page, order);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * page is set pfmemalloc when ALLOC_NO_WATERMARKS was necessary to</span></span><br><span class="line"><span class="comment">	 * allocate the page. The expectation is that the caller is taking</span></span><br><span class="line"><span class="comment">	 * steps that will free more memory. The caller should avoid the page</span></span><br><span class="line"><span class="comment">	 * being used for !PFMEMALLOC purposes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)</span><br><span class="line">	<span class="comment">//设置pfmemalloc标志.</span></span><br><span class="line">		set_page_pfmemalloc(page);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clear_page_pfmemalloc(page);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="rmqueue"><a href="#rmqueue" class="headerlink" title="rmqueue"></a>rmqueue</h4><p>rmqueue是实质性从指定zone中完成一次分配的操作, 涉及过程较复杂(且dispatch很多, 分析着会比较乱), 是BuddySystem的核心分配逻辑.</p>
<h5 id="rmqueue-pcplist"><a href="#rmqueue-pcplist" class="headerlink" title="rmqueue_pcplist"></a>rmqueue_pcplist</h5><p>首先, 对于order为0的分配, 使用pcplist而不是传统意义上的BuddySystem.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rmqueue</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">			<span class="type">gfp_t</span> gfp_flags, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> migratetype)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(order == <span class="number">0</span>)) {</span><br><span class="line">		page = rmqueue_pcplist(preferred_zone, zone, order,</span><br><span class="line">				gfp_flags, migratetype, alloc_flags);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>



<p>__rmqueue_pcplist: 如果对应pcp_list不为空, 取出第一个page.否则调用rmqueue_bulk向BuddySystem请求pcp-&gt;batch个页面加入到pcp_list中, 然后再正常取出第一个page.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove page from the per-cpu list, caller must protect the list */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_pcplist</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class">			<span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> {</span><br><span class="line">		<span class="keyword">if</span> (list_empty(<span class="built_in">list</span>)) {</span><br><span class="line">			pcp-&gt;count += rmqueue_bulk(zone, <span class="number">0</span>,</span><br><span class="line">					pcp-&gt;batch, <span class="built_in">list</span>,</span><br><span class="line">					migratetype, alloc_flags);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(list_empty(<span class="built_in">list</span>)))</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		page = list_first_entry(<span class="built_in">list</span>, <span class="keyword">struct</span> page, lru);</span><br><span class="line">		list_del(&amp;page-&gt;lru);</span><br><span class="line">		pcp-&gt;count--;</span><br><span class="line">	} <span class="keyword">while</span> (check_new_pcp(page));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>rmqueue_bulk可以看作对__rmqueue的一个循环wrapper</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Obtain a specified number of elements from the buddy allocator, all under</span></span><br><span class="line"><span class="comment"> * a single hold of the lock, for efficiency.  Add them to the supplied list.</span></span><br><span class="line"><span class="comment"> * Returns the number of new pages which were placed at *list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rmqueue_bulk</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> count, <span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> migratetype, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i, alloced = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;zone-&gt;lock);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; ++i) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> __rmqueue(zone, order, migratetype,</span><br><span class="line">								alloc_flags);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(page == <span class="literal">NULL</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(check_pcp_refill(page)))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Split buddy pages returned by expand() are received here in</span></span><br><span class="line"><span class="comment">		 * physical page order. The page is added to the tail of</span></span><br><span class="line"><span class="comment">		 * caller's list. From the callers perspective, the linked list</span></span><br><span class="line"><span class="comment">		 * is ordered by page number under some conditions. This is</span></span><br><span class="line"><span class="comment">		 * useful for IO devices that can forward direction from the</span></span><br><span class="line"><span class="comment">		 * head, thus also in the physical page order. This is useful</span></span><br><span class="line"><span class="comment">		 * for IO devices that can merge IO requests if the physical</span></span><br><span class="line"><span class="comment">		 * pages are ordered properly.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		list_add_tail(&amp;page-&gt;lru, <span class="built_in">list</span>);</span><br><span class="line">		alloced++;</span><br><span class="line">		<span class="keyword">if</span> (is_migrate_cma(get_pcppage_migratetype(page)))</span><br><span class="line">			__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,</span><br><span class="line">					      -(<span class="number">1</span> &lt;&lt; order));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * i pages were removed from the buddy list even if some leak due</span></span><br><span class="line"><span class="comment">	 * to check_pcp_refill failing so adjust NR_FREE_PAGES based</span></span><br><span class="line"><span class="comment">	 * on i. Do not confuse with 'alloced' which is the number of</span></span><br><span class="line"><span class="comment">	 * pages added to the pcp list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__mod_zone_page_state(zone, NR_FREE_PAGES, -(i &lt;&lt; order));</span><br><span class="line">	spin_unlock(&amp;zone-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> alloced;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<p>__rmqueue:</p>
<ul>
<li>调用__rmqueue_smallest<ul>
<li>从当前order的free_area开始遍历<ul>
<li>若area-&gt;free_list[migratetype]为空, 则尝试从下一级order获取页面.</li>
<li>直到获取到页面<ul>
<li>将页面从链表中移除</li>
<li>page-&gt;private=0</li>
<li>调用expand将页面展开, 填充低order的free_area.</li>
<li>page-&gt;index=migratetype</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果没获取到, 且迁移类型为MIGRATE_MOVABLE, 则尝试回退分配__rmqueue_smallest(zone, order, MIGRATE_CMA)</li>
<li>如果还是没分配到, 调用__rmqueue_fallback继续分配,该函数较复杂, 不在这里分析.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do the hard work of removing an element from the buddy allocator.</span></span><br><span class="line"><span class="comment"> * Call me with the zone-&gt;lock already held.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">rmqueue</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class">						<span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	page = __rmqueue_smallest(zone, order, migratetype);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!page)) {</span><br><span class="line">		<span class="keyword">if</span> (migratetype == MIGRATE_MOVABLE)</span><br><span class="line">			page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,</span><br><span class="line">								alloc_flags))</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Go through the free lists for the given migratetype and remove</span></span><br><span class="line"><span class="comment"> * the smallest available page from the freelists</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_smallest</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">						<span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> current_order;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find a page of the appropriate size in the preferred list */</span></span><br><span class="line">	<span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) {</span><br><span class="line">		area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">		page = list_first_entry_or_null(&amp;area-&gt;free_list[migratetype],</span><br><span class="line">							<span class="keyword">struct</span> page, lru);</span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		list_del(&amp;page-&gt;lru);</span><br><span class="line">		rmv_page_order(page);</span><br><span class="line">		area-&gt;nr_free--;</span><br><span class="line">		expand(zone, page, order, current_order, area, migratetype);</span><br><span class="line">		set_pcppage_migratetype(page, migratetype);</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p>其中expand的操作与”Buddy”一词联系紧密.<br>从本次实际获取到的页面的order开始递减, 直到达到本次请求的order, 将当前页面分成两半, 每次将后一部分加入<br>area[cur_order]-&gt;freelist[migratetype], 并设置page-&gt;private=cur_order.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The order of subdivision here is critical for the IO subsystem.</span></span><br><span class="line"><span class="comment"> * Please do not alter this order without good reasons and regression</span></span><br><span class="line"><span class="comment"> * testing. Specifically, as large blocks of memory are subdivided,</span></span><br><span class="line"><span class="comment"> * the order in which smaller blocks are delivered depends on the order</span></span><br><span class="line"><span class="comment"> * they're subdivided in this function. This is the primary factor</span></span><br><span class="line"><span class="comment"> * influencing the order in which pages are delivered to the IO</span></span><br><span class="line"><span class="comment"> * subsystem according to empirical testing, and this is also justified</span></span><br><span class="line"><span class="comment"> * by considering the behavior of a buddy system containing a single</span></span><br><span class="line"><span class="comment"> * large block of memory acted on by a series of small allocations.</span></span><br><span class="line"><span class="comment"> * This behavior is a critical factor in sglist merging's success.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- nyc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">expand</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> low, <span class="type">int</span> high, <span class="keyword">struct</span> free_area *area,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> migratetype)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> size = <span class="number">1</span> &lt;&lt; high;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (high &gt; low) {</span><br><span class="line">		area--;</span><br><span class="line">		high--;</span><br><span class="line">		size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Mark as guard pages (or page), that will allow to</span></span><br><span class="line"><span class="comment">		 * merge back to allocator when buddy will be freed.</span></span><br><span class="line"><span class="comment">		 * Corresponding page table entries will not be touched,</span></span><br><span class="line"><span class="comment">		 * pages will stay not present in virtual address space</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		list_add(&amp;page[size].lru, &amp;area-&gt;free_list[migratetype]);</span><br><span class="line">		area-&gt;nr_free++;</span><br><span class="line">		set_page_order(&amp;page[size], high);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下方是一个分配前后的例子. 请求的是order 0的页面.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20240916212533.png"></p>
<h5 id="常规分配"><a href="#常规分配" class="headerlink" title="常规分配"></a>常规分配</h5><p>(分割线以下）<br>如果指定了ALLOC_HARDER策略, 则尝试从MIGRATE_HIGHATOMIC迁移类型进行分配.<br>否则调用__rmqueue(上文分析过)</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rmqueue</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">			<span class="type">gfp_t</span> gfp_flags, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> migratetype)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(order == <span class="number">0</span>)) {</span><br><span class="line">		page = rmqueue_pcplist(preferred_zone, zone, order,</span><br><span class="line">				gfp_flags, migratetype, alloc_flags);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We most definitely don't want callers attempting to</span></span><br><span class="line"><span class="comment">	 * allocate greater than order-1 page units with __GFP_NOFAIL.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="number">1</span>));</span><br><span class="line">	spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> {</span><br><span class="line">		page = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (alloc_flags &amp; ALLOC_HARDER) {</span><br><span class="line">			page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);</span><br><span class="line">			<span class="keyword">if</span> (page)</span><br><span class="line">				trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">			page = __rmqueue(zone, order, migratetype, alloc_flags);</span><br><span class="line">	} <span class="keyword">while</span> (page &amp;&amp; check_new_pages(page, order));</span><br></pre></td></tr></tbody></table></figure>


<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20240917140348.png"></p>
<h5 id="rmqueue-fallback"><a href="#rmqueue-fallback" class="headerlink" title="__rmqueue_fallback"></a>__rmqueue_fallback</h5><p>接下来分析回退处理.</p>
<p>有一个fallbacks二维数组, 指示当某个迁移类型的页面分配失败时, 可以回退到的其他迁移类型.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This array describes the order lists are fallen back to when</span></span><br><span class="line"><span class="comment"> * the free lists for the desirable migrate type are depleted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fallbacks[MIGRATE_TYPES][<span class="number">4</span>] = {</span><br><span class="line">	[MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_TYPES },</span><br><span class="line">	[MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES },</span><br><span class="line">	[MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_TYPES },</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">	[MIGRATE_CMA]         = { MIGRATE_TYPES }, <span class="comment">/* Never used */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	[MIGRATE_ISOLATE]     = { MIGRATE_TYPES }, <span class="comment">/* Never used */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p>find_suitable_fallback函数查找适合的回退页。如果找到合适的页，则返回对应的迁移类型.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check whether there is a suitable fallback freepage with requested order.</span></span><br><span class="line"><span class="comment"> * If only_stealable is true, this function returns fallback_mt only if</span></span><br><span class="line"><span class="comment"> * we can steal other freepages all together. This would help to reduce</span></span><br><span class="line"><span class="comment"> * fragmentation due to mixed migratetype pages in one pageblock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_suitable_fallback</span><span class="params">(<span class="keyword">struct</span> free_area *area, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">			<span class="type">int</span> migratetype, <span class="type">bool</span> only_stealable, <span class="type">bool</span> *can_steal)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> fallback_mt;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (area-&gt;nr_free == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	*can_steal = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;; i++) {</span><br><span class="line">		fallback_mt = fallbacks[migratetype][i];</span><br><span class="line">		<span class="keyword">if</span> (fallback_mt == MIGRATE_TYPES)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (list_empty(&amp;area-&gt;free_list[fallback_mt]))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (can_steal_fallback(order, migratetype))</span><br><span class="line">			*can_steal = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!only_stealable)</span><br><span class="line">			<span class="keyword">return</span> fallback_mt;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (*can_steal)</span><br><span class="line">			<span class="keyword">return</span> fallback_mt;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>这里的适合有两个含义. </p>
<ol>
<li>新的migratetype在原本的migratetype的fallback数组中</li>
<li>can_steal_fallback: 能否偷取整个页块. (有不能偷取整个页块但”适合”的例外)<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When we are falling back to another migratetype during allocation, try to</span></span><br><span class="line"><span class="comment"> * steal extra free pages from the same pageblocks to satisfy further</span></span><br><span class="line"><span class="comment"> * allocations, instead of polluting multiple pageblocks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If we are stealing a relatively large buddy page, it is likely there will</span></span><br><span class="line"><span class="comment"> * be more free pages in the pageblock, so try to steal them all. For</span></span><br><span class="line"><span class="comment"> * reclaimable and unmovable allocations, we steal regardless of page size,</span></span><br><span class="line"><span class="comment"> * as fragmentation caused by those allocations polluting movable pageblocks</span></span><br><span class="line"><span class="comment"> * is worse than movable allocations stealing from unmovable and reclaimable</span></span><br><span class="line"><span class="comment"> * pageblocks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 当我们偷取相对较大的伙伴页时, 页块中可能会出现更多的空闲页, 所以尝试偷取全部空闲页.</span></span><br><span class="line"><span class="comment">// 对于对可回收类型和不可移动类型的分配, 则不考虑页面大小.(注释这里的解释笔者暂时还没理解)</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">can_steal_fallback</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">int</span> start_mt)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Leaving this order check is intended, although there is</span></span><br><span class="line"><span class="comment">	 * relaxed order check in next check. The reason is that</span></span><br><span class="line"><span class="comment">	 * we can actually steal whole pageblock if this condition met,</span></span><br><span class="line"><span class="comment">	 * but, below check doesn't guarantee it and that is just heuristic</span></span><br><span class="line"><span class="comment">	 * so could be changed anytime.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (order &gt;= pageblock_order)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (order &gt;= pageblock_order / <span class="number">2</span> ||</span><br><span class="line">		start_mt == MIGRATE_RECLAIMABLE ||</span><br><span class="line">		start_mt == MIGRATE_UNMOVABLE ||</span><br><span class="line">		page_group_by_mobility_disabled)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>__rmqueue_fallback:</p>
<ul>
<li>先从高order遍历, 尝试找到最大的合适的可回退页类型.<ul>
<li>若找到合适的页面, 调用steal_suitable_fallback.</li>
<li>如果不能从页块中窃取所有空闲页，并且请求的迁移类型是可移动的, 那么为了防止永久碎片, 从低order遍历尝试找到最小的合适的可回退页类型.</li>
<li>否则返回false, 回退分配失败.<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Try finding a free buddy page on the fallback list and put it on the free</span></span><br><span class="line"><span class="comment"> * list of requested migratetype, possibly along with other pages from the same</span></span><br><span class="line"><span class="comment"> * block, depending on fragmentation avoidance heuristics. Returns true if</span></span><br><span class="line"><span class="comment"> * fallback was found so that __rmqueue_smallest() can grab it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The use of signed ints for order and current_order is a deliberate</span></span><br><span class="line"><span class="comment"> * deviation from the rest of this file, to make the for loop</span></span><br><span class="line"><span class="comment"> * condition simpler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span></span><br><span class="line">__rmqueue_fallback(<span class="keyword">struct</span> zone *zone, <span class="type">int</span> order, <span class="type">int</span> start_migratetype,</span><br><span class="line">						<span class="type">unsigned</span> <span class="type">int</span> alloc_flags)</span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line">	<span class="type">int</span> current_order;</span><br><span class="line">	<span class="type">int</span> min_order = order;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">int</span> fallback_mt;</span><br><span class="line">	<span class="type">bool</span> can_steal;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do not steal pages from freelists belonging to other pageblocks</span></span><br><span class="line"><span class="comment">	 * i.e. orders &lt; pageblock_order. If there are no local zones free,</span></span><br><span class="line"><span class="comment">	 * the zonelists will be reiterated without ALLOC_NOFRAGMENT.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_NOFRAGMENT)</span><br><span class="line">		min_order = pageblock_order;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Find the largest available free page in the other list. This roughly</span></span><br><span class="line"><span class="comment">	 * approximates finding the pageblock with the most free pages, which</span></span><br><span class="line"><span class="comment">	 * would be too costly to do exactly.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (current_order = MAX_ORDER - <span class="number">1</span>; current_order &gt;= min_order;</span><br><span class="line">				--current_order) {</span><br><span class="line">		area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">		fallback_mt = find_suitable_fallback(area, current_order,</span><br><span class="line">				start_migratetype, <span class="literal">false</span>, &amp;can_steal);</span><br><span class="line">		<span class="keyword">if</span> (fallback_mt == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We cannot steal all free pages from the pageblock and the</span></span><br><span class="line"><span class="comment">		 * requested migratetype is movable. In that case it's better to</span></span><br><span class="line"><span class="comment">		 * steal and split the smallest available page instead of the</span></span><br><span class="line"><span class="comment">		 * largest available page, because even if the next movable</span></span><br><span class="line"><span class="comment">		 * allocation falls back into a different pageblock than this</span></span><br><span class="line"><span class="comment">		 * one, it won't cause permanent fragmentation.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 我们不能从页块中窃取所有空闲页，并且请求的迁移类型是可移动的。</span></span><br><span class="line"><span class="comment">         * 在这种情况下，窃取并拆分最小的可用页比窃取最大的可用页更好，</span></span><br><span class="line"><span class="comment">         * 因为即使下一次可移动的分配退回到不同的页块，也不会造成永久性的碎片化。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="keyword">if</span> (!can_steal &amp;&amp; start_migratetype == MIGRATE_MOVABLE</span><br><span class="line">					&amp;&amp; current_order &gt; order)</span><br><span class="line">			<span class="keyword">goto</span> find_smallest;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> do_steal;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">find_smallest:</span><br><span class="line">	<span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER;</span><br><span class="line">							current_order++) {</span><br><span class="line">		area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">		fallback_mt = find_suitable_fallback(area, current_order,</span><br><span class="line">				start_migratetype, <span class="literal">false</span>, &amp;can_steal);</span><br><span class="line">		<span class="keyword">if</span> (fallback_mt != <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This should not happen - we already found a suitable fallback</span></span><br><span class="line"><span class="comment">	 * when looking for the largest page.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	VM_BUG_ON(current_order == MAX_ORDER);</span><br><span class="line"></span><br><span class="line">do_steal:</span><br><span class="line">	page = list_first_entry(&amp;area-&gt;free_list[fallback_mt],</span><br><span class="line">							<span class="keyword">struct</span> page, lru);</span><br><span class="line"></span><br><span class="line">	steal_suitable_fallback(zone, page, alloc_flags, start_migratetype,</span><br><span class="line">								can_steal);</span><br><span class="line"></span><br><span class="line">	trace_mm_page_alloc_extfrag(page, order, current_order,</span><br><span class="line">		start_migratetype, fallback_mt);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个函数实现了实际的窃取行为。如果 `order` 足够大，我们可以窃取整个页块。</span></span><br><span class="line"><span class="comment"> * 如果不够大，我们首先将该页块中的空闲页移动到我们的迁移类型，并确定页块中已经分配的页</span></span><br><span class="line"><span class="comment"> * 有多少具有兼容的迁移类型。如果至少一半的页是空闲的或兼容的，我们可以改变整个页块的迁移类型，</span></span><br><span class="line"><span class="comment"> * 这样将来释放的页就会被放到正确的空闲列表中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">steal_suitable_fallback</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> alloc_flags, <span class="type">int</span> start_type, <span class="type">bool</span> whole_block)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> current_order = page_order(page);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line">	<span class="type">int</span> free_pages, movable_pages, alike_pages;</span><br><span class="line">	<span class="type">int</span> old_block_type;</span><br><span class="line"></span><br><span class="line">	old_block_type = get_pageblock_migratetype(page);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This can happen due to races and we want to prevent broken</span></span><br><span class="line"><span class="comment">	 * highatomic accounting.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (is_migrate_highatomic(old_block_type))</span><br><span class="line">		<span class="keyword">goto</span> single_page;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Take ownership for orders &gt;= pageblock_order */</span></span><br><span class="line">	<span class="keyword">if</span> (current_order &gt;= pageblock_order) {</span><br><span class="line">		change_pageblock_range(page, current_order, start_type);</span><br><span class="line">		<span class="keyword">goto</span> single_page;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Boost watermarks to increase reclaim pressure to reduce the</span></span><br><span class="line"><span class="comment">	 * likelihood of future fallbacks. Wake kswapd now as the node</span></span><br><span class="line"><span class="comment">	 * may be balanced overall and kswapd will not wake naturally.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	boost_watermark(zone);</span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">		set_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We are not allowed to try stealing from the whole block */</span></span><br><span class="line">	<span class="keyword">if</span> (!whole_block)</span><br><span class="line">		<span class="keyword">goto</span> single_page;</span><br><span class="line"></span><br><span class="line">	free_pages = move_freepages_block(zone, page, start_type,</span><br><span class="line">						&amp;movable_pages);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Determine how many pages are compatible with our allocation.</span></span><br><span class="line"><span class="comment">	 * For movable allocation, it's the number of movable pages which</span></span><br><span class="line"><span class="comment">	 * we just obtained. For other types it's a bit more tricky.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (start_type == MIGRATE_MOVABLE) {</span><br><span class="line">		alike_pages = movable_pages;</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If we are falling back a RECLAIMABLE or UNMOVABLE allocation</span></span><br><span class="line"><span class="comment">		 * to MOVABLE pageblock, consider all non-movable pages as</span></span><br><span class="line"><span class="comment">		 * compatible. If it's UNMOVABLE falling back to RECLAIMABLE or</span></span><br><span class="line"><span class="comment">		 * vice versa, be conservative since we can't distinguish the</span></span><br><span class="line"><span class="comment">		 * exact migratetype of non-movable pages.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (old_block_type == MIGRATE_MOVABLE)</span><br><span class="line">			alike_pages = pageblock_nr_pages</span><br><span class="line">						- (free_pages + movable_pages);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			alike_pages = <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* moving whole block can fail due to zone boundary conditions */</span></span><br><span class="line">	<span class="keyword">if</span> (!free_pages)</span><br><span class="line">		<span class="keyword">goto</span> single_page;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If a sufficient number of pages in the block are either free or of</span></span><br><span class="line"><span class="comment">	 * comparable migratability as our allocation, claim the whole block.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (free_pages + alike_pages &gt;= (<span class="number">1</span> &lt;&lt; (pageblock_order<span class="number">-1</span>)) ||</span><br><span class="line">			page_group_by_mobility_disabled)</span><br><span class="line">		set_pageblock_migratetype(page, start_type);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">single_page:</span><br><span class="line">	area = &amp;zone-&gt;free_area[current_order];</span><br><span class="line">	list_move(&amp;page-&gt;lru, &amp;area-&gt;free_list[start_type]);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="alloc-pages-slowpath-slowpath"><a href="#alloc-pages-slowpath-slowpath" class="headerlink" title="__alloc_pages_slowpath (slowpath)"></a>__alloc_pages_slowpath (slowpath)</h3><p>fastpath失败后, 内存分配转入slowpath.<br>借用一张网上的图<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/2907560-20230102121042642-17385135.png"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_slowpath</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">						<span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="type">bool</span> can_direct_reclaim = gfp_mask &amp; __GFP_DIRECT_RECLAIM;</span><br><span class="line">	<span class="type">const</span> <span class="type">bool</span> costly_order = order &gt; PAGE_ALLOC_COSTLY_ORDER;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> alloc_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> did_some_progress;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">compact_priority</span> <span class="title">compact_priority</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">compact_result</span> <span class="title">compact_result</span>;</span></span><br><span class="line">	<span class="type">int</span> compaction_retries;</span><br><span class="line">	<span class="type">int</span> no_progress_loops;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cpuset_mems_cookie;</span><br><span class="line">	<span class="type">int</span> reserve_flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We also sanity check to catch abuse of atomic reserves being used by</span></span><br><span class="line"><span class="comment">	 * callers that are not in atomic context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE((gfp_mask &amp; (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==</span><br><span class="line">				(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))</span><br><span class="line">		gfp_mask &amp;= ~__GFP_ATOMIC;</span><br><span class="line"></span><br><span class="line">retry_cpuset:</span><br><span class="line">	compaction_retries = <span class="number">0</span>;</span><br><span class="line">	no_progress_loops = <span class="number">0</span>;</span><br><span class="line">	compact_priority = DEF_COMPACT_PRIORITY;</span><br><span class="line">	cpuset_mems_cookie = read_mems_allowed_begin();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The fast path uses conservative alloc_flags to succeed only until</span></span><br><span class="line"><span class="comment">	 * kswapd needs to be woken up, and to avoid the cost of setting up</span></span><br><span class="line"><span class="comment">	 * alloc_flags precisely. So we do that now.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_flags = gfp_to_alloc_flags(gfp_mask);</span><br></pre></td></tr></tbody></table></figure>


<p>slowpath会使用比fastpath更激进的分配策略, 请求水位线调整到ALLOC_WMARK_MIN.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">gfp_to_alloc_flags</span><span class="params">(<span class="type">gfp_t</span> gfp_mask)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> alloc_flags = ALLOC_WMARK_MIN | ALLOC_CPUSET;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* __GFP_HIGH is assumed to be the same as ALLOC_HIGH to save a branch. */</span></span><br><span class="line">	BUILD_BUG_ON(__GFP_HIGH != (__force <span class="type">gfp_t</span>) ALLOC_HIGH);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The caller may dip into page reserves a bit more if the caller</span></span><br><span class="line"><span class="comment">	 * cannot run direct reclaim, or if the caller has realtime scheduling</span></span><br><span class="line"><span class="comment">	 * policy or is asking for __GFP_HIGH memory.  GFP_ATOMIC requests will</span></span><br><span class="line"><span class="comment">	 * set both ALLOC_HARDER (__GFP_ATOMIC) and ALLOC_HIGH (__GFP_HIGH).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	alloc_flags |= (__force <span class="type">int</span>) (gfp_mask &amp; __GFP_HIGH);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gfp_mask &amp; __GFP_ATOMIC) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Not worth trying to allocate harder for __GFP_NOMEMALLOC even</span></span><br><span class="line"><span class="comment">		 * if it can't schedule.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!(gfp_mask &amp; __GFP_NOMEMALLOC))</span><br><span class="line">			alloc_flags |= ALLOC_HARDER;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Ignore cpuset mems for GFP_ATOMIC rather than fail, see the</span></span><br><span class="line"><span class="comment">		 * comment for __cpuset_node_allowed().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		alloc_flags &amp;= ~ALLOC_CPUSET;</span><br><span class="line">	} <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(rt_task(current)) &amp;&amp; !in_interrupt())</span><br><span class="line">		alloc_flags |= ALLOC_HARDER;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gfp_mask &amp; __GFP_KSWAPD_RECLAIM)</span><br><span class="line">		alloc_flags |= ALLOC_KSWAPD;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">	<span class="keyword">if</span> (gfpflags_to_migratetype(gfp_mask) == MIGRATE_MOVABLE)</span><br><span class="line">		alloc_flags |= ALLOC_CMA;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> alloc_flags;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>若设置了__GFP_KSWAPD_RECLAIM, 会在此时唤醒kswapds进行异步内存回收.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">	wake_all_kswapds(order, gfp_mask, ac);</span><br></pre></td></tr></tbody></table></figure>

<p>调整后的内存策略可能会导致快速路径的成功, 所以再尝试一次快速路径.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The adjusted alloc_flags might result in immediate success, so try</span></span><br><span class="line"><span class="comment"> * that first</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line">	<span class="keyword">goto</span> got_pg;</span><br></pre></td></tr></tbody></table></figure>

<p>若失败, 则尝试进行内存规整. __alloc_pages_direct_compact函数在实际内存规整后还会进行一次快速路径的尝试.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For costly allocations, try direct compaction first, as it's likely</span></span><br><span class="line"><span class="comment"> * that we have enough base pages and don't need to reclaim. For non-</span></span><br><span class="line"><span class="comment"> * movable high-order allocations, do that as well, as compaction will</span></span><br><span class="line"><span class="comment"> * try prevent permanent fragmentation by migrating from blocks of the</span></span><br><span class="line"><span class="comment"> * same migratetype.</span></span><br><span class="line"><span class="comment"> * Don't try this for allocations that are allowed to ignore</span></span><br><span class="line"><span class="comment"> * watermarks, as the ALLOC_NO_WATERMARKS attempt didn't yet happen.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (can_direct_reclaim &amp;&amp;</span><br><span class="line">		(costly_order ||</span><br><span class="line">		   (order &gt; <span class="number">0</span> &amp;&amp; ac-&gt;migratetype != MIGRATE_MOVABLE))</span><br><span class="line">		&amp;&amp; !gfp_pfmemalloc_allowed(gfp_mask)) {</span><br><span class="line">	page = __alloc_pages_direct_compact(gfp_mask, order,</span><br><span class="line">					alloc_flags, ac,</span><br><span class="line">					INIT_COMPACT_PRIORITY,</span><br><span class="line">					&amp;compact_result);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br></pre></td></tr></tbody></table></figure>

<p>若还是失败, 将进入一个可能会不断retry的阶段.<br>在每次retry开始, 先再次唤醒kswapds.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">retry:</span><br><span class="line">	<span class="comment">/* Ensure kswapd doesn't accidentally go to sleep as long as we loop */</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">		wake_all_kswapds(order, gfp_mask, ac);</span><br></pre></td></tr></tbody></table></figure>

<p>尝试忽略水位线限制.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reserve_flags = __gfp_pfmemalloc_flags(gfp_mask);</span><br><span class="line"><span class="keyword">if</span> (reserve_flags)</span><br><span class="line">	alloc_flags = reserve_flags;</span><br></pre></td></tr></tbody></table></figure>

<p>根据调整后的策略重新选出preferred_zoneref. 并进行一次快速路径的尝试.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Reset the nodemask and zonelist iterators if memory policies can be</span></span><br><span class="line"><span class="comment"> * ignored. These allocations are high priority and system rather than</span></span><br><span class="line"><span class="comment"> * user oriented.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(alloc_flags &amp; ALLOC_CPUSET) || reserve_flags) {</span><br><span class="line">	ac-&gt;nodemask = <span class="literal">NULL</span>;</span><br><span class="line">	ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">				ac-&gt;high_zoneidx, ac-&gt;nodemask);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* Attempt with potentially adjusted zonelist and alloc_flags */</span></span><br><span class="line">page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line">	<span class="keyword">goto</span> got_pg;</span><br></pre></td></tr></tbody></table></figure>


<p>若还是失败, 则不得不进行直接内存回收了, 如果不允许直接内存回收, 跳转到nopage.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller is not willing to reclaim, we can't balance anything */</span></span><br><span class="line"><span class="keyword">if</span> (!can_direct_reclaim)</span><br><span class="line">	<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Avoid recursion of direct reclaim */</span></span><br><span class="line"><span class="keyword">if</span> (current-&gt;flags &amp; PF_MEMALLOC)</span><br><span class="line">	<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p>进行一次直接内存回收和一次直接内存规整.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try direct reclaim and then allocating */</span></span><br><span class="line">page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">						&amp;did_some_progress);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line">	<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Try direct compaction and then allocating */</span></span><br><span class="line">page = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">				compact_priority, &amp;compact_result);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line">	<span class="keyword">goto</span> got_pg;</span><br></pre></td></tr></tbody></table></figure>

<p>若还未分配到, 则本次尝试已经失败, 如果不能retry, 则跳转到nopage.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Do not loop if specifically requested */</span></span><br><span class="line"><span class="keyword">if</span> (gfp_mask &amp; __GFP_NORETRY)</span><br><span class="line">	<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do not retry costly high order allocations unless they are</span></span><br><span class="line"><span class="comment"> * __GFP_RETRY_MAYFAIL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (costly_order &amp;&amp; !(gfp_mask &amp; __GFP_RETRY_MAYFAIL))</span><br><span class="line">	<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>在retry之前, 需要先判断本次retry中reclaim是否是有意义的.下列两个条件满足任一即为无意义.</p>
<ol>
<li>如果内核已经重试了 MAX_RECLAIM_RETRIES(16)次仍然没有任何效果或失败</li>
<li>如果内核将所有可选内存区域中的所有可回收页面全部回收之后，仍然无法满足内存的分配<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,</span><br><span class="line">			 did_some_progress &gt; <span class="number">0</span>, &amp;no_progress_loops))</span><br><span class="line">	<span class="keyword">goto</span> retry;</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Checks whether it makes sense to retry the reclaim to make a forward progress</span></span><br><span class="line"><span class="comment"> * for the given allocation request.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We give up when we either have tried MAX_RECLAIM_RETRIES in a row</span></span><br><span class="line"><span class="comment"> * without success, or when we couldn't even meet the watermark if we</span></span><br><span class="line"><span class="comment"> * reclaimed all remaining pages on the LRU lists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns true if a retry is viable or false to enter the oom path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">should_reclaim_retry</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> order,</span></span><br><span class="line"><span class="params">		     <span class="keyword">struct</span> alloc_context *ac, <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">		     <span class="type">bool</span> did_some_progress, <span class="type">int</span> *no_progress_loops)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line">	<span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Costly allocations might have made a progress but this doesn't mean</span></span><br><span class="line"><span class="comment">	 * their order will become available due to high fragmentation so</span></span><br><span class="line"><span class="comment">	 * always increment the no progress counter for them</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (did_some_progress &amp;&amp; order &lt;= PAGE_ALLOC_COSTLY_ORDER)</span><br><span class="line">		*no_progress_loops = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		(*no_progress_loops)++;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure we converge to OOM if we cannot make any progress</span></span><br><span class="line"><span class="comment">	 * several times in the row.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (*no_progress_loops &gt; MAX_RECLAIM_RETRIES) {</span><br><span class="line">		<span class="comment">/* Before OOM, exhaust highatomic_reserve */</span></span><br><span class="line">		<span class="keyword">return</span> unreserve_highatomic_pageblock(ac, <span class="literal">true</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Keep reclaiming pages while there is a chance this will lead</span></span><br><span class="line"><span class="comment">	 * somewhere.  If none of the target zones can satisfy our allocation</span></span><br><span class="line"><span class="comment">	 * request even if all reclaimable pages are considered then we are</span></span><br><span class="line"><span class="comment">	 * screwed and have to go OOM.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	for_each_zone_zonelist_nodemask(zone, z, ac-&gt;zonelist, ac-&gt;high_zoneidx,</span><br><span class="line">					ac-&gt;nodemask) {</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> available;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> reclaimable;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> min_wmark = min_wmark_pages(zone);</span><br><span class="line">		<span class="type">bool</span> wmark;</span><br><span class="line"></span><br><span class="line">		available = reclaimable = zone_reclaimable_pages(zone);</span><br><span class="line">		available += zone_page_state_snapshot(zone, NR_FREE_PAGES);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Would the allocation succeed if we reclaimed all</span></span><br><span class="line"><span class="comment">		 * reclaimable pages?</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		wmark = __zone_watermark_ok(zone, order, min_wmark,</span><br><span class="line">				ac_classzone_idx(ac), alloc_flags, available);</span><br><span class="line">		trace_reclaim_retry_zone(z, order, reclaimable,</span><br><span class="line">				available, min_wmark, *no_progress_loops, wmark);</span><br><span class="line">		<span class="keyword">if</span> (wmark) {</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If we didn't make any progress and have a lot of</span></span><br><span class="line"><span class="comment">			 * dirty + writeback pages then we should wait for</span></span><br><span class="line"><span class="comment">			 * an IO to complete to slow down the reclaim and</span></span><br><span class="line"><span class="comment">			 * prevent from pre mature OOM</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!did_some_progress) {</span><br><span class="line">				<span class="type">unsigned</span> <span class="type">long</span> write_pending;</span><br><span class="line"></span><br><span class="line">				write_pending = zone_page_state_snapshot(zone,</span><br><span class="line">							NR_ZONE_WRITE_PENDING);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (<span class="number">2</span> * write_pending &gt; reclaimable) {</span><br><span class="line">					congestion_wait(BLK_RW_ASYNC, HZ/<span class="number">10</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			ret = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Memory allocation/reclaim might be called from a WQ context and the</span></span><br><span class="line"><span class="comment">	 * current implementation of the WQ concurrency control doesn't</span></span><br><span class="line"><span class="comment">	 * recognize that a particular WQ is congested if the worker thread is</span></span><br><span class="line"><span class="comment">	 * looping without ever sleeping. Therefore we have to do a short sleep</span></span><br><span class="line"><span class="comment">	 * here rather than calling cond_resched().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;flags &amp; PF_WQ_WORKER)</span><br><span class="line">		schedule_timeout_uninterruptible(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cond_resched();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>如果内存回收没有意义, 再判断retry中内存规整是否有意义.如果 did_some_progress = 0 则没有必要在进行内存整理重试了，因为内存整理的实现依赖于足够的空闲内存量</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * It doesn't make any sense to retry for the compaction if the order-0</span></span><br><span class="line"><span class="comment"> * reclaim is not able to make any progress because the current</span></span><br><span class="line"><span class="comment"> * implementation of the compaction depends on the sufficient amount</span></span><br><span class="line"><span class="comment"> * of free memory (see __compaction_suitable)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (did_some_progress &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">		should_compact_retry(ac, order, alloc_flags,</span><br><span class="line">			compact_result, &amp;compact_priority,</span><br><span class="line">			&amp;compaction_retries))</span><br><span class="line">	<span class="keyword">goto</span> retry;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>检查在分配过程中cpuset是否由于并发发生改变, 若发生改变则重新进入慢速路径.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Deal with possible cpuset update races before we start OOM killing */</span></span><br><span class="line"><span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))</span><br><span class="line">	<span class="keyword">goto</span> retry_cpuset;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p>尝试启动OOM机制, 释放某个得分高的进程的内存.如果有作用就跳转到retry.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reclaim has failed us, start killing things */</span></span><br><span class="line">page = __alloc_pages_may_oom(gfp_mask, order, ac, &amp;did_some_progress);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line">	<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Avoid allocations with no watermarks from looping endlessly */</span></span><br><span class="line"><span class="keyword">if</span> (tsk_is_oom_victim(current) &amp;&amp;</span><br><span class="line">    (alloc_flags == ALLOC_OOM ||</span><br><span class="line">     (gfp_mask &amp; __GFP_NOMEMALLOC)))</span><br><span class="line">	<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Retry as long as the OOM killer is making progress */</span></span><br><span class="line"><span class="keyword">if</span> (did_some_progress) {</span><br><span class="line">	no_progress_loops = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">goto</span> retry;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>retry部分自此结束.下面看nopage部分.</p>
<p>跳转到nopage部分不代表无路可走. 如果分配过程中cpuset由于并发发生改变, 则重新进行慢速路径.<br>如果开启了__GFP_NOFAIL, 那么将会尝试使用保留的页面或回退到其他节点进行内存分配. 若失败则先调度其他进程, 然后不断retry.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">nopage:</span><br><span class="line">	<span class="comment">/* Deal with possible cpuset update races before we fail */</span></span><br><span class="line">	<span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))</span><br><span class="line">		<span class="keyword">goto</span> retry_cpuset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure that __GFP_NOFAIL request doesn't leak out and make sure</span></span><br><span class="line"><span class="comment">	 * we always retry</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (gfp_mask &amp; __GFP_NOFAIL) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * All existing users of the __GFP_NOFAIL are blockable, so warn</span></span><br><span class="line"><span class="comment">		 * of any new users that actually require GFP_NOWAIT</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(!can_direct_reclaim))</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * PF_MEMALLOC request from this context is rather bizarre</span></span><br><span class="line"><span class="comment">		 * because we cannot reclaim anything and only can loop waiting</span></span><br><span class="line"><span class="comment">		 * for somebody to do a work for us</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		WARN_ON_ONCE(current-&gt;flags &amp; PF_MEMALLOC);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * non failing costly orders are a hard requirement which we</span></span><br><span class="line"><span class="comment">		 * are not prepared for much so let's warn about these users</span></span><br><span class="line"><span class="comment">		 * so that we can identify them and convert them to something</span></span><br><span class="line"><span class="comment">		 * else.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		WARN_ON_ONCE(order &gt; PAGE_ALLOC_COSTLY_ORDER);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Help non-failing allocations by giving them access to memory</span></span><br><span class="line"><span class="comment">		 * reserves but do not use ALLOC_NO_WATERMARKS because this</span></span><br><span class="line"><span class="comment">		 * could deplete whole memory reserves which would just make</span></span><br><span class="line"><span class="comment">		 * the situation worse</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		page = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);</span><br><span class="line">		<span class="keyword">if</span> (page)</span><br><span class="line">			<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">		cond_resched();</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>


<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_cpuset_fallback</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">			      <span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class">			      <span class="title">const</span> <span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	page = get_page_from_freelist(gfp_mask, order,</span><br><span class="line">			alloc_flags|ALLOC_CPUSET, ac);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * fallback to ignore cpuset restriction if our nodes</span></span><br><span class="line"><span class="comment">	 * are depleted</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!page)</span><br><span class="line">		page = get_page_from_freelist(gfp_mask, order,</span><br><span class="line">				alloc_flags, ac);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="页面释放"><a href="#页面释放" class="headerlink" title="页面释放"></a>页面释放</h2><p>借用网上的图:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/2907560-20230203201542986-539846198.png"></p>
<p>__free_pages 是页面释放的入口点.它将page-&gt;count减一并测试是否为0, 若引用计数为0调用free_the_page释放该页面.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __free_pages(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (put_page_testzero(page))</span><br><span class="line">		free_the_page(page, order);</span><br><span class="line">}</span><br><span class="line">EXPORT_SYMBOL(__free_pages);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>和分配一样, free_the_page中对可以释放到pcplist中的order 0的页面做了特化.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">free_the_page</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (order == <span class="number">0</span>)		<span class="comment">/* Via pcp? */</span></span><br><span class="line">		free_unref_page(page);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__free_pages_ok(page, order);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="free-unref-page"><a href="#free-unref-page" class="headerlink" title="free_unref_page"></a>free_unref_page</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Free a 0-order page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_unref_page</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pfn = page_to_pfn(page);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!free_unref_page_prepare(page, pfn))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	free_unref_page_commit(page, pfn);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>如果迁移类型在MIGRATE_PCPTYPES中, 直接加入pcp-&gt;lists[migratetype]. 如果插入后pcp-&gt;count &gt;= pcp-&gt;high, 则释放batch个页面回BuddySystem. 否则通过free_one_page释放页面回BuddySystem.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_unref_page_commit</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">long</span> pfn)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span> =</span> page_zone(page);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>;</span></span><br><span class="line">	<span class="type">int</span> migratetype;</span><br><span class="line"></span><br><span class="line">	migratetype = get_pcppage_migratetype(page);</span><br><span class="line">	__count_vm_event(PGFREE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We only track unmovable, reclaimable and movable on pcp lists.</span></span><br><span class="line"><span class="comment">	 * Free ISOLATE pages back to the allocator because they are being</span></span><br><span class="line"><span class="comment">	 * offlined but treat HIGHATOMIC as movable pages so we can get those</span></span><br><span class="line"><span class="comment">	 * areas back if necessary. Otherwise, we may have to free</span></span><br><span class="line"><span class="comment">	 * excessively into the page allocator</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (migratetype &gt;= MIGRATE_PCPTYPES) {</span><br><span class="line">		<span class="keyword">if</span> (unlikely(is_migrate_isolate(migratetype))) {</span><br><span class="line">			free_one_page(zone, page, pfn, <span class="number">0</span>, migratetype);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		migratetype = MIGRATE_MOVABLE;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</span><br><span class="line">	list_add(&amp;page-&gt;lru, &amp;pcp-&gt;lists[migratetype]);</span><br><span class="line">	pcp-&gt;count++;</span><br><span class="line">	<span class="keyword">if</span> (pcp-&gt;count &gt;= pcp-&gt;high) {</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> batch = READ_ONCE(pcp-&gt;batch);</span><br><span class="line">		free_pcppages_bulk(zone, batch, pcp);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p>free_pcppages_bulk根据当前pcp各freelist的负载来决定如何从各freelist中取出这count张page, 组成临时链表, 再遍历调用__free_one_page进行释放.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Frees a number of pages from the PCP lists</span></span><br><span class="line"><span class="comment"> * Assumes all pages on list are in same zone, and of same order.</span></span><br><span class="line"><span class="comment"> * count is the number of pages to free.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the zone was previously in an "all pages pinned" state then look to</span></span><br><span class="line"><span class="comment"> * see if this freeing clears that state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * And clear the zone's pages_scanned counter, to hold off the "all pages are</span></span><br><span class="line"><span class="comment"> * pinned" detection logic.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_pcppages_bulk</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="type">int</span> count,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> per_cpu_pages *pcp)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">int</span> migratetype = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> batch_free = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> prefetch_nr = <span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> isolated_pageblocks;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">	LIST_HEAD(head);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (count) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Remove pages from lists in a round-robin fashion. A</span></span><br><span class="line"><span class="comment">		 * batch_free count is maintained that is incremented when an</span></span><br><span class="line"><span class="comment">		 * empty list is encountered.  This is so more pages are freed</span></span><br><span class="line"><span class="comment">		 * off fuller lists instead of spinning excessively around empty</span></span><br><span class="line"><span class="comment">		 * lists</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">do</span> {</span><br><span class="line">			batch_free++;</span><br><span class="line">			<span class="keyword">if</span> (++migratetype == MIGRATE_PCPTYPES)</span><br><span class="line">				migratetype = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">list</span> = &amp;pcp-&gt;lists[migratetype];</span><br><span class="line">		} <span class="keyword">while</span> (list_empty(<span class="built_in">list</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* This is the only non-empty list. Free them all. */</span></span><br><span class="line">		<span class="keyword">if</span> (batch_free == MIGRATE_PCPTYPES)</span><br><span class="line">			batch_free = count;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span> {</span><br><span class="line">			page = list_last_entry(<span class="built_in">list</span>, <span class="keyword">struct</span> page, lru);</span><br><span class="line">			<span class="comment">/* must delete to avoid corrupting pcp list */</span></span><br><span class="line">			list_del(&amp;page-&gt;lru);</span><br><span class="line">			pcp-&gt;count--;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (bulkfree_pcp_prepare(page))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">			list_add_tail(&amp;page-&gt;lru, &amp;head);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We are going to put the page back to the global</span></span><br><span class="line"><span class="comment">			 * pool, prefetch its buddy to speed up later access</span></span><br><span class="line"><span class="comment">			 * under zone-&gt;lock. It is believed the overhead of</span></span><br><span class="line"><span class="comment">			 * an additional test and calculating buddy_pfn here</span></span><br><span class="line"><span class="comment">			 * can be offset by reduced memory latency later. To</span></span><br><span class="line"><span class="comment">			 * avoid excessive prefetching due to large count, only</span></span><br><span class="line"><span class="comment">			 * prefetch buddy for the first pcp-&gt;batch nr of pages.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (prefetch_nr++ &lt; pcp-&gt;batch)</span><br><span class="line">				prefetch_buddy(page);</span><br><span class="line">		} <span class="keyword">while</span> (--count &amp;&amp; --batch_free &amp;&amp; !list_empty(<span class="built_in">list</span>));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;zone-&gt;lock);</span><br><span class="line">	isolated_pageblocks = has_isolate_pageblock(zone);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Use safe version since after __free_one_page(),</span></span><br><span class="line"><span class="comment">	 * page-&gt;lru.next will not point to original list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	list_for_each_entry_safe(page, tmp, &amp;head, lru) {</span><br><span class="line">		<span class="type">int</span> mt = get_pcppage_migratetype(page);</span><br><span class="line">		<span class="comment">/* MIGRATE_ISOLATE page should not go to pcplists */</span></span><br><span class="line">		VM_BUG_ON_PAGE(is_migrate_isolate(mt), page);</span><br><span class="line">		<span class="comment">/* Pageblock could have been isolated meanwhile */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(isolated_pageblocks))</span><br><span class="line">			mt = get_pageblock_migratetype(page);</span><br><span class="line"></span><br><span class="line">		__free_one_page(page, page_to_pfn(page), zone, <span class="number">0</span>, mt);</span><br><span class="line">		trace_mm_page_pcpu_drain(page, <span class="number">0</span>, mt);</span><br><span class="line">	}</span><br><span class="line">	spin_unlock(&amp;zone-&gt;lock);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="free-pages-ok"><a href="#free-pages-ok" class="headerlink" title="__free_pages_ok"></a>__free_pages_ok</h3><p>free_one_page的wrapper.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __free_pages_ok(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order)</span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">int</span> migratetype;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> pfn = page_to_pfn(page);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!free_pages_prepare(page, order, <span class="literal">true</span>))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	migratetype = get_pfnblock_migratetype(page, pfn);</span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	__count_vm_events(PGFREE, <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">	free_one_page(page_zone(page), page, pfn, order, migratetype);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="free-one-page"><a href="#free-one-page" class="headerlink" title="__free_one_page"></a>__free_one_page</h3><p>BuddySystem页面释放的核心.</p>
<p>先进行一些check工作.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __free_one_page(<span class="keyword">struct</span> page *page,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> pfn,</span><br><span class="line">		<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span><br><span class="line">		<span class="type">int</span> migratetype)</span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> combined_pfn;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">uninitialized_var</span><span class="params">(buddy_pfn)</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">buddy</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_order;</span><br><span class="line"></span><br><span class="line">	max_order = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, MAX_ORDER, pageblock_order + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(!zone_is_initialized(zone));</span><br><span class="line">	VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(migratetype == <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (likely(!is_migrate_isolate(migratetype)))</span><br><span class="line">		__mod_zone_freepage_state(zone, <span class="number">1</span> &lt;&lt; order, migratetype);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON_PAGE(pfn &amp; ((<span class="number">1</span> &lt;&lt; order) - <span class="number">1</span>), page);</span><br><span class="line">	VM_BUG_ON_PAGE(bad_range(zone, page), page);</span><br></pre></td></tr></tbody></table></figure>

<p>然后进入一个merging阶段, BuddySystem的释放就是不断向Merge成高阶page的过程.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">continue_merging:</span><br><span class="line">	<span class="keyword">while</span> (order &lt; max_order - <span class="number">1</span>) {</span><br><span class="line">		buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">		buddy = page + (buddy_pfn - pfn);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pfn_valid_within(buddy_pfn))</span><br><span class="line">			<span class="keyword">goto</span> done_merging;</span><br><span class="line">		<span class="keyword">if</span> (!page_is_buddy(page, buddy, order))</span><br><span class="line">			<span class="keyword">goto</span> done_merging;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page,</span></span><br><span class="line"><span class="comment">		 * merge with it and move up one order.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (page_is_guard(buddy)) {</span><br><span class="line">			clear_page_guard(zone, buddy, order, migratetype);</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			list_del(&amp;buddy-&gt;lru);</span><br><span class="line">			zone-&gt;free_area[order].nr_free--;</span><br><span class="line">			rmv_page_order(buddy);</span><br><span class="line">		}</span><br><span class="line">		combined_pfn = buddy_pfn &amp; pfn;</span><br><span class="line">		page = page + (combined_pfn - pfn);</span><br><span class="line">		pfn = combined_pfn;</span><br><span class="line">		order++;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (max_order &lt; MAX_ORDER) {</span><br><span class="line">		<span class="comment">/* If we are here, it means order is &gt;= pageblock_order.</span></span><br><span class="line"><span class="comment">		 * We want to prevent merge between freepages on isolate</span></span><br><span class="line"><span class="comment">		 * pageblock and normal pageblock. Without this, pageblock</span></span><br><span class="line"><span class="comment">		 * isolation could cause incorrect freepage or CMA accounting.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * We don't want to hit this code for the more frequent</span></span><br><span class="line"><span class="comment">		 * low-order merging.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(has_isolate_pageblock(zone))) {</span><br><span class="line">			<span class="type">int</span> buddy_mt;</span><br><span class="line"></span><br><span class="line">			buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">			buddy = page + (buddy_pfn - pfn);</span><br><span class="line">			buddy_mt = get_pageblock_migratetype(buddy);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (migratetype != buddy_mt</span><br><span class="line">					&amp;&amp; (is_migrate_isolate(migratetype) ||</span><br><span class="line">						is_migrate_isolate(buddy_mt)))</span><br><span class="line">				<span class="keyword">goto</span> done_merging;</span><br><span class="line">		}</span><br><span class="line">		max_order++;</span><br><span class="line">		<span class="keyword">goto</span> continue_merging;</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<p>done_merging阶段, 将最终合成的高阶页面加入对应free_list. 这里有一个细节, 就是如果更高阶的相邻页面是空闲的, 意味着这些空闲页面可能很快再次合并, 所以将本次page释放到free_list的尾部, 避免被马上使用以促使更高阶页面的合并.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">done_merging:</span><br><span class="line">	set_page_order(page, order);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If this is not the largest possible page, check if the buddy</span></span><br><span class="line"><span class="comment">	 * of the next-highest order is free. If it is, it's possible</span></span><br><span class="line"><span class="comment">	 * that pages are being freed that will coalesce soon. In case,</span></span><br><span class="line"><span class="comment">	 * that is happening, add the free page to the tail of the list</span></span><br><span class="line"><span class="comment">	 * so it's less likely to be used soon and more likely to be merged</span></span><br><span class="line"><span class="comment">	 * as a higher order page</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((order &lt; MAX_ORDER<span class="number">-2</span>) &amp;&amp; pfn_valid_within(buddy_pfn)) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">higher_page</span>, *<span class="title">higher_buddy</span>;</span></span><br><span class="line">		combined_pfn = buddy_pfn &amp; pfn;</span><br><span class="line">		higher_page = page + (combined_pfn - pfn);</span><br><span class="line">		buddy_pfn = __find_buddy_pfn(combined_pfn, order + <span class="number">1</span>);</span><br><span class="line">		higher_buddy = higher_page + (buddy_pfn - combined_pfn);</span><br><span class="line">		<span class="keyword">if</span> (pfn_valid_within(buddy_pfn) &amp;&amp;</span><br><span class="line">		    page_is_buddy(higher_page, higher_buddy, order + <span class="number">1</span>)) {</span><br><span class="line">			list_add_tail(&amp;page-&gt;lru,</span><br><span class="line">				&amp;zone-&gt;free_area[order].free_list[migratetype]);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	list_add(&amp;page-&gt;lru, &amp;zone-&gt;free_area[order].free_list[migratetype]);</span><br><span class="line">out:</span><br><span class="line">	zone-&gt;free_area[order].nr_free++;</span><br></pre></td></tr></tbody></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://polaris-snowfall.github.io/2024/Linux%20-%20%20BuddySystem%20--%20ARM64%20v5.0/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Memory-Management/" rel="tag">Memory_Management</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/Linux%20-%20memory%20reclaim%20--%20ARM64%20v5.0/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Linux内核 页面回收 -- ARM64 v5.0
          
        </div>
      </a>
    
    
      <a href="/2024/Linux%20-%20physical%20memory%20initialization%20--%20ARM64%20v5.0/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Linux内核  物理内存初始化过程 -- ARM64 v5.0</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> 翰青HanQi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="北极落小雪"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/About">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>