<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
        
      <meta name="description" content="Boom? PWN ! ! !" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Linux内核  页表映射建立过程 -- ARM64 v5.0 |  北极落小雪</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>
  </html>
</html>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Linux - pagetable mapping establishment -- ARM64 v5.0"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Linux内核  页表映射建立过程 -- ARM64 v5.0
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/Linux%20-%20pagetable%20mapping%20establishment%20--%20ARM64%20v5.0/" class="article-date">
  <time datetime="2024-09-04T16:00:00.000Z" itemprop="datePublished">2024-09-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux%E5%86%85%E6%A0%B8/">Linux内核</a> / <a class="article-category-link" href="/categories/Linux%E5%86%85%E6%A0%B8/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">3.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">19 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>以Linux v5.0分析.</p>
<p>注意参数或变量中的pgd,pud指的是表项, 为表示区分, 在分析过程中使用大写表示表, 小写表示表项.(如PGD表示全局页目录表.pgd表示全局目录表中的表项)<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20240901191657.png"></p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ol>
<li>内核如何适应MMU开启前后的访存机制差异?</li>
<li>MMU开启之后, 虚拟地址到物理地址的映射是什么样的?</li>
</ol>
<span id="more"></span>
<h2 id="ARM64页表映射建立过程"><a href="#ARM64页表映射建立过程" class="headerlink" title="ARM64页表映射建立过程"></a>ARM64页表映射建立过程</h2><h3 id="head-S"><a href="#head-S" class="headerlink" title="head.S"></a>head.S</h3><h4 id="相关宏分析"><a href="#相关宏分析" class="headerlink" title="相关宏分析"></a>相关宏分析</h4><h5 id="create-table-entry"><a href="#create-table-entry" class="headerlink" title="create_table_entry"></a>create_table_entry</h5><p>在tbl中创建一个条目, 指向tbl的下一个物理页.</p>
<p>实际上就是创建virt虚拟地址对应的tbl中的下一级页表, 下一级页表使用当前tbl的下一页面的空间.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* Macro to create a table entry to the next page.</span><br><span class="line">*</span><br><span class="line">*	tbl:	page table address</span><br><span class="line">*	virt:	virtual address</span><br><span class="line">*	shift:	#imm page table shift</span><br><span class="line">*	ptrs:	#imm pointers per table page</span><br><span class="line">*</span><br><span class="line">* Preserves:	virt</span><br><span class="line">* Corrupts:	ptrs, tmp1, tmp2</span><br><span class="line">* Returns:	tbl -&gt; next level table page address</span><br><span class="line">*/</span><br><span class="line">.macro	create_table_entry, tbl, virt, shift, ptrs, tmp1, tmp2</span><br><span class="line">add	\tmp1, \tbl, #PAGE_SIZE</span><br><span class="line">phys_to_pte \tmp2, \tmp1</span><br><span class="line">orr	\tmp2, \tmp2, #PMD_TYPE_TABLE	// address of next table and entry type</span><br><span class="line">lsr	\tmp1, \virt, #\shift</span><br><span class="line">sub	\ptrs, \ptrs, #1</span><br><span class="line">and	\tmp1, \tmp1, \ptrs		// table index</span><br><span class="line">str	\tmp2, [\tbl, \tmp1, lsl #3]</span><br><span class="line">add	\tbl, \tbl, #PAGE_SIZE		// next level table page</span><br><span class="line">.endm</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h5 id="populate-entries"><a href="#populate-entries" class="headerlink" title="populate_entries"></a>populate_entries</h5><p>将rtbl指向的连续物理内存地址填充到tbl中下标在index到eindex之间的表项, 填充到每个表项中的物理地址增量为inc.</p>
<p>这些物理内存可能是下一级页表,也可能是普通页面(当tbl是PT).</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Macro to populate page table entries, these entries can be pointers to the next level</span><br><span class="line"> * or last level entries pointing to physical memory.</span><br><span class="line"> *</span><br><span class="line"> *	tbl:	page table address</span><br><span class="line"> *	rtbl:	pointer to page table or physical memory</span><br><span class="line"> *	index:	start index to write</span><br><span class="line"> *	eindex:	end index to write - [index, eindex] written to</span><br><span class="line"> *	flags:	flags for pagetable entry to or in</span><br><span class="line"> *	inc:	increment to rtbl between each entry</span><br><span class="line"> *	tmp1:	temporary variable</span><br><span class="line"> *</span><br><span class="line"> * Preserves:	tbl, eindex, flags, inc</span><br><span class="line"> * Corrupts:	index, tmp1</span><br><span class="line"> * Returns:	rtbl</span><br><span class="line"> */</span><br><span class="line">	.macro populate_entries, tbl, rtbl, index, eindex, flags, inc, tmp1</span><br><span class="line">.Lpe\@:	phys_to_pte \tmp1, \rtbl</span><br><span class="line">	orr	\tmp1, \tmp1, \flags	// tmp1 = table entry</span><br><span class="line">	str	\tmp1, [\tbl, \index, lsl #3]</span><br><span class="line">	add	\rtbl, \rtbl, \inc	// rtbl = pa next level</span><br><span class="line">	add	\index, \index, #1</span><br><span class="line">	cmp	\index, \eindex</span><br><span class="line">	b.ls	.Lpe\@</span><br><span class="line">	.endm</span><br></pre></td></tr></tbody></table></figure>

<h5 id="compute-indices"><a href="#compute-indices" class="headerlink" title="compute_indices"></a>compute_indices</h5><p>根据一个虚拟地址范围[vstart,vend]以及额外所需的上一级页表条目数量count, 计算其在本级页表中的下标istart和iend, 以及计算额外所需的下一级页表数量count.</p>
<p>翻译一下还是很一目了然的.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iend = (vend &gt;&gt; shift) &amp; (ptrs - <span class="number">1</span>)</span><br><span class="line">iend += (count - <span class="number">1</span>) * ptrs</span><br><span class="line">istart = (vstart &gt;&gt; shift) &amp; (ptrs - <span class="number">1</span>)</span><br><span class="line">count = iend - istart</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Compute indices of table entries from virtual address range. If multiple entries</span><br><span class="line"> * were needed in the previous page table level then the next page table level is assumed</span><br><span class="line"> * to be composed of multiple pages. (This effectively scales the end index).</span><br><span class="line"> *</span><br><span class="line"> *	vstart:	virtual address of start of range</span><br><span class="line"> *	vend:	virtual address of end of range</span><br><span class="line"> *	shift:	shift used to transform virtual address into index</span><br><span class="line"> *	ptrs:	number of entries in page table</span><br><span class="line"> *	istart:	index in table corresponding to vstart</span><br><span class="line"> *	iend:	index in table corresponding to vend</span><br><span class="line"> *	count:	On entry: how many extra entries were required in previous level, scales</span><br><span class="line"> *			  our end index.</span><br><span class="line"> *		On exit: returns how many extra entries required for next page table level</span><br><span class="line"> *</span><br><span class="line"> * Preserves:	vstart, vend, shift, ptrs</span><br><span class="line"> * Returns:	istart, iend, count</span><br><span class="line"> */</span><br><span class="line">	.macro compute_indices, vstart, vend, shift, ptrs, istart, iend, count</span><br><span class="line">	lsr	\iend, \vend, \shift</span><br><span class="line">	mov	\istart, \ptrs</span><br><span class="line">	sub	\istart, \istart, #1</span><br><span class="line">	and	\iend, \iend, \istart	// iend = (vend &gt;&gt; shift) &amp; (ptrs - 1)</span><br><span class="line">	mov	\istart, \ptrs</span><br><span class="line">	mul	\istart, \istart, \count</span><br><span class="line">	add	\iend, \iend, \istart	// iend += (count - 1) * ptrs</span><br><span class="line">					// our entries span multiple tables</span><br><span class="line"></span><br><span class="line">	lsr	\istart, \vstart, \shift</span><br><span class="line">	mov	\count, \ptrs</span><br><span class="line">	sub	\count, \count, #1</span><br><span class="line">	and	\istart, \istart, \count</span><br><span class="line"></span><br><span class="line">	sub	\count, \iend, \istart</span><br><span class="line">	.endm</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<h5 id="map-memory"><a href="#map-memory" class="headerlink" title="map_memory"></a>map_memory</h5><p>将[vstart,vend]的虚拟内存区域映射到从phys开始的物理内存区域. 过程是自顶而下建立各级页表, 各页表使用相邻的物理页.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Map memory for specified virtual address range. Each level of page table needed supports</span><br><span class="line"> * multiple entries. If a level requires n entries the next page table level is assumed to be</span><br><span class="line"> * formed from n pages.</span><br><span class="line"> *</span><br><span class="line"> *	tbl:	location of page table</span><br><span class="line"> *	rtbl:	address to be used for first level page table entry (typically tbl + PAGE_SIZE)</span><br><span class="line"> *	vstart:	start address to map</span><br><span class="line"> *	vend:	end address to map - we map [vstart, vend]</span><br><span class="line"> *	flags:	flags to use to map last level entries</span><br><span class="line"> *	phys:	physical address corresponding to vstart - physical memory is contiguous</span><br><span class="line"> *	pgds:	the number of pgd entries</span><br><span class="line"> *</span><br><span class="line"> * Temporaries:	istart, iend, tmp, count, sv - these need to be different registers</span><br><span class="line"> * Preserves:	vstart, vend, flags</span><br><span class="line"> * Corrupts:	tbl, rtbl, istart, iend, tmp, count, sv</span><br><span class="line"> */</span><br><span class="line">	.macro map_memory, tbl, rtbl, vstart, vend, flags, phys, pgds, istart, iend, tmp, count, sv</span><br><span class="line">	add \rtbl, \tbl, #PAGE_SIZE</span><br><span class="line">	mov \sv, \rtbl</span><br><span class="line">	mov \count, #0</span><br><span class="line">	compute_indices \vstart, \vend, #PGDIR_SHIFT, \pgds, \istart, \iend, \count</span><br><span class="line">	populate_entries \tbl, \rtbl, \istart, \iend, #PMD_TYPE_TABLE, #PAGE_SIZE, \tmp</span><br><span class="line">	mov \tbl, \sv</span><br><span class="line">	mov \sv, \rtbl</span><br><span class="line"></span><br><span class="line">#if SWAPPER_PGTABLE_LEVELS &gt; 3</span><br><span class="line">	compute_indices \vstart, \vend, #PUD_SHIFT, #PTRS_PER_PUD, \istart, \iend, \count</span><br><span class="line">	populate_entries \tbl, \rtbl, \istart, \iend, #PMD_TYPE_TABLE, #PAGE_SIZE, \tmp</span><br><span class="line">	mov \tbl, \sv</span><br><span class="line">	mov \sv, \rtbl</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if SWAPPER_PGTABLE_LEVELS &gt; 2</span><br><span class="line">	compute_indices \vstart, \vend, #SWAPPER_TABLE_SHIFT, #PTRS_PER_PMD, \istart, \iend, \count</span><br><span class="line">	populate_entries \tbl, \rtbl, \istart, \iend, #PMD_TYPE_TABLE, #PAGE_SIZE, \tmp</span><br><span class="line">	mov \tbl, \sv</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	compute_indices \vstart, \vend, #SWAPPER_BLOCK_SHIFT, #PTRS_PER_PTE, \istart, \iend, \count</span><br><span class="line">	bic \count, \phys, #SWAPPER_BLOCK_SIZE - 1</span><br><span class="line">	populate_entries \tbl, \count, \istart, \iend, \flags, #SWAPPER_BLOCK_SIZE, \tmp</span><br><span class="line">	.endm</span><br></pre></td></tr></tbody></table></figure>
<h4 id="相关过程分析"><a href="#相关过程分析" class="headerlink" title="相关过程分析"></a>相关过程分析</h4><p>首先清空init_pg_dir避免脏缓存行的污染.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Setup the initial page tables. We only setup the barest amount which is</span><br><span class="line"> * required to get the kernel running. The following sections are required:</span><br><span class="line"> *   - identity mapping to enable the MMU (low address, TTBR0)</span><br><span class="line"> *   - first few MB of the kernel linear mapping to jump to once the MMU has</span><br><span class="line"> *     been enabled</span><br><span class="line"> */</span><br><span class="line">__create_page_tables:</span><br><span class="line">	mov	x28, lr</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Invalidate the init page tables to avoid potential dirty cache lines</span><br><span class="line">	 * being evicted. Other page tables are allocated in rodata as part of</span><br><span class="line">	 * the kernel image, and thus are clean to the PoC per the boot</span><br><span class="line">	 * protocol.</span><br><span class="line">	 */</span><br><span class="line">	adrp	x0, init_pg_dir</span><br><span class="line">	adrp	x1, init_pg_end</span><br><span class="line">	sub	x1, x1, x0</span><br><span class="line">	bl	__inval_dcache_area</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Clear the init page tables.</span><br><span class="line">	 */</span><br><span class="line">	adrp	x0, init_pg_dir</span><br><span class="line">	adrp	x1, init_pg_end</span><br><span class="line">	sub	x1, x1, x0</span><br><span class="line">1:	stp	xzr, xzr, [x0], #16</span><br><span class="line">	stp	xzr, xzr, [x0], #16</span><br><span class="line">	stp	xzr, xzr, [x0], #16</span><br><span class="line">	stp	xzr, xzr, [x0], #16</span><br><span class="line">	subs	x1, x1, #64</span><br><span class="line">	b.ne	1b</span><br></pre></td></tr></tbody></table></figure>


<p>然后创建恒等映射(idmap_pg_dir), 将虚拟内存区域[__idmap_text_start,__idmap_text_end]映射到物理内存区域[__idmap_text_start,__idmap_text_end].<br>在创建恒等映射时, 如果VA_BITS太小且系统RAM位于很高的物理地址空间时, 就无法创建恒等映射. 所以需要扩展虚拟地址空间范围, 方法是:</p>
<ol>
<li>若VA_BITS小于48, 在页目录表的上一级增加一级额外的页表, 此时idmap_pg_dir指向的位置是额外页表而不是页目录表.</li>
<li>若VA_BITS等于48, 那么只需增加页目录表中的条目数.<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">	/*</span><br><span class="line">	 * Create the identity mapping.</span><br><span class="line">	 */</span><br><span class="line">	adrp	x0, idmap_pg_dir</span><br><span class="line">	adrp	x3, __idmap_text_start		// __pa(__idmap_text_start)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_ARM64_USER_VA_BITS_52</span><br><span class="line">	mrs_s	x6, SYS_ID_AA64MMFR2_EL1</span><br><span class="line">	and	x6, x6, #(0xf &lt;&lt; ID_AA64MMFR2_LVA_SHIFT)</span><br><span class="line">	mov	x5, #52</span><br><span class="line">	cbnz	x6, 1f</span><br><span class="line">#endif</span><br><span class="line">	mov	x5, #VA_BITS</span><br><span class="line">1:</span><br><span class="line">	adr_l	x6, vabits_user</span><br><span class="line">	str	x5, [x6]</span><br><span class="line">	dmb	sy</span><br><span class="line">	dc	ivac, x6		// Invalidate potentially stale cache line</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * VA_BITS may be too small to allow for an ID mapping to be created</span><br><span class="line">	 * that covers system RAM if that is located sufficiently high in the</span><br><span class="line">	 * physical address space. So for the ID map, use an extended virtual</span><br><span class="line">	 * range in that case, and configure an additional translation level</span><br><span class="line">	 * if needed.</span><br><span class="line">	 *</span><br><span class="line">	 * Calculate the maximum allowed value for TCR_EL1.T0SZ so that the</span><br><span class="line">	 * entire ID map region can be mapped. As T0SZ == (64 - #bits used),</span><br><span class="line">	 * this number conveniently equals the number of leading zeroes in</span><br><span class="line">	 * the physical address of __idmap_text_end.</span><br><span class="line">	 */</span><br><span class="line">	adrp	x5, __idmap_text_end</span><br><span class="line">	clz	x5, x5</span><br><span class="line">	cmp	x5, TCR_T0SZ(VA_BITS)	// default T0SZ small enough?</span><br><span class="line">	b.ge	1f			// .. then skip VA range extension</span><br><span class="line"></span><br><span class="line">	adr_l	x6, idmap_t0sz</span><br><span class="line">	str	x5, [x6]</span><br><span class="line">	dmb	sy</span><br><span class="line">	dc	ivac, x6		// Invalidate potentially stale cache line</span><br><span class="line"></span><br><span class="line">#if (VA_BITS &lt; 48)</span><br><span class="line">#define EXTRA_SHIFT	(PGDIR_SHIFT + PAGE_SHIFT - 3)</span><br><span class="line">#define EXTRA_PTRS	(1 &lt;&lt; (PHYS_MASK_SHIFT - EXTRA_SHIFT))</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If VA_BITS &lt; 48, we have to configure an additional table level.</span><br><span class="line">	 * First, we have to verify our assumption that the current value of</span><br><span class="line">	 * VA_BITS was chosen such that all translation levels are fully</span><br><span class="line">	 * utilised, and that lowering T0SZ will always result in an additional</span><br><span class="line">	 * translation level to be configured.</span><br><span class="line">	 */</span><br><span class="line">#if VA_BITS != EXTRA_SHIFT</span><br><span class="line">#error "Mismatch between VA_BITS and page size/number of translation levels"</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	mov	x4, EXTRA_PTRS</span><br><span class="line">	create_table_entry x0, x3, EXTRA_SHIFT, x4, x5, x6</span><br><span class="line">#else</span><br><span class="line">	/*</span><br><span class="line">	 * If VA_BITS == 48, we don't have to configure an additional</span><br><span class="line">	 * translation level, but the top-level table has more entries.</span><br><span class="line">	 */</span><br><span class="line">	mov	x4, #1 &lt;&lt; (PHYS_MASK_SHIFT - PGDIR_SHIFT)</span><br><span class="line">	str_l	x4, idmap_ptrs_per_pgd, x5</span><br><span class="line">#endif</span><br><span class="line">1:</span><br><span class="line">	ldr_l	x4, idmap_ptrs_per_pgd</span><br><span class="line">	mov	x5, x3				// __pa(__idmap_text_start)</span><br><span class="line">	adr_l	x6, __idmap_text_end		// __pa(__idmap_text_end)</span><br><span class="line"></span><br><span class="line">	map_memory x0, x1, x3, x6, x7, x3, x4, x10, x11, x12, x13, x14</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p>然后创建内核镜像映射(init_pg_end), 将虚拟内存区域[(KIMAGE_VADDR+TEXT_OFFSET+KASLR_OFFSET), (KIMAGE_VADDR+TEXT_OFFSET+KASLR_OFFSET+(_end-_text))]的区域映射到物理内存区域[_text,_end]</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Map the kernel image (starting with PHYS_OFFSET).</span><br><span class="line"> */</span><br><span class="line">adrp	x0, init_pg_dir</span><br><span class="line">mov_q	x5, KIMAGE_VADDR + TEXT_OFFSET	// compile time __va(_text)</span><br><span class="line">add	x5, x5, x23			// add KASLR displacement</span><br><span class="line">mov	x4, PTRS_PER_PGD</span><br><span class="line">adrp	x6, _end			// runtime __pa(_end)</span><br><span class="line">adrp	x3, _text			// runtime __pa(_text)</span><br><span class="line">sub	x6, x6, x3			// _end - _text</span><br><span class="line">add	x6, x6, x5			// runtime __va(_end)</span><br><span class="line"></span><br><span class="line">map_memory x0, x1, x5, x6, x7, x3, x4, x10, x11, x12, x13, x14</span><br></pre></td></tr></tbody></table></figure>

<p>此时就可以开启MMU了, 将TTBR0指向idmap_pg_dir, TTBR1指向init_pg_dir.<br>由于物理地址必然是比较低的, 所以在做恒等映射时, 地址的高位必然是0, 则必然需要使用TTBR0.</p>
<blockquote>
<p>ARM64处理器有两个页表基地址寄存器，一个是TTBR0，另外一个TTBR1。当虚拟地址的第63位为0时，选择TTBR0指向的页表；当虚拟地址的第63位为1时，选择TTBR1指向的页表</p>
</blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Enable the MMU.</span><br><span class="line"> *</span><br><span class="line"> *  x0  = SCTLR_EL1 value for turning on the MMU.</span><br><span class="line"> *  x1  = TTBR1_EL1 value</span><br><span class="line"> *</span><br><span class="line"> * Returns to the caller via x30/lr. This requires the caller to be covered</span><br><span class="line"> * by the .idmap.text section.</span><br><span class="line"> *</span><br><span class="line"> * Checks if the selected granule size is supported by the CPU.</span><br><span class="line"> * If it isn't, park the CPU</span><br><span class="line"> */</span><br><span class="line">ENTRY(__enable_mmu)</span><br><span class="line">	mrs	x2, ID_AA64MMFR0_EL1</span><br><span class="line">	ubfx	x2, x2, #ID_AA64MMFR0_TGRAN_SHIFT, 4</span><br><span class="line">	cmp	x2, #ID_AA64MMFR0_TGRAN_SUPPORTED</span><br><span class="line">	b.ne	__no_granule_support</span><br><span class="line">	update_early_cpu_boot_status 0, x2, x3</span><br><span class="line">	adrp	x2, idmap_pg_dir</span><br><span class="line">	phys_to_ttbr x1, x1</span><br><span class="line">	phys_to_ttbr x2, x2</span><br><span class="line">	msr	ttbr0_el1, x2			// load TTBR0</span><br><span class="line">	offset_ttbr1 x1</span><br><span class="line">	msr	ttbr1_el1, x1			// load TTBR1</span><br><span class="line">	isb</span><br><span class="line">	msr	sctlr_el1, x0</span><br><span class="line">	isb</span><br><span class="line">	/*</span><br><span class="line">	 * Invalidate the local I-cache so that any instructions fetched</span><br><span class="line">	 * speculatively from the PoC are discarded, since they may have</span><br><span class="line">	 * been dynamically patched at the PoU.</span><br><span class="line">	 */</span><br><span class="line">	ic	iallu</span><br><span class="line">	dsb	nsh</span><br><span class="line">	isb</span><br><span class="line">	ret</span><br><span class="line">ENDPROC(__enable_mmu)</span><br></pre></td></tr></tbody></table></figure>


<p>但实际上, 在此前KASLR_OFFSET并没有经历初始化, 只有在建立完内核镜像映射后通过kaslr_early_init才进行初始化工作.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This routine will be executed with the kernel mapped at its default virtual</span></span><br><span class="line"><span class="comment"> * address, and if it returns successfully, the kernel will be remapped, and</span></span><br><span class="line"><span class="comment"> * start_kernel() will be executed from a randomized virtual offset. The</span></span><br><span class="line"><span class="comment"> * relocation will result in all absolute references (e.g., static variables</span></span><br><span class="line"><span class="comment"> * containing function pointers) to be reinitialized, and zero-initialized</span></span><br><span class="line"><span class="comment"> * .bss variables will be reset to 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u64 __init <span class="title function_">kaslr_early_init</span><span class="params">(u64 dt_phys)</span></span><br></pre></td></tr></tbody></table></figure>

<p>所以需要回到__create_page_tables重新映射一次内核. 自此初始的内核映射正式完成.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">__primary_switch:</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">	mov	x19, x0				// preserve new SCTLR_EL1 value</span><br><span class="line">	mrs	x20, sctlr_el1			// preserve old SCTLR_EL1 value</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	adrp	x1, init_pg_dir</span><br><span class="line">	bl	__enable_mmu</span><br><span class="line">#ifdef CONFIG_RELOCATABLE</span><br><span class="line">	bl	__relocate_kernel</span><br><span class="line">#ifdef CONFIG_RANDOMIZE_BASE</span><br><span class="line">	ldr	x8, =__primary_switched</span><br><span class="line">	adrp	x0, __PHYS_OFFSET</span><br><span class="line">	blr	x8</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * If we return here, we have a KASLR displacement in x23 which we need</span><br><span class="line">	 * to take into account by discarding the current kernel mapping and</span><br><span class="line">	 * creating a new one.</span><br><span class="line">	 */</span><br><span class="line">	pre_disable_mmu_workaround</span><br><span class="line">	msr	sctlr_el1, x20			// disable the MMU</span><br><span class="line">	isb</span><br><span class="line">	bl	__create_page_tables		// recreate kernel mapping</span><br><span class="line"></span><br><span class="line">	tlbi	vmalle1				// Remove any stale TLB entries</span><br><span class="line">	dsb	nsh</span><br><span class="line"></span><br><span class="line">	msr	sctlr_el1, x19			// re-enable the MMU</span><br><span class="line">	isb</span><br><span class="line">	ic	iallu				// flush instructions fetched</span><br><span class="line">	dsb	nsh				// via old mapping</span><br><span class="line">	isb</span><br><span class="line"></span><br><span class="line">	bl	__relocate_kernel</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">	ldr	x8, =__primary_switched</span><br><span class="line">	adrp	x0, __PHYS_OFFSET</span><br><span class="line">	br	x8</span><br><span class="line">ENDPROC(__primary_switch)</span><br></pre></td></tr></tbody></table></figure>

<p>恒等映射:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20240903130626.png"><br>内核镜像映射:<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20240903130638.png"></p>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20240902201832.png"></p>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20240902202656.png"></p>
<p>补充一个细节, 如何实现MMU开启前后的内核地址切换?<br>将要在MMU开启前及过渡阶段的代码和数据链接到正常低物理地址处, 过渡阶段部分会因为恒等映射的存在而正常运行.<br>建立完成后的代码链接到高地址的内核虚拟内存, 跳转到上面即完成地址的切换.</p>
<h3 id="early-fixmap-init"><a href="#early-fixmap-init" class="headerlink" title="early_fixmap_init"></a>early_fixmap_init</h3><p>early_fixmap_init在init_mm-&gt;PGD中建立FIXADDR区域映射的相关页表结构, 此时还未做实际映射. </p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Here we define all the compile-time 'special' virtual</span></span><br><span class="line"><span class="comment"> * addresses. The point is to have a constant address at</span></span><br><span class="line"><span class="comment"> * compile time, but to set the physical address only</span></span><br><span class="line"><span class="comment"> * in the boot process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * These 'compile-time allocated' memory buffers are</span></span><br><span class="line"><span class="comment"> * page-sized. Use set_fixmap(idx,phys) to associate</span></span><br><span class="line"><span class="comment"> * physical memory with fixmap indices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fixed_addresses</span> {</span></span><br><span class="line">	FIX_HOLE,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reserve a virtual window for the FDT that is 2 MB larger than the</span></span><br><span class="line"><span class="comment">	 * maximum supported size, and put it at the top of the fixmap region.</span></span><br><span class="line"><span class="comment">	 * The additional space ensures that any FDT that does not exceed</span></span><br><span class="line"><span class="comment">	 * MAX_FDT_SIZE can be mapped regardless of whether it crosses any</span></span><br><span class="line"><span class="comment">	 * 2 MB alignment boundaries.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Keep this at the top so it remains 2 MB aligned.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIX_FDT_SIZE		(MAX_FDT_SIZE + SZ_2M)</span></span><br><span class="line">	FIX_FDT_END,</span><br><span class="line">	FIX_FDT = FIX_FDT_END + FIX_FDT_SIZE / PAGE_SIZE - <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">	FIX_EARLYCON_MEM_BASE,</span><br><span class="line">	FIX_TEXT_POKE0,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ACPI_APEI_GHES</span></span><br><span class="line">	<span class="comment">/* Used for GHES mapping from assorted contexts */</span></span><br><span class="line">	FIX_APEI_GHES_IRQ,</span><br><span class="line">	FIX_APEI_GHES_NMI,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_ACPI_APEI_GHES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UNMAP_KERNEL_AT_EL0</span></span><br><span class="line">	FIX_ENTRY_TRAMP_DATA,</span><br><span class="line">	FIX_ENTRY_TRAMP_TEXT,</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMP_VALIAS		(__fix_to_virt(FIX_ENTRY_TRAMP_TEXT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_UNMAP_KERNEL_AT_EL0 */</span></span></span><br><span class="line">	__end_of_permanent_fixed_addresses,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Temporary boot-time mappings, used by early_ioremap(),</span></span><br><span class="line"><span class="comment">	 * before ioremap() is functional.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NR_FIX_BTMAPS		(SZ_256K / PAGE_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIX_BTMAPS_SLOTS	7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_FIX_BTMAPS	(NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)</span></span><br><span class="line"></span><br><span class="line">	FIX_BTMAP_END = __end_of_permanent_fixed_addresses,</span><br><span class="line">	FIX_BTMAP_BEGIN = FIX_BTMAP_END + TOTAL_FIX_BTMAPS - <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Used for kernel page table creation, so unmapped memory may be used</span></span><br><span class="line"><span class="comment">	 * for tables.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	FIX_PTE,</span><br><span class="line">	FIX_PMD,</span><br><span class="line">	FIX_PUD,</span><br><span class="line">	FIX_PGD,</span><br><span class="line"></span><br><span class="line">	__end_of_fixed_addresses</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>在ARM64架构中, 此时的init_mm-&gt;PGD为init_pg_dir.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_MM_CONTEXT(name)	\</span></span><br><span class="line"><span class="meta">	.pgd = init_pg_dir,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For dynamically allocated mm_structs, there is a dynamically sized cpumask</span></span><br><span class="line"><span class="comment"> * at the end of the structure, the size of which depends on the maximum CPU</span></span><br><span class="line"><span class="comment"> * number the system can see. That way we allocate only as much memory for</span></span><br><span class="line"><span class="comment"> * mm_cpumask() as needed for the hundreds, or thousands of processes that</span></span><br><span class="line"><span class="comment"> * a system typically runs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Since there is only one init_mm in the entire system, keep it simple</span></span><br><span class="line"><span class="comment"> * and size this cpu_bitmask to NR_CPUS.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> <span class="title">init_mm</span> =</span> {</span><br><span class="line">	.mm_rb		= RB_ROOT,</span><br><span class="line">	.pgd		= swapper_pg_dir,</span><br><span class="line">	.mm_users	= ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">	.mm_count	= ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">	.mmap_sem	= __RWSEM_INITIALIZER(init_mm.mmap_sem),</span><br><span class="line">	.page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),</span><br><span class="line">	.arg_lock	=  __SPIN_LOCK_UNLOCKED(init_mm.arg_lock),</span><br><span class="line">	.mmlist		= LIST_HEAD_INIT(init_mm.mmlist),</span><br><span class="line">	.user_ns	= &amp;init_user_ns,</span><br><span class="line">	.cpu_bitmap	= { [BITS_TO_LONGS(NR_CPUS)] = <span class="number">0</span>},</span><br><span class="line">	INIT_MM_CONTEXT(init_mm)</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;start_kenrel()-&gt; setup_arch()-&gt;early_fixmap_init()&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The p*d_populate functions call virt_to_phys implicitly so they can't be used</span></span><br><span class="line"><span class="comment"> * directly on kernel symbols (bm_p*d). This function is called too early to use</span></span><br><span class="line"><span class="comment"> * lm_alias so __p*d_populate functions must be used to populate with the</span></span><br><span class="line"><span class="comment"> * physical address from __pa_symbol.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">early_fixmap_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">pgd_t</span> *pgdp, pgd;</span><br><span class="line">	<span class="type">pud_t</span> *pudp;</span><br><span class="line">	<span class="type">pmd_t</span> *pmdp;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> addr = FIXADDR_START;</span><br><span class="line"></span><br><span class="line">	pgdp = pgd_offset_k(addr); <span class="comment">//获取addr对应的init_mm-&gt;PGD中pgd的虚拟地址.</span></span><br><span class="line">	pgd = READ_ONCE(*pgdp); <span class="comment">// 获取addr对应的init-&gt;mm-&gt;PGD中pgd的值.</span></span><br><span class="line">	<span class="keyword">if</span> (CONFIG_PGTABLE_LEVELS &gt; <span class="number">3</span> &amp;&amp;</span><br><span class="line">	    !(pgd_none(pgd) || pgd_page_paddr(pgd) == __pa_symbol(bm_pud))) {</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * We only end up here if the kernel mapping and the fixmap</span></span><br><span class="line"><span class="comment">		 * share the top level pgd entry, which should only happen on</span></span><br><span class="line"><span class="comment">		 * 16k/4 levels configurations.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		BUG_ON(!IS_ENABLED(CONFIG_ARM64_16K_PAGES));</span><br><span class="line">		pudp = pud_offset_kimg(pgdp, addr);</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">    	<span class="comment">// 若pgd为空, 使用bm_PUD的地址来填充该pgd</span></span><br><span class="line">		<span class="keyword">if</span> (pgd_none(pgd))</span><br><span class="line">			__pgd_populate(pgdp, __pa_symbol(bm_pud), PUD_TYPE_TABLE);</span><br><span class="line">		pudp = fixmap_pud(addr); <span class="comment">// 获取addr对应的PUD中的pud的虚拟地址.</span></span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//若pud为空, 使用bm_PMD的地址来填充该pud</span></span><br><span class="line">	<span class="keyword">if</span> (pud_none(READ_ONCE(*pudp)))</span><br><span class="line">		__pud_populate(pudp, __pa_symbol(bm_pmd), PMD_TYPE_TABLE);</span><br><span class="line">	pmdp = fixmap_pmd(addr); <span class="comment">//获取addr对应的PMD中的pmd的虚拟地址.</span></span><br><span class="line">	<span class="comment">//使用bm_PTE的地址来填充该pmd</span></span><br><span class="line">	__pmd_populate(pmdp, __pa_symbol(bm_pte), PMD_TYPE_TABLE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The boot-ioremap range spans multiple pmds, for which</span></span><br><span class="line"><span class="comment">	 * we are not prepared:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查boot-ioremap range是否跨越了多个pmd(PT). (此时仅准备了一个pmd, 也就是一个PT).</span></span><br><span class="line">	BUILD_BUG_ON((__fix_to_virt(FIX_BTMAP_BEGIN) &gt;&gt; PMD_SHIFT)</span><br><span class="line">		     != (__fix_to_virt(FIX_BTMAP_END) &gt;&gt; PMD_SHIFT));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((pmdp != fixmap_pmd(fix_to_virt(FIX_BTMAP_BEGIN)))</span><br><span class="line">	     || pmdp != fixmap_pmd(fix_to_virt(FIX_BTMAP_END))) {</span><br><span class="line">		WARN_ON(<span class="number">1</span>);</span><br><span class="line">		pr_warn(<span class="string">"pmdp %p != %p, %p\n"</span>,</span><br><span class="line">			pmdp, fixmap_pmd(fix_to_virt(FIX_BTMAP_BEGIN)),</span><br><span class="line">			fixmap_pmd(fix_to_virt(FIX_BTMAP_END)));</span><br><span class="line">		pr_warn(<span class="string">"fix_to_virt(FIX_BTMAP_BEGIN): %08lx\n"</span>,</span><br><span class="line">			fix_to_virt(FIX_BTMAP_BEGIN));</span><br><span class="line">		pr_warn(<span class="string">"fix_to_virt(FIX_BTMAP_END):   %08lx\n"</span>,</span><br><span class="line">			fix_to_virt(FIX_BTMAP_END));</span><br><span class="line"></span><br><span class="line">		pr_warn(<span class="string">"FIX_BTMAP_END:       %d\n"</span>, FIX_BTMAP_END);</span><br><span class="line">		pr_warn(<span class="string">"FIX_BTMAP_BEGIN:     %d\n"</span>, FIX_BTMAP_BEGIN);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/E8C37AC638081379363B37982547238A.jpg"></p>
<p>该FIXADDR区域用来做一些特定的映射(FDT……) 或是建立临时映射来对物理内存进行处理(如early_pgtable_alloc函数中使用其来将物理内存区域清零)..<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/1771657-20190831230833457-192209033.png"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">phys_addr_t</span> __init <span class="title function_">early_pgtable_alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">phys_addr_t</span> phys;</span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">	phys = memblock_phys_alloc(PAGE_SIZE, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The FIX_{PGD,PUD,PMD} slots may be in active use, but the FIX_PTE</span></span><br><span class="line"><span class="comment">	 * slot will be free, so we can (ab)use the FIX_PTE slot to initialise</span></span><br><span class="line"><span class="comment">	 * any level of table.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ptr = pte_set_fixmap(phys);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(ptr, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Implicit barriers also ensure the zeroed page is visible to the page</span></span><br><span class="line"><span class="comment">	 * table walker</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	pte_clear_fixmap();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> phys;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="paging-init"><a href="#paging-init" class="headerlink" title="paging_init"></a>paging_init</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;start_kenrel()-&gt; setup_arch()-&gt;paging_init()&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * paging_init() sets up the page tables, initialises the zone memory</span></span><br><span class="line"><span class="comment"> * maps and sets up the zero page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">paging_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">pgd_t</span> *pgdp = pgd_set_fixmap(__pa_symbol(swapper_pg_dir)); </span><br><span class="line"></span><br><span class="line">	map_kernel(pgdp);</span><br><span class="line">	map_mem(pgdp);</span><br><span class="line"></span><br><span class="line">	pgd_clear_fixmap();</span><br><span class="line"></span><br><span class="line">	cpu_replace_ttbr1(lm_alias(swapper_pg_dir));</span><br><span class="line">	init_mm.pgd = swapper_pg_dir;</span><br><span class="line"></span><br><span class="line">	memblock_free(__pa_symbol(init_pg_dir),</span><br><span class="line">		      __pa_symbol(init_pg_end) - __pa_symbol(init_pg_dir));</span><br><span class="line"></span><br><span class="line">	memblock_allow_resize();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>


<p>首先使用pgd_set_fixmap将swapper_pg_dir对应的物理内存映射到FIXADDR区域:<br>计算出FIX_PGD对应的固定虚拟地址, 再映射,相关过程如下: </p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pgd_set_fixmap(addr)	((pgd_t *)set_fixmap_offset(FIX_PGD, addr))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fixmap_offset(idx, phys) \</span></span><br><span class="line"><span class="meta">	__set_fixmap_offset(idx, phys, FIXMAP_PAGE_NORMAL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return a pointer with offset calculated */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __set_fixmap_offset(idx, phys, flags)				\</span></span><br><span class="line"><span class="meta">({									\</span></span><br><span class="line"><span class="meta">	unsigned long ________addr;					\</span></span><br><span class="line"><span class="meta">	__set_fixmap(idx, phys, flags);					\</span></span><br><span class="line"><span class="meta">	________addr = fix_to_virt(idx) + ((phys) &amp; (PAGE_SIZE - 1));	\</span></span><br><span class="line"><span class="meta">	________addr;							\</span></span><br><span class="line"><span class="meta">})</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __set_fixmap(<span class="keyword">enum</span> fixed_addresses idx,</span><br><span class="line">			       <span class="type">phys_addr_t</span> phys, <span class="type">pgprot_t</span> flags)</span><br><span class="line">{</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> addr = __fix_to_virt(idx);</span><br><span class="line">	<span class="type">pte_t</span> *ptep;</span><br><span class="line"></span><br><span class="line">	BUG_ON(idx &lt;= FIX_HOLE || idx &gt;= __end_of_fixed_addresses);</span><br><span class="line"></span><br><span class="line">	ptep = fixmap_pte(addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pgprot_val(flags)) {</span><br><span class="line">		set_pte(ptep, pfn_pte(phys &gt;&gt; PAGE_SHIFT, flags));</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		pte_clear(&amp;init_mm, addr, ptep);</span><br><span class="line">		flush_tlb_kernel_range(addr, addr+PAGE_SIZE);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __fix_to_virt(x)	(FIXADDR_TOP - ((x) &lt;&lt; PAGE_SHIFT))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>笔者暂且认为映射swapper_pg_dir到FIXADDR是为了某种意义上的访问方便, 因为实际上swapper_pg_dir所在的物理内存已经在初始内存映射时映射到了init_pg_dir中, 可以直接访问对应虚拟内存来完成其的初始化.</p>
<p>下图中第一段为初始内核映射, 第二段为FIXADDR到swapper_pg_dir的映射, 可见第二段映射的物理地址是包含在第一段映射内的.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20240903132722.png"></p>
<p>然后在swapper_pg_dir中进行内核映像完整映射及所以物理内存的线性映射, 然后切换到swapper_pg_dir.<br>init_pg_dir完成了其的使命, 通过memblock_free释放.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map_kernel(pgdp);</span><br><span class="line">map_mem(pgdp);</span><br><span class="line"></span><br><span class="line">pgd_clear_fixmap();</span><br><span class="line"></span><br><span class="line">cpu_replace_ttbr1(lm_alias(swapper_pg_dir));</span><br><span class="line">init_mm.pgd = swapper_pg_dir;</span><br><span class="line"></span><br><span class="line">memblock_free(__pa_symbol(init_pg_dir),</span><br><span class="line">	      __pa_symbol(init_pg_end) - __pa_symbol(init_pg_dir));</span><br><span class="line"></span><br><span class="line">memblock_allow_resize();</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>map_kernel(pgdp)：对内核映像文件的各个块重新映射。在head.S文件中，我们对内核映像文件做了块映射，现在需要使用页机制来重新映射。<br>map_mem(pgdp)：物理内存的线性映射。物理内存会全部线性映射到以PAGE_OFFSET开始的内核空间的虚拟地址，以加速内核访问内存。</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://polaris-snowfall.github.io/2024/Linux%20-%20pagetable%20mapping%20establishment%20--%20ARM64%20v5.0/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Memory-Management/" rel="tag">Memory_Management</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/Linux%20-%20physical%20memory%20initialization%20--%20ARM64%20v5.0/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Linux内核  物理内存初始化过程 -- ARM64 v5.0
          
        </div>
      </a>
    
    
      <a href="/2024/KalmarCTF2024%20Beautify_Me/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">KalmarCTF2024 Beautify_Me</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> 翰青HanQi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="北极落小雪"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/About">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>