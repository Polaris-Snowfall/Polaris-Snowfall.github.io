<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8" />
        
      <meta name="description" content="Boom? PWN ! ! !" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>CVE-2021-41073 在安卓5.10内核上利用IO_URING类型混淆 |  北极落小雪</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
  </html>
</html>


<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-CVE-2021-41073"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  CVE-2021-41073 在安卓5.10内核上利用IO_URING类型混淆
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/CVE-2021-41073/" class="article-date">
  <time datetime="2025-04-21T16:00:00.000Z" itemprop="datePublished">2025-04-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Pwn/">Pwn</a> / <a class="article-category-link" href="/categories/Pwn/Kernel/">Kernel</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">2.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">12 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>第一次安卓实机内核利用, 感觉安卓上的利用确实还是比较受限的.<br>分析就简写了, 主要是利用.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于 io_uring 的异步性质，应用程序需要跟踪当前正在传输请求中的缓冲区, 这可能会比较复杂。IORING_OP_PROVIDE_BUFFERS 提供了自动管理缓冲区的功能.  首先通过IOURING_OP_PROVIDE_BUFFERS向内核提前注册一组缓冲区(buf_group), 组中的每一个缓冲区对应一个bid. 注册完成后,  可以通过在读写请求中带IOSQE_BUFFER_SELECT标志并指定 buf_group, 内核将自动在对应组中选择一个空闲的缓冲区进行传输,  完成后在CQE中给出选择的bid.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202508041746640.png" alt="image.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202508041747219.png" alt="image.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202508041747813.png" alt="image.png"></p>
<span id="more"></span>

<p>io_kiocb结构体是一次io_uring请求的内核表示, 结构体开头是联合体的形式, 用来存储不同类型请求需要的不同数据结构, 对于读写请求来说它是io_rw.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202508041750131.png" alt="image.png"></p>
<p>内核在使用io_rw这一结构体时, 其中的addr字段在不同情况下有不同意义, 可能指向一个用户缓冲区,  也可能指向io_buffer结构体(IOSQE_BUFFER_SELECT, 即由内核管理缓冲区). 这就可能引入混淆, 内核使用req-&gt;flags中的REQ_F_BUFFER_SELECTED标志来区分这两种情况.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202508041748764.png" alt="image.png"></p>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202508041754820.png" alt="image.png"><br>如果内核在处理rw.addr之前没有检查这一标志, 就会出现类型混淆漏洞.<br>loop_rw_iter函数是实际执行读写请求的函数, 在每次循环初始化时, 通过iov_iter_is_bvec函数检查REQ_F_BUFFER_SELECTED标志并进行不同的处理, 这是标准的流程. 但在循环结束的步进位置却遗失了判断, 在req-&gt;rw.addr是io_buffer指针时也将其进行了偏移.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202508041758328.png" alt="image.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202508041759129.png" alt="image.png"></p>
<p>这会导致在随后的io_put_rw_kbuf函数中的偏移释放, 而这个偏移是用户可控的读写大小, 所以就有了一个任意偏移内存释放原语.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202508041802133.png" alt="image.png"></p>
<p>将漏洞模式提炼一下, 一个kmalloc得到的指针永远不应该在偏移后进行释放操作, 使用CodeQL对这样的行为进行建模, 确实找到了一些类似的一个字段多重意义的用法, 但可惜都进行了必要的检查.</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="基本原语"><a href="#基本原语" class="headerlink" title="基本原语"></a>基本原语</h3><p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/62254ebdee34d32c897e53fe_IOURING_5.png"></p>
<p>值得一提的是这样一种任意偏移释放原语, 不同于传统的UAF, Double Free, 它可以很轻易的做到CrossCache. 但本次利用并没有采用CrossCache方案.</p>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20250509154718.png"></p>
<p>有了UAF之后就要找用来堆喷并读写数据的结构体, 常见的堆喷读取结构体是msg_msg和user_key_payload, 常见的写入结构体(其实是系统调用)是setxattr(需要配合userfaultfd和fuse, 因为用户数据位于临时对象中, 调用结束被释放), 但这些在安卓上都无法使用.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/userfaultfd2.svg"></p>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20250509155306.png"></p>
<p>但有一种punching hole技术可以在安卓上近似替代userfaultfd和fuse.</p>
<h3 id="punching-hole"><a href="#punching-hole" class="headerlink" title="punching hole"></a>punching hole</h3><p>fallocate系统调用可以直接对磁盘空间进行操作. 默认行为是为文件分配磁盘空间, 以保证之后在指定范围内对文件的写入不会出现磁盘空间不足.</p>
<blockquote>
<p>   Allocating disk space<br>       The default operation (i.e., mode is zero) of fallocate()<br>       allocates the disk space within the range specified by offset and<br>       size.  The file size (as reported by stat(2)) will be changed if<br>       offset+size is greater than the file size.  Any subregion within<br>       the range specified by offset and size that did not contain data<br>       before the call will be initialized to zero.  This default<br>       behavior closely resembles the behavior of the posix_fallocate(3)<br>       library function, and is intended as a method of optimally<br>       implementing that function.</p>
<pre><code>  After a successful call, subsequent writes into the range
   specified by offset and size are guaranteed not to fail because of
   lack of disk space.
</code></pre>
</blockquote>
<p>有分配自然就有释放.</p>
<blockquote>
<p>Deallocating file space<br>       Specifying the FALLOC_FL_PUNCH_HOLE flag (available since Linux<br>       2.6.38) in mode deallocates space (i.e., creates a hole) in the<br>       byte range starting at offset and continuing for size bytes.<br>       Within the specified range, partial filesystem blocks are zeroed,<br>       and whole filesystem blocks are removed from the file.  After a<br>       successful call, subsequent reads from this range will return<br>       zeros.</p>
</blockquote>
<p>在shmem_fallocate执行FALLOC_FL_PUNCH_HOLE时, 会设置inode-&gt;private = &amp;shmem_falloc, 在punch hole结束之前, 访问这片内存的线程会被加入一个等待队列中.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">shmem_fallocate</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span></span><br><span class="line"><span class="params">							 <span class="type">loff_t</span> len)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">shmem_sb_info</span> *<span class="title">sbinfo</span> =</span> SHMEM_SB(inode-&gt;i_sb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">shmem_inode_info</span> *<span class="title">info</span> =</span> SHMEM_I(inode);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">shmem_falloc</span> <span class="title">shmem_falloc</span>;</span></span><br><span class="line">	<span class="type">pgoff_t</span> start, index, end, undo_fallocend;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mode &amp; ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))</span><br><span class="line">		<span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line">	inode_lock(inode);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mode &amp; FALLOC_FL_PUNCH_HOLE) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> file-&gt;f_mapping;</span><br><span class="line">		<span class="type">loff_t</span> unmap_start = round_up(offset, PAGE_SIZE);</span><br><span class="line">		<span class="type">loff_t</span> unmap_end = round_down(offset + len, PAGE_SIZE) - <span class="number">1</span>;</span><br><span class="line">		DECLARE_WAIT_QUEUE_HEAD_ONSTACK(shmem_falloc_waitq);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* protected by i_rwsem */</span></span><br><span class="line">		<span class="keyword">if</span> (info-&gt;seals &amp; (F_SEAL_WRITE | F_SEAL_FUTURE_WRITE)) {</span><br><span class="line">			error = -EPERM;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		shmem_falloc.waitq = &amp;shmem_falloc_waitq;</span><br><span class="line">		shmem_falloc.start = (u64)unmap_start &gt;&gt; PAGE_SHIFT;</span><br><span class="line">		shmem_falloc.next = (unmap_end + <span class="number">1</span>) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">		spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">		inode-&gt;i_private = &amp;shmem_falloc;</span><br><span class="line">		spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((u64)unmap_end &gt; (u64)unmap_start)</span><br><span class="line">			unmap_mapping_range(mapping, unmap_start,</span><br><span class="line">					    <span class="number">1</span> + unmap_end - unmap_start, <span class="number">0</span>);</span><br><span class="line">		shmem_truncate_range(inode, offset, offset + len - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">/* No need to unmap again: hole-punching leaves COWed pages */</span></span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">		inode-&gt;i_private = <span class="literal">NULL</span>;</span><br><span class="line">		wake_up_all(&amp;shmem_falloc_waitq);</span><br><span class="line">		WARN_ON_ONCE(!list_empty(&amp;shmem_falloc_waitq.head));</span><br><span class="line">		spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">		error = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">vm_fault_t</span> <span class="title function_">shmem_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> vmf-&gt;vma;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(vma-&gt;vm_file);</span><br><span class="line">	<span class="type">gfp_t</span> gfp = mapping_gfp_mask(inode-&gt;i_mapping);</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">vm_fault_t</span> ret = VM_FAULT_LOCKED;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Trinity finds that probing a hole which tmpfs is punching can</span></span><br><span class="line"><span class="comment">	 * prevent the hole-punch from ever completing: which in turn</span></span><br><span class="line"><span class="comment">	 * locks writers out with its hold on i_rwsem.  So refrain from</span></span><br><span class="line"><span class="comment">	 * faulting pages into the hole while it's being punched.  Although</span></span><br><span class="line"><span class="comment">	 * shmem_undo_range() does remove the additions, it may be unable to</span></span><br><span class="line"><span class="comment">	 * keep up, as each new page needs its own unmap_mapping_range() call,</span></span><br><span class="line"><span class="comment">	 * and the i_mmap tree grows ever slower to scan if new vmas are added.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * It does not matter if we sometimes reach this check just before the</span></span><br><span class="line"><span class="comment">	 * hole-punch begins, so that one fault then races with the punch:</span></span><br><span class="line"><span class="comment">	 * we just need to make racing faults a rare case.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The implementation below would be much simpler if we just used a</span></span><br><span class="line"><span class="comment">	 * standard mutex or completion: but we cannot take i_rwsem in fault,</span></span><br><span class="line"><span class="comment">	 * and bloating every shmem inode for this unlikely case would be sad.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(inode-&gt;i_private)) {</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">shmem_falloc</span> *<span class="title">shmem_falloc</span>;</span></span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">		shmem_falloc = inode-&gt;i_private;</span><br><span class="line">		<span class="keyword">if</span> (shmem_falloc &amp;&amp;</span><br><span class="line">		    shmem_falloc-&gt;waitq &amp;&amp;</span><br><span class="line">		    vmf-&gt;pgoff &gt;= shmem_falloc-&gt;start &amp;&amp;</span><br><span class="line">		    vmf-&gt;pgoff &lt; shmem_falloc-&gt;next) {</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fpin</span>;</span></span><br><span class="line">			<span class="type">wait_queue_head_t</span> *shmem_falloc_waitq;</span><br><span class="line">			DEFINE_WAIT_FUNC(shmem_fault_wait, synchronous_wake_function);</span><br><span class="line"></span><br><span class="line">			ret = VM_FAULT_NOPAGE;</span><br><span class="line">			fpin = maybe_unlock_mmap_for_io(vmf, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">if</span> (fpin)</span><br><span class="line">				ret = VM_FAULT_RETRY;</span><br><span class="line"></span><br><span class="line">			shmem_falloc_waitq = shmem_falloc-&gt;waitq;</span><br><span class="line">			prepare_to_wait(shmem_falloc_waitq, &amp;shmem_fault_wait,</span><br><span class="line">					TASK_UNINTERRUPTIBLE);</span><br><span class="line">			spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">			schedule();</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * shmem_falloc_waitq points into the shmem_fallocate()</span></span><br><span class="line"><span class="comment">			 * stack of the hole-punching task: shmem_falloc_waitq</span></span><br><span class="line"><span class="comment">			 * is usually invalid by the time we reach here, but</span></span><br><span class="line"><span class="comment">			 * finish_wait() does not dereference it in that case;</span></span><br><span class="line"><span class="comment">			 * though i_lock needed lest racing with wake_up_all().</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">			finish_wait(shmem_falloc_waitq, &amp;shmem_fault_wait);</span><br><span class="line">			spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (fpin)</span><br><span class="line">				fput(fpin);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		}</span><br><span class="line">		spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>


<p>这给了一个”内核线程阻塞在读写用户空间数据”的原语, 类似fuse/userfaultfd, 且在安卓上能触发.<br>阻塞时间长短取决于fallocate的大小(应该是与反向映射的数量有关).</p>
<p>在之前的尝试中, 笔者一直认为shmem_sz的上限是0x80000000,因为超过这个值会报EINVAL.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="type">size_t</span> shmem_sz = (<span class="number">0x1000</span> * <span class="number">0x7f</span>) * PAGE_SIZE;</span><br></pre></td></tr></tbody></table></figure>

<p>但利用完后想提高稳定性, 分析fallocate源码并没有找到这一限制. 调试后发现计算出的shmem_sz的值为0xffffffff80000000,这显然不合理.  将PAGE_SIZE改成UL后, 可以用fallocate更大的空间.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000UL</span></span><br><span class="line"><span class="type">size_t</span> shmem_sz = (<span class="number">0x1000</span> * <span class="number">0x7f</span>) * PAGE_SIZE;</span><br></pre></td></tr></tbody></table></figure>

<h3 id="punching-hole-setxattr-安卓通用堆喷读写"><a href="#punching-hole-setxattr-安卓通用堆喷读写" class="headerlink" title="punching hole + setxattr 安卓通用堆喷读写"></a>punching hole + setxattr 安卓通用堆喷读写</h3><p>setxattr在内核利用中大多数时候用来写入payload, 但其实也能用来读取.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/62265f37876402371e98f237_IOURING_10%20(1)-1.png"></p>
<h3 id="leak-with-pipe-buffer"><a href="#leak-with-pipe-buffer" class="headerlink" title="leak with pipe_buffer"></a>leak with pipe_buffer</h3><p>现代内核利用总是使用pipe_buffer结构体, 也确实好用, 但大小限制为0x28以上.</p>
<ol>
<li>结构体大小弹性, 能适配大多数情况. </li>
<li>头部有一个page指针, 修改后可以读写任意数据. </li>
<li>flags字段可以造dirtypipe<br>不过在aarch64架构下, DMA_CACHE是0x80字节对齐的, 所以最小的slub是kmalloc-128, 0x20字节的io_buffer可以与pipe_buffer来自同一个slub.</li>
</ol>
<p>堆喷setxattr并阻塞, 并在中间插入vuln object的分配, 这样可以保证在CONFIG_SLAB_FREELIST_RANDOM的情况下, vuln object的相邻对象大概率是我们的target object. 然后触发invalid free, 再堆喷pipe_buffer进行占位</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sem_post(&amp;punching_sem);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NSETXATTR; ++i)</span><br><span class="line">{</span><br><span class="line">    sem_post(&amp;setxattr_sem); <span class="comment">//一个线程开始setxattr</span></span><br><span class="line">    <span class="keyword">if</span>(i == NSETXATTR / <span class="number">2</span>)</span><br><span class="line">        pthread_mutex_unlock(&amp;lock1); <span class="comment">//分配vuln object</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock(&amp;lock2); <span class="comment">// 触发invalid free</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/622552360461b545e33b7d55_IOURING_9.png"></p>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20250509212418.png"></p>
<p>这样我们就能将pipe_buffer中的数据写入xattr, 并读出….<br>然而实际情况没这么简单.</p>
<p>io_uring是异步的, invalid free发生在io_wrk线程的上下文中, 而将io_uring线程绑定到特定cpu的功能直到5.14内核才加入, 安卓5.10系列是没有的. 所以释放的setxattr的内存可能会在任何kmem_cache_cpu上.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != io_uring_register_iowq_aff(&amp;ring, <span class="keyword">sizeof</span>(<span class="type">cpu_set_t</span>), &amp;mask))</span><br><span class="line">{</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"++ register failed: %m\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>只能在每个核上都进行堆喷, 才能拿回释放的setxattr. 这在8核的设备上会降低成功率.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_RESIZE 0x2000</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCORES; ++i)</span><br><span class="line">    {</span><br><span class="line">        bind_core(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; NPIPEFD_PER_CORE; ++j)</span><br><span class="line">        {</span><br><span class="line">            ret = fcntl(pipe_fds[i*NPIPEFD_PER_CORE + j][<span class="number">1</span>],F_SETPIPE_SZ,PIPE_RESIZE); <span class="comment">//kmalloc-128</span></span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">                err_exit(<span class="string">"Failed set pipe_sz"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>


<h3 id="construct-page-level-uaf-aar-aaw-with-pipe-buffer"><a href="#construct-page-level-uaf-aar-aaw-with-pipe-buffer" class="headerlink" title="construct page-level uaf &amp;&amp; aar / aaw with pipe_buffer"></a>construct page-level uaf &amp;&amp; aar / aaw with pipe_buffer</h3><p>当setxattr结束后, pipe_buffer结构体会再次被释放, 但这次会在cpu 0上(exploit线程上下文), 这是稳定的. 于是可以再次使用punching hole + setxattr技术改写pipe_buffer的page字段进行任意地址读写(如果只需要写只读文件, 这里造dirtypipe即可).</p>
<p>但每一次setxattr写完之后都会被释放, 即每次写都会引入一个被噪音占位的风险, 所以决定继续构造page-level uaf.</p>
<p>将pipe_buffer.page字段增加0x40, 也就是指向下一个物理连续的page(提前喷射order-0的页面来构造物理连续).  再关闭其中一个pipe, 完成page-level uaf.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20250509220150.png"></p>
<p>再次喷射pipe_buffer占回刚释放的页面, 就可以使用一个pipe去修改另一个pipe_buffer了, 并且由于pipe中tmp_page的特性, 这就是无限次的任意地址读写原语.最后用读写原语爬取task树, 改写当前cred, 关闭selinux, 完成提权.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20250509220247.png"></p>
<h3 id="其他安卓通用堆喷原语"><a href="#其他安卓通用堆喷原语" class="headerlink" title="其他安卓通用堆喷原语"></a>其他安卓通用堆喷原语</h3><h4 id="PR-SET-VMA-ANON-NAME"><a href="#PR-SET-VMA-ANON-NAME" class="headerlink" title="PR_SET_VMA_ANON_NAME"></a>PR_SET_VMA_ANON_NAME</h4><p>Linux 5.17之后, 引入了给匿名页设置名称的功能.且需要开启CONFIG_ANON_VMA_NAME(安卓默认开启).</p>
<blockquote>
<p>PR_SET_VMA_ANON_NAME<br>             Set a name for anonymous virtual memory areas.  val should<br>             be a pointer to a null-terminated string containing the<br>             name.  The name length including null byte cannot exceed 80<br>             bytes.  If val is NULL, the name of the appropriate<br>             anonymous virtual memory areas will be reset.  The name can<br>             contain only printable ascii characters (isprint(3)),<br>             except ‘[‘, ‘]’, ‘', ‘$’, and ‘`’.</p>
</blockquote>
<p>最多80字节, 且只能是合法字符串. 读原语可以通过读/proc/self/maps实现.</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> anon_vma_name *<span class="title function_">anon_vma_name_alloc</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma_name</span> *<span class="title">anon_name</span>;</span></span><br><span class="line">	<span class="type">size_t</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add 1 for NUL terminator at the end of the anon_name-&gt;name */</span></span><br><span class="line">	count = <span class="built_in">strlen</span>(name) + <span class="number">1</span>;</span><br><span class="line">	anon_name = kmalloc(struct_size(anon_name, name, count), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (anon_name) {</span><br><span class="line">		kref_init(&amp;anon_name-&gt;kref);</span><br><span class="line">		<span class="built_in">memcpy</span>(anon_name-&gt;name, name, count);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> anon_name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">is_valid_name_char</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">/* printable ascii characters, excluding ANON_VMA_NAME_INVALID_CHARS */</span></span><br><span class="line">	<span class="keyword">return</span> ch &gt; <span class="number">0x1f</span> &amp;&amp; ch &lt; <span class="number">0x7f</span> &amp;&amp;</span><br><span class="line">		!<span class="built_in">strchr</span>(ANON_VMA_NAME_INVALID_CHARS, ch);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h4 id="KBASE-JIT-FREE-PREPARE"><a href="#KBASE-JIT-FREE-PREPARE" class="headerlink" title="KBASE_JIT_FREE_PREPARE"></a>KBASE_JIT_FREE_PREPARE</h4><p>一些在野利用使用安卓GPU进行堆喷读写操作, 比如Mali GPU的kbase_jit_free_prepare函数提供了大小内容完全可控的强大堆喷原语.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/202508041809044.png" alt="图片1.png"></p>
<h4 id="pipe-buffer-again"><a href="#pipe-buffer-again" class="headerlink" title="pipe_buffer again"></a>pipe_buffer again</h4><p>当然用pipe_buffer.page做CrossCache的堆喷读写也是惯用手段了.<br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20250515230255.png"></p>
<h4 id="DirtyCred"><a href="#DirtyCred" class="headerlink" title="DirtyCred"></a>DirtyCred</h4><p>也尝试过用DirtyCred来做这次利用.<br>主要思想是用高特权级的cred来占低特权级的cred.<br>或者相反用低特权级的file来占高特权级的file.</p>
<p>在安卓上的问题: </p>
<ul>
<li>缺少喷射高特权级cred的能力, 因为安卓上没有suid的程序. 但可以通过创建内核线程喷射高特权cred, 比如在5.14后内核的io_uring中, 普通用户也能通过IORING_SETUP_IOPOLL创建内核线程.</li>
<li>喷射file可以, 但写入任意文件原语到提权, 绕过Selinux还有一段距离.</li>
</ul>
<p><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20250515113334.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20250515113342.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20250515113348.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20250515113354.png"><br><img src="https://obsidian-1314737433.cos.ap-beijing.myqcloud.com/20250515113401.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://polaris-snowfall.github.io/2025/CVE-2021-41073/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CVE/" rel="tag">CVE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/" rel="tag">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pwn/" rel="tag">Pwn</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2025/AliyunCTF2025%20Alimem/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">AliyunCTF2025 Alimem</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> 翰青HanQi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="北极落小雪"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/About">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

</html>